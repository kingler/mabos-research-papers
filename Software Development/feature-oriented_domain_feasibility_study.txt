Technical Report
CMU/SEI-90-TR-21
ESD-90-TR-222
Feature-Oriented Domain Analysis (FODA)
Feasibility Study
Kyo C. Kang
Sholom G. Cohen
James A. Hess
William E. Novak
A. Spencer Peterson
November 1990
Technical Report
CMU/SEI-90-TR-21
ESD-90-TR-222
November 1990
Feature-Oriented Domain Analysis
(FODA)
Feasibility Study
/logoleft/logoright
Kyo C. Kang
Sholom G. Cohen
James A. Hess
William E. Novak
A. Spencer Peterson
Domain Analysis Project
Approved for public release.
Distribution unlimited.
Software Engineering Institute
Carnegie Mellon University
Pittsburgh, Pennsylvania 15213
Acknowledgements
We would like to acknowledge the support of Capt. Patrick Carroll, USAF, for his contribu-
tion to the project, which helped make this report possible.
We would also like to acknowledge the support and expert counsel of Bill Wood, Mario Bar-
bacci, Len Bass, Robert Firth, and Marc Kellner of the SEI for helping to shape and clarifythe ideas contained within.  Thanks go also to Brad Myer of Carnegie-Mellon University forsharing his domain expertise in window management systems.
Finally, we would like to thank the careful reviewers of a large document, specifically Len
Bass, Robert Firth, Larry Howard, Tom Lane, Nancy Mead, Don O’Neill, Dan Roy, and KurtWallnau.
Executive Summary
This report describes a method for discovering and representing commonalities among re-
lated software systems.  By capturing the knowledge of experts, this domain analysis meth-
od attempts to codify the thought processes used to develop software systems in a relatedclass or domain . While domain analysis supports software reuse by capturing domain ex-
pertise, domain analysis can also support communication, training, tool development, andsoftware specification and design.
The primary focus of the method is the identification of prominent or distinctive features of
software systems in a domain.  These features are user-visible aspects or characteristics ofthe domain.  They lead to the creation of a set of products that define the domain and alsogive the method its name: Feature-Oriented Domain Analysis (FODA). The features define
both common aspects of the domain as well as differences between related systems in thedomain. Features are also used to define the domain in terms of the mandatory, optional, oralternative characteristics of these related systems. This report provides a description of theproducts of the domain analysis, as well as the process for generating them. The reportalso contrasts the FODA method with other related work.
An important component of this report is a comprehensive example of the application of the
method. The example demonstrates the utility of the FODA method in providing an under-standing of a domain, both in terms of the scope of the domain and in terms of the featuresand common requirements. The report also describes several technical issues raised dur-ing the development of the method. These issues will be further explored in subsequentdomain analyses.
This report does not cover the non-technical issues related to domain analysis, such as
legal, economic, or managerial issues. The emphasis on defining process and productsstems from the belief that the non-technical issues can be fully explained only in light ofspecific approaches to domain analysis and to reuse in general.  This report establishes onesuch approach.
Domain analysis remains a relatively new practice.  Although first proposed ten years ago,
domain analysis is still a topic primarily of research groups.  The report Feature-Oriented
Domain Analysis can advance the state of the practice of domain analysis by providing
meaningful examples and issues for further exploration.
CMU/SEI-90-TR-21 1
Unix is a trademark of AT&T Bell Laboratories.
Open Look is a trademark of AT&T.OSF/Motif is a trademark of the Open Software Foundation.The X Window System is a trademark of the Massachusetts Institute of Technology.SunView and NeWS are trademarks of Sun Microsystems, Inc.VMS Windows is a trademark of Digital Equipment Corporation.Macintosh is a trademark of Apple Computer, Inc.Symbolics is a trademark of Symbolics, Inc.Statemate is a trademark of i-Logix, Inc.
2 CMU/SEI-90-TR-21
Feature-Oriented Domain Analysis
Abstract: Successful software reuse requires the systematic discovery and ex-
ploitation of commonality across related software systems.  By examining relatedsoftware systems and the underlying theory of the class of systems they repre-sent, domain analysis can provide a generic description of the requirements ofthat class of systems and a set of approaches for their implementation.  This re-port will establish methods for performing a domain analysis and describe theproducts of the domain analysis process.  To illustrate the application of domainanalysis to a representative class of software systems, this report will provide adomain analysis of window management system software.
1. Introduction
1.1. Scope
The systematic discovery and exploitation of commonality across related software systems
is a fundamental technical requirement for achieving successful software reuse [Prieto-Diaz90]. Domain analysis is one technique that can be applied to meet this requirement.  Byexamining a class of related software systems and the common underlying theory of thosesystems, domain analysis can provide a reference model for describing the class. It canprovide a basis for understanding and communication about the problem space addressedby software in the domain.  Domain analysis can also propose a set of architectural ap-proaches for the implementation of new systems.
The primary intent of this report is to establish the Feature-Oriented Domain Analysis
(FODA) method for performing a domain analysis. The feature-oriented concept is based
on the emphasis placed by the method on identifying those features a user commonly ex-pects in applications in a domain.  This method, which is based on a study of other domainanalysis approaches, defines both the products and the process of domain analysis.  Thereport also provides a comprehensive example to illustrate the application of the FODAmethod to a representative class of software systems.
This report is directed toward three groups:
1. Individuals providing information about a domain under analysis (domain
experts).
2. Individuals performing the domain analysis (domain analysts).3. Consumers of domain analysis products (systems analysts and developers).
The roles of each group with respect to domain analysis will be defined later in this chapter.This report provides an introduction to domain analysis, a description of a method for per-
CMU/SEI-90-TR-21 1
forming the analysis, and a sample application of that method.  It does not address such
related areas as legal and economic issues pertaining to domain analysis, nor does it ex-plore other non-technical areas.
The report is organized in the following way:
•The rest of this chapter will introduce the concepts of domain analysis
•The second chapter provides an historical overview of the field, describing sev-
eral methods proposed for performing domain analysis; the chapter also estab-lishes a set of basic criteria for evaluating domain analysis methodologies.
•Resulting from this evaluation of existing methodologies, Chapter 3 presents an
overview of the Feature-Oriented Domain Analysis (FODA) method by describ-ing the three basic activities of the method: context analysis ,domain modelling
andarchitecture modelling . Chapters 4-6 then contain detailed discussions of
each of these activities and the products produced.
•Chapter 7 presents a domain analysis of window manager software, illustrating
the application of the FODA method.
•The appendices provide the detailed domain terminology dictionary and other
supporting information to document the window manager software domain anal-ysis. Other material supporting the method is also presented in the appen-dices.
1.2. Domain Analysis Concepts
The development of large and complex software systems requires a clear understanding of
desired system features and of the capabilities of the software required to implement thosefeatures. Software reuse, which has long promised improvements in the development proc-ess, will become feasible only when the features and capabilities common to systems withina domain can be properly defined in advance of software development.  Domain analysis,the systematic exploration of software systems to define and exploit commonality, definesthe features and capabilities of a class of related software systems. Thus, the availability ofdomain analysis technology is a factor that can improve the software development processand promote software reuse by providing a means of communication and a common under-standing of the domain.
The list below offers definitions of several terms which are basic to domain analysis, and
which are essential to the following discussion of a domain analysis method.
Application: A system which provides a set of general services for solving
some type of user problem.
Context: The circumstances, situation, or environment in which a par-
ticular system exists.
Domain: (also called application domain ) A set of current and future
applications which share a set of common capabilities anddata.
Domain analysis: The process of identifying, collecting, organizing, and
2 CMU/SEI-90-TR-21
representing the relevant information in a domain based on
the study of existing systems and their development histories,knowledge captured from domain experts, underlying theory,and emerging technology within the domain.
Domain engineering: An encompassing process which includes domain analysis
and the subsequent construction of components, methods,and tools that address the problems of system/subsystem de-velopment through the application of the domain analysisproducts.
Domain model: A definition of the functions, objects, data, and relationships in
a domain.
Feature: A prominent or distinctive user-visible aspect, quality, or char-
acteristic of a software system or systems [American 85].
Software architecture: The high-level packaging structure of functions and data, their
interfaces and control, to support the implementation of ap-plications in a domain.
Software reuse: The process of implementing new software systems using ex-
isting software information.
Reusable component: A software component (including requirements, designs,
code, test data, etc.) designed and implemented for the spe-cific purpose of being reused.
User: Either a person or an application that operates a system in
1order to perform a task.
Because it is central to several of the definitions and to the concept of domain analysis itself,
the term domain requires some clarification through examples. A domain does not neces-
sarily have to occur at a specific level of software granularity, such as that of a system,Computer Software Component (CSC), or Computer Software Configuration Item (CSCI).Rather, a domain is a more general concept which may be stretched to apply to most anypotential class of systems. This class is referred to as the target domain, which may have
both higher-level domains to which it belongs and sub-domains within it. As an example,
different instances of the same type of system (such as window management systems orrelational database management systems) can be grouped together to define a domain.  Ina similar way a domain of data structures could be identified which would be at a muchlower level than that of entire systems, but could still constitute a target domain in its ownright. Grady Booch could be said to have performed an analysis of this domain whichresulted in the creation of the abstract data type components described in [Booch 87]. Inanother context this target domain of abstract data types could be viewed as a sub-domainof the larger data management domain.  Put another way, the X window system is correctlythought of as a system on which user application programs are written and executed. Froma different perspective, however, a collection of similar window management systems such
1The user of a system is not necessarily the same as the customer for a system. These are two separate
concepts, although they may be combined in many cases.
CMU/SEI-90-TR-21 3
as X windows, NeWS, and others, constitutes a domain, and each window management
system is an application in that domain. Both views are correct, in that X windows is both acomplete system and an instance of a larger domain. One view may be more useful than theother if it helps to solve the problem at hand.
1.2.1. Domain Analysis Process
Domain analysis gathers and represents information on software systems that share a com-mon set of capabilities and data.  The methods proposed in [GILR89A, MCNI86A, PRIE86A]suggest that there are three basic phases in the domain analysis process:
1.Context analysis: defining the extent (or bounds) of a domain for analysis.
2.Domain modelling: describing the problems within the domain that are ad-
dressed by software.
3.Architecture modelling: creating the software architecture(s) that implements a
solution to the problems in the domain.
Figure 1-1 depicts the three groups of participants in the domain analysis process.  During
each phase these players take on slightly different roles.
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar!/patchar/patchar/patchar/patchar/patchar
End user - uses systems
in the domainDomain analyst - gathers
information and performs
analysis
Domain expert - provides
information about systems inthe domainRequirements analyst -
specifies new systems in
the domain
Software designer -
designs new systems in
the domainSources
/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
End user - uses systems inthe domainProducer Consumers
Figure 1-1: Participants in the Domain Analysis Process
•Context analysis: The domain analyst interacts with users and domain experts
to establish the bounds of the domain and establish a proper scope for theanalysis. The analyst also gathers sources of information for performing theanalysis.
•Domain modelling: The domain analyst uses information sources and the other
4 CMU/SEI-90-TR-21
products of the context analysis to support the creation of a domain model.
This model is reviewed by the system user, the domain expert, and the require-ments analyst.
•Architecture modelling: Using the domain model, the domain analyst produces
the architecture model.  This model should be reviewed by the domain expert,the requirements analyst, and the software engineer.  The user need not partic-ipate in this review.
The requirements analyst and software designer will use the products of a domain analysis
when implementing a new system.  During implementation, these products are tailored toproduce the specification and design of that system.  This tailoring process will provide feed-back of information to the domain analyst and expert to modify or extend the domain anal-ysis for future developments.  (See Figure 1-2.)  This feedback may also serve to improvethe domain analysis process, by discovering possible weaknesses in the original methods.The specific roles of the participants in the tailoring process will be defined as part of theFODA method in Chapter 3.
/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patcharDomain
Context &
Scope
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar /patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patcharArchitecture
Control
StructureDomain
Model
E-R
State trans.
Data flowFeatures
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar!/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar /patchar/patchar/patchar /patchar/patchar/patchar/patchar/patchar /patchar /patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar!/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar /patchar /patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar!/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patcharNew
System
Context
New
System
Software
ArchitectureNew
System
Software
Specification/patchar/patchar/patchar/patchar/patchar/patchar/patchar!Add, modify,
delete features
Requirements analystEnd user
End userDomain expertDomain analyst
Domain analyst
Domain analystDomain analyst
Requirements analystRequirements analyst
Software
designerProducts of
Domain analysisProducts of new
system development
Add, modify,
delete features
Add, modify,
delete features
Figure 1-2: Tailoring the Products to Enhance the Domain Analysis
CMU/SEI-90-TR-21 5
1.2.2. Domain Analysis Products
The domain analysis method must provide specific representations to document the results
of each of the domain analysis activities.  These representations form a reference model forsystems in the domain.  The representations define the scope of the domain, describe theproblems solved by software in the domain, and provide architectures that can implementsolutions.
For each of the three phases of the domain analysis process there will be a separate set of
representations of the domain.
Context analysis: The results of this phase provide the context of the domain.
This requires representing the primary inputs and outputs ofsoftware in the domain as well as identifying other software in-terfaces.
Domain modelling: The products of this phase describe the problems addressed
by software in the domain.  They provide:
•features of software in the domain
•standard vocabulary of domain experts
•documentation of the entities embodied in soft-
ware
•generic software requirements via control flow,
data flow, and other specification techniques
Architecture modelling: This phase establishes the structure of implementations of soft-
ware in the domain. The representations generated providedevelopers with a set of architectural models for constructingapplications and mappings from the domain model to the ar-chitectures. These architectures can also guide the develop-ment of libraries of reusable components.
Figure 1-3 depicts the three phases of the method and lists the products of each.
The FODA method provides a means of applying these products of domain analysis to sup-
port software development.  Figure 1-4 depicts the use of domain analysis products andtheir ability to provide a means to support communication between users and developers.This view of domain analysis shows that it can be integrated into a more general process forsoftware development to support:
•understanding the domain
•implementing applications in the domain
•creating reusable resources (designs, components, etc.)
•supporting creation of domain analysis and other reuse tools
6 CMU/SEI-90-TR-21
Domain Analysis
Domain Modelling Context Analysis Architecture Modelling
Structure diagram
Context diagramEntity relationship model
Features model
Domain terminology
dictionaryFunctional modelProcess interaction
model
Module structure
chart
Figure 1-3: Phases and Products of Domain Analysis
1.3. Feasibility Study Overview
Before a discussion of the details of the FODA domain analysis method itself is appropriate,
it is necessary to discuss the context in which this feasibility study was performed. Certainconstraints applied to this initial study influenced the work, and are re-examined in Chapter8 in light of the study’s results.
First, domain analysis is still a research topic. Despite the different efforts outlined in Chap-
ter 2 there is no uniform agreement on method, representation, or products. This reportpresents a proposed approach and some experience in applying it, but does not attempt toimply that all of the central issues surrounding domain analysis have been resolved.
Second, the application of the FODA method to the window manager domain was done as a
feasibility study to see if it would be possible and useful to analyze application domains withthis method. While most aspects of the method were applied to the sample window managerdomain, it was not deemed necessary to exhaustively apply the method beyond the pointwhere basic feasibility had been determined and significant lessons learned.
CMU/SEI-90-TR-21 7
Context analysis (scope of domain)
Domain Model
ArchitecturesImplement
applicationsin domain
/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patcharCreate reusable resources (designs,
components, etc.)
/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar /patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patcharDomain(representation
of problems in
domain)
(representation
of solutions in
domain)
New applicationNew application/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patcharDomain
analysis
Tools and training
support
Figure 1-4: Domain Analysis Supports Software Development
Third, in performing the sample domain analysis no sufficiently mature automated tool sup-
port for domain analysis was available. While general purpose tools are available which cansupport some domain analysis functions, and prototype tools have been built specifically tosupport domain analysis activities, no tool support was available which was both robust andspecific to domain analysis.  In addition, the purpose of the study was to demonstrate thefeasibility of a general domain analysis method, rather than the effectiveness of any partic-ular support environment.  As a result, primarily manual methods were used, with some spe-cific automated support such as Statemate for some of the model types. As is discussed inSection 8.1.3, the issue of effective knowledge representation will be a focus of future work.
Fourth, at the time the feasibility study began, the definition of the third and final phase of
the FODA method, architecture modelling, had not been completed. Therefore, while thegeneral approach to this phase is defined in this document, it was not applied to the sampledomain analysis.  One effect of this is that the architecture modelling phase of the method isnot as specific in direction as the others because there has been no feedback to it fromactual use.
8 CMU/SEI-90-TR-21
Fifth, the products of the sample window manager domain analysis were not formally vali-
dated against another application in the domain (one which was not used as an input to thedomain analysis), as the FODA method recommends. The products were informally vali-dated through review by experts, and showed good agreement across the eight windowmanager systems which were used as inputs to the analysis.
1.4. Successful Application of Domain Models
The process of domain analysis has been successfully applied in many mature domains.While not formally called domain analysis, companies that establish generic architectures forsoftware systems that they build are creating and using some of the products of a domainanalysis. This is precisely the approach taken by the Toshiba Corporation [Matsumoto 84],which has successfully established a software "factory" that can produce many highly similarsystems that are customized to the specific needs of each customer.  The Thomson-CSFCompany [Andribet 90] has also used this approach to develop air traffic control systems.They recognize that they are building similar software systems in an established domain, sothe architecture becomes a standard from which new systems are derived.  This is a varia-tion of domain analysis.
These successes point towards the need for a domain analysis method to achieve two spe-
cific goals:
1. The method leads to the development of domain analysis products that sup-
port implementation of new applications.  This goal will be met when domainanalysis products are used in new implementations.
2. The method can be incorporated into the general software development proc-
ess. This goal will be met when domain analysis methods become an ac-cepted part of software development.
The successful application of methods similar to those proposed in this report support the
contention that the products of a domain analysis can be used efficiently to produce newsystems in the domain, and to implement software reuse.
The use of the FODA method in this feasibility study, while successful in explicitly setting
forth the capabilities of systems in the domain, is not yet a complete success for the method.The method produces accurate products which describe the domain, but these productshave not been used in the implementation of new applications. When this has been done,then the method may be considered a success.
The next chapter will highlight other domain analysis approaches, document their suc-
cesses, and describe where they differ from the FODA method.  These successes show thatdomain analysis methods can succeed when:
•The domain of applicability is of suitable scope (i.e., the extent or size of the
analysis is feasible).
•The analysis attempts to abstract the requirements to the problem level from
the application level.
CMU/SEI-90-TR-21 9
•The products provide documentation of the problem abstraction and guidance
in tailoring the abstraction to meet specific requirements.
This report will provide specific methods to meet these three criteria.
10 CMU/SEI-90-TR-21
2. Review of Domain Analysis Methods
While the reuse community has not established a uniform approach to identifying reusable
software resources, there is general agreement that domain analysis offers the ability toidentify and support development of these resources.  During the past ten years, there havebeen several major efforts in domain analysis.  Reports on these efforts include descriptions
2of methods, case studies, and tool recommendations.
The following list provides a brief chronology of those domain analysis studies that describe
usable products to support software reuse.
•1979: Raytheon Missile Systems Division [Lanergan 79]
•1980: Neighbors’ dissertation: Software Construction Using Components
[Neighbors 80]
•1985: McDonnell Douglas: Common Ada Missile Packages (CAMP) [McNicholl
86, McNicholl 88]
•1985: Schlumberger: Domain Specific Automatic Programming [Barstow 85]
•1988: Batory: Domain Analysis of Database Management Systems [Batory
88a, Batory 88b, Batory 88c]
•1988: CTA studies and tools for NASA [Bailin 88, Moore 89, Bailin 89]
•1988: SEI: An OOD Paradigm for Flight Simulators [Lee 88, D’Ippolito 89]
•1989: MCC: DESIRE System [Biggerstaff 89a]
•1989: Thompson-CSF: Air Traffic Control Systems Domain Analysis [Andribet
90]
•1989: CSC: Domain Analysis for Flight Dynamics Applications
In addition to the product-directed studies, there have been other studies that focused on
the process of domain analysis:
•1987: Prieto-Diaz: "Domain Analysis for Reusability" [Prieto-Diaz 87]
•1988: Arango: thesis and other domain analysis studies [Arango 88a, Arango
88b, Arango 88c, Arango 89]
•1988: Bruns and Potts: "Domain Modeling Approaches to Software
Development" [Bruns 88]
•1988: Lubars: "A Domain Modeling Representation" [Lubars 88]
•1989: SPS: Impact of Domain Analysis on Reuse Methods [Gilroy 89]
•1990: SPC: A Domain Analysis Process [Jaworski 90]
The distinction between product and process emphasis in these lists is not purely organiza-
tional; most studies to date have concentrated on one of the two areas.  Studies such asthose by Neighbors and CAMP describe their products in detail, but give little insight into the
2A more complete enumeration of related studies and papers is available in a companion report, A Domain
Analysis Bibliography , CMU/SEI-90-SR-3 [Hess 90].
CMU/SEI-90-TR-21 11
methods used to generate them.  The process studies such as those by Lubars or SPS
define methods but do not give significant examples of the application of those methods.While much work has been done on methods for domain analysis there is no single defini-tive domain analysis method.  The next section proposes some criteria for evaluatingdomain analysis methods and applies those criteria to support a comparison of existingmethods to the FODA method.
2.1. Evaluation of Methods
Gathering and representing domain knowledge in the form of a domain model and genericarchitecture presents problems that have not been addressed by traditional developmentmethods. These traditional methods are not reuse-based, but rather are oriented towardsingle system development.  Domain analysis can be distinguished from this single systemapproach in that its objective is to represent exploitable commonalities among many sys-
tems.
This domain analysis task is made more complex by the fact that information comes from
multiple sources such as source code, requirements and design documents, domain litera-ture, and domain experts.  Assimilating all this information presents a difficulty in informationmanagement. The requirement that this information and other end-products be general inform and in a format that can be exploited by others complicates the requirements for repre-sentation mechanisms.
In order to facilitate the evaluation of existing domain analysis methods and their products, a
set of classification and evaluation criteria is very helpful [Firth 87].  Criteria for classifyingand evaluating the existing products and processes of domain analysis can assist the devel-opment of a domain analysis method.  A set of appropriate criteria can be broken down intothree major areas:
1. The process aspect considers: how the domain analysis method will affect an
organization (e.g., evolutionary vs. revolutionary); how to manage and main-tain the products; how the producer gathers, organizes, validates, and main-tains information; and how the users can effectively apply the products in thedevelopment.
2. The product aspect considers: the types of products that are generated by the
method; how they are represented; and how applicable they are in applica-tions development.
3. The tool support aspect considers the availability of tools and the extent to
which the tools support the method.  It also looks at how well the support toolsare integrated, their ease of use, and their robustness.
For the purposes of this study, emphasis will be placed on process and product considera-
tions of the different methods.  The level of tool support is less important than the methodembodied in the tool.
12 CMU/SEI-90-TR-21
2.2. Comparative Study
A comparative study of domain analysis techniques will provide a better understanding of
the range of approaches. Several of the studies listed in the previous section describe dif-fering approaches to the techniques of domain analysis. The following four approaches willbe the focus of this section:
1. Genesis/University of Texas: a tool for constructing database management
systems (DBMSs). An analysis of the DBMS domain is the basis of a genericarchitecture, components, and the constructor.
2. KAPTUR (Knowledge Acquisition for the Preservation of Tradeoffs and Under-
lying Rationales)/CTA: a tool to facilitate knowledge representation and anal-ysis. A domain analysis provides a baseline structure; any deviations from thebaseline are stored as distinctive features of the domain, along with a rationale
for the new features.
3. DESIRE (DESIgn REcovery)/MCC: a tool that supports recovering and re-
engineering a design from existing code. This is one of the parts of performinga domain analysis.
4. SPS (Software Productivity Solutions): guidelines for conducting a domain
analysis.
The following sections describe each of these methods and contrast it with the FODA meth-
od.
2.2.1. The Genesis System
Genesis is a tool system developed by Don Batory of the University of Texas ( [Batory 88b],
[Batory 88c]). The goal of this effort was to develop a "database compiler" to synthesize
customized DBMSs from pre-written components.  The developers report that:
Enormous increases in software productivity are achieved by exploiting reusable
and plug-compatible modules.  The popularized, but mythical, concept of ‘softwareICs’ is actually a reasonably accurate description of our technology [Batory 88c].
The system has been under development for ten years and can now generate centralized
relational DBMSs with various configurations.  Current efforts include extending the proto-type to support object-oriented and distributed databases.
The developers used domain analysis techniques to formulate a building-block technology
for file management systems.  Their approach, similar to the FODA method, uses "existingsystems, published algorithms, and structures to discern generic architectures for large
classes of systems." [Batory 88c] The Genesis method also defines the generic architectureas the primary product of the domain analysis.  While the method recognizes the need togain a full understanding of a domain in order to construct the architecture, Genesis doesnot give specific techniques for obtaining or representing this understanding. The devel-opers of Genesis point out, however, that their domain model has been evolving for years.
The Genesis generic architecture is a template for constructing systems.  Building-block
CMU/SEI-90-TR-21 13
modules with standardized interfaces can be "plugged" into this template by the Genesis
tool at the direction of the user.  The Genesis approach recommends studying domain infor-mation, including systems, algorithms, and data structures, to produce an architecture andinterfaces that cover the class of systems.  This product forms a blueprint for constructingsoftware systems from building blocks.
The Genesis approach describes the two steps to the analysis process:
1. Defining a generic architecture: a software architecture is defined in terms of a
hierarchy of "independently-definable objects" (IDOs): objects whose imple-mentations have no impact on other objects.  For each IDO, there are opera-tions, standard interfaces, and a collection of algorithms that implement theoperations. The method does not produce a domain model, domain terminol-ogy dictionary, or method of mapping the DBMS problem domain to the IDOs,as would be required by the FODA method.
2. Defining standardized interfaces to objects: in addition to the architecture in-
formation, the Genesis method also produces information about the inter-relationships between the building-blocks (i.e., IDOs, operations, andalgorithms). When the tool is executed, these constraint rules eliminate allbuilding blocks that are incompatible with others already selected by the user.These constraints are similar to rules for combining required, optional, or alter-native features in the FODA method.
Genesis offers some guidelines for creating a software architecture, but in general the meth-
od relies on the knowledge, experience, and creativity of domain experts to create the ar-chitecture. The underlying problem domain is not represented.  In addition, the methoddoes not capture information to support requirement or design decisions.  A developer usingthe Genesis tool must be an expert in the domain and should know what to select and theimplications of the selection. To improve its utility, the tool should provide users an inter-active design aid that explains the effects of each design decision.
The Genesis developers have recognized many of the issues that have also been used in
creating the FODA method.
•Establishing the proper decomposition of the domain is essential.  If the sub-
domains are too restricted, the analysis may lead to interfaces that are un-stable, with changes required each time new algorithms or structures are intro-duced. If the decomposition is too broad, the grouping of algorithms and struc-tures will link objects that really should be separate.
•Developing the architecture is not simply listing algorithms and structures and
allowing a developer to select what appears to support his requirements.  Thedomain analysis must provide an architecture for building a system from theseorthogonal units (IDOs).
•The technology embodied in Genesis is intended to support the exploration of
solutions to problems in the domain.  The architecture provides "a platform onwhich to implement a class of previously identified solutions." [Batory 88c]
The developers of Genesis have validated a reuse approach based on domain analysis.
14 CMU/SEI-90-TR-21
Their method is built upon identifying the underlying IDOs of a domain, fashioning a generic
architecture for structuring the IDOs, constructing the building blocks to implement thesestructures and implementing the tool to perform system synthesis.  The FODA method isdirected towards generalizing that approach for other domains.
2.2.2. MCC Work
The Microelectronics and Computer Technology Corporation (MCC) has developed domainanalysis methods and related tools to support software reuse ( [Biggerstaff 89a, Biggerstaff89b, Lubars 87, Lubars 88]). These tools include:
DESIRE: A tool for recovering design from code and re-engineering the
recovered design.
ROSE: A tool for representing design templates and generating code from
the templates.
TAO: An expert tool for domain understanding and modeling (in concept
development stage).
Each of these tools was developed independently of the other, leading to an integrationproblem. For instance, the designs recovered by DESIRE cannot be accessed by ROSE.  Inaddition, there is no single underlying domain analysis approach; DESIRE is built uponreverse engineering concepts, while ROSE selects abstract designs to meet requirementsand specifications supplied by a user.
2.2.2.1. The DESIRE Design Recovery Tool
The MCC DESIgn REcovery method gathers design information from source code, organ-
izes the information, and abstracts a design.  The DESIRE tool performs these steps andallows domain experts to display and restructure the design, incorporating their knowledge.The recovery results have been positive, and there are active users of the tool that canprocess C and C++ programs of moderate size (50 - 100,000 lines of code).
The main product of this method is a generic design which MCC calls a domain model .
Various aspects of this model, such as the calling structure and module structure, can becaptured and displayed using the tool. However, there is no way to abstract the designmodel into an architecture model (e.g., a layered architecture that shows packaging ofroutines) or to access design decision information.  The MCC design recovery method alsodoes not provide any model of the problem space.  Both design criteria and problem spacemodelling are important aspects of the FODA domain analysis method.
DESIRE is used primarily as a tool for maintaining or re-engineering existing code.  To truly
support domain analysis and reuse, the design recovery method and tool must provideknowledge to support an analysis of the features of the problem domain.  One could thenuse the tool to explore the extent to which existing systems exhibit these features, and ex-tract their implementation.  The information extracted from the code could be structured torepresent the implementation in a format (such as a design template) that could be reusedin other developments.
CMU/SEI-90-TR-21 15
2.2.2.2. Domain Analysis Method
The MCC domain analysis method is primarily embodied in the Reuse of Software Elements
(ROSE) system.  This tool attempts to capture domain knowledge to support early reusedecisions. The tool is aimed at meeting four goals:
1. Feature based selection: identifying domain objects and associated compo-
nents from their known features.
2. Constraint based analysis: analyzing a set of user requirements based on
known domain dependencies and relationships.
3. Domain-driven completion: performing completeness checks to ensure there
are no missing requirements in a system specification.
4. Domain-driven refinement: collecting and applying design issues as the crite-
ria for support of design decisions.
The goals of the MCC domain analysis method directly match those of the FODA method.
However, while stating these goals, the MCC approach does not provide specific techniquesfor capturing or representing this information.  The ROSE tool embodies some of these ele-ments and has been used experimentally to produce small programs (up to 600 lines ofcode). ROSE assumes that the domain information already exists, and does not support itscreation. The tool remains a prototype for exploring the concepts of design analysis, but isuseful in defining requirements for domain analysis support.
2.2.3. CTA Work
Computer Technology Associates (CTA) has developed a domain analysis method and aseries of prototype support tools. CTA has used its method, independent of the tools, toperform a domain analysis of NASA payload operations control center (POCC)software [Moore 89].  This effort was a major factor in setting requirements for a tool cur-rently under development called KAPTUR (Knowledge Acquisition for the Preservation ofTradeoffs and Underlying Rationales) [Bailin 89]. KAPTUR will embody CTA’s current ap-proach to domain analysis.
One of the major concepts behind KAPTUR is the ability to apply the tool to successive
system developments in the same domain and have KAPTUR semi-automatically supportthe detection of significant differences between these systems. These differences arereferred to in KAPTUR terminology as distinctive features . Distinctive features consist of (1)
3new functions, (2) new subsystems, or (3) new placements of existing subsystems. As
new systems are input into KAPTUR, the user must identify and name new capabilities, oruse the same name for a feature that is identical to one present in a previous system.  Giventhis information, KAPTUR can automatically build a set of knowledge base relationships thatconnect the different systems sharing common features. (This is done using a Prologprogram.)
3Note that these features are not decomposable into lower-level features as such, although the function,
subsystem, etc. which constitutes the distinctive feature may be decomposed like other functions, subsystems,etc. in KAPTUR’s knowledge base description.
16 CMU/SEI-90-TR-21
The CTA approach highlights the roles played by domain developers ("supply side") and by
system developers ("demand side") to define a reuse-based life-cycle, much as the FODAmethod establishes the domain analyst as supplying information to the user community.(Figure 2-1 shows the CTA roles and equivalent FODA method roles in italics under eachCTA label.)  In the CTA approach, the "develop- for-reuse" expert establishes the scope of
the domain knowledge that is commonly used across the systems in the domain.  Thedomain developer organizes this knowledge in the domain library in a consumable form.The "develop- by-reuse" expert uses the domain library to discover resources available for
development and provides them to the system developers who apply these resources toimplement systems. The system developers feedback new reuse requirements to thedomain developers to improve the domain library.  This process very closely matches that ofthe FODA method.
Domain
Library
Domain
developer
(Domain analyst)
Develop-for-
reuse Expert
(Domain expert)System
developer
(Software designer)
Develop-by-
reuse expert
(Requirements analyst)Domain
knowledge
DomainrequirementsResources
to support
reuse Resources
to support
reuseNew reuse
requirementsSupply Side Demand Side
Figure 2-1: Participants in CTA’s Reuse-Based Development Process
The CTA method produces many of the same products considered essential by the FODA
method. The CTA domain model is stored as a hypertext network to represent system
CMU/SEI-90-TR-21 17
structure. The network includes system features such as subsystems, functions, resources
(documents or people), external entities, and parameters.  In addition, the links carry rela-tional information, such as composition/decomposition, inputs/outputs, interactions, etc.  Be-cause the model is intended to capture the domain knowledge of system developers, thenetwork also includes design decision information.  This includes justifications that representdesign issues, positions, and arguments, as well as explanations to help users understandthe system.  The method also advocates the use of entity-relationship and data flowdiagrams as conventional specification methods.
CTA is developing the KAPTUR tool to support its method. One of the salient features of the
KAPTUR tool is its ability to store and trace the decision process that leads to a specificarchitecture. This reasoning process is captured in the database, an idea previously em-bodied in the gIBIS (graphical Issue Based Information Systems) [Begeman 88] system fromMCC at a greater level of detail.  FODA also makes use of design decision information,linking it to specific features of the domain.
2.2.4. SPS Work
Software Productivity Solutions (SPS) has developed guidelines for performing a domainanalysis [Gilroy 89]. SPS defines domain analysis as: "the systems engineering of a familyof systems in an application domain through development and application of a reuse library"
[Gilroy 89]. The process proposed in their guidelines follows the phases of the FODA meth-
od. The SPS method defines the goal of domain analysis as the production of a "reuselibrary asset that will be used in the implementation of system instances."  Although themethod includes the domain model and generic architecture as assets, the method does notprovide concrete examples of these products.
The SPS method proposes a three-step process for domain analysis:
1.Model the domain: to scope the domain and develop "a complete specification
of the domain, accomplishing a sort of requirements analysis."
2.Architect the domain: to develop and validate a generic, object-oriented Ada
architecture for the family of systems.
3.Develop software component assets: to build a set of reusable object-oriented
Ada components and catalog the components into a library for the domain.
The FODA method is similar to the SPS method in that both include separate scoping,
modelling, and architecture phases.  The SPS method differs in its emphasis on Ada ar-chitectures and components as the products of the analysis.
A detailed view of the SPS method also reveals similarities to the FODA method.  The scop-
ing activity in the SPS method produces a "domain planning document" to guide the anal-ysis. The other modelling activities produce a domain model based on the planning docu-ment and knowledge of previous systems.  While the FODA method concentrates on user-visible features, the SPS method seems to concentrate on internal characteristics of theidentified objects, such as data flow and state transition. FODA also includes this internal
18 CMU/SEI-90-TR-21
view in the functional descriptions, but it is not the primary focus of the method.  This
domain modelling phase also generates a domain dictionary, similar to FODA’s domain ter-minology dictionary.
The SPS domain architecture provides design information for building Ada software compo-
nents. This view of an architecture contrasts with that of the FODA method.  Both SPS andFODA provide dynamic/static requirements information as part of the domain model. SPSthen turns this information into Ada package specifications for reusable code. The FODAmethod relies on a generic set of parallel processes to define the control aspect of the ar-chitecture, and allocates specific functions defined in the domain model to modules thatthese processes control.  The available documentation for the SPS method also does notprovide any example of its architectural methods.
Although the SPS method lacks detailed guidelines for representing the products of a
domain analysis, it is useful in establishing a process for domain analysis.  The method isalso valuable in connecting domain analysis to the development process as a whole.  TheSPS process model served as an example in defining the FODA methods.
CMU/SEI-90-TR-21 19
20 CMU/SEI-90-TR-21
3. Overview of the Feature-Oriented Domain Analysis
(FODA) Method
The FODA method supports reuse at the functional and architectural levels.  Domain prod-
ucts, representing the common functionality and architecture of applications in a domain, areproduced from domain analysis.  Specific applications in the domain may be developed asrefinements of the domain products.
Domain analysis is related to requirements analysis and high-level design, but is performed
in a much broader scope and generates different results.  It encompasses a family of sys-
tems in a domain, rather than a single system, producing a domain model withparameterization to accommodate the differences and a standard architecture for develop-ing software components.  An ideal domain model and architecture would be applicablethroughout the life cycle from requirements analysis through maintenance.
3.1. Method Concepts
The development of domain products that are generic and widely applicable within a domainis a primary goal of the FODA method. This genericness (i.e., general knowledge) can beachieved by abstracting away "factors" that make one application different from other ap-plications. However, to develop applications from the generic products, those factors thathave been abstracted away must be made specific and reintroduced during refinement.  Notonly the genericness, but also those factors that make each application unique are an im-portant part of the domain knowledge and should be captured in the domain products.  Withthis method, domain products are not ends unto themselves, but evolve though applications.
The underlying concepts of this method are discussed in the remainder of this section.  Sec-
tion 3.2 describes some of the sources of domain information.  A summary of the domainanalysis activities and products is included in Section 3.3.
3.1.1. Modelling Primitives
The maturity of an engineering field can perhaps be indicated by the level of standardizationof the design of products in the field. No cars are designed from scratch these days: designframeworks have been standardized over time, and new features are added to an existingdesign framework to develop a new model.  Software development, like other engineeringfields, can benefit from the development and reuse of "product frameworks" in an applicationdomain (i.e., a product line or a product family).  The "product frameworks" in the context ofsoftware are abstractions of functionalities and designs (i.e., architecture) of the applications
in an application domain.
To support the development and reuse of "abstractions," this method is founded on a set of
modelling concepts. They are:
•aggregation/decomposition
CMU/SEI-90-TR-21 21
•generalization/specialization [Borgida 84]
•parameterization [Goguen 84]
Abstracting a collection of units into a new unit is called aggregation . For example, school is
an aggregation of students, teachers, etc. Refining an aggregation into its constituent unitsis called decomposition . This modelling primitive allows composition of components into a
new aggregated component or decomposition of an abstract component into its parts. Thestepwise refinement method [Wirth 71] is based on this aggregation/decomposition concept.
Abstracting the commonalities among a collection of units into a new conceptual unit sup-
pressing detailed differences is called generalization . Refining a generalized unit into a unit
incorporating details is called specialization . For example, the conceptual entity "employee"
is an abstraction of secretaries, managers, technical staffs, etc.  This modelling primitiveallows the development of generic components that can be refined in many different ways.
Parameterization is a component development technique in which components are adapted
in many different ways by substituting the values of parameters which are embedded in thecomponent. It allows codification of how adaptation is made within a component. The Adageneric is one example of parameterization.
The FODA method applies the aggregation and generalization primitives to capture the
commonalities of the applications in the domain in terms of abstractions.  Differences be-tween applications are captured in the refinements. An abstraction can usually be refined(i.e., decomposed or specialized) in many different ways depending on the contexts in whichrefinements are made.  Parameters are defined to uniquely specify the context for each spe-cific refinement.  The result of this approach is a domain product consisting of a collection ofabstractions and a series of refinements of each abstraction with parameterization. When-ever a new refinement (i.e., a refinement that is not already included in the domain product)is made, the context in which the refinement is made must be defined in terms ofparameters before it is incorporated into the domain product.  Therefore, in the FODA meth-od, a domain product is not the end-product; it expands and evolves through application.
Understanding what differentiates applications in a domain is most critical in domain anal-
ysis since it is the basis for abstraction, refinement, and parameterization.  The FODA meth-od focuses on identifying factors that can cause differences among applications in a domain(both at the functional and the architectural level) and uses those to parameterize domainproducts. The concept of parameterization and the types of factors considered in this meth-od for parameterization are described in the following section.
3.1.2. Product Parameterization
The purpose of parameterization is to develop generic components that can be adapted inmany ways by supplying values to parameters.  This is not a new software engineering con-cept; it has been implemented in many forms such as subroutines, generics, macros, andpreprocessors. However, these techniques have mostly been applied to code, althoughcode is not the only software engineering product.  The FODA method applies this conceptto other software engineering products including requirements and design.
22 CMU/SEI-90-TR-21
Identifying and understanding "factors" that result in different applications or different imple-
mentations of similar applications in a domain is the basis for parameterization.  The factorsconsidered in this method for parameterization can be largely classified into commonalitiesand differences of:
•Thecapabilities of applications in a domain from the end-user’s perspective.
•Theoperating environments in which applications are used and operated.
•The application domain technology (e.g., navigation methods in the avionics
domain) based on which requirements decisions are made.
•Theimplementation techniques (e.g., synchronization mechanisms used in the
design).
Applications in a domain, although they provide a large set of common capabilities, provide
different sets of capabilities, which make each application different from others.  These ca-pabilities from the perspective of end-users are modelled as features . Some examples of
features from the window manager domain are tiled and overlapped window layouts, and
listener and real estate window selection modes.  A set of features (e.g., an overlapped
window system with listener mode) from the window manager domain characterizes the ca-
pability of a window manager.  Therefore, features are used to parameterize domain prod-ucts from the user’s perspective.
It is important to understand the use of the term user in this context. In Section 1.2 a user is
defined as being either a person oran application that operates a system. In this sense the
term user can include the interactive user of a database management system (DBMS), the
developer of an inventory application built on top of the DBMS, or the inventory application
itself. All of these "users" require similar, but slightly varying knowledge of the interfaces to
the DBMS and how to operate it. In a practical sense the scope of the term "user" should betaken to apply to the "interface" which is of most relevance; the interactive interface, theapplication programmer interface (API), or other interfaces.
Applications may run in different operating environments. They may run on different
hardware or operating systems, or interface with different types of devices.  Understandingthe commonalities and differences between the external components with which the applica-tions interface is essential to abstracting the functionalities of those external componentsand defining common interfaces to them.
There are many ways to provide the features desired by the end-users.  Different people
involved in the development can make different decisions, all of which affect how the fea-tures are implemented.  Requirements analysts select a set of domain technologies anddefine internal functions based on the selected technologies.  For example, the choice be-tween pixel-based andpaint-and-stencil imaging models determines what internal functions
the display software should provide.
Designers also see many ways to implement the internal functions defined by requirements
analysts. Considering the hardware and software platforms, the space and time constraints,the expected transaction volume and frequency, etc., designers make a number of design
CMU/SEI-90-TR-21 23
decisions which all affect the formulation of software products.  For example, a decision as
to whether a window system will be implemented based on the kernel-based model or the
client-server model affects the structure of the system.  Various technical factors, from the
perspectives of requirements analysts and designers, that can result in different productstructures (e.g., different functional decompositions or design structure) are defined asissues and decisions . The issues and decisions , along with features , are used to
parameterize the functional and the architecture models of the domain.
In the development of an application, earlier decisions generally affect the range of deci-
sions that can be made later, as shown in Figure 3-1.  For instance, any prior decisions onan operating environment may affect the range of architecture models and implementationtechniques that can be selected later.  In the window management domain, for example, akernel-based window system might be appropriate in a non-multitasking environment.  The
knowledge of inter-relationships between various development decisions is an importantpart of domain knowledge.
Capabilities
Operating Environments
Domain Technology
Implementation Techniques
 
 
Figure 3-1: Types of Development Decisions
3.1.3. Levels of Abstraction
To maximize reusability, the FODA method advocates that applications in the domain be
abstracted to the level where differences between the applications are not revealed.  Thisabstraction is accomplished by using the modelling primitives discussed in Section 3.1.1.The factors that make each application unique are subsequently incorporated into the refine-ments of the abstractions, but incorporation should be delayed as much as possible. Forexample, "x" in Figure 3-2 represents the commonalities of all applications considered in thedomain analysis. As "x" is refined, the information on the context in which each refinement ismade is incorporated into the refinement. Therefore, "x1" and "x2" in Figure 3-2 are morecontext sensitive and less reusable than "x."
24 CMU/SEI-90-TR-21
abstract
detailedX
X1 X2
X111 X112 . . ..
..free of "factors"
"factors"
embedded in
the model
Figure 3-2: Model Abstraction
A generic component that captures only the common characteristics of applications in a
domain and, therefore, is free of those "factors" discussed in Section 3.1.2 has a high de-
4gree of reusability because of generality.  However, the "productivity increase" from thereuse of a generic component may not be as high as the productivity increase from thereuse of a component that is less generic but addresses specific features of the intendedapplication, as shown in Figure 3-3.  The FODA method gives the benefits of both ap-proaches by providing generic components and also refinements of those components atvarious levels.  As generic components are refined the factors that make applications uniqueare incorporated into the refinements. Reuse of the components can happen at the level thatis most appropriate for an application.
Domain products (i.e., abstractions and refinements) embody a wide range of domain
knowledge. During the domain analysis, the knowledge is collected from various sourcesand then organized and represented as domain products.  Some of the important sources ofdomain knowledge are discussed in the next section.
3.2. Information Sources
There are several information sources that may be available for a domain analysis, eachwith distinct advantages and drawbacks in the types of information it offers. Table 3-1 pro-vides an overview of information sources to use while gathering information for the domainanalysis.
4The phrase "productivity increase" here refers to the reduction in total software development effort from
applying the component.
CMU/SEI-90-TR-21 25
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patcharlevel of
abstractionreuse
potentialproductivity
increaselevel of "factors"
incorporated ina model
generic
(free of "factors,"i.e., context free)
application specific
("factors" fully incorporated,i.e., context sensitive)high high low
low low high
Figure 3-3: Model Reuse
Source Advantages Disadvantages
Textbooks •Good source of domain knowledge, •Reflects only specific author’s
theories, methods, techniques, viewsmodels•May use idealized or biased
models
Standards •Represents standard reference •Model may not be current with new
model for domain technology
Existing Applications •Most important source of domain •Cost of analyzing many systems is
knowledge high
•Can be directly used to determine
user-visible features
•Requirements documents available
for domain model
•Detailed design & source code
show architectures
Domain Experts •Can provide contextual/rationale in- •Experts have different areas of ex-
formation unavailable elsewhere pertise; several experts may be
needed•Can be consultant during DA,
validator of products afterwards
Table 3-1: Domain Analysis Information Sources
As an example of the use of textbooks, in the database domain there are many books de-
scribing the relational theory [Codd 70] that is the basis of many database management sys-tems. An understanding of the theory is essential to understand the database managementsystems. Also, many textbooks describe the principles of different domain-specific tech-niques, such as hashing and indexing methods.
26 CMU/SEI-90-TR-21
In the use of existing applications it should be pointed out that systems should be selected
that are as divergent (or "orthogonal") in functionality as possible, while still being in thedomain. This helps to minimize the number of systems that must be examined. As a generalguideline, at the very least three systems should be used as inputs to the domain analysis.
Domain products are produced through a number of activities. The domain analysis activi-
ties of this method and their inter-relationships are discussed in the next section.
3.3. Activities and Products
The domain analysis process consists of a number of activities and many models are pro-duced from the process. Table 3-2 summarizes a grouping of the activities into phases, withthe inputs to and outputs from each activity, and shows how the outputs from one activityare used in other activities.
The models produced from a domain analysis are used to develop applications in the
domain, as depicted in Figure 3-4.  The context model can be used by a requirementsanalyst to determine if the application required by the user is within the domain for which aset of domain products is available.  If the application is within the domain, then the featuremodel can be used by the requirements analysts to negotiate the capabilities of the appli-cation with the users.  The feature model (described in detail in Section 5.1.2) identifiescommon (i.e., mandatory ), alternative, and optional features. Where the terms relevant to
the features are new or unclear, the domain terminology dictionary contains descriptions oftheir meanings. Typically, a data-flow model has been used as a communication mediumbetween users and developers. However, a data-flow model contains definitions of the inter-nal functions and does notcontain the information that the user needs most, which is a
description of the external, oruser-visible aspects of the system.  The feature model is a
better communication medium since it provides this external view that the user can under-stand.
The entity-relationship model can be used by a requirements analyst to acquire knowledge
about the entities in the domain and their inter-relationships. An understanding of thedomain will help the analyst to deal with the user’s problems.  The analysis can determine ifthe functional model, consisting of the data-flow model and the finite state machine model ofthe domain products, can be applied to the user’s problems to define the requirements ofthe application. If the user’s problems are all reflected in the feature model, then the require-ments may be easily derived from the models by tracing the features embedded in themodels as parameters.  Otherwise, new refinements of the abstract components may haveto be made. The architecture model is used by the designer as a high-level design for theapplication. Again, if the user’s problems are reflected in the feature model, a design may beeasily derived from the architecture model. If the problems are not represented, then thearchitecture model should be further refined from the other domain products.
Detailed discussions of the domain analysis activities and models are included in Chapters 4
through 6.
CMU/SEI-90-TR-21 27
Table 3-2: A Summary of the FODA Method
28 CMU/SEI-90-TR-21
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patcharSoftware engineer/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
End userFeatures
Model
DFD
FSMArch.
Model
ER
ModelRequirements
analyst
Domain expertContext
Model
Figure 3-4: Use of Domain Analysis Products in Software Development
CMU/SEI-90-TR-21 29
30 CMU/SEI-90-TR-21
4. FODA Context Analysis
4.1. Purpose
The purpose of context analysis is to define the scope of a domain that is likely to yield
exploitable domain products. In the context analysis phase the relationships between thecandidate domain and the elements external to the domain are analyzed, and variability ofthe relationships and the external conditions (e.g., different applications using the domainand their data requirements, different operating environments, etc.) are evaluated.  Theresults of the context analysis, along with other factors such as availability of domain exper-tise, domain data, and project constraints, are used to scope the domain.
The final results of the context analysis are documented in a context model.  This context
model defines the boundary of the domain, that is, the scope of the domain modelling whichfollows the context analysis.
4.2. Model Description
A context model consists of one or more structure diagrams and data-flow diagrams.  Astructure diagram is an informal block diagram in which the target domain is placed relativeto higher, lower, and peer-level domains.  The higher level domains, if any, are those ofwhich the target domain is a part. If there is no higher level domain, then the types of ap-plications in the domain should be identified.  The lower level domains (i.e., sub-domains)are those that are within the scope of the target domain, but are well understood. Previousdomain analysis results or standards are available and, therefore, they will not be includedin the analysis.  Any other domains that interface with the target domain (i.e., peer-leveldomains) must also be in the diagram.  More than one structure diagram may be used ifnecessary. (An example structure diagram may be found in Figure 7-3 on page 60.)
A data-flow diagram shows data-flows between the target domain and all other domains and
entities with which the target domain communicates.  (See Figure 7-4 on page 61 for anexample.) One thing that differentiates the use of data-flow diagrams in domain analysisfrom other typical uses is that the variability of the data-flows across the domain boundarymust be indicated in the diagram.  This may be done with a set of diagrams, each describinga different context, or with one diagram with the text describing the differences.  If the varia-tions are due to different features of the applications in the domain, the variations must bedescribed in terms of the features.  (Context modelling and features modelling may have tobe performed in parallel or iteratively until the context model becomes complete, at whichtime detailed feature modelling may start.)  Textual descriptions of the functionality andreusability of the target domain, the objectives of the domain analysis, and any standardsthat are relevant must also be included in the context model.
The sub-domains that need not be included in the analysis are also identified in the diagram.
CMU/SEI-90-TR-21 31
These are the domains for which the results of previous domain analyses exist as stan-
dards, reusable components, and/or domain models. These sub-domains should be identi-fied as lower-level domains in the structure diagram and as external entities in the data flowdiagrams. Standards or other domain analyses results that apply to the external entitiesshould be identified in the diagram.
For each entity in the context model, the following information should be included in the
document.
•Name of the entity (an object on the diagram).
•Description of the function for a functional entity or description of the contents
for a data entity.
•Applicable standards and/or reusable components.
•Description of variability, including the range, frequency, and binding time (i.e.,
compile-time, activation-time, and runtime) of the variation (see Section 5.1.2for details of feature binding times).
•Other items describing the attributes of the entity.
•Source for the information or for additional information.
Other information which would be appropriate to include in the context model would be the
applicable or related features from the feature model produced during the domain modellingphase (see Section 5.1). The incorporation of this information into the context model implieseither an "iterative" or a parallel approach to the context analysis and domain modellingphases, since in a strictly sequential approach the feature model would not be available tothe context analysis (it is developed in the next phase of the analysis). The feature modelinformation may be useful in determining the scope of the analysis.
4.3. Model Usage
One of the necessary conditions for building reusable software is an understanding of thedifferent contexts in which the reusable software is to be incorporated or operated. This un-derstanding of the extent of contextual differences, and when and how frequently the con-text changes, will help software developers decide if software that meets the requirementscan be built and, if so, what to parameterize and how to structure software so that it can beadapted to different contexts as needed. For example, in an environment where there aremany different types of terminals, the user interface part of the software should be built so
5that it can handle different terminals without modification. In order to be able to build com-mon user interface software, the commonality and differences of terminals (to abstract anddefine common interfaces) and their usages (to build common utilities) must be understood.
The understanding of contextual variations will help rescope the domain.  If there is a high
degree of variation in context and the contextual differences cannot be abstracted away, it
5Precisely this capability is provided by the UNIX "curses" and "termcap" facilities.
32 CMU/SEI-90-TR-21
might indicate either that there is no commonality, or that the domain needs to be rescoped
to a narrower domain.
The context model defines the scope of a domain analysis. Other subsequent analysis acti-
vities, such as feature modeling, functional modelling, entity-relationship modelling, and ar-chitecture modelling, are all performed within the scope defined in the context diagram.  Thedata-flow context diagram is used as the starting point in the functional modelling.
4.4. Process and Guidelines
To yield domain products that can be exploited in other applications, the scope of a domainshould be decided considering: (1) the commonality of the domain in existing systems, (2)the availability of information on the domain and domain expertise, (3) the expected usagesof the domain products, and (4) the project resources and constraints.  Keeping these fac-tors in mind, the activities for context analysis and domain scoping are identified as follows:
1. Make an initial "cut" of the target domain and the domain boundary.  (It is as-
sumed that a candidate domain for context analysis is already selected.)Identify the existing applications in the domain or applications using thedomain. Identify information sources and any previous works on the domainincluding domain analysis products, standards, and books and technicalpapers.
2. For each application identified for the analysis, describe the context of the
candidate domain in terms of structure diagrams and data-flow diagrams.Verify that the domain has a clear physical boundary within the application. Ifthere are any previous domain analysis results or standards, determine if theyaddress each application adequately; record problems, if any.
3. Understand the usage of the target domain, any recent technical develop-
ments that will affect the domain, and any future plans or requirements.
4. Analyze the variability of the usages and the contexts of each use.
a. Based on the features of applications in the domain, begin the defini-
6tion of a feature model (See Section 5.1 on the feature model).
b. Identify the environmental differences (i.e., operating environments).
c. Identify any assumptions (sub-domains and standards) on which the
target domain is based.
d. Construct a common model by classifying specifics of the contexts into
general categories so that each context can be defined as an instan-tiation of the common model.
5. Evaluate the model against the applications used in the analysis and incor-
porate the variability information (i.e., how the common model can be adaptedto each context) into the context model.
6Again, use of the feature model in the context analysis phase requires iterative or parallel development of the
context and domain models.
CMU/SEI-90-TR-21 33
6. Evaluate the commonality of the applications, feasibility of constructing
domain products, and potential uses and benefits of the domain products.
7. Estimate the resources for the subsequent activities considering availability of
domain experts, previous work, and maturity of the domain.
8. Document the context model; define the terms used in the model in the
domain terminology dictionary.
9. Validate the model against at least one application that is notincluded in the
analysis. Also, have the model reviewed by domain experts.  Record the vali-dation results in the context model documentation.
Within the scope defined from the context analysis, the problems pertaining to the domain
are analyzed and modelled in the domain modelling phase.  Chapter 5 describes domainmodelling activities.
34 CMU/SEI-90-TR-21
5. FODA Domain Modelling
For the domain that is scoped in the context analysis, commonalities and differences of the
problems that are addressed by the applications in the domain are analyzed in the domainmodelling phase and a number of models representing different aspects of the problems areproduced. The domain modelling phase consists of three major activities: feature analysis,entity-relationship modelling, and functional analysis.  Each of these activities is described inthe following sections.
5.1. Feature Analysis
5.1.1. Purpose
The purpose of feature analysis is to capture in a model the end-user’s (and customer’s)understanding of the general capabilities of applications in a domain. Typically, data-flowdiagrams have been used by software developers as a medium to communicate require-ments with customers (and also with designers).  However, data-flow diagrams includedefinitions of software functions for satisfying customers’ needs and, often, such information
is not of interest to customers.  Customers need to know the essential capabilities of theapplication that satisfy their needs.  These capabilities might include features such as:
1. services provided by the application,
2. performance of the application,3. hardware platform required by the application,4. cost,5. others
Our approach to analysis focuses on an end-user perspective of the functionality of applica-
tions, that is, the "services" provided by the applications and the operating environments inwhich the applications run.
Since the primary interest is in the commonality of a family of applications, the feature model
should capture the common features and differences of the applications in the domain.  Thefeatures in the feature model will be used to generalize and parameterize other models.
5.1.2. Model Description
Features are the attributes of a system that directly affect end-users. The end-users have to
make decisions regarding the availability of features in the system, and they have to under-stand the meaning of the features in order to use the system.  Examples of such featuresare the call-forwarding andcall-transfer features of a telephone switching system, and the
automatic andmanual transmission features of an automobile, as illustrated in Figure 5-1.
When a person buys an automobile a decision must be made about which transmission
CMU/SEI-90-TR-21 35
7feature the car will have, as it is not possible to have both.
Car
Transmission Horsepower Air conditioningOptional
featureMandatory
features
Alternative
features
Manual AutomaticAir conditioning requires Horsepower > 100Composition rule:
Manual more fuel efficientRationale:
Figure 5-1: Example Showing Features of a Car
A feature model represents the standard features of a family of systems in the domain and
relationships between them.  The structural relationship consists of , which represents a logi-
cal grouping of features, is of interest. Alternative oroptional features of each grouping
must be indicated in the feature model. For example, the automatic andmanual features are
alternatives and the air-conditioning feature is optional, as indicated in Figure 5-1 by small
arcs and circles, respectively.  Each feature must be named distinctively and the definitionshould be included in the domain terminology dictionary.
Alternative features can be thought of as specializations of a more general category. For
example, the automatic and manual transmission features can be thought of as specializa-tions of the general "transmission" feature.  The term "alternative features" is used (ratherthan "specialization features") to indicate that no more than one specialization can be madefor a system.  However, the attributes of (i.e., the description made for) a general feature areinherited by all its specializations.
Composition rules define the semantics existing between features that are not expressed in
the feature diagram.  All optional and alternative features that cannot be selected when the
8named feature is selected must be stated using the "mutually exclusive with" statement. All
optional and alternative features that must be selected when the named feature is selected
must be defined using the "requires" statement.
7At the time of the publication of this report a car was announced which had both types of transmission
available simultaneously. This is a common evolution of features over time and is discussed in Section 8.2.1.
8The syntactical form and automated tool used to process this statement is presented in Section 7.3.2.6.
36 CMU/SEI-90-TR-21
Selection of optional or alternative features is not made arbitrarily. It is usually made based
on a number of objectives or concerns that the end-user (and customer) has. For example,in the case of buying an automobile, if the buyer’s only concern is fuel efficiency, then hemight want to take the manual transmission feature and the smallest available engine, per-haps a diesel if that option is available. However, if the user’s concern is fuel efficiency andmaintenance cost, and if the maintenance cost of a diesel engine were much higher thanthat of a gasoline engine, then he might want to take the gasoline engine option instead,even if the fuel efficiency is not as good as that of a diesel engine. A set of issues andalternative decisions in the selection of optional and alternative features is captured usingthe form in Appendix A.5.
One of the fundamental trade-offs a system architect makes is deciding when to "bind" or fix
the value of a feature, as this will have an impact on the final architecture.  For the purposeof generalization and parameterization of the software architecture, alternative and optionalfeatures are grouped into three classes based on when the binding of those features (i.e.,instantiation of software) is done, as depicted in Figure 5-2.
Compile-time features: features that result in different packaging of the software and,
therefore, should be processed at compile-time.  Examples of thisclass of features are those that result in different applications (ofthe same family), or those that are not expected to change oncedecided. It is better to process this class of features at compile-time for efficiency reasons (time and space).
Load-time features: features that are selected or defined at the beginning of execution
but remain stable during the execution.  Examples of this class offeatures are the features related to the operating environment(e.g., terminal types), and mission parameters of weapon systems.Software is generalized (e.g., table-driven software) for these fea-tures, and instantiation is done by providing values at the start ofeach execution.
Runtime features: features that can be changed interactively or automatically during
execution. Menu-driven software is an example of implementingruntime features.
Documentation of a feature model includes: a structure diagram showing a hierarchical
decomposition of features indicating optional and alternative features, definition of features,and composition rules of the features. Each feature definition should include the informationstated in the sample form in Appendix A.1.
5.1.3. Model Usage
The feature model serves as a communication medium between users and developers. Tothe users, the feature model shows what the standard features are, what other features theycan choose, and when they can choose them.  To the developers, the feature model in-dicates what needs to be parameterized in the other models and the software architecture,and how the parameterization should be done.
CMU/SEI-90-TR-21 37
Generic Component
ApplicationsRun-time Software/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patcharPreprocess
or generateat compile-timeInstantiate at
load-timeSelect at run-time
 
 
Figure 5-2: Processing of Features
Other domain models and the software architecture should be defined around the standard
features. Alternative and optional features must be incorporated into the models and ar-chitecture, but should always be parameterized with the corresponding features so that in-stantiation of the models and architecture can be done easily.
5.1.4. Process and Guidelines
The feature analysis process consists of: (1) collecting source documents, (2) identifyingfeatures, (3) abstracting and classifying the identified features as a model, (4) defining thefeatures, and (5) validating the model. The various sources of domain information are dis-cussed in Section 3.2; each of the remaining activities is detailed below.
5.1.4.1. Feature Identification
Application features fall largely into four categories (as shown in Figure 3-1 on page 24):
•operating environments
•capabilities
•domain technology
•implementation techniques
Of these features, this method focuses on the analysis of features related to application ca-
pabilities. (This limitation is due to the experimental nature of the current project. The featureanalysis process outlined in this section can be extended to cover other types of features.)
38 CMU/SEI-90-TR-21
Features related to capabilities can further be categorized into three areas (according to
[Myers 88]):
•functional features
•operational features
•presentation features
Functional features are basically "services" that are provided by the applications. Features
of this type can be found in the user manual and the requirements documents. Operational
features are those that are related to the operation of applications (again, from the user’s
perspective); that is, how user interactions with the applications occur. User manuals are agood source for this type of features.  The last category, presentation features , includes
those that are related to what and how information is presented to the users. User manualsand requirements documents usually provide information for this type of features.
The feature categories discussed above may not be complete; they are provided as a guide-
line for identifying features. Other types of features that are appropriate should also be in-cluded in the model.  More experience in domain analysis supports the definition of a morecomplete set of feature categories.
The identified features should be named and any naming conflicts should be resolved.
Synonyms for the features should also be recorded in the domain terminology dictionary.
5.1.4.2. Feature Abstraction, Classification, and Modelling
Once the features of all applications used in the analysis are named and defined and anynaming conflicts are resolved, then a hierarchical model should be created by classifyingand structuring features using the consists-of relationship. Whether or not each feature is
mandatory, alternative, or optional should be indicated in the model. Each feature in themodel should be defined. The description should also indicate whether it is a compile-time,an activation-time, or a runtime feature. This can be determined based on when and howfrequently the adaptation will be made.
The classification of the features can be used in the components construction for
modularization and for selection of appropriate development techniques.  If the domain iswell-defined and is expected to remain stable, a preprocessor or an application generatordevelopment technique might be appropriate to process the compile-time features.  A table-driven approach which has been used in many terminal handlers (e.g., UNIX "termcap" files)might be appropriate for the activation-time features, and an interactive menu might be ap-propriate for the runtime features.
5.1.4.3. Model Validation
Whether the feature model correctly represents the features of the domain must be vali-dated by domain experts and against existing applications.  The domain experts who havebeen consulted during the analysis should notbe selected for validation so as to avoid any
possible bias.  Also, at least one application that was not included in the analysis should be
CMU/SEI-90-TR-21 39
used in the validation to determine the generality and applicability of the model. If available,
a new setof several applications would provide a better validation, but the ability to do this
will depend on the maturity of the domain and financial constraints.
5.2. Entity-Relationship Modelling
5.2.1. Purpose
The entity-relationship model captures and defines the domain knowledge that is essentialfor implementing applications in the domain.  The domain knowledge is either contextualinformation which gets lost after the development, or is deeply embedded in software and isoften difficult to trace.  Those who maintain or reuse software have to re-acquire this knowl-edge in order to understand the problems that the application addresses.  Therefore, thepurpose of entity-relationship modelling is to represent the domain knowledge explicitly interms of domain entities and their relationships, and to make them available for the deriva-tion of objects and data definitions during the functional analysis and architecture modelling.
5.2.2. Model Description
The entity-relationship modelling technique in the FODA method is an adaptation of Chen’smethod [Chen 76] with semantic data modelling ( [McLeod 78], [Borgida 84]). Chen’s nota-tion and method are used, with the adoption of the generalization and aggregation conceptsfrom semantic data modelling that are used as predefined relationship types.  Therefore, thebasic building blocks of the model are entity classes and consist-of andis-arelationships.
Entity classes represent abstractions of objects in the application domain and the relation-ship types is-aandconsists-of represent generalization and aggregation relationships, re-
spectively. Aggregation relationships specify composition structures between entities whilegeneralization relationships specify commonalities and differences among entities.  Any re-lationship types other than these two relationship types that are important for the domainmay be defined using the form in Appendix A.4 and used in the model.  The definitions oftheis-aand the consists-of relationships are also included in Appendix A.4.
Relationships between entities are described graphically using [Chen 76].  An example of
the entity-relationship diagram notation may be found in Figure 7-5 on page 62. Other infor-mation pertaining to each entity may be described textually following the sample form foundin Appendix A.2.
More than one attribute may be defined for an entity. Also, attributes may be defined
separately from entities and may be used in an entity definition.  In this case, the values ofan attribute used in the entity definition must be within the range of the attribute value speci-fied in the original definition. Attributes used in the relationships must always be definedprior to use.  An attribute should be defined using the form in Appendix A.3.
40 CMU/SEI-90-TR-21
5.2.3. Model Usage
The primary use of an entity-relationship model is to support analysis and understanding of
the domain problems and to derive and structure domain objects used in the applicationsdevelopment. Entities are units of domain information that have to be processed and/ormaintained by the systems. They, with their definitions of attributes, can be used to identifydomain objects, which are then used to define data-flows and data-stores in the functionalmodel. They may also be used for object-oriented development.
The consists-of and is-a relationships generally are used to identify the compositions of
domain objects and the commonality and differences among domain objects, which will leadto the development of domain products that are general and parameterized. For example,an inheritance structure may be derived from is-arelationships in an object-oriented devel-
opment. Also, the consists-of relationships group together entities that are integrated. This
information can be used to identify consistency and integrity rules and to derive data-storesdefinitions in the functional model.  Often, integrated and related data are accessed togetherin applications and need to be kept in the same area.
5.2.4. Process and Guidelines
Construction of a system starts by perceiving entities and their relationships which may bederived from existing systems or from a hypothetical system.  (An entity is either a physicalentity or a concept.)  Then, the perceived entities and their relationships are named, andeach entity is characterized by its properties (attributes), some of which (for example, name )
may be used as identifiers.
One of the heuristics used in the development of an entity relationship model is that entities,
relationships, and attributes are usually English nouns, verbs, and adjectives, respectively.When analyzing the existing systems, nouns and verbs that repeatedly appear in the docu-mentation are collected, synonyms are identified, and the meanings of the words in the con-text of the domain are clarified. The nouns and verbs that appear repeatedly in the docu-mentation and are considered important conceptual elements for the domain are captured inthe model as entities and relationships, respectively. This is a heuristic, however, not analgorithm, and should be treated as such. It is limited in its usefulness, and should not beapplied indiscriminately.
The perceived reality may contain names which are not within the scope of the target
domain: they are eliminated from the model.  The concepts captured in the model constitutea major part of the domain terminology (which is recorded in the domain terminologydictionary).
The entities in the model are classified into homogeneous sets (classes or types) of entities;
homogeneous in the sense that all entities in the same class have some properties in com-mon. Each entity classified as such is named as an entity type , which is a unit in conceptual
model construction.  The generalization relationships identified during the classification willlead to is-ahierarchies. Other relationships existing between the entities, including the ag-
CMU/SEI-90-TR-21 41
gregation shown by consists-of relationships, are also classified into relationship types, and
these types are defined between the entity types. Properties of the entities in a class areclassified into attribute types, and for each attribute type, possible values are defined. Theentity-relationship model contains an abstraction of the target domain.
Of the many relationships that exist between entities, structural relationships are the most
interesting, specifically is-a(generalization) and consists-of (aggregation). These relation-
ships are important because they are critical to understanding similarities and differences.The entity-relationship analysis of the domain will primarily focus on these relationships; anyother relationship types that are important for the domain may be added in the entity-relationship model, but only after they are defined using the form in Appendix A.4.  The is-a
and the consists-of relationship types are predefined and the definitions are also included in
Appendix A.4.
5.3. Functional Analysis
5.3.1. Purpose
Functional analysis identifies functional commonalities and differences of the applications in
a domain. It abstracts and structures the common functions in a model from which appli-cation specific functional models can be instantiated or derived with appropriate adaptation.
The feature model and entity-relationship model are used as guidelines in developing the
functional model. The mandatory features and the entities are the basis for defining an ab-stract functional model.  The alternative and optional features are embedded into the modelduring refinement. Also, any factors (other than features) that cause functional differencesbetween the applications are defined as issues anddecisions , which are used in the refine-
ments for parameterization.
5.3.2. Model Description
Specifications of a functional model can be classified into two major categories: specifica-tions of functions and specifications of behavior. The specification of functions describesthe structural aspect of an application in terms of inputs, outputs, activities, internal data,logical structures of these, and data-flow relationships between them. The specification ofbehaviors describes how an application behaves in terms of events, inputs, states, con-ditions, and state transitions.  (The sample domain analysis presented in Chapter 7 employsthe Statemate Activitycharts andStatecharts to describe the functional and the behavioral
aspects, respectively.)
An abstract model of the functionality of domain applications is defined at the top level. (Any
difficulty in abstracting the functionality as a model might indicate that the selected domain istoo broad.) During refinement of a model, there may be cases where an entity of a modelcan be refined in more than one way. For instance, in the case where there is more thanone domain technology that can be selected, the selection of a particular technology canresult in functional specifications that are different from others. The analyst must understandthe implication of the selection of each technology and make a decision that is best for the
42 CMU/SEI-90-TR-21
application. The major decision points and the alternative decisions at each decision point
are captured as issues anddecisions by the FODA method. (This concept is also supported
by [Conklin 88], [Baldo 89], and [Bailin 89].) The rationale for each decision and any
constraints orrequirements derived from the decision are also recorded. The information
that is collected for each issue and the related decisions is shown in a sample form found in
Appendix A.
One thing that differentiates the FODA method from other domain analysis methods is
parameterization through the use of features andissues/decisions . As an abstract model is
refined, alternative and optional features are embedded into the model. Any issues raisedduring the analysis and the resolutions (i.e., decisions) of the issues are also incorporatedinto the model. There are generally three ways to incorporate the features and
issues/decisions into the model:
1. By developing separate components (refinements) for every alternative, as il-
lustrated by Case 1 of Figure 5-3.
2. By developing one component, but with parameterization for adaptation to
each alternative, as illustrated by Case 2 of Figure 5-3.
3. By defining a general component and developing each alternative as an in-
stantiation of the general component (with an inheritancemechanism) [Borgida 84], as illustrated by Case 3 of Figure 5-3.
Case 1A
BC A
BD
A
BC
DFeature A1 Feature A2
if A1
if A2
Case 2
Activity A1:
is-a AAperform CActivity AA:
perform A, BActivity A2:
is-a AAperform D
Case 3orActivity AA:
perform A,B
if A1 perform C
if A2 perform D
 
 Figure 5-3: Parameterization: An Illustration
Most of the requirements analysis techniques available today do not support the above ap-
CMU/SEI-90-TR-21 43
proaches, and it is especially difficult to extend them to support the second and third ap-
proaches. Statemate conditions are used in the example domain analysis to parameterize
specifications as illustrated by Case 2.
5.3.3. Model Usage
The primary uses of this model are to (1) understand the domain problems and (2) reusemodels in the requirements analyses.  The model represents the functionality of applicationsfrom an abstract level down to the detailed level. The decomposition structure and rationalesassociated with decompositions will help analysts understand the domain problems. Also,analysts can reuse the model at the level where it is most appropriate for the given appli-cation.
5.3.4. Process and Guidelines
The notion of generalization/specialization is adopted to define generic functions and ob-jects, and specifications of each system are made as specialization of the generic functionsand objects.  What to generalize/specialize can be determined as follows:
•Alternative features in the feature model may be used to identify generic func-
tions. Alternative features are specializations of a more general feature, andthe functionality corresponding to the general feature is defined as a genericfunction which is inherited by the functions implementing the alternative fea-tures.
•The generalization/specialization relationships (i.e., is-a relationships) of the
entity-relationship model can be used to identify generic objects and the func-tionality associated with the generic objects.
•The context model identifies the external entities and the commonalities among
the same type of entities, which can be used to definegeneralization/specialization of functions.
•Alternative domain technologies, with which different requirements decisions
are made, can be a basis for defining generic functions.  A generic function isdefined based on the commonality of the alternatives, which is inherited by thefunctional definitions of specific technologies.  This information is obtained byanalyzing and comparing applications in the domain during the function anal-ysis phase.
The process of functional model development takes both re-engineering and reverse engi-
neering approaches to specify the functionality of existing applications.  If requirements doc-uments are available, the functional models are re-engineered from the documents. Other-wise, the functional models are reverse engineered from the design documents and/or code.In either case the functional models are specified using data flow and state transitionmodelling techniques (which is done in the Statemate notation for the feasibility study).  Thesteps of the process are:
1. Gather and study the documents (e.g., requirements documents) describing
the functionality of the applications. See if there is any standard model or if amodel emerges as standard in the domain.
44 CMU/SEI-90-TR-21
2. Produce data flow and finite state machine representations of the functional
and behavioral aspects of each application used in the domain analysis.While naming objects in the representations, be certain that the semantics ofthe names are consistent; resolve any conflicts.
3. Based on the understanding of the models, see if there is enough common-
ality among the models to warrant a general model. If a general model cannotbe readily abstracted because of structural differences, check if the entity-relationship model can serve as a basis for object-oriented modelling [Coad89]. Check if the feature model or other real-world models such as the queu-ing network model, feedback control model, or decision support systemsmodels can be used to represent the problem.
4. Refine the general model until all the problems represented in the application
specific models are addressed. Embed features in the model to parameterizeor to define alternative decompositions.
5. Check if all features are properly addressed in the model; document the map-
pings between features and the objects of the model.
6. Have the model validated by domain experts. Demonstrate the applicability of
the model by using the model to describe an application not included in theanalysis.
CMU/SEI-90-TR-21 45
46 CMU/SEI-90-TR-21
6. FODA Architecture Modelling
6.1. Purpose
The purpose of architecture modelling is to provide a software "solution" to the problems
defined in the domain modelling phase. An architecture model (also known as a design
reference model ) is developed in this phase, and from it detailed design and component
construction can be done.
A primary goal of the FODA method is to make domain products reusable.  In the devel-
opment of an architecture model, architecture layering is done so that reuse can occur at thelayer appropriate for a given application and the impact of technical and requirementschanges to the model can be localized.
A FODA architecture model is a high-level design of the applications in a domain. Therefore,
the FODA method focuses on identifying concurrent processes and domain-oriented com-mon modules, and on allocating the features, functions, and data objects defined in thedomain model to the processes and modules. Many other implementation decisions stillhave to be made to complete the design.
6.2. Model Description
An architecture model must address the problems defined in the domain in a way that themodel can be adapted to future changes in the problems and technology. This adaptation isachieved through architecture layering where:
•An architecture is defined at various levels of abstraction so that reuse can oc-
cur at the level appropriate for a given application.
•Packaging of domain functions and objects is done separately from packaging
of implementation techniques so that:
•Implementation decisions can be separated from the packaging of func-tionality.
•The reusability of modules (both application-oriented and generic) can beincreased.
•The impact to the rest of the system arising from changes in implemen-tation techniques can be localized.
Many decisions are made during the design of a software system.  An application is decom-
posed into a collection of programs (i.e., processes) that can be compiled separately andexecuted in parallel.  (A finite state machine model from the domain modelling phase pro-vides the necessary information.) Each process must be designed as a hierarchy of mod-ules with the allocation of functions and data objects defined in the data-flow model.  Then,domain-oriented common modules that can be used across the applications must be identi-fied to increase the reusability.  Implementation decisions must be made in which various
CMU/SEI-90-TR-21 47
implementation techniques such as communication and synchronization mechanisms, proc-
ess scheduling methods, database management systems, and programming languages areselected.
A layered architecture of systems may be defined as shown in Figure 6-1.  This is based on
the types of design decisions discussed above and the general sequence of making thosedesign decisions.  The top, or domain architecture layer, is represented as a model showing
the concurrent domain-processes and inter-connections between them. This model is calledaprocess interaction model in the FODA method and is represented using the DARTS
(Design Approach for Real-Time Systems) methodology [Gomaa 84].  The layer below that,thedomain utilities layer, shows the packaging of functions and data objects into modules
and the inter-connections between. This is called module structure charts and is
represented using the Structure Chart notations [Yourdon 78] following the DARTS method-ology. Domain-oriented modules that are common across the applications in the domainare also identified. For example, in the window management system domain (discussed inChapter 7), window management library domain utilities (such as Xlib) are used for devel-oping window applications, and these utilities are identified in this layer.  The common
utilities layer contains modules that can be used across different domains.  Modules for
inter-process communication and synchronization (e.g., a message queue implementation,an event handler) and for data management belong in this layer.  Any utilities provided bythe operating systems and programming languages, such as, semaphores and the Ada run-time environment, belong in the bottom systems layer. Classifications similar to Figure 6-1
may also be found in [Shlaer 90] and [Neighbors 87].
Domain Architecture Layer
Domain Utilities Layer
Common Utilities Layer
Systems Layer
Figure 6-1: Architectural Layers
This methodology focuses on the top two layers, that is, the development of an application
domain-oriented architecture. It is a high-level design where the packaging of functions andobjects in software modules is the primary objective. Concurrent tasks are identified, and
48 CMU/SEI-90-TR-21
communication and synchronization between the tasks are defined using the DARTS nota-
tion. Each task is designed as a sequential program by allocating application specific func-tions and data using the Structured Design. No decision as to the implementation of com-munication and synchronization mechanisms is made at this level; they should be madelater to complete the design.
Components in each of the architectural layers above can further be layered based on the
levels of "conceptual models" one can define for the component.  For example, in the win-dow management system domain, a layered design can be developed as shown in Figure6-2. The layer at the lowest level, a virtual device driver, provides a conceptual model interms of the pixel level operations hiding peculiarities of particular devices from the rest of asystem. The next layer above the virtual device driver provides a conceptual model at thelevel of "graphics" where different types of lines and shapes are defined and the operationsto create, move, and destroy those are provided. The layer above the graphics layer is de-fined based on the concept of windows and window operations: a window has a shape,contains information, has display attributes, etc.; operations for creating windows, displayingcontents, and changing attributes are provided. The top level layer contains different typesof windows (typically called widgets ) including push buttons, scroll bars, menus, forms, etc.,
which can be composed to create more complex windows (i.e., composite windows).
Types of Windows
Windows (Core Class)
Graphics
Virtual Device Driver
Figure 6-2: Window Management Subsystem Design Structure
The following should be noted from the above example.
•Each layer is defined based on a "conceptual model."
•A conceptual model at a low level is generic across more domains than the
models above (i.e., each layer is a specialization of the layer below).
Designing a module based on a conceptual model is important because the model provides
a basis for defining objects and operations and for verifying the design. Also, with an under-
CMU/SEI-90-TR-21 49
standing of this model, users can easily relate this model to the problems they have and
decide if the module implementing the model will solve their problems.
Although low-level models are generic and reusable across more domains than high-level
models, the productivity increase from the reuse of high-level models is higher than that oflow-level models (as explained in Section 3.1.3).  Therefore, in the architecture modellingmany levels of layering should be done to increase both productivity and reusability.  How-ever, program performance might be degraded with many layers and an optimal decisionshould be made considering all these factors.
As with other models discussed in the previous sections, features and other design deci-
sions are embedded in the architecture model for parameterization.  Also, many design de-cisions (e.g., selection of an implementation technique) are made during the design, whichcan result in different implementations.  These decision points are captured as issues and
possible alternatives are captured as decisions in the architecture model as discussed in
Section 5.1.2.  The types of information collected on design issues and decisions are thesame as those collected on requirements issues and decisions (see Section 5.1.2 fordetails).
Packaging of functions and objects into modules must be done considering the processing
time of the features (i.e., compile-time, activation-time, and runtime) that each module imple-ments. Packaging of compile-time features must be done so that modules implementingeach compile-time feature can be identified uniquely from a collection of alternative modulesor be instantiated from general ones.  There must be a module for activation-time featuresthat collects values of the activation-time features at the start of execution, verifies the cor-rectness, and stores values for other modules to access during the execution of the appli-cation. For runtime features, a module(s) allowing interactive selection of the features duringexecution must be included in the design.
6.3. Model Usage
An architecture model can be used to:
•Make a detailed design and identify opportunities for reusable components.
•Provide a reference model for future systems development and for evolution of
existing systems.
•Ascertain reusability of candidate components.
•Provide a model for managing (classifying, storing, and retrieving) software
components in a domain.
•Provide a framework for tooling and systems synthesis.
An architecture model for a domain serves many different purposes. It is in essence a stan-
dard reference model for building applications in the domain, and thus may be used as aframework for building new systems, as a means to educate potential system engineers inthat application domain, or as a template for the construction of domain-specific reusablecomponents.
50 CMU/SEI-90-TR-21
6.4. Process and Guidelines
FODA uses the DARTS methodology to develop an architecture model with some exten-
sions for parameterization of modules as illustrated in Figure 5-3.  (The DARTS method-ology uses the Structured Design [Yourdon 78] technique to design module structures.Therefore, the Structured Design technique will be considered a part of the DARTSmethodology.) The DARTS methodology is summarized here; details can be found in
[Gomaa 84].
•Real-time software consists of a set of synchronously or asynchronously com-
municating tasks. Each task is a sequential program.
•From data flow diagrams, concurrent tasks are identified using the following cri-
teria:
•dependency on I/O devices
•time-criticality
•computational requirements
•functional cohesion
•temporal cohesion
•periodicity
•A Task Communication Module (TCM) handles all cases of communication
among tasks.  Two types of TCMs are supported in DARTS: message commu-nication modules for loosely or tightly coupled message communication, and in-formation hiding modules for data pool or data store.
•A Task Synchronization Module (TSM) is typically the main module of a task,
controlling the synchronous behavior of the task. A task may wait for one ormore synchronizing or message queue events.
•Each task is designed using the Structured Design technique.
A process for developing an architecture model is defined below based on the DARTS
methodology, the architecture layering concept, and the parameterization concept. Theprocess is:
1. Identify major concurrent processes from the data-flow diagrams and finite
state machine diagrams. A Statemate representation of the finite state ma-chine identifies parallel states which indicate concurrency.
2. Identify other concurrent processes using the criteria provided by DARTS.3. Allocate the functions and data to each process and check if all the functions
and data in the data flow diagrams are properly allocated to the processes.
4. Define process interactions using the DARTS notation.5. Design each process using the Structured Design method producing structure
charts. (Other design methods may be used instead of the Structured Designmethod.) Each process consists of a TSM (as the main module), which in-vokes TCMs and application modules. Application modules include abstractdata types, mathematics libraries, device interface modules, and other infor-mation hiding modules. In designing application modules apply the layering
CMU/SEI-90-TR-21 51
concept as shown in Figure 6-2.  Also, define modules for activation-time and
runtime features.
6. Parameterize modules for the compile-time features (as shown in Figure 5-3)
so that they may be instantiated for different selections of compile-time fea-tures.
7. Specify the components identified in the structure charts.  Specifications of
each module should include operations and parameters, a high-level internallogic, and allocation of features and functions.  Ada PDL [IEEE 89] may beused for this purpose.
52 CMU/SEI-90-TR-21
7. Application of Domain Analysis to Window
Management Systems
The previous four chapters have presented the underlying concepts and specific products of
the FODA method.  This chapter presents a comprehensive example of their application.
As a sample domain window manager software , a sub-domain of window management sys-
tems software, offers a fairly complex set of requirements for domain analysis and is an
application area that should be familiar to most users of the method.  This domain features:
•Availability of many examples of implementations.
•Relevant literature and documentation, both user and developer.
•Availability of domain expertise to those performing the example analysis.
This chapter presents an application of the FODA method to the window manager software
domain. An overview of window manager capabilities is presented, followed by presenta-tions of each of the domain analysis products produced in the course of the study. Due tothe size of even this sample domain, only excerpts of some of the models are discussed.For the complete documentation of the analysis, see Appendices B-G.
The example covers the first two phases of the FODA method: context analysis and domain
modelling. The context analysis section focuses on the window manager context diagramand structure diagram. (However, not all of the steps outlined in Section 4.4 were performeddue to resource constraints.) The domain modelling section describes the window managerentity-relationship diagram, the different components of the feature model (feature diagram,composition rules, and "issues and decisions") and the automated features tool, and thefunctional behavior model’s data flow and state transition models.  Although the architecturemodelling phase of the method was not applied to this sample domain because that portionof the methodology had not been completed, the results of the first two phases demonstratea successful application of much of the method.
7.1. Definition of a Window Management System
Awindow management system (often called simply a window system ) is a type of interactive
user interface that enables users to work with multiple separate applications at the sametime. This is achieved through the use of a desktop metaphor, in which each process is
associated with a graphical window, which is visually analogous to a paper or document on
a physical desktop. Users may switch back and forth between different applications much asa person at a desk might choose between different documents on a desktop in the course ofa day. A window management system provides the functionality to create and manipulatethis display of multiple processes.
The functionality of a window manager is central to a window management system, and is to
help the user manage screen "real estate," i.e., the portions of the screen that are available
CMU/SEI-90-TR-21 53
for displaying useful information.  The window manager helps the user to do this by provid-
ing various operations on windows that are, again, taken from the desktop metaphor.
For example, the window manager allows users to make ( create ) and discard ( destroy ) win-
dows. Users can relocate ( move ) windows to different positions on the screen just as they
might move documents on a desktop. Some window managers allow users to stack ( expose
and hide) windows on top of one another.  Most window systems extend the desktop
metaphor by allowing users to change the size of windows ( resize ) and to change ( iconify )
the windows into icons , an alternate form of the window that requires little space. With these
operations available the user is in full control of the appearance of the workstation screenand may effectively manage several different tasks.  Figure 7-1 shows a conceptual view ofwhere the window manager is positioned relative to the "outside world." It accepts user in-puts from the pointer (mouse) and the keyboard, communicates with the appropriate inde-pendent client programs, and sends the output to the display [Peterson 86].
Despite the fact that the window manager in some sense has control of the user interface, it
does not directly influence the applications that run in the windows; it simply routes the inputand output to and from the application. Often a window manager has no knowledge of thecontents or activities of an application within a window. As an example of this, applicationsare often responsible for maintaining the contents of their own windows. The window man-ager will notify an application that its display has been damaged (i.e., by having a previouslyobscured portion revealed), but the application is responsible for redrawing it. Even if thewindow manager does preserve obscured portions of windows for the applications, it is
simply saving graphic data.
There are many different implementations of window managers and some have important
differences, but there is still significant commonality. Some window managers do not allowwindows to be stacked on top of one another ( tiled systems), while most others do
9(overlapped systems). Other window managers do not support icons, or have more subtle
differences in the way the common operations work. Nonetheless, virtually all window man-agers support creating, destroying, moving, resizing, and other window operations.
An important aspect of window management systems is the distinction between the
capabilities of the window system and the presentation style , or set of conventions, by which
the window system operates. Often applications are written under a window system where aconsistent appearance, style, and interface, referred to as a "look and feel", are consideredmore important than the functionality of a single application. The window manager is an im-portant part of the "look and feel" of a window system, primarily supplying the "feel."  Of thewindow managers that are currently available, many have been written to run under X win-dows, since X allows a "user-defined" window manager that is separate from the rest of thewindow system. The following list of window managers displays a wide range of function-ality, all implemented with the X window system.
9In fact, a window manager may support virtually any window layout policy the designer wishes to impose.
54 CMU/SEI-90-TR-21
Window
managerDisplay
Keyboard
Mouse
Client programs
UserActs ReactsApplication
Acts Reacts
Figure 7-1: Function of a Window Manager
•uwm: Universal Window Manager
•olwm: Open Look Window Manager
•wm: Andrew Window Manager
•mwm: Motif Window Manager
•wmc: CMU Computer Club Window Manager
•twm: Tom’s Window Manager
•gwm: Generic Window Manager
In other systems the window manager is integrated into the window management system
and has no individual name, as is the case in the Macintosh, SunView, the Symbolics win-dow system, and others.
CMU/SEI-90-TR-21 55
7.1.1. Window Manager Capabilities
In order to be able to discuss the capabilities of window managers it is necessary to review
some of the basic functionality.  Some of the operations which are typically, but not neces-sarily, provided by a window manager are:
•Create andDestroy
•Move andResize
•Iconify andDeiconify
•Hide, Expose, andCirculate
•Change Focus
•Refresh
For the purposes of explaining the FODA method in the context of the window manager, the
examples will be centered around the window manager Move operation for windows. Move
is amandatory operation, and must be present in all window managers. This restriction in
scope of the presentation of the analysis is done to limit the amount of new concepts andterminology which must be introduced. Move was chosen because it is one of the most
complex operations a window manager must perform; as a result it has a wide variety offeature variations.  The full set of features and other results for all window manager opera-tions may be found in Appendices C-G.
Figure 7-2 depicts several common window manager features that pertain to the Move oper-
ation. These are defined below.
constrainedMove: A window may be constrained so as to move only
horizontally or vertically, rather than in any direc-tion.
eraseBefore/eraseAfter: The image of a window is erased either before
the move operation begins, or after it ends.
exposeAfterMove: After the move operation ends, the window is
10placed at the top of the stacking order (in an
overlappedLayout system).
ghostFeedback/opaqueFeedback: Either a "rubber-banded" outline of a window
(ghost), or the entire window image (opaque) isdisplayed while the position of the window isbeing changed.
moveIcon: This feature provides the ability to move an icon
to a new location.
objectAction/actionObject: (also called select-then-operate orsubject-verb )
This feature determines if the user must first se-lect an object to operate on (a window) and then
10The order of overlapping sibling windows that determines which one lies visually on top and which on the
bottom. Circulating, exposing, andhiding windows changes the stacking order. The first window in the stacking
order is the window on top.
56 CMU/SEI-90-TR-21
an action to perform on it ( objectAction ), or
vice versa.
overlappedLayout/tiledLayout: Either windows may overlap (or be overlapped
by) other windows, or no windows are allowed tooverlap (like tiles).
partiallyOffScreen: A window is allowed to be pushed partially (but
not entirely) off the screen.
realEstateMode/listenerMode: (also called point-to-type orfollow-the-pointer )
TherealEstate feature is a paradigm where
thekeyboard input focus is always at the window
in which the pointer is currently "in." InlistenerMode (also called click-to-type ) the in-
put focus is set to be a particular window by amouse click, regardless of the position of thepointer.
zapEffect: Optional "ghost" lines which temporarily "flash" to
follow a window or icon from its original positionto its new position after a move operation.
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar /patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patcharZapEffect
/patchar/patchar
/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
ConstrainedMove
OverlappedLayout
TiledLayout/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patcharPartiallyOffScreen
OpaqueFeedback
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patcharGhostFeedback/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patchar/patchar/patchar
Figure 7-2: Sample User Features Found in Window Managers
CMU/SEI-90-TR-21 57
7.2. Scoping the Window Management System Domain
The first step in performing any domain analysis is to gather sufficient information about the
domain. The following sources were used as inputs to the window manager domain anal-ysis:
Domain experts: people with extensive knowledge of user interfaces and window man-
agement systems, and experienced users of these systems.
Window systems: user experience primarily with features of X10/uwm, VMS Windows, and
SunView, with additional experience with X11/uwm, Macintosh, Andrew,Symbolics, OSF/Motif, and NeWS
Domain literature: books, articles, surveys, manuals, and evaluations of many different
window managers and window management systems
It is essential to first thoroughly understand the proposed domain area in order to properly
scope the domain. A lack of sufficient domain knowledge can lead to choosing domains thatare too large, have relatively little commonality, or do not have clean, logical boundaries totheir scope.
After an initial review of the window management system domain, it became clear that an
analysis of the entire domain was inappropriate for a small-scale feasibility study. It alsobecame clear that the window manager portion was central to the user-visible functionality
of the window management system. Further study of window managers confirmed this, andthe window manager itself became the scope of the feasibility study domain analysis.
Given a well-defined domain, at this stage of the process it is most useful to have access to
any previously done surveys or commonality studies of applications in the domain. Suchsurveys do exist for many domains. In the window management domain, a paper by BradMyers, "A Taxonomy of Window Manager User Interfaces" [Myers 88], provided an excellentstarting point for further research, as well as an initial bibliography. Given a basic back-ground in the domain, other references could be researched for additional information be-fore having discussions with domain experts.
A significant advantage in collecting information about external, user-visible aspects of win-
dow managers came from the ready availability of multiple implementations of window man-agers. While this availability of systems is not the case in some other domains, there arealways "existing systems" of some kind, even if they are manual systems and/or procedures.
In terms of the FODA method, scoping of the domain to be analyzed is done in the context
analysis phase. The two primary products of this phase are the structure diagram and the
context diagram . The purpose of these diagrams is to clearly delineate what the scope of
the analysis is to be.  It is useful for the domain analysts to return to these diagramsthroughout the analysis as they help to avoid unnecessary and wasteful digressions.
The structure diagram (shown in Figure 7-3) shows the position of the window manager
within the entire domain of window management systems.  The window manager is shown
58 CMU/SEI-90-TR-21
in bold outline in the upper left corner. The purpose of this diagram, informal though it may
be, is to separate the logical concept of the window manager from many other related itemswith which it is often confused. For example, a window manager is nota graphical user
interface (GUI), although it may provide the "feel" portion of a GUI’s "look and feel".
The context diagram (shown in Figure 7-4) is a standard top-level data flow diagram of the
interfaces a window manager has with the other significant parts of a window managementsystem. This particular view of the role of a window manager within a window system wasone of the products of the early context analysis process, and was not taken from any out-side source. In the context diagram the functionality of the window manager is separatedfrom the closely related functions of the input manager, the process manager, and the dis-play manager. The input manager converts the "raw" user input events into higher-levelevents for the window manager.
The implications of this arrangement are that the window manager is not responsible for
interpreting combinations of keys and button presses, dealing with application processes, ormaintaining the integrity of the screen. The window manager isresponsible for allowing the
user to manipulate the shape, size, and position of windows. These other (admittedly closelyrelated) activities are notpart of the window manager functionality and are therefore not part
of the window manager domain analysis. While the context diagram serves as a good cut atthe boundaries of the domain analysis scope, the process of refining the scope continuesthroughout the analysis.
7.3. Domain Model
Thedomain model (as explained in Chapter 5) describes the elements of systems in a given
application domain from the point of view of a "problem space"; that is, what the systems in
that domain must do. It complements the architecture model (i.e., the solution space ) which
describes various alternative ways in which systems may be built to meet the requirementsof the domain model and the operating environment.
The domain model comprises the following:
•entity-relationship model
•feature model
•functional model
•domain terminology dictionary
The domain terminology dictionary is used to standardize the terminology that describes the
domain. The dictionary is especially critical in a new and rapidly evolving domain, such aswindow management systems, where no clear standard may exist. As an example, even theterm "window" is non-standard, also being referred to as "view," "canvas," and "wob" in dif-ferent window system documents. The dictionary results from information gathering in all ofthe analysis phases. The dictionary resulting from the window manager domain analysis hasapproximately 300 entries including many synonyms due to the evolving window systemnomenclature. This dictionary is included in this report as Appendix B.
CMU/SEI-90-TR-21 59
X Protocol
......Open Look, Motif, ...
Xlib, ...Toolkit
Xt, Xview, ATK, Motif, ...Widgets/Controls
Intrinsics/Primitives
LibraryGraphical User Interface (GUI)Application Programmer
Interface (API)
X, NeWS, ...xterm, sight, IDE, ...managers manageruwm, awm, olwm, ... Window Other
Device drivers Sun, DEC, HP, IBM, ...Device drivers
ServerExamples Examples
Protocol
Kernel-based Client-serverWindow
Management
SystemApplic.
#1 #nApplic.
Figure 7-3: Structure Diagram: Relationship of Window Managers
to Window Management Systems
The following three sections describe the three components of the domain model for the
window manager domain analysis: the entity-relationship model, the feature model, and thefunctional model.
7.3.1. Entity-Relationship Model
The entity-relationship model used in the domain analysis consists of three parts:
1. entity-relationship diagram
2. attributes of the entities3. constraints on the entities and relationships
Figure 7-5 is the entity-relationship diagram for a window manager, showing (in a different
way from the context diagram) its relationships with the other significant entities of windowsystems in general. These entities are (as shown in Figure 7-5):
60 CMU/SEI-90-TR-21
/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar/patchar
/patcharInput
Manager
Window
Manager
Process
ManagerConstraints,
Parameters
Screen
ManagerKeyboard &
mouse events
Constraints,
initial values
Screen
updates
Window
changesProcess
changes
Figure 7-4: Context Diagram: Major Data Flows of Window Management
Systems
•window
•main window
•process
•icon
•screen
•pointer
Many of the relationships shown in the diagram are straightforward, such as those between
11the pointer, the screen, a window, and the application process(es). Some of the other
relationships require further explanation.  By its nature this diagram is a generalization of theway many window systems are structured, and therefore the degree to which it maps direct-ly to the model of a specific implementation varies. The diagram uses the is-a and
consists-of relationships defined in Section 5.1.2 to show that both an icon is-awindow, and
12a "main window" is-awindow. The diagram calls out these two entities as specializations
11The 1-to-many relationship between the screen and the pointer is a maximum. While this is almost always a
1-to-1 relationship in practice, the emerging window manager technology indicates that this may change.
12Amain window is a window displayed in its normal, full form, i.e., notan icon.
CMU/SEI-90-TR-21 61
screen
pointerhas
is ahas connects
tois ahashas
has
cursor picture
for1 m
1
mm child 1 parent
main
window process
window icon
111
1m
n
Figure 7-5: Window Manager Entity-Relationship Diagram
of a generic window entity because they are closely related, and they are fundamental to
window managers. While some implementations explicitly view icons as a type of window(such as X Windows), others do not. However, the fact that a particular implementation doesnot treat icons as a type of window does not invalidate the application of the entity-relationship diagram to that implementation.
Another relationship depicted in the diagram is the one-to-many, parent-child, hasrelation-
ship among main windows, which describes a parent-child hierarchy. While this is not al-ways the approach used in actual implementation, it is useful to describe the behavior whenone window manager operation can affect a group of seemingly independent windows.
The attributes associated with these entities are listed in Appendix A. The attributes could
be used in designing the data structures of the implementations of these entities, much asthey are traditionally used in database schema design. One assumption that is made in thelisting of these attributes is that inheritance of attributes will take place across is-arelation-
ships. As a result, attributes belonging to the generic window entity are not also listed asbelonging to icons or main windows.
In addition to the entity-relationship diagram and the attributes, during the course of the
domain analysis it became clear that there are many (typically unstated) constraints on theoperation of a window manager.  The entity-relationship model can include these constraints
62 CMU/SEI-90-TR-21
as well, even though they are not expressible through the entity-relationship diagram.
These constraints include:
•There is at most one input focus.
•There is one rootwindow that has no parent window.
•Therootwindow exactly covers the screen.
•The pointer cannot leave the area of the screen.
•Events propagate from the source window to ancestor windows until they are
handled.
•Child windows exist only while their parent windows do.
Some constraints are specific to the presence of certain features in the window manager.  In
such cases the entity-relationship model may be parameterized by the feature model, as aremany other models of the domain model.
If thewindowLayout isoverlappedLayout then:
•A child window must be in front of its parent window.
•Only sibling windows may overlap.
•Child windows are clipped by their parent window.
•The position and size of child windows within their parent window can be fixed.
7.3.2. Feature Model
The purpose of the feature model is to describe the "requirements space" of known window
managers. The model should encompass as many window managers as is feasible, to in-clude the fullest range of features and feature values.  A specific implementation of a win-dow manager, such as the OSF/Motif mwm, may be thought of as an instantiation of the
feature model, or a set of feature values which describes its particular capabilities. Being
able to describe a proposed system to a potential customer in terms of the possible featureswhich can be provided simplifies the requirements elicitation process, and can clarify thevarious implicit trade-off decisions which must be made.
The components of the feature model are as follows:
Feature diagram: A graphical And/Or hierarchy of features
Composition rules: Mutual dependency (Requires) and mutual exclusion
(Mutex-with) relationships
Issues and decisions: Record of trade-offs, rationales, and justificationsSystem feature catalogue: Record of existing system features
The following paragraphs discuss each of these parts of the feature model in detail.
CMU/SEI-90-TR-21 63
7.3.2.1. Feature Diagram
The feature diagram, shown in Figure 7-6, is an and/or tree of different features. Optional
features are designated graphically by a small circle immediately above the feature name,as inpartiallyOffScreen .Alternative features are shown as being children of the same
parent feature, with an arc drawn through all of the options, as is the case inwindowLayout . The arc signifies that one and only one of those features must be chosen.
The remaining features with no special notation are all mandatory .
The line drawn between a child feature and a parent feature indicates that a child feature
requires its parent feature to be present; if the parent is not marked as valid, then the child
feature for that system is in essence "unreachable."  For example, if the windowLayout
were selected to be overlappedLayout , then the feature tiledColumns would be
"unreachable" for that specific system, since its parent tiledLayout would not be valid.
interiortiled
tiledLayoutMoveOpabort
Inputmove
borderIconmove
Feedbackinteractive
Feedbackghost
FeedbackopaquemoveResizeFeedback
erase
After BeforeeraseErasuremove
MoveAfterexposepartially
OffScreenMove
Configurationwindow zapEffectconstrained
MovewindowLayout
overlapped
Layout
tiled
Columns Arbitrary
Figure 7-6: Features for the Window Manager Move Operation
To illustrate the use of the feature diagram Figure 7-7 shows a comparison of the move
operation features for two different existing window managers: X10/uwm and SunView. Theselected optional and alternative features are highlighted in the diagram with boxes. For ex-ample, notice that the feature partiallyOffScreenWindows (abbreviated on the
diagram) is present in X10/uwm, but not present in SunView. Thus, when a SunView win-dow is moved so that its border touches the edge of the screen, the window will stop movingin that direction. In X10/uwm the window will continue to move, disappearing off the screen,until the cursor hits the screen edge and stops the window from moving completely off.
This type of comparison information, which may be available in this graphical form or in the
catalogue form shown in Appendix C, makes the task of evaluating and comparing different
64 CMU/SEI-90-TR-21
systems straightforward. Certain types of information are more difficult to obtain from such a
display, such as knowledge of invalid feature combinations or underlying issues andrationales. These types of information are discussed in the next two sections.
windowLayoutwindowLayout
interiorinterior
Arbitrary ColumnstiledLayoutoverlappedMoveconstrained
zapEffect window
ConfigurationOffScreenpartially expose
AfterMovemove
Erasure
erase
Before AftererasemoveResizeFeedback
opaque
Feedbackghost
Feedbackinteractive
FeedbackmoveIcon
bordermove
Inputabort
MoveOp
Layout
tiledtiledMoveX10/uwm
tiled
tiledLayoutMoveOpabort
Inputmove
borderIconmove
Feedbackinteractive
Feedbackghost
FeedbackopaquemoveResizeFeedback
erase
After BeforeeraseErasuremove
MoveAfterexposepartially
OffScreen
Configurationwindow zapEffectconstrained
Move
overlapped
Layout
tiled
Columns ArbitrarySunView
Move
Figure 7-7: Comparison of Move Operation Features in X10/uwm and SunView
7.3.2.2. Composition Rules
Features are related to one another primarily through the use of composition rules, which
are a type of constraint on the use of a feature. Composition rules have two forms: (1) onefeature requires the existence of another feature (because they are interdependent), and (2)
one feature is mutually exclusive with another (they cannot coexist).
The textual representation for these rules is as follows:<feature1> (‘requires’ | ‘mutex-with’) <feature2>An example of a composition rule used in the window manager domain is:
moveIcon requireshasIcons
In Section 7.1.1 these window manager capabilities were defined. Composition rules may be
obvious, given an understanding of the domain. In this case a window manager cannot have
CMU/SEI-90-TR-21 65
themoveIcon feature unless the system hasIcons . While this is clear, in large system
definitions these interdependencies can be lost in the overall complexity.  Also, some com-position rules are less immediately obvious, but are based on common sense. For example:
opaqueFeedback mutex-with moveErasure :
If the entire window image is moved, then there is nothing left in the previous posi-tion to erase.
zapEffect requ iresghostFeedback :
If the entire window image is moved (i.e., opaqueFeedback ), then there is no
window to draw the final zap lines from.
zapEffect requireseraseAfter :
If the old window image were erased before the move operation, then there would
be nowhere to draw the final zap lines from.
ghostFeedback requiresmoveErasure :
IfghostFeedback is used, then the old window image must be erased at some
point, either before or after. Thus one of the two alternatives of moveErasure
must be selected.
exposeAfterMove requiresoverlappedLayout :
Anexpose operation can only be done in an overlapped system.
These composition rules relating the features were often derived from experience with sys-
tems that have these features. For example, observing the interaction of ghostFeedback
andmoveErasure makes the composition relationship clear.
7.3.2.3. Issues and Decisions
A record of the issues and decisions that arise in the course of the feature analysis must be
incorporated into the feature model to provide the rationale for choosing options and select-ing among several alternatives.  As an example, the interactiveFeedback feature has
two different alternatives: ghostFeedback andopaqueFeedback . It is impossible to se-
lect one or the other without having access to the same information the original designerhad. However, if the feature model contains a record of the original rationales, it is a simpleprocess. The following excerpt from the "Issues and Decisions" record attached to the
13interactiveFeedback feature demonstrates the usefulness of this information.
13The forms for recording this information (presented in Appendix A) were modified for use with the window
manager example.
66 CMU/SEI-90-TR-21
Issue: Resource consumption/Feedback clarity
Description: interactiveFeedback is the way the window manager shows the user the
current size or shape of a window being moved or resized.
Raised at: interactiveFeedback
Decision:ghostFeedback
Description: An outline and/or grid of the window is drawn and
moved with the cursor to the new location, wherethe complete window is drawn (and the old windowerased).
Rationale: Provides sufficient user feedback for positioning
and resizing, and requires significantly fewerresources than redrawing the entire image oftenenough to follow the moving cursor.
Decision:opaqueFeedback
Description: The window manager moves or resizes the entire
original image of the window.
Rationale: Opaque moving and resizing allows the user to see
immediately what the window will look like in thenew position or shape, and is typically used on fastdisplays where the act of updating a potentiallycomplex window display is feasible.
If the user knows enough about the trade-offs between the two options, then an informed
decision based on the user’s hardware environment (in this example) may be made.
7.3.2.4. System Feature Catalogue
In the course of gathering information for the domain analysis, one useful source is experi-ence with existing systems in the domain. This is not always an option, as some domainsmay have a history of largely manual methods, but in the case of window managers thereare many existing systems. It is important to record the features and feature values of actualexisting systems (even in the case of manual methods) to allow for later modelling of thesystems in terms of their features. An excerpt of the system feature catalogue generated forthe window manager domain analysis is given in Table 7-1 for the Move operation features.
CMU/SEI-90-TR-21 67
System/Feature X10/uwm VMS Windows SunView Mac Windows
moveWindow Move yes Move yes
constrainMove no no yes no
moveIcon yes yes yes no
moveErasure after before after
exposeAfterMove yes yes no yes
zapEffectMove ∗ no no no
interactiveFeedback ∗ ghost ghost ghost
partiallyOff yes yes no yes
abortMove no no Cancel no
selectOrder actionObject objectAction objectAction objectAction
Table 7-1: Window Operation Functionality
Certain window managers have already incorporated into their software some of the range
of variation in the domain, making it possible for the user to specify certain features of theappearance and functionality at activation-time or runtime. This is specified in Tableref{Catalogue} by an asterisk (" ∗"). The X11/twm window manager profile file offers a num-
ber of user-settable options, many of which relate directly back to features offered in thefeature model. Some of these features are illustrated in Table 7-2.
In the full feature catalogue tables in Appendix C, as well as in Table 7-1, the following
conventions are used:
•<Name> : This is the name used for this feature on this system (i.e., Move or
Cancel ).
•"yes/no ": This feature does/does not exist on this system.
•<blank> : No information has been collected for this feature on this system.
•"∗": This feature is bound at either activation-time or runtime, but not at compile-
time.
•"--": This feature is inapplicable to this system (a composition rule with anoth-
er feature excludes it).
68 CMU/SEI-90-TR-21
Profile Option Feature
AutoRaise {" application "}exposeAfterMove
DontMoveOff no partiallyOffScreen
DontIconifyByUnmapping unmappedDeiconifiedIcons
IconManagers {" application "}iconBox
NoHighlight no highlightInputFocus
NoRaiseOnDeiconify no exposeAfterDeiconify
NoRaiseOnResize no exposeAfterResize
NoTitle no titleBars
NoTitleHighlight no titlebarHighlight
OpaqueMove opaqueFeedback
StartIconified createIconified
WarpCursor warpToWindow
Zoom 10 zoomEffect
Table 7-2: X11/twm Profile Options Related to Features
7.3.2.5. Model Validation
The feature model may be used to predict behavior in a given scenario based on the feature
values of a specific system. The results of having two (or more) specific systems perform anoperation may be compared with the results predicted by the feature model instantiations forthose systems. Any variation between the predicted and actual results should indicate prob-lems with the system descriptions of one or both systems.
An example is a comparison of X10/uwm andSunView in performing a move operation on
an existing window at the bottom of the stacking order, and trying to push it off the screenwhile it is overlapped by another window. While the scenario is simple, it can involve a sig-nificant number of features.  The results of the scenario (given by listing features from thecatalogue for each system) are as follows:X10/uwm:
•actionObject: Command is selected before the window.
•opaqueFeedback: Feedback is an image of the window itself.
•partiallyOffScreen: Window moves partially off the screen.
•exposeAfterMove: Window is exposed after the move.
•realEstateMode: Window becomes the input focus after move due to the
pointer position being above the window.
CMU/SEI-90-TR-21 69
SunView:
•objectAction: Window is selected before the command.
•ghostFeedback: Feedback is an outline of the window.
•nopartiallyOffScreen: Window kept inside screen.
•noexposeAfterMove: Window still partly hidden.
•listenerMode: Window becomes the input focus before the move by clicking
to select it.
Due to the choices made by the designers of X10/uwm and SunView, and the runtime selec-
tions made in this example for X10/uwm ( opaqueFeedback andrealEstateMode ), the
results are direct opposites of one another in terms of the possible feature values.
7.3.2.6. Automated Tool Support for Features
Manually creating a feature model that correctly describes a complex domain is a large ef-fort; validating that model in some way is still more difficult. As part of the feasibility study forperforming useful, "real-world" domain analyses it became clear that manual methods wouldnot suffice, even in a relatively small example. Because the FODA method is new, and noexisting automated tool support was available, a prototype tool was developed using Prolog.The primary function of the tool is to validate the usefulness of the feature analysis ap-proach, and secondarily to establish some baseline requirements for future automated sup-port for the method.
The tool is separate from the information about the domain being analyzed, so that it may be
applied to any domain. The features are stored in a Prolog fact base, along with the com-position rules and other related information.  The tool supports definition of existing or pro-posed systems by allowing arbitrary sets of feature values to be specified and checked. Thecomposition rules relating the features are enforced, as are standard rules about complete-ness of the model.
Given a set of user-specified (i.e., "marked") features, the automated features tool presently
performs the following functions:
•Checks for allfeatures that are specified, but which may not be reachable.
•Marks a feature as "valid" if it is either:
•marked "valid",
•mandatory,
•notmarked "invalid", or
•required by a "valid" feature.
•Marks a feature as "invalid" if it is mutually exclusive with a "valid" feature.
•Produces an error if a feature is marked as both "valid" and "invalid."
•Enforces the proper selection of alternatives:
•at least one alternative must be marked "valid."
70 CMU/SEI-90-TR-21
•more than one alternative cannot be "valid."
14The features stored in the fact base have six pieces of information attached to them (see
Appendix A). These are illustrated with the example of the exposeAfterMove feature be-
low.
Name: exposeAfterMove
Description: Expose the window at the end of a move operation
Type: optional
Parent: moveWindowOp
Rules: requires overlappedLayout
Source: SunView window system experience
The fact as it is stored in Prolog format is as follows:
daFeature(exposeAfterMove,
’Expose the window at the end of a move operation.’,optional,moveWindowOp,[requires(overlappedLayout)],’SunView window system experience’).
In addition to the general feature model, specific systems (i.e., sets of feature values) may
also be stored; as they are developed they may be periodically checked for consistency. Toillustrate this consistency checking process, the following small example of an inconsistentsystem description will suffice.
An imaginary (and certainly incomplete) system is specified with a set of only three feature
values:
•zapEffect
•eraseBefore
•opaqueFeedback
While the actual automated features tool will report in detail the incompleteness of the
model, for now the focus is only on the consistency of the feature model or lack thereof. It isalready clear from the discussion of the sample composition rules in Section 7.3.2.2 thatthese particular features are not compatible, and in fact a run of the features tool on theabove "system" definition produces a report including the following messages:
•ghostFeedback is selected due to zapEffect .
•eraseAfter is selected due to zapEffect .
•moveErasure is selected due to ghostFeedback .
14The issue and decision information should be stored in the Prolog automated features tool with the feature,
but currently is not.
CMU/SEI-90-TR-21 71
•moveErasure isinvalid due toopaqueFeedback .
•More than one alternative of interactiveFeedback has been selected- only
one is allowed.
In this case the features tool attempted to make the description complete where possible,
without knowing that doing so would lead to inconsistencies.  For example, it addedghostFeedback anderaseAfter , as well as others. There are several inconsistencies
here: both ghostFeedback andopaqueFeedback have been selected (i.e., more than
one alternative); both eraseBefore anderaseAfter have been selected; moveErasure
has been marked as both valid and invalid. While the system will continue to discover othererrors, only one is necessary to point out that the system description is incorrect. As is thecase with many similar systems (notably compilers), further messages may provide little ad-ditional information.
7.3.3. Functional Model
The functional model of the domain analysis identifies functional commonalities of the ap-plications in a domain.  The model also seeks to identify and compare differences betweenthese related applications.  The model abstracts and represents these common/differingfunctions so that a specific application can be viewed as an adaptation or refinement of the
model.
The development of the functional model depends on the features and entity-relationship
models. A high-level, abstract functional model is derived from the common features andentities of these models.  Features from the feature model parameterize the functionalmodel through refinement by representing alternative and optional functions. While the fea-ture model is used to communicate between the requirements analyst and the user (seeFigure 3-4), the functional model together with the feature model support communicationbetween the analyst and the software designer.  The user’s choice of features provides ac-tual values for the parameters of the functional model.
The example domain analysis uses Statemate Statecharts and Activitycharts to represent
the functional model [Harel 89]. As was the case in the Prolog automated features tool, noexisting tool adequately handles the requirements necessary for modelling common func-tionality and handling parameterization through features.  Statemate offers a good, general-purpose specification and documentation tool, though the application of the tool to supportdomain analysis requires tailoring.  Through tailoring to handle domain analysis, Statematecan:
•Capture commonality
•Statecharts show all states and transitions for specifying a behavioral
view.
•Activitycharts show common functions and data flows (input and output)for specifying a functional view.
•Parameterize differences through features
72 CMU/SEI-90-TR-21
•Statecharts show alternative/optional features as conditions for modifying
behavior.
•Activitycharts show optional data flows and provide textual descriptions.
While Statemate can support many aspects of functional modelling, it does have some
weaknesses (presented in Chapter 8).  In addition to its use as a modelling tool, the experi-ence of applying Statemate to the functional modelling task can provide guidance in estab-lishing specific requirements for a domain analysis support tool, as is discussed in Sections8.1.3 and 8.2.
7.3.3.1. Specification of Behavior −State Transition View
The behavioral view of a system can be specified by characterizing the system in terms of
states andstate transitions . A state represents a conceptual mode of a system.  For the
window manager domain, examples of the states include window creation, operation selec-tion, and window moving.  A transition causes transfer from one state to the next in re-sponse to an event , such as the window manager user’s selecting an operation to perform
on a window, or the user’s deleting a window.  In addition, transitions can be affected byconditions ; the value of the condition will determine whether the transition will take place.
The Statemate tool captures this behavior in a Statechart, as shown in Figure 7-8.
State_1 State_2Event_1
Event_2[On_Condition]
(In this example, the arrow into State_1 indicates that the system starts in
State_1. A transition to State_2 will occur when Event_1 takes place.  The sys-tem will transition back to State_1 when Event_2 occurs and the boolean
On_Condition is true.)
Figure 7-8: Statechart Illustrating Behavioral View of a System
A domain analysis of window managers must capture the behavior exhibited by allof the
systems studied in the domain analysis and represent that behavior. In the window man-ager domain analysis features that are common to all window managers appear on
CMU/SEI-90-TR-21 73
Statecharts as mandatory states.  Alternative and optional features are handled through
conditional transitions and optional states.
For the window manager domain, the behavior includes information on the state of windows
controlled by the window manager and on the state of actions of the user of the window
manager. Figure 7-9 shows the parallelism of these two views of the behavior of systems inthe domain.  The two parallel states show:
WNDW_CONTROLLER
OPER_BUILDER
CCIDLE
CREATE_WNDW
WNDW_SELECT
OP_PERFORM
MOVE_OP
INITIALIZING DRAGGING REPOSITIONINGOP_SELECTWINDOW_X
1
1WINDOW_SETUPRESIZING MOVING
AVAILABLE
IN_USE_X
INPUT_FOCUS
H
NOT_FOCUS FOCUS_WNDW
ICON
H
CICONIFIEDMAIN_WINDOW
NO_ICON
WNDW_DESTRUCTIONSETUP_DONE[not AVAILABLE]
[not OBJ_ACT][OBJ_ACT]
OP_COMPLETE[AVAILABLE]CREATE
CREATE[AVAILABLE]WNDW_SELECTED[OBJ_ACT]/D_WNDW:=X
WNDW_SELECTED[not OBJ_ACT]/D_WNDW:=XOP_SELECTED[not OBJ_ACT]
OP_SELECTED[OBJ_ACT]
/MOVE_SELECTED
INIT_COMPLETE[OPAQUE] or IMAGE_DRAWNPOINTER_MOVE[OPAQUE]
DROP/tr!(FINAL_POS)
WNDW_DRAWN[OPAQUE and not FINAL_POS]MOVE_COMPLETERESIZE_COMPLETE
SETUP_DONECREATE[D_WNDW=X]
RESIZE_SELECTED[in(IN_USE_X.ICON.MAIN_WINDOW) and D_WNDW=X]
MOVE_SELECTED[D_WNDW=X]
REMOVEDDESTROY[D_WNDW=X]CURRENT_FOCUS[D_WNDW=X]CURRENT_FOCUS[D_WNDW/=X]
[not HAS_ICONS][HAS_ICONS]
DEICONIFY[D_WNDW=X]ICONIFY[D_WNDW=X]
Figure 7-9: Statechart Illustrating Behavioral View of Window Manager
1.WINDOW_X - the behavior of the system in response to user operations.  This
side of the state chart shows the state of a given window on which the usermay choose to operate.
2.OPER_BUILDER - the behavior of the system to support user operations.
Once a user creates a window, he can perform operations on that window.
The functional analysis focussed again on the move operation to illustrate the application of
74 CMU/SEI-90-TR-21
the method.  Within the state called WINDOW_X are substates in which a window operates.
The states labeled AVAILABLE and WINDOW_SETUP are the window states that exist be-fore and during creation of the window, respectively.  Following window creation, the windowgoes into an IN_USE_X state.  The IN_USE_X state illustrates the manner in which a fea-ture can parameterize the functional model.  When the window enters IN_USE_X, it is al-ways in state FOCUS_WNDW indicating it is the input_focus . This mandatory feature is
common to all window managers.  However, the transition to MAIN_WINDOW is conditional;thisoptional state is parameterized via the hasIcons condition. This parameter is derived
directly from the feature model; the has_icons feature is optional among window manag-
ers and parameterizes the functional model.
The state transitions (events) within the WINDOW_X behavioral view of the window man-
ager are also derived from features of the domain.  For example, each state transition underthe WINDOW_X state occurs in response to an operational feature (e.g., create ,destroy ,
move ,resize ). Table 7-3 illustrates this correspondence.  The features shown in the table
from the feature model are represented as events prompting a state transition in the func-tional model.
Feature Event
create create
destroy destroymove move_selectedresize resize_selectediconify iconify
Table 7-3: Features and State Transitions
The states under OPER_BUILDER are also related to specific features of a user’s inter-
actions with window managers.  The basic operational cycle shown in this state consists of:
1. Creating a window.
2. Selecting a new operation (which may be to perform an operation on that win-
dow, perform an operation on another window, or create a new window).
3. Performing the operation.
The feature model gives explicit guidance in the specification of the user’s interactions.  For
each state transition that a window may undergo in WINDOW_X there is a correspondingtransition in the user’s interaction with the window manager shown in state
15OPER_BUILDER. For example:
Creating a window
•WINDOW_X: The create event causes a transition to the
WINDOW_SETUP state to perform the create operation.  When
15For clarity, the Statechart does not show these transitions to the level of detail necessary to explicitly show
each transition.  Only those for creating and moving a window are shown.
CMU/SEI-90-TR-21 75
this operation is complete, the setup_done causes a transition
to IN_USE_X.
•OPER_BUILDER: When the user performs a create operation
thecreate event causes a transition to the CREATE_WNDW
state. From this state, the setup_done will cause the transition
out of the CREATE_WNDW state.
Moving a window
•WINDOW_X: The move_selected event causes a transition to
the MOVING state. When the user completes the move, themove_complete event causes a transition back to the state
IN_USE_X (signified by the connector labelled "1" in Figure7-9).
•OPER_BUILDER: The move_selected event causes a transi-
tion to the INITIALIZING state within MOVE_OP.  The statessubsequent to INITIALIZING perform the move operation.  Themove_complete event (shown in detail in Figure 7-11) causes a
transition out of the MOVE_OP state.
The feature model also provides alternative and optional states for user interaction with the
window manager.  One feature of all window managers is the order in which a user selects awindow and an operation to perform on that window.  The alternatives are:
•objectAction : The user first selects the window, then chooses an operation.
•actionObject : The user selects an operation, then designates the window.
The conditional transition following the setup_done event in Figure 7-9 demonstrates the
use of these features to parameterize the functional model.  The obj_act condition will cause
a transition to the WNDW_SELECT state first, in accordance with the objectAction fea-
ture. After selecting the window, the feature is completed with the transition to theOP_SELECT state to allow the user to select the operation.  When actionObject is the
feature, the not obj_act conditional causes the states to be OP_SELECT first, then
WNDW_SELECT in accordance with actionObject .
A detailed study of the common features of the move operation (Figure 7-10) will provide a
further understanding of the application of the FODA method in establishing the functionalmodel. This example will also show the interaction between the behavioral and functionalaspects of the model.  The basic move operation consists of three successive states, com-
mon to all window managers:
1.Initializing: obtaining current window position and other parameters and con-
straints
2.Dragging: moving the window or a ghost image of the window to an interim
position
3.Repositioning: redrawing the entire window and establishing the new location
of the window, both visually on the screen and in internal tables.
Transitions between these states occur in response to specific events, such as the comple-
76 CMU/SEI-90-TR-21
MOVE_OP
INITIALIZING DRAGGING REPOSITIONING/MOVE_SELECTED
INIT_COMPLETE[OPAQUE] or IMAGE_DRAWN
POINTER_MOVE[OPAQUE]
DROP/tr!(FINAL_POS)
WNDW_DRAWN[OPAQUE and not FINAL_POS]
Figure 7-10: Statechart Illustrating Basic Move Behavior
tion of initialization (event init_complete ) or the movement of the pointer (event
pointer_move ).
One significant difference between window manager move operations is highlighted by the
parameterization for the opaqueFeedback vs.ghostFeedback features.
•UnderopaqueFeedback , each movement of the pointer causes the entire win-
dow to be redrawn.  The behavioral view must show this feature as causing aloop from dragging to repositioning and back to dragging.  This loop causes thewindow to be redrawn with each pointer movement as shown by the transitionfrom DRAGGING to REPOSITIONING that occurs on event pointer_move
when the opaque condition is true.
•ForghostFeedback , the looping occurs entirely within the dragging state −
the window is not redrawn until it is dropped via event drop in its final desired
new location.
The combination of other move -related features leads to a more detailed view of the move
operation in Figure 7-11.  This refinement of the more abstract functional view of Figure 7-10
shows the effect of both alternative and optional features.  These features becomeStatemate conditionals in the figure within each of the higher level states.  The following list
shows the result that selecting certain features has on transitions:
•INITIALIZING: The opaqueFeedback feature is parameterized as the opaque
condition, which is mutually exclusive with the ghost condition.  This condition
CMU/SEI-90-TR-21 77
MOVE_OP
INITIALIZING
C
C
DRAW_GHOST
ERASEINIT_MOVE
DRAW_CURSORDRAGGING
C
MOVE_GHOSTMOVE_CURSOR
EVENT_WAITREPOSITIONING
C
C
DONEEXPOSEMOVE_TILE
OVERLAPPED
CC
C
DRAW_WNDWDO_ZAP_LINESERASE/MOVE_SELECTED
INIT_COMPLETE[OPAQUE] or IMAGE_DRAWNINIT_COMPLETE
[OVERLAPPED and GHOST][TILED]
[ERASE_BEFORE][ERASE_AFTER]
ERASE_DONEPOINTER_MOVE[OPAQUE]
DROP/tr!(FINAL_POS)
WNDW_DRAWN[OPAQUE and not FINAL_POS]POINTER_MOVE[not OPAQUE][TILED]
[OVERLAPPED and GHOST]/fs!(FINAL_POS)
IMAGE_DRAWNIMAGE_DRAWN[TILED]
[OVERLAPPED]
WNDW_DRAWN[FINAL_POS]/MOVE_COMPLETE
[EXPOSE_AFTER]
[not EXPOSE_AFTER]/OP_COMPLETEERASE_DONE
[ZAP]
[not ZAP][OPAQUE][GHOST]
[ERASE_AFTER]
[ERASE_BEFORE]
LINES_DONE
Figure 7-11: Statechart Illustrating Details of Move Behavior
causes a transition from the INITIALIZING state when the event init_complete
occurs. In order to support the feature, this parameterization causes the win-dow manager to bypass other substates in INITIALIZING that erase the windowor draw a ghost.
•INITIALIZING: The eraseBefore anderaseAfter features are also
parameterized. The condition erase_before causes a transition to erase the
window before drawing a ghost; erase_after bypasses this state.
•DRAGGING: The opaqueFeedback andghostFeedback features
parameterize this state.  The condition not opaque (i.e., ghost) will support the
ghostFeedback feature, causing an internal loop to drag the ghost image with
each pointer movement.  The opaque condition causes a transition to the
REPOSITIONING state with each pointer_move event, causing the window to
be completely redrawn in a new position every time the pointer is moved.
•REPOSITIONING: The zapEffect feature parameterizes the OVERLAPPED
substate within REPOSITIONING.  The condition zapwill support this feature
by causing a transition to DO_ZAP_LINES.  When the zapEffect condition is
not true, for example when the opaqueFeedback feature is in effect due to the
composition rule relating the two discussed in Section 7.3.2.2, the transition will
78 CMU/SEI-90-TR-21
be to the DRAW_WNDW state, to redraw the window in a new position without
zap lines.
This detailed functional model can be instantiated for any valid combination of features to
specialize the model for a particular window manager.  This type of specialization will be
presented in Section 7.3.3.3.
7.3.3.2. Specification of Function −Data Flow View
The functional view of the functional model is based on data flow techniques. Among the
factors that this view establishes are:
•functions of applications in a domain
•their inputs and outputs
•internal data and data structures
•data flow between functions
As with the behavioral view, the features and entity relationship models play a significant
role in the functional view of the domain.  The features can lead to mandatory, optional, andalternative functions or data flows:
TheconstrainedMove feature will determine whether window motion can be
restricted in the horizontal or vertical direction during a move . This will affect the
functionality of converting new pointer position to new window position.
Features will also be a factor in characterizing the data inputs and outputs:
ThewindowShape feature will parameterize the data flow to a function to draw a
window; a window manager that supports non-rectangular windows will have adata flow different from that of a window manager supporting only rectangular win-dows. The functional view must be general enough to accommodate either value,rectangular or non-rectangular, for this feature.
The entity-relationship model and attributes provide guidance in specifying the data struc-
tures for the functional view:
The window geometry attribute defines the window size, shape, position, and, if
applicable, stacking order position.  The functional view of the window managermust capture this information in its internal data structures.
For the window manager domain, the functional view includes functions such as setting the
position of the pointer, drawing a new window, and erasing a window. These functions mustinput data to obtain the positions of windows and the pointer, window shapes and sizes, andother parameters and constraints.  The functional view also defines the relationship betweenfunctions:
Drawing a window requires input from the pointer position to determine the new
window position and from the window data to determine the window’s size andshape; the function must output the new window position to a window data store.
The Statemate tool handles these functional specification requirements through the Ac-
CMU/SEI-90-TR-21 79
tivitychart. Boxes on the activity chart shown in Figure 7-12 represent functions, while flow
lines represent data flows.  In addition, the activities are controlled by a control activity ,
namely the WNDW_CONTROLLER shown in Figure 7-12 and in detail in Figure 7-9. Duringeach state of Figure 7-9, the system performs one or more specific activities.  The man-datory, alternative, and optional features of the behavioral view will control exactly whichactivities are performed for a specific window manager.  This separation of concerns be-
tween control (behavioral view) and function (functional view) is directly supported byStatemate.
PARAMETERSPRIMITIVES
WINDOW_DATA
WINDOW_IDSET_CURSOR_LOC
ERASE_WNDWDRAW_WNDWDRAW_LINEDRAW_BOXDRAW_CURSORWNDW_CONTROLLER
INPUT_MGR
SCREEN_MGR
POS_CONSTRAINTS
TARGET_PICTURE
GHOST_DATAINT_CURSOR_LOC
WINDOW_IDWNDW_SHAPE_POSNEW_WNDW_POSPOINTER_POSITION
SCREEN_UPDATESSCREEN_UPDATESSCREEN_UPDATESSCREEN_UPDATESSCREEN_UPDATES
Figure 7-12: Activitychart Illustrating Functional Specification
The sequence of activities performed by several window manager states will illustrate the
purpose of the Activitychart.  During the MOVE_GHOST state of DRAGGING in the move
operation (Figure 7-11), the window manager must determine the new position of the ghostas well as its shape and size.  Figure 7-13 shows the activities and data flows for this state,as a subset of those of Figure 7-12.
80 CMU/SEI-90-TR-21
PARAMETERSINPUT_MGR
SCREEN_MGRMOVE_GHOST_PRIMI
WINDOW_DATASET_CURSOR_LOC
DRAW_BOX
POS_CONSTRAINTS
GHOST_DATAPOINTER_POSITION
SCREEN_UPDATES
WNDW_SHAPE_POSINT_CURSOR_LOC
Figure 7-13: Activitychart Illustrating MOVE_GHOST Activities
Theset_cursor_loc activity will get the pointer location from the input manager and position
constraints from the external parameters data store.  The activity takes the actual location of
the pointer (labelled pointer_position ) and converts it to an internal location.  The conversion
is necessary to account for features such as constrainedMove or
partiallyOffScreen , which restrict the movement of the window and require rein-
terpretation of pointer position.  The data flow labelled int_cursor_loc represents this position
value for the location.  The draw_box activity will then draw a ghost image, using ghost data
(such as outline and background characteristics) and data on the shape and location of thewindow being moved.  The draw_box activity outputs data to update the screen display
through the screen_manager activity.
During the DRAW_WNDW state of REPOSITIONING in the move operation (Figure 7-11), a
similar set of activities will occur.  Figure 7-14 shows the activities and data flows for thisstate. As with the MOVE_GHOST state, the set_cursor_loc activity must be parameterized
CMU/SEI-90-TR-21 81
for theconstrainedMove andpartiallyOffScreenWindows features of the move op-
eration. The draw_wndw activity inputs wndw_shape_pos to get the window characteristics
and outputs data to update the screen.  In addition, the activity updates the windowgeometry; these updated values are output as new_wndw_pos to the window_data store.
PARAMETERSINPUT_MGR
SCREEN_MGRDRAW_WNDW_PRIMIT
WINDOW_DATA
WINDOW_IDSET_CURSOR_LOC
DRAW_WNDWPOS_CONSTRAINTSPOINTER_POSITION
SCREEN_UPDATES
WNDW_SHAPE_POSNEW_WNDW_POS
WINDOW_IDINT_CURSOR_LOC
Figure 7-14: Activitychart Illustrating DRAW_WNDW Activities
7.3.3.3. Validation of Functional Model
A critical aspect of the domain analysis is verifying that the model can be used to represent
the performance of a new or existing system. The verification of the feature model wasdescribed in Section 7.3.2.5.  To perform this verification, the domain model was refined
using features of two different window managers. In verifying the functional model, theserefinements entail parameterization through setting conditions to account for differences inthe behavioral and functional views of the two managers.  The use of Statemate to repre-sent the functional model provides an additional benefit; the performance of the functionalmodel can be simulated in Statemate to test if the parameterization corresponds to expected
operations.
82 CMU/SEI-90-TR-21
For each of the two systems in the comparison, X10/uwm and SunView , the group of
relevant features was set via conditional parameters.  Three alternative features were ex-amined for the purpose of this validation:
X10/uwm SunView
objectAction actionObject
opaqueFeedback ghostFeedback
exposeAfterMove noexposeAfterMove
Running the simulation using the features of the X10/uwm window manager produced the
results shown in Figure 7-15. After the INIT_MOVE state, the operation immediately transi-tions to the DRAGGING state because there is no change to the window underopaqueFeedback during INITIALIZING.  When a window is being dragged under the
X10/uwm move operation with opaqueFeedback selected, each pointer movement causes
the entire window to be redrawn in the new position. Statemate simulates this performanceby making a transition from the DRAGGING state to the REPOSITIONING state with eachpointer_move event. The simulation continues to model the performance of the X10/uwm
window manager by looping back to the DRAGGING state following the redrawing of thewindow in the DRAW_WNDW state, until the user indicates the final position of the windowvia the final_pos condition on the drop event. (In most window managers, this event is
caused by the release of a mouse button or similar user input.)  Following the move,X10/uwm exposes the window, i.e., moves it to the top of the stacking order, in the new
position. The simulation makes a transition to the EXPOSE state to perform this operation.
Running the simulation using the features of the SunView window manager produced the
results shown in Figure 7-16.  Because the SunView move operation supports onlyghostFeedback , after the INIT_MOVE state the manager makes a transition to the
DRAW_GHOST state, as is the case when the SunView window manager is performing aghost move.  The erase_after condition is also followed to indicate that the window will not
be erased until the move is complete.  Within the DRAGGING state, each movement of thepointer causes a corresponding ghost movement.  The loop states of EVENT_WAIT andMOVE_GHOST simulate the ghost movement following a pointer movement within DRAG-GING. When the user signals the final position for the move, a drop event occurs.  This
causes the transition to REPOSITIONING. During this state, the SunView window managererases the old window and redraws it in the new position.  Statemate successfully simulatedthe performance of both actual window managers.
This discussion has traced only the state transitions of the move operation. The actual sim-
ulation also shows the activities and data flows performed in response to states and
transitions .
CMU/SEI-90-TR-21 83
MOVE_OP
INITIALIZING
INIT_MOVEDRAGGING
EVENT_WAITREPOSITIONING
C
C
EXPOSEOVERLAPPED
C
DRAW_WNDW/MOVE_SELECTED
INIT_COMPLETE[OPAQUE] or IMAGE_DRAWN
POINTER_MOVE[OPAQUE]
DROP/tr!(FINAL_POS)
WNDW_DRAWN[OPAQUE and not FINAL_POS]/fs!(FINAL_POS)[OVERLAPPED]
WNDW_DRAWN[FINAL_POS]/MOVE_COMPLETE
[EXPOSE_AFTER][OPAQUE]
Figure 7-15: Statechart Illustrating X10/uwm Specification
7.3.3.4. Application of Functional Model
The functional model supports several important factors in performing the domain analysis:
•It captures commonality of data and control flow.
•Through applying Statemate, it verifies system performance through simulation.
•It provides requirements for architectures and reusable components.
The example analysis did not include the analysis of architectures or components.  The
feasibility study did produce a functional model that can be applied during architecturemodelling:
•Behavioral view: used to establish control of the system in the process inter-
action model.
•Functional view: used to establish packaging of functions and data objects in
the module structure charts.
84 CMU/SEI-90-TR-21
MOVE_OP
INITIALIZING
C
C
DRAW_GHOSTINIT_MOVEDRAGGING
C
MOVE_GHOSTEVENT_WAITREPOSITIONING
C
C
DONEOVERLAPPED
CC
C
DRAW_WNDWERASE/MOVE_SELECTED
INIT_COMPLETE[OPAQUE] or IMAGE_DRAWNINIT_COMPLETE
[OVERLAPPED and GHOST]
[ERASE_AFTER]
DROP/tr!(FINAL_POS)POINTER_MOVE[not OPAQUE]
[OVERLAPPED and GHOST]/fs!(FINAL_POS)
IMAGE_DRAWN[OVERLAPPED]
WNDW_DRAWN[FINAL_POS]/MOVE_COMPLETE
[not EXPOSE_AFTER]/OP_COMPLETEERASE_DONE
[not ZAP][GHOST]
[ERASE_AFTER]
Figure 7-16: Statechart Illustrating SunView Specification
CMU/SEI-90-TR-21 85
86 CMU/SEI-90-TR-21
8. Discussion of the FODA Method
The primary purpose of the sample analysis was to apply the FODA method to a realistic
domain. Although the sample analysis did not cover the entire method (omitting the ar-chitecture modelling phase), the application of the method uncovered several limitationswhich are discussed in the next section.  The sample analysis also pointed out the need forfollow-on study to broaden the application of the method and to explore new uses for thedomain products.
8.1. Limitations of the FODA Method
8.1.1. Methods for Representing Generalization/Specialization
Although a set of modelling primitives for capturing commonalities and differences of adomain is identified in the FODA method, the method does not provide representation tech-niques or tools that will adequately support these primitives.  For instance,generalization/specialization relationships cannot be represented graphically at the function-al level and the method must rely on textual description. Also, parameterization of the func-tional model is not adequately supported. Statemate conditions for feature parameterization
could not be distinguished from other conditions used in the specification.  A representation
technique that will support these modelling primitives and a support tool that will allow theusers to instantiate diagrams easily are necessary.
8.1.2. Composition Rules vs. And-Or of Features
The hierarchical relationship between the features in the and/or tree is an alternate graphicalrepresentation of the requires composition rule (discussed in Section 7.3.2.2). While using
two alternate representations of the same relationship complicates the feature model, thefeature diagram provides a way for users of the model to "see" some of the feature relation-ships. That is difficult to do with a model composed solely of composition rules. Sophis-ticated automated support for the interactive display of the feature model, such as hypertexttechniques, could provide displays that would make the feature diagram redundant andhence unnecessary.
8.1.3. Manual vs. Automated Methods
The domain analysis of window managers was first approached with the intention of per-forming the analysis using only manual techniques. As the amount of information needed todescribe the domain grew, the manual techniques became more complex. For example, thefeature diagram had no way of displaying the effects of the composition rules on the rela-tions between features to show that the existence of one feature was conditional on anotherfeature. To handle this some notational extensions to the diagram were tried, but these onlymade an already complex diagram larger and more abstruse.  The feature diagram hadbeen split across several pages along arbitrary boundaries in an attempt to make it moremanageable, and contained inconsistencies that could be found only through exhaustive
CMU/SEI-90-TR-21 87
manual examination. This situation was a primary reason for building a prototype automated
features tool to represent the feature model and support consistency and completenesschecking. The manual methods were insufficient to handle a set of little more than 100 fea-tures, and would clearly be inadequate to the task of modelling a larger domain.
Representing the results of a domain analysis process is primarily a task of representing a
large amount of knowledge, and providing facilities so that the user can access that knowl-edge quickly and easily. The goal of domain analysis tool support is to offer an integratedenvironment for collecting and retrieving the domain model and architectures. The currentset of manual and independent semi-automated methods does not meet this goal. It has,however, clearly pointed out the problem which must be addressed, and provides a basis forworking on the problem.
The sample analysis used Statemate to prototype a tool that could take a consistent set of
features produced by the automated features tool and support the functional modelling ofthe domain.  Statemate has provided valuable support to the domain analysis, but also hasseveral limitations.  Among the strengths of the Statemate tool are:
•It is a good analysis tool.
•It supports parameterization.
•It is a production-quality tool.
Some of the weaknesses of the Statemate tool are:
•It is not scalable without tailoring.
•The transitions/conditionals hide commonality.
•It is difficult to transition due to the cost and training required.
Statemate can also serve as a means of establishing requirements for domain analysis tools
as discussed in Section 8.2.
8.2. Future Directions
8.2.1. Near-Term
8.2.1.1. Formalization of Features
The FODA method does not apply formal techniques in the specification of features.  Thespecification of features is made informally in English text, which can result in ambiguity andinconsistency. For example, features from the window manager domain such asconstrainedMove andzapEffect could have been specified more precisely using a for-
mal specification technique. The project applied an algebraic specification technique to
16specify the concept of stacking order in the window manager domain. However, this effortwas not expanded to cover the entire model.
16This technique is not discussed in this report.
88 CMU/SEI-90-TR-21
8.2.1.2. Formalization of Issues/Decisions
The FODA method records issues related to each decision point of the feature model to help
users make selections of both optional and alternative features. However, it does not pro-vide a model showing how these issues are related. For example, in the case of automobilefeatures in Figure 5-1, the issue ofoperating cost is related to maintenance cost andfuel
efficiency, and to help users make decisions this relationship must be captured in the model
with quantitative values.  (One way of implementing this feature is to define issues as fea-ture attributes; the issue model would be used to define relationships between these attri-butes, i.e., issues.)
Also, a customer often has a set of conflicting issues.  For example, if one wants to buy a
car with good acceleration and low fuel consumption, he identifies the requirements (i.e.,issues) that are contradictory and a compromise decision must be made.  While this type ofsituation is resolved on a regular basis without automated support, more complex sets ofconflicting issues are not so easily decided.  Automated assistance is needed to identifythese conflicting issues and resolve them to make an optimal decision.
8.2.1.3. Tool Support for Domain Analysis
The feasibility study determined the need for tools to support both the process of domainanalysis and the process by which the products of domain analysis support software devel-opment. These tools are needed to deal with the volume and complexity of informationgathered during the domain analysis and the presentation of that information in specificdomain analysis products.  Tools are also required to provide a user with an understandingof the domain and to support the user/implementor interaction in developing a new systemwithin the domain. Domain analysis tools will also be used to support the development andapplication of reusable software.
The study established four levels of tool support, ranging from manual methods to those that
are specifically intended to support domain analysis. Figure 8-1 illustrates the successivelevels of support and provides examples of each.  The first level provides only a database ofinformation that the user must handle through manual means to derive any new results.The second level takes the data from the first level and automates part of the derivationprocess. For example, the automated features tool (see Section 7.3.2.6) checks consis-tency between features and the Statemate-supported simulation of the functional model.The third level, that of integrated tools, takes general-purpose tools that may be used in aninformal way at the second level and incorporates their use into the method. Tools at thefourth level are those specifically developed or tailored to support the specific needs ofdomain analysis.
One task in future domain analysis methods investigation will be to further integrate tool
support into the domain analysis method and produce requirements for specific domainanalysis support tools.  This investigation will determine which of the four approaches pro-vides the best support for the FODA method and which can be most easily transitioned.The investigation will continue to work in well established domains to refine these require-ments in a prototype tool.
CMU/SEI-90-TR-21 89
ManualProlog tool,
Current
StatemateStatemate,
HypertextKAPTUR
Data baseAutomated
toolsIntegrated
toolsDomain
analysis tools
Level
Example
Legend
Increasing complexity
Figure 8-1: Levels of Domain Analysis Tool Support
8.2.1.4. Handling the Feature Binding Time Attribute
One of the fundamental trade-offs that a system designer makes is to select binding times
for features, which can then have a significant impact on system functionality, size, speed,and architecture.  As discussed in Section 7.3.2.4, some window managers have alreadyincorporated a range of variation into the executable, allowing activation-time and runtimetailoring of functionality. It is worth generalizing this concept into another attribute of a fea-ture, feature binding time. For example, in describing the features of a specific system it is
necessary to select all of the features and feature values which that system has, which oftenincludes selecting a single feature from a set of alternatives. In the case of an activation-time tailorable system such as X11/uwm (using a profile file) there may be no single appro-priate alternative. Section 5.1.2 describes how the model must designate at what time thealternative will be bound: compile-time, activation-time, orruntime . An example of a tradi-
tional compile-time feature might be tiledLayout versusoverlappedLayout (where the
constraints are "hard-coded" into the window manager source), an activation-time feature
might be ghostFeedback versusopaqueFeedback , and a runtime feature might be
realEstateMode versuslistenerMode (in X10/uwm both options are available
simultaneously).
In addition to affecting the feature model, the ability of the user to postpone the selection of
features until activation-time or runtime can significantly change the software architecture by
90 CMU/SEI-90-TR-21
requiring a profile file for input of the activation-time selections, or runtime menus, or other
capabilities. As another example, "late" binding times (i.e., activation-time and runtime)might require more general and robust access to data, rather than less general, optimizeddata structures which would suffice for compile-time binding. As the technology of windowmanagers progresses, features which now may be thought of as compile-time will migrate
toward being runtime features. Some more advanced window managers such as gwm
[Nahaboo 89] have already done this to some extent, making features that have always
been assumed to be compile-time options (of necessity) into runtime choices.
Another option to pursue is that of widening the set of possible binding times to include
"system design" phase binding as a subdivision of compile-time binding, where system de-sign binding indicates more far-reaching architectural decisions. For example, in such anapproach different values of compile-time features may all have source code available, butonly one can exist in the executable.  This area must be addressed more completely, withfeature binding time being fully incorporated into the feature model.
8.2.2. Long-Term
8.2.2.1. Justifying Domain Analysis Economically
The intuitive justifications for performing domain analysis are the same as those which jus-
tify software reuse: improved quality and reduced cost. The specific questions which a sys-tem engineer contemplating the use of domain analysis must have answered are:
•What will the up-front costs be?
•What kind of return on investment can be expected, and over what period?
In order to properly answer these questions metrics must be collected on the effort ex-
pended in applying a domain analysis method such as FODA. This must be followed by theuse of the domain analysis products on subsequent efforts, with a measurement of the im-pact they have. Until this has been done, the benefits of domain analysis are theoretical,and the work done must be treated as research.
8.2.2.2. Automating Support of the User Decision-Making Process
The domain analysis should provide information that supports the user’s decision-makingprocess as the user specifies and implements a new system.  This information should in-clude a standard set of products from which to build systems.  (These products are calleddomain products in the FODA method.)  To support decision-making, these products must
include performance and cost assessments.  The process of applying these products mustbe grounded in existing methods for engineering design [Cross 89], providing support bothduring:
•Divergence: when a wide range of alternatives are under evaluation.
•Convergence: when the final, evaluated specification is complete.
CMU/SEI-90-TR-21 91
An approach from the design engineering discipline commonly used to explore established
design alternatives and create a new design is the morphological method . In this approach,
the design of a related class of systems is broken down into a set of sub-problems that arecommon to the entire class.  For any new system in the class there are known means ofsolving the sub-problems.  The design process becomes one of recognizing the common-ality of a new system with other previously developed systems, and choosing the appro-priate methods of implementing each of the sub-problems.  Design reuse is further ad-vanced because many of the same sub-problems generally apply to more than one class ofsystems. Tools to support this process may incorporate expert systems to support designconstraints [Maher 86].
Domain analysis can support a similar process for software development.  By establishing
the set of sub-problems (the feature model) and solutions to these problems (the functionaland architecture models), domain analysis supports both divergence and convergence. Inaddition, development of design rationales, with issues and arguments, addresses issues indesign constraints. Merging this approach with already established design engineering ap-proaches can be an effective means of supporting the decision making process.
8.2.2.3. Merging Domain Analysis and Other Reuse Methods
Domain analysis can also provide guidance in determining what to build to support reuseand how to build it.  By agreeing on a common model for development, developers of reus-able software can produce software to meet a range of needs for a set of problems.  Insteadof filling a repository with a large number of general purpose, non-integrated components,the pool of reusable resources will consist of tested and measured solutions to specific sub-problems in a given application area.  In addition, the range of capabilities of systems in thearea (i.e., the features) will determine customization requirements.  Reusable software de-velopers will know what to build and how to parameterize their products for varied useacross the domain, rather than overgeneralizing them for all possible contexts.
The products of the FODA method also provide a natural organization for the library. The
features/functional models define the structure for organizing and populating a softwarereuse library.  The models allow users to see a recommended structure for solving theirproblem, while finding out about the software available to implement the solution.  The cus-tomer for a new system is asked to define his software requirements in light of capabilitiessuggested by the domain products.  The developer can then work with the customer to es-tablish appropriate means for delivering those capabilities from existing software.  Cost andperformance factors that have been established for existing solutions can be compared, andthe customer-designer interaction becomes one of negotiation in selecting the best choicesthat meet the customer’s requirements.
92 CMU/SEI-90-TR-21
9. Conclusions
Domain analysis is a necessary first step in establishing requirements for software reuse.
The analysis can serve a variety of purposes toward this end:
•specifications for reusable resources
•tool support (e.g., catalogs, constructors)
•process model for reuse
In general, the analysis provides a detailed overview of the problems solved by software in a
given domain.
Methods for domain analysis must take both the products and process into account.  Those
methods that have generated successful results have been tested in realistic domains.  Insome cases the analysis can lead to tools that can construct entire applications. Othermethods are geared towards coverage of a number of domains, without providing detailedconstructor tools.
The Feature-Oriented Domain Analysis (FODA) method is built on the results of other suc-
cessful domain analysis endeavors.  The method establishes three phases of a domainanalysis:
•Context analysis: to establish scope
•Domain modelling: to define the problem space
•Architecture modelling: to characterize the solution space
The FODA method establishes a basis for proper domain scoping, which is critical to suc-
cess. Without appropriate scoping the results can be too diffuse to meet the needs of appli-cation developers, or too narrow and omit critical areas of a domain.  The feature model ofthe FODA method is central to domain modelling; features parameterize all other models.They provide a description of any real or proposed systems by means of sets of featurevalues. The domain model is refined by additional characteristics of the domain:
•Composition rules, also a part of the feature model, constrain combinations of
features. They provide a means of developing automated support tools to vali-date complete and consistent sets of feature values.
•The functional model provides a behavioral andfunctional view of the system.
Features are used to parameterize this model to support alternative views.
•The rationale for selecting options is supported by "Issues and Decisions."
These are built around specific features or around aspects of the functionalmodel.
Tool development/adaptation must take into account domain analysis methods.  The com-
plexity of even a well understood domain, such as that of window managers, establishes theneed for tools to handle the volume and variety of information a domain analysis can gener-ate.
CMU/SEI-90-TR-21 93
The FODA method will continue to evolve through subsequent domain analyses.  While the
sample analysis covered the first two phases of the method, performing the architecturemodelling is required to test the FODA method in that phase.  The sample analysis pointedout the need for additional support in the area of handling the representation of common-ality, both generalization and specialization.  The FODA method must also be expanded toprovide automated support for rationales to support user decisions.  Applying the FODAmethod in new domains will support the evolution of the method and give further validationto the approach.
94 CMU/SEI-90-TR-21
Appendix A:  Forms
A.1. Feature Definition Form
Name: <standard feature name>
Synonyms: <name> [FROM <source name>]
One or more synonyms may be defined, and the source of each
name may optionally be included.
Description:<textual description of the feature>
Consists Of <feature names> [ { optional | alternative } ]
This information shows the hierarchical structure of features,
and may be represented graphically.
Source:
<information source>
This information is used to produce a feature catalog.
The source of information (e.g., standards, textbooks, existingsystems) from which the feature is derived is included here.
Type: { compile-time | load-time | runtime }
[Mutually Exclusive With: <feature names>]
[Mandatory With: <feature names>]
A.2. Entity Description Form
Entity: <entity name>
Synonyms: <synonyms>Description:
<a textual description of the entity>
Attributes:<attribute name>:  <value range> [<unit>]Source:
<information source>
The source of information (e.g., standards, textbooks, existing
systems) from which the feature is derived is included here.
CMU/SEI-90-TR-21 95
A.3. Attribute Description Form
Attribute: <attribute name>
Synonyms: <synonyms>Description:
<a textual description of the attribute>
Value range:
<value range specification> [ <unit name>]
Source:
<information source>
The source of information (e.g., standards, textbooks, existing
systems) from which the feature is derived is included here.
A value range can be any combination of:
(1) value types such as integer, string, real, boolean(2) range of values (e.g., 10 through 100)(3) strings (e.g., South, North)
Examples of the <unit name> are days, pounds, seconds, etc.
A.4. Relationship Type Forms
...................................................
Relationship Type <name>Description:
<A textual description of the semantics of the
relationship type. Any rules applied to therelationship type must also be included.>
Parts: (<role name> { <entity type name> ... |
<attribute name> |ANY-ENTITY} ;) ...
The Parts statement defines the roles of the entities in a
relationship and what types of entities can play each role.For example, the Activity hierarchy relation of Statematecan be defined as:
96 CMU/SEI-90-TR-21
Parts: upper-part Activity
lower-part Activity;
Connectivity:
(<role name> {ONE | MANY} ) ... ;
The Connectivity defines how many entities can play
the same role in a relationship. The example above,could be specified as:
Connectivity: upper-part ONE
lower-part MANY;
to indicate that one Activity may contain many Activities
and that one Activity cannot be contained in other Activitiesmore than once.
Syntax:
(<role name> (<keyword> ... <role name> ... ;) ...
The Syntax statement is used to define a language statement
for expressing the relationship in text. A graphical languagemay also be defined.
A.4.1. Relationship Type is-aForm
Relationship Type is-a ;
Description:
To describe generalization/specialization relationshipsbetween entities. An entity in a generalization/specialization hierarchy inherits all of the attributesof its generalization entity. The value of an inheritedattribute may be modified as long as the modified valueis within the range of its generalization entity’s value.A specialization entity may have attributes that are notdefined for its generalization entity.;
Parts: generalization ANY
specialization ANY;
Connectivity:
generalization MANYspecialization MANY;
Syntax:
specialization IS-A generalization;generalization IS-A-GENERALIZATION-OF specialization;
CMU/SEI-90-TR-21 97
A.4.2. Relationship Type consists-of Form
Relationship Type consists-of;
Description:
To specify an aggregation relationship between anentity and its constituent parts.;
Parts: whole ANY
parts ANYhow-many INTEGER;
Connectivity:
whole MANYparts MANYhow-many ONE;
Syntax:
whole CONSISTS OF [how-many] parts;parts IS A PART OF whole;
A.5. Issue Description Form
--------------------------------------------
Issue: <issue-name>Description:
<a textual description of the issue>
Raised at: <component name>
The "Raised at" statement indicates the component
(e.g., an Activity of Statemate or a feature in thefeature model) during the refinementof which the named issue was raised.
98 CMU/SEI-90-TR-21
Decision: <decision name>
Description:
<a textual description of the decision>
Rationale:
<a textual description the rationale behindthe decision>
Constraints/Requirements:
<a textual description of any new constraintscaused by, or any new requirements derivedfrom the decision>
Applies to: <component name>The "Applies to" statement identifies the
components that are resulted by the decision.
CMU/SEI-90-TR-21 99
100 CMU/SEI-90-TR-21
Appendix B:  Domain Terminology Dictionary
In this dictionary terms which have been designated as "standard" for the purposes of the
domain analysis appear in bold type, with a list of synonyms following.Entries for the synonyms point back to the standard entries.
above: Seeexpose
abstract data object: A generic view of a widget, which allows various styles of user
inputs to be transformed into simple data values
accelerator: (also called shortcut )
A way for an experienced user to bypass cumbersome novice com-mands to allow faster operation. A keyboard equivalent of a menu com-
mand is a type of accelerator .
active grab: (see also grab andpassive grab )
A grab is active when the pointer or keyboard is actually owned by the
single grabbing application
active window: Seeinput focus
active window selection: Seeinput focus selection
ancestor: (also called superior )
A window is an ancestor of any and all of its descendants.
application programmer interface (API):
The set of subroutines and calling conventions for the programmer’s in-terface to the window system
application: An executable process
atom: A unique ID corresponding to a string name. Atoms are used to identify
various pieces of information within the window manager.
auto exposure: Seeauto raise
auto raise: (also called auto exposure )
The ability of the window to go to the top of the current stacking order ofoverlapping windows as soon as it becomes the input focus, without anexplicit expose operation.
back: Seehide
backing store: (see also save under )
When the contents of a window (or a region of a window) which isobscured (by an overlapping or transient window) are saved for later
restoration, the temporary area used to save the pixels is called abacking store .
background: The background color or tile pattern of a window upon which all text oor
graphics are displayed
base bar: Seefooter
base window: The main window associated with an application process
below: Seehide
bitblt: (pronounced bit-blit ) An abbreviation of " bit bl ocktransfer" which is an operation that
CMU/SEI-90-TR-21 101
moves a rectangle of pixels from one area of a pixel-based screen to
another.
bit gravity: (see also window gravity )
The way the contents of a window are attracted to a particular positionwithin a window relative to a corner or edge during a resize operation.
bitmap: A (usually rectangular) portion of a pixel-based display where each pixel
is represented by one bit.
border: (also called frame )
Aborder is the displayed edging around a window that can (depending
on the window system) be used as both a command area and a visualfeedback area. The border may be a solid color or a pattern, and usuallyhas a variable width.
bottom: Seehide
bounding box: (see also ghost andselect all )
When multiple items need to be selected for an operation the bounding
boxparadigm may be used. A ghost box is drawn with, typically, the
upper left-hand corner at the the point of origin and the lower right-handcorner rubber-banding to the pointer position.  The items within the boxare considered to be selected for the operation.  This is most commonlyused to mark portions of a graphic image for manipulation.
bury: Seehide
busy feedback: Seedimmed
button: Seemouse button
callback: A type of procedure, usually bound to a widget, that is invoked by a user
action, such as a click on a mouse button. Typically the window man-ager receives notification of the click via an event, looks for any proce-dures attached to the event, and uses a callback to have the application
execute the attached procedure(s).
canvas: Seewindow
caret: Seetext cursor
cascading menu: Seewalking menu
child window: (also called subwindow )
A window that has a parent window. A top-level window has the rootwindow as its parent, and so all windows (except for the root window)arechild windows , but some have different parents.
circulate: (also called cycle windows orshuffle )
Rotate through all displayed windows which overlap (in an overlappedwindow system), exposing the bottom window (or hiding the topwindow) and continue to cycle through all (overlapping) windows. Cir-culating windows by exposing the lowest is called circulating up , and the
opposite is called circulating down .
click: Pressing and releasing a button (typically a mouse button) in rapid suc-
cession.
click-to-type: Seelistener
102 CMU/SEI-90-TR-21
client: An application program that makes requests of the server to do things,
such as draw windows, text, and other objects.
client server model: An architectural model that separates into two parts the job of
drawing windows between the client and the server. The client and ser-ver execute asynchronously and communicate via a protocol. Thismodel is used to improve device independence in some windowing sys-tems.
client window: Strictly speaking, a window whose display is totally controlled by a client
application. In more general terms, a subwindow controlled by any ap-plication, excluding any related subwindows such as the scroll bar, titlebar, etc.
clipboard: A holding area where data is placed after it is "cut" from within a window
system, and from which data may be "pasted".
clipping: Trimming the output of a window so that it only goes into the areas that
need to be updated. For example, if a window is half-covered, when it isrefreshed it only needs to redraw half of itself, and the other half isclipped .
clip mask: Seeclipping region
clipping region: (also called clip mask )
The area of a window that is visible to the user after the window’s size,shape, and other overlapping windows are considered. The windowmanager clips the output from the window to this shape before display-ing it on the screen. With rectangular shaped windows the clippingregion may be defined with a bitmap or a list of rectangles.
close: Seeiconify
collapsed window: Seeicon
color cell: A 3-tuple of values specifying red, green, and blue intensities.
color map: A set of color cells which, put together, constitute all of the colors which
are currently displayable.
command button: A widget that resembles a button and contains text or graphics to in-
dicate the function of the button. When the mouse enters the window itis highlighted, and clicking the mouse while in the button notifies the ap-plication.
composite widget: A widget which is composed of other widgets
confirmer: Seeconfirmation box
confirmation box: (also called confirmer )
A pop-up menu widget that offers a binary choice to the user, typicallyyesandno, orcancel andcontinue
containment: (see also in) A window contains the pointer if the hotspot of the pointer is
within a visible region of the window or a visible region of one of its childwindows.
context-sensitive borders: Button presses and releases on a window border will be inter-
preted as commands to the window
control: Seewidget
CMU/SEI-90-TR-21 103
corner: (see also handle ) A pointer-sensitive area of a window located at each of a
window’s corners.  A corner may be used in move and resize opera-
tions.
covered presentation: Seeoverlapped presentation
cover: Seehide
current window: Seeinput focus
cursor: A locator of information on the screen, presented as a small graphical
image (a cursor picture ) superimposed on the screen and controlled by
apointing device .
cursor picture: (also called tracking symbol )
The specific image used to show the location of the pointer, often toindicate the current function the pointer is performing. Different cursorpictures may be associated with different windows.
cut buffer: Seecut-and-paste buffer
cut-and-paste: (see also selection )
To delete a portion of a text or graphics window display and later re-insert it into the same or another window
cut-and-paste buffer: (also called cut buffer )
A temporary buffer belonging to the window manager used to store thecontents being transferred in curt-and-paste operations
cycle windows: Seecirculate
deiconify: (also called expand, open, orrestore )
Change an icon into its corresponding main window
depth: The number of bits available for a pixel to represent its shade or color in
a pixel-based imaging model.
descendant: (also called inferior )
The descendants of a window are all of the child windows nested belowit: the children, the children’s children, etc.
desktop metaphor: Either 1: an intuitive user interface metaphor used with overlapped win-
dow managers that makes an analogy between overlapped windowsand papers laying stacked on a physical desk top, or 2: a window man-ager that uses icons to represent files and directories rather than ex-ecuting processes, in addition to the overlapped appearance, so thatthere is an even stronger resemblance to a physical desktop. TheMacIntosh is generally considered to use a desktop metaphor .
display: A set of one or more screens that are all driven by a single server
dialogue box: (also called form)
A window widget that may appear dynamically to inform the user of anevent and possibly ask for input.
dimmed: (also called busy feedback )
When a widget or object is currently either busy or inactive it is dimmed
(i.e., typically grayed or displayed in a gray font, rather than black) toshow that it can’t accept input.
dock: (see also icon box ) A special area on the screen where icons are kept
104 CMU/SEI-90-TR-21
double-click: (see also click)
Two clicks in rapid succession
drag: To press a button (typically a mouse button) and hold it down while
moving the mouse. This is sometimes used to move an object on thescreen (such as a window or icon) by visibly dragging it across the
screen to its new position.
drawable: Windows and pixmaps are collectively known as drawables .
draw through: Selecting a region of text by moving the pointing device through it.
drop-down menu: A type of menu widget
drop shadow: An image that resembles a shadow falling from the window onto the
screen background behind it. Its ostensible purpose is to enhance theoutline of the window.
elevator scroll bar: Seescroll bar
end style: The shape used to terminate the end of a line: rounded, square, etc.
event: An occurrence that typically causes action within a window system,
such as input, output, an error, etc. Events are grouped into types, andare usually reported relative to a window.
event mask: The set of event types that is requested relative to a window is de-
scribed by an event mask .
event propagation: Device-related events propagate from the event source window to an-
cestor windows until interest is expressed in handling that type of eventor until the event is discarded explicitly.
event source: The smallest window containing the pointer is the source of a device-
related event.
expand:
1. See deiconify
2. See full screen
expose: (also called above, top, front, orraise )
To change the stacking order of a window in an overlapped system sothat no other window obscures any part of it. After a window has beenexposed , it may then obscure other overlapping windows.
exposure event: An event caused by the exposure of a window. This event informs the
application that contents of regions of its window have been lost byhaving been previously obscured.
fixed menu: A menu which always appears at a fixed place on the screen or within a
window.
fill pattern: Seestipple
focus of control indicator: This visual feedback device tells the user whether or not this
window is the input focus. Examples of such indicators are highlightedborders, cursors, scroll bars, title bars, exposing the focus window, andshading all other windows.
follow-the-pointer: Seereal estate
CMU/SEI-90-TR-21 105
font: A font is an array of glyphs along with information about the sizes of its
glyphs.
footer: (also called base bar , see also title bar )
A region displayed immediately below a window that is used for infor-mation and error messages
foreground: The color or tile pattern that is used for drawing text or graphics; in text
display the foreground is often black and the background is white.
form: Seedialogue box
frame: Seeborder
front: Seeexpose
frozen events: Event processing may be frozen while the screen is being changed. As
an example, if a button is pressed to indicate that a menu should ap-pear, then events may be frozen to insure that the menu is drawn before
the button-release event is processed. This means that the event isguaranteed to be reported with respect to the menu windows, and notthose underneath where the menu now lies.
full screen: (also called expand ormaximize ) (see also zoom )
The state of a window that occupies the entire screen display, or theaction that resizes and moves a window so that it reaches that state
gadget: A type of widget that is not tied to a window, but is rather an independ-
ently executing process
gauge: (also called thermometer )
A read-only display of a value that resembles a thermometer
geometry manager: A mechanism that can be used to define the layout of a window
and its children, as well as determine the action to be taken when aresize of the window is performed
ghost: (also called window outline orhair-lines )
Typically a rubber-banded outline of a window displayed while the posi-tion or size of the window is being changed by the user
glyph: A type of small image- font characters are glyphs
grab: The input devices such as the keyboard, pointing device, and mouse
buttons may be temporarily grabbed for exclusive use by an application
graphical user interface (GUI): (also called look and feel )
The appearance and behavior of the system. Both OSF/Motif and OpenLook are GUIs. A GUI may be realized through a combination of toolkitwidgets, usage conventions, and window manager policy.
graphics context (GC): The collection of information that influences drawing operations,
including the foreground and background, the clipping region, the line
width and style, the plane mask, the tile and stipple, the end style and
thejoin style.
graphics package: Seeimaging model
gravity: (see also bit gravity andwindow gravity )
An attraction between objects on the screen that imposes a precisealignment between them in response to an approximate user movement
106 CMU/SEI-90-TR-21
grid:
1. See ghost
2. An automatic way of neatly aligning a set of windows or
icons for the user
grow: Seeresize
hair-lines: Seeghost
handle: (see also corner ) A pointer-sensitive area of a window located at each of a
window’s sides.  A handle may be used in move and resize operations.
header: Seetitle bar
hide: (also called below, bury, bottom, back, cover, obscure, occlude, orlower )
To change the stacking order of a window in an overlapped system sothat it obscures no other window.
hidden region: (also called shared region )
A region on the screen in an overlapped system which is used by twowindows simultaneously
highlight: A visual feedback mechanism used to indicate a special state of some-
thing on the screen. Highlighting may be achieved by blinking, by
reverse video on monochrome systems, or by special colors on colorsystems.
hint: A piece of information provided to the window manager about the rec-
ommended placement or sizing of a window which may or may not behonored.
history: Seesaved lines
hotspot: The specific point within a pointer’s cursor picture whose coordinates
are returned with a cursor event.
icon: (also called collapsed window oricon window )
1. A small graphical image that represents a window running
an application.  An icon of the window is used when thewindow is not currently in use, but will be used again. Useof the icon rather than the main window when it is inactiveconserves screen real estate.
2. Any small image that is used to represent a concept to the
user. An icon in this sense may be used to label a buttonwidget instead of a text name.
icon box: (see also icon manager )
A window in which all icons are stored
icon manager: (see also icon box )
An alternative to normal separate icons for handling temporarily unusedprocesses. Icon managers will list the names of the windows they are
currently handling. Multiple icon managers may coexist simultaneouslyto handle different sets of windows.
icon window: Seeicon
CMU/SEI-90-TR-21 107
iconic menu: A menu whose options consist of symbolic images representing the dif-
ferent functions which can be performed.
iconify: (also called shrink, close, minimize, oriconize )
Change a main window into its corresponding icon.
iconize: Seeiconify
illegal item: A menu item which is not valid in a certain context. In some window
systems theses items are dimmed to indicate they cannot be chosen.
image: A graphical representation normally realized as a pixmap
imaging model: (also called graphics package )
The model used for displaying images, such as the pixel model.
in: The pointer is ina window if the window contains the pointer but no infe-
rior contains the pointer.
inferior: See descendant. May also refer to a window’s position in the stacking
order as not being the top window.
input device: Allows the user to provide input to the system in various forms such as
positions, text, and values
input focus: (also called active window orcurrent window )
The window that is the current recipient of user input. See keyboard
focus .
input focus selection: (also called active window selection )
The way the window manager allows the user to choose a window asthe current input focus
input manager: Accepts input events and transmits them to the process manager
inputonly window: A window which cannot display any output- inputonly windows are invis-
ible, but can handle input differently from other windows. Typically a dif-ferent cursor picture is used for the pointer so that the user understandsthat input will be handled differently. Inputonly windows cannot have
inputoutput windows as children.
inputoutput window: A normal main window (one which is not an inputonly window)
insert point: The point in a window where new keyboard input will be inserted. This
point is designated by the text cursor .
intrinsics: The foundation layer of functionality used to manipulate widgets
join style: The shape used to connect two lines at a corner: rounded, flat, closed,
etc.
joystick: A type of pointing device
kernel: The low-level interface to the underlying graphics hardware and operat-
ing system
key grabbing: Keys on the keyboard may be passively grabbed. When the key is
pressed, the keyboard is then actively grabbed.
keyboard: A keyboard is a set of keys that allows the entry of textual data.
keyboard equivalent: (see also accelerator )
A single key or a sequence of keys that performs an operation which isalso accessible from a menu
108 CMU/SEI-90-TR-21
keyboard focus: (see also input focus )
The window that is the current recipient of all keyboard user input.
keyboard grabbing: The keyboard may be actively grabbed by an application, and then key
event will be sent to that application, rather than to the usual applicationindicated by the input focus.
knob: A type of physical input device that functions as a valuator
label: The displayed name or title of a menu item, button, or other widget
light pen: A type of pointing device
lightweight process: (also called thread )
A type of process that lacks the normal full process context, which al-lows fast context switching
list menu: A menu widget which appears on the screen as a sequence of lines,
each of which contains an item; it can be of the fixed orpop-up variety
listener: (also called click-to-type )
A listener style window manager sets the input focus to a particular win-dow when that window is clicked on with a mouse button.
locked menu: A menu where the user is not allowed to change the current item selec-
tion
look and feel: Seegraphical user interface
lower: Seehide
main window: A window displayed in its normal, full form-- i.e., notan icon
menu: A widget that is a finite list of text buttons called menu items ; choosing
an item from a menu typically invokes some action
mapped: (see also unmapped andviewable )
A window is mapped if the window manager has designated that it
should be viewable to a user. For example, while a window is being
used, its corresponding icon is unmapped , and therefore not viewable .
maximize: Seefull screen
menu item: One of the possible choices on a menu
minimize: Seeiconify
modifier key: A key which, when pressed in conjunction with or preceding another
key, does not send another character, but instead alters the character
that is sent.
monitor: A type of physical output device
mouse: (see also pointer ) A pointing device that is held in the hand and moved across a
surface.
mouse-ahead: Giving commands with the pointer before the system is ready to execute
them; these are queued for later execution
mouse button: (also called button )
A physical input device with two states, upanddown (orreleased and
pressed )
mouse cursor: Seepointer
CMU/SEI-90-TR-21 109
multiclicking: Clicking a button two or more times in rapid succession.
multitasking: The ability of an operating system to simultaneously execute more than
one process. The UNIX operating system is multitasking; the DOSoperating system is not.
object-action model: (also called select-then-operate paradigm orsubject-verb model )
A user interface model where the user must first select an object tooperate on (a window in a window system) and then an action to per-form on it
output device: Converts data into a human-understandable format such as displayed
text and graphics, or sound
obscure: Seehide
occlude: Seehide
opaque: Refers to the way a window is represented during a move or resize op-
eration. An opaque window means that the full window image is pre-
served and continually displayed during the operation so that the full ef-fect of the operation may be seen by the user. This is typically sup-ported only on relatively fast display hardware.
open: Seedeiconify
overlapped presentation: (also called covered presentation )
A window system paradigm where a window may occupy any positionon the screen, and may overlap or be overlapped by any number ofother windows
pages: Seestacked menu
paint and stencil model: An imaging model used in some window systems (such as
NeWS). PostScript is one implementation of a paint and stencil model.
pan: (see also scroll when applied to text)
The ability to use a window as a viewport on a larger virtual graphicspace, and move the viewport to focus on different parts of the space.
pane: A defined area within a window, typically the central or primary display
of the window; multiple panes within a window are normally tiled and do
not overlap one another.
parent window: A window that has child windows. The area of a child window can never
extend beyond the borders of its parent.
passive grab: (see also grab andactive grab )
Grabbing a key or mouse button is a passive grab . The grab activates
when the key or mouse button is actually pressed.
pixel: A short form for " picture element"- a single point on a bitmap monitor
which may be either colored or black and white.
pixel map: Seepixmap
pixmap: (abbreviation of pixel map )
An array of pixels; alternately, a stack of bitmaps, or a three-dimensional array of bits.
pixel model: (also called raster model )
110 CMU/SEI-90-TR-21
An imaging model based on pixels and logical operations upon pixels,
such as AND ing and ORing pixels together. Within a system based on
thepixel model all images are generated using pixels.
point: Move the pointer to a specific region or object
point-to-type: Seereal estate
pointer: (also called mouse cursor )
A type of cursor that marks the current position of the pointing device.
pointing device: (also called mouse )
An input device that allows the entry of accurate location data on thescreen by moving the pointer on the screen
pop-up window: (see also transient window )
A window that appears dynamically to allow the user to enter some kindof input, and then disappears again after the input is made. A pop-up
window is a type of transient window.
presentation: The representation of a window on the screen, which is either in iconic
or main form.
process manager: Ties applications to windows for I/O and other operations
prompter: A pop-up window widget that requires the user to type in a response
property: Windows may have associated properties such as name, type, data for-
mat, and various data. Such information as resize hints, programnames, and icon formats may be expressed as properties.
property list: The list of all properties defined for a window
pull-down menu: (see also pop-up menu )
A type of pop-up menu that appears after the selection of an item on the
screen, usually immediately below, and allows the user to specify fur-ther options
pushpin: Apushpin is used to fix a transient menu into a position.
raise: Seeexpose
raster model: Seepixel model
real estate: (also called point-to-type orfollow-the-pointer )
A window system paradigm where the input focus is always at the win-dow the pointer is in
recursive subwindows: (see also child window )
Windows which adhere to a parent-child window hierarchy
redirecting control: A way of enforcing window layout policy- when an application attempts
to change the size or position of a window, the operation may beredirected to another application
redisplay: Seerefresh
redraw: Seerefresh
refresh: (also called redisplay orredraw )
To erase and freshly display all or part of the screen that may havebeen damaged
CMU/SEI-90-TR-21 111
region: The area of a polygon defined by a collection of points. Regions are
usually used within windows to further subdivide the containing spacefor the application.
reparent: Toreparent a window means to insert a new parent window behind an
existing window, often for highlighting or additional user input.
reserved area: Seespecial area
resize: (also called shape orgrow )
To change the shape and/or the size of a window
resource: Aresource is an object handled by the window manager, such as a win-
dow, cursor, font, color map, etc.
restore: Seedeiconify
root window: The window that has no parent window, and is the ancestor of all other
windows on the screen. The root window covers the entire screen.
rubber band: The act of interactively moving the pointer in relation to a stationary
point while lines are continuously drawn between them to show the pos-sible final state of the relationship. Rubber-banding is often used to al-
low the user to visualize the results of a resize operation on a window.
save-set: A list of windows that will be restored to their normal state if the window
manager exits abnormally (i.e., the windows will be mapped again if thewindow manager had unmapped them for an icon)
save under: (see also backing store )
The pixmap of the contents of a window (or a region of a window) whichisobscured (in an overlapped window system)
saved lines: (also called history )
The lines of text in a window that have been scrolled off the window, buthave been saved and are still available for display.
screen: A logical output display device on which windows and other graphics
may be displayed
screen real estate: The visible area provided by a screen. A window manager’s function is
to manage this area.
screen manager: Directs output to the proper window on the screen.
scroll: To move through a set of data which is larger than the available window
by alternately showing different portions of it.
scroll bar: (also called elevator scroll bar )
A composite widget usually associated with a window that allows theuser to specify the scroll amount using valuators and command buttonwidgets.
select all: (see also bounding box )
When multiple items need to be selected for an operation the select all
paradigm may be used to allow the user to individually select each item.
select-then-operate paradigm:
Seeobject-action model
selection: Aselection is an item of data which can be highlighted in one instance
112 CMU/SEI-90-TR-21
of an application and pasted into another instance of the same or a dif-
ferent application.
server: A program that runs on each user’s workstation and draws the required
objects on the display in a client-server architecture
shadow: (see also drop shadow )
A shaded area on the screen sometimes used to show the previous po-sition of an icon that has been deiconified to its main window.
shape: Seeresize
shared region: Seehidden region
shortcut: Seeaccelerator
shrink: Seeiconify
shuffle: Seecirculate
sibling: Children windows of the same parent are known as siblings .
slide-off menu: Seewalking menu
slidebox: A rectangular area within a valuator widget that may be positioned with
the pointer
slider: An input/output widget used to both set and display a value; sliders may
resemble gauges.
special area: (also called reserved area )
A reserved region on the screen that is provided exclusively for specialfunctions, such as the display of error messages, prompts, icons, etc.
stacked menu: (also called pages )
A type of submenu that stacks menus on top of one another but slightly
offset so that the total effect is that of pages in a book. Each page willtypically auto raise when touched by the cursor to display its options.
stacking order: The order of overlapping sibling windows (in an overlapped system) that
determines which one lies visually on top and which on the bottom.  Cir-culating, exposing, and hiding windows changes the stacking order. Thefirst window in the stacking order is the window on top.
stipple: (also called fill pattern )
A bitmap that is used to tilea region (not related to tiled presentation )
stippling: Tiling a region with a stipple
subject-verb model: Seeobject-action model
submenu: (see also walking menu andstacked menu )
A menu widget that displays an additional menu after an item in a previ-ous menu is selected, providing additional options and parameters tothat selected operation.
subwindow: Seechild window
superior: See ancestor. May also refer to a window’s position in the stacking
order as being the top window.
switch: A type of input device
tear-off menu: A pop-up menu which is fixed in a certain position with a push-pin and
remains there.
CMU/SEI-90-TR-21 113
temporary window: Seetransient window
terminal emulator: A window which emulates the functionality of a standard terminal such
as a VT100.
text button: A widget that consists of a displayed piece of text which becomes high-
lighted when the pointer crosses over it. If a mouse button is pressedwhile the cursor is within the text button the application is notified.
text cursor: (also called caret )
A cursor that marks the current position for text insertion within a win-dow. This cursor position is independent of the position of the pointer .
thermometer: Seegauge
thread: Seelightweight process
tile: A pixel map that can be repeated both vertically and horizontally to com-
pletely cover (or tile) an area.
tile mode: The position of a background tile pattern in a window can be placed rel-
ative to the parent window, or absolutely in the child without considera-tion of matching the parent’s pattern.
tiled presentation: A window system paradigm where each window occupies a separate
portion of the screen, and no window can overlap any other.
title bar: (also called header )
A region displayed immediately above a window that indicates the nameor title of the window
titlebutton: A type of command button that is incorporated into the window title bar
and is typically used for moving or resizing windows
toolkit: A set of facilities for building user interfaces for applications, typically
including widgets for menus, forms, text editing, and scrolling capabil-ities
top: Seeexpose
top-level window: A window that is a direct child of the root window
touch panel: An input device that uses the touch of the user’s finger or a stylus on the
screen to mark a position
touch tablet: A pointing device that uses the touch of the user’s finger or a stylus on a
tablet to mark a position or move the pointer
track ball: An input device that remains stationary and is used to move the pointer
tracking symbol: Seecursor picture
transient window: (also called temporary window )
A temporary subwindow of the root window that is usually (in actuality)associated with a top-level window, rather than the root. Having the win-dow be a temporary subwindow of the root means that it will not beclipped by the borders of the top-level window which is its realparent.
Transient windows typically use save-unders to prevent redrawing any
underlying windows.
typescript package: Provides basic text editing capability for typing in command input, such
as backspace, delete, etc.
114 CMU/SEI-90-TR-21
unmapped: (see also mapped )
A window is unmapped when it is not mapped . An unmapped window is
notviewable .
user interface language (UIL):
A language used to determine the user interface of an application bydefining the functional characteristics
user interface management system (UIMS):
A system that provides facilities for the high-level design of user inter-faces. Provides an additional layer of abstraction above a window sys-tem toolkit.
valuator: A widget sometimes used to implement scrolling bars that contains a
rectangular slidebox that follows the motion of the mouse.  The valuator
informs the application whenever the user changes the position of theslidebox.
view: Seewindow
viewable: (see also mapped andunmapped )
A window is viewable if it and all of its ancestors are mapped. The fact
that a window is viewable does not imply that it is necessarily visible ,
since the window may be totally obscured by other windows.
visible: A region of a window is visible if someone looking at the screen can see
it (i.e., it is not obscured by another window).
visual: Avisual is a data structure defining the physical characteristics sup-
ported by a particular screen. In particular it defines the various color-map abstractions supported and the depth(s) of the display.
warp: To automatically place the pointer into a window immediately after it has
been deiconified
walking menu: (also called cascading menu orslide-off menu )
A type of submenu where as the user slides the cursor off the right side
of a menu an additional menu appears containing sub-options of thechosen command. All of the menus will disappear after the final optionshave been chosen.
widget: (also called control )
An object found in a UIMS toolkit that is used to construct user inter-faces. Widgets include such graphical devices for input and output as
command buttons ,valuators ,gauges, etc. A widget may exist as an ob-
ject in a single-inheritance class hierarchy of other types of widgets.
window: (also called view, wob, orcanvas )
A logical area on a bit-mapped display that is connected to at least oneapplication process.
window configuration: The collection of information about the appearance of a window
on the screen which consists of the size, position, border width, andstacking order.
window geometry: A window’s position, shape, and size
window gravity: (see also bit gravity )
The way the children windows are attracted to a particular position
CMU/SEI-90-TR-21 115
within a parent window relative to a corner or edge during a resize oper-
ation. Styles of gravity may include static, center, and the compass
points .
window layout policy: A policy on how top-level windows will be placed on the screen
window management system:
Manages a set of display windows running asynchronous processes.
window manager: Performs operations on windows ( create ,move ,resize , etc.) so as to
allow the user to use the screen space effectively.
window outline: Seeghost
wob (window object): Seewindow
zap lines: Ghost lines which temporarily "flash" to follow a window or icon from its
original position to its new position during move, resize, or (de)iconifyoperations
zoom:
1. See full screen
2. Display successively smaller (or larger) outlines of a win-
dow to suggest shrinking (or expanding) during Iconify (orDeiconify) operations
zoomed window: A window whose pixmap is displayed at a larger than normal magnifica-
tion.
116 CMU/SEI-90-TR-21
Appendix C:  System Feature Catalogue
In the feature catalogue tables the following conventions are used:
1.<Name> : This is the name used for this feature on this system.
2. "yes/no ": This feature does/does not exist on this system.
3.<blank> : No information was collected for this feature.
4. "∗": Selection of this feature is a load-time or run-time option.
5. "--": This feature is inapplicable to this system (a composition rule with
another feature excludes it).
CMU/SEI-90-TR-21 117
System/Feature X10/uwm VMS Windows SunView Mac Windows
multObjSelect no no no yes
inputFocusSelect ∗ listener realEstate listener
mandatoryFocus no no no yes
revertToNewFocus -- nextOnStack -- nextOnStack
selectOrder actionObject objectAction objectAction objectAction
windowLayout overlapped overlapped overlapped overlapped
partiallyOff yes yes no yes
tiledColumns -- -- -- --
windowShape rectangular rectangular rectangular rectangular
hasIcons yes yes yes yes
specialAreas no no no yes
titleBars ∗ yes yes yes
11 1highlightedAreas bord./title/cur. cursor bord./cur. title/scroll
77changeFocus yes yes yes yes
3,7 3,7,8 3,7 3createWindow yes yes yes yes
44destroyWindow yes Delete Quit yes
exposeWindow Raise Pop to Top Front Select
hideWindow Lower Push Behind Back no
circulateUp Circulate no no no
circulateDown no no no Cycle Windows
7 5,7,8 5moveWindow Move yes Move yes
constrainedMove no no yes no
77resizeWindow Resize Change Size Resize yes
corners&Handles all all all lower right
expandWindow no no Full Screen yes
7 7,8 7iconify (De)iconify Shrink Close yes
7 7,8 7deiconify (De)iconify yes Open yes
refreshWindow yes no Redisplay no
refreshAll Refresh no Redisplay no
abortMove no no Cancel no
quitWindowSystem no no Exit no
Table C-1: Window Manager Features I
118 CMU/SEI-90-TR-21
System/Feature Andrew Symbolics X11/uwm OSF/Motif
multObjSelect no no
inputFocusSelect realEstate listener ∗
mandatoryFocus no
revertToNewFocus --
selectOrder objectAction actionObject objectAction
windowLayout tiled overlapped overlapped overlapped
partiallyOff no yes yes
tiledColumns yes -- -- --
windowShape rectangular rectangular rectangular rectangular
hasIcons yes no yes yes
specialAreas no yes no no
titleBars yes ∗ yes
12 1highlightedAreas title greyed bord./cur. bord./title/cur.
77changeFocus yes yes yes yes
336createWindow yes yes yes yes
destroyWindow Quit Kill yes Quit
7exposeWindow -- Select Raise no
hideWindow -- Bury Lower Lower
circulateUp -- no Circulate Up Shuffle Up
circulateDown -- no Circulate Dn. Shuffle Down
5moveWindow yes Move Move Move
constrainedMove
resizeWindow Enlarge Shape Resize Size
corners&Handles no all all
6expandWindow Proportion Expand Maximize
iconify yes -- (De)iconify Minimize
deiconify yes -- (De)iconify Restore
refreshWindow Redisplay Refresh no no
refreshAll no yes
abortMove no
quitWindowSystem Logout Quit
Table C-2: Window Manager Features II
CMU/SEI-90-TR-21 119
NOTES
1.Bord. refers to a highlighting (or shading) of the border around the window,
titlerefers to a highlighting of the window’s title bar, scroll refers to the exis-
tence of the graphics in the scrollbar, and cur.refers to a highlighting of the
text cursor in the window.
2.Greyed signifies that all portions of the screen other than the input focus win-
dow are overlaid with a grey stipple.
3. Few window managers have explicit create commands- a window is implicitly
created when its primary associated application is started.
4. Few window managers have explicit destroy commands- a window is
destroyed when its primary associated application is terminated.
5. These systems do not have explicitly named move functions- moving a win-
dow is accomplished by clicking on the border or title bar and dragging theresulting ghost.
6. The proportion command proportions all of the windows in a column so that
they share the available space equally. It is analogous to expand since it
makes a window as large as it can be without sacrificing the other windows.
7. These commands move the window to the top of the stacking order.8. These commands change the current input focus.
120 CMU/SEI-90-TR-21
Appendix D:  Issues and Decisions
Issue: Input Focus Selection
Description: The way the window manager allows the user to designate the current input
focus
Raised at: inputFocusSelection
Decision:realEstateMode
Description: A window becomes active by moving the cursor
over it (if it is visible).
Rationale: Simple and quick to use
Decision:listenerMode
Description: The user must click on a window to make it active.
Rationale: Helps prevent accidental activation of the window.
Allows the system to make the existence of a cur-rent input focus mandatory.
Issue: Window Layout
Description: The way windows relate physically on the screen.
Raised at: windowLayout
Decision:tiledLayout
Description: A window system paradigm where each window oc-
cupies a separate portion of the screen, and no win-dow can overlap any other.
Rationale: Avoids dealing with issues of exposing and hiding
overlapping windows, and makes it simpler to iden-tify the recipient of user input (complex clippingmasks are avoided). However, a tiled system mustprovide some sort of automatic layout system forthe windows. In this paradigm, resizing events be-
come common.
Decision:overlappedLayout
Description: A window system paradigm where a window may
occupy any position on the screen, and may overlapor be overlapped by any number of other windows
Rationale: Provides a user interface that emulates the overlap-
ping papers found in a physical desktop environ-ment. The user is in almost full control of the win-dow layout, but an overlapped system must dealwith maintaining the stacking order of the windowand the clipping masks for displaying their contents.In this paradigm, exposure events become com-
mon.
Issue: Tiling Method
CMU/SEI-90-TR-21 121
Description: The type of window tiling which is enforced
Raised at: tiledLayout
Decision:tiledColumns
Description: Allow windows to be positioned only within a set
number of columns.
Rationale: Simpler than the alternative, and it avoids potential-
ly unpredictable screen layout changes when win-dows are added or removed.
Decision:tiledArbitrary
Description: Allow windows to be positioned anywhere on the
screen (as long as no other window is overlapped).
Rationale: Intuitively less constraining than using columns to
avoid overlap
Issue: Window Shape
Description: The set of shapes allowed for windows by the window manager
Raised at: windowShape
Decision:rectangularShape
Description: A window may only have a rectangular shape
Rationale: Relatively simple to compute which window the
pointer is in, and the clipping regions for display
Decision:arbitraryShape
Description: A window may have any arbitrary two-dimensional
shape
Rationale: If the window information is not rectangular (i.e., a
clock face) then there is no wasted space from fit-ting a circle into a square.
Issue: Interactive Feedback
Description: The way the window manager shows the user the current size or shape of a
window being moved or resized.
Raised at: interactiveFeedback
Decision:ghostFeedback
Description: An outline and/or grid of the window is drawn and
moved with the cursor to the new location, wherethe complete window is drawn (and the old windowerased.
Rationale: Provides sufficient user feedback for positioning
and resizing, and requires significantly fewerresources than redrawing the entire image oftenenough to follow the moving cursor.
Decision:opaqueFeedback
Description: The window manager moves or resizes the entire
original image of the window.
122 CMU/SEI-90-TR-21
Rationale: Opaque moving and resizing allows the user to see
immediately what the window will look like in thenew position or shape, and is typically used on fastdisplays where the act of updating a potentiallycomplex window display is feasible.
Issue: Command Selection Order
Description: The order in which objects and actions are selected for the performance of win-
dow operations.
Raised at: selectionOrder
Decision:objectAction
Description: The window is selected before the command.
Rationale: Selecting the object first allows the menu of pos-
sible actions to be tailored based on the type of ob-ject, i.e., an icon or a window. This makes the userinterface more intuitive.
Decision:actionObject
Description: The command is selected before the window.
Rationale: Allows the possible actions to include commands
that do not require the selection of a destination ob-ject.
CMU/SEI-90-TR-21 123
124 CMU/SEI-90-TR-21
Appendix E:  Window Manager Features
abortMoveOp: optional
Abort the current move operation.
Parent:moveWindowOp
Source: SunView window system experience
abortResizeOp: optional
Abort the current resize operation.
Parent:resizeWindowOp
Source: SunView window system experience
actionObject: alternative
First the command, then the window.
Parent:selectionOrder
Source: Open Look GUI documentation
activeIcons: alternative
An icon may update its image.
Parent:iconIO
Source: A Taxonomy of Window Manager User Interfaces
arbitraryNumberColumns: alternative
Window layout is tiled using arbitrarily many columns.
Parent:tiledColumns
Source: A Taxonomy of Window Manager User Interfaces
arbitraryShape: alternative
Windows may be of any shape.
Parent:windowShape
Source: NeWS window system documentation
borderHighlight: optional
Highlight the border.
Parent:highlightedAreas
Source: A Taxonomy of Window Manager User Interfaces
changeFocusOp: mandatory
Change the input (keyboard) focus.
Parent:windowManager
Source: General
circulateDownWindowsOp: optional
Circulate down through all windows.
Parent:stackingOrder
Source: X11 Xlib documentation
circulateUpWindowsOp: optional
Circulate up through all windows.
Parent:stackingOrder
CMU/SEI-90-TR-21 125
Source: X11 Xlib documentation
colorHighlight: alternative
Highlighting via a color.
Parent:highlightMethod
Source: Motif window manager experience
commandAreaHighlight: optional
Highlight the command areas.
Parent:highlightedAreas
Source: A Taxonomy of Window Manager User Interfaces
constrainedMove: optional
Window movement may be constrained horizontally or vertically.
Parent:moveWindowOp
Source: SunView window system experience
cornersAndHandlesResize: alternative
Users may select the windows corners and handles to resize it.
Parent:resizeInput
Source: A Taxonomy of Window Manager User Interfaces
createIconified: optional
Create new windows as icons.
Parent:createWindowOp
Source: X11/twm documentation
Rules: requires hasIcons
createWindowOp: mandatory
Create a new window.
Parent:windowManager
Source: General
dataIcons: alternative
Icons represent data items such as files and directories.
Parent:iconUsage
Source: A Taxonomy of Window Manager User Interfaces
deiconifiedIconDisplay: mandatory
The way currently deiconified icons displayed.
Parent:hasIcons
Source: X10/uwm window manager experience
deiconifyIconOp: mandatory
Turn an icon into a main window.
Parent:hasIcons
Source: General
destroyWindowOp: mandatory
Destroy an existing window.
Parent:windowManager
126 CMU/SEI-90-TR-21
Source: General
dimmedDeiconifiedIcons: alternative
They are dimmed.
Parent:deiconifiedIconDisplay
Source: Macintosh window system experience
dimmedHighlight: optional
Dim all other windows.
Parent:highlightedAreas
Source: Symbolics window system experience
dropShadowsEffect: optional
Aesthetically pleasing 3D visual effect to make windows stand out.
Parent:windowManager
Source: X11 Xlib documentation
eraseAfter: alternative
Erase at the end of the move.
Parent:moveErasure
Source: VMS window system experience
eraseBefore: alternative
Erase at the start of the move.
Parent:moveErasure
Source: VMS window system experience
expandWindowOp: optional
Expand a window to fill the entire screen.
Parent:resizeInput
Source: SunView window system experience
exposeAfterChangeFocus: optional
Expose the window at the end of a change focus operation.
Parent:changeFocusOp
Source: SunView window system experience
Rules: requires overlappedLayout
exposeAfterDeiconify: optional
Expose the window at the end of a deiconify operation.
Parent:deiconifyIconOp
Source: SunView window system experience
Rules: requires overlappedLayout
exposeAfterIconify: optional
Expose the icon at the end of an iconify operation.
Parent:iconifyWindowOp
Source: SunView window system experience
Rules: requires overlappedLayout
exposeAfterMove: optional
CMU/SEI-90-TR-21 127
Expose the window at the end of a move operation.
Parent:moveWindowOp
Source: SunView window system experience
Rules: requires overlappedLayout
exposeAfterResize: optional
Expose the window at the end of a resize operation.
Parent:resizeWindowOp
Source: SunView window system experience
Rules: requires overlappedLayout
exposeWindowOp: mandatory
Expose a window.
Parent:stackingOrder
Source: X10/uwm window manager experience
fixedNumberColumns: alternative
Window layout is tiled in a fixed number of columns.
Parent:tiledColumns
Source: A Taxonomy of Window Manager User Interfaces
focusBeforeCommand: optional
The need to make a window the focus before a command is performed on it.
Parent:changeFocusOp
Source: Macintosh window system experience
ghostFeedback: alternative
An outline displayed for feedback.
Parent:interactiveFeedback
Source: X10/uwm window manager experience
Rules: requires moveErasure
hasIcons: optional
The window manager supports icons.
Parent:windowManager
Source: Symbolics window system experience
hiddenInputFocus: optional
The ability to make a hidden window the input focus.
Parent:updateHiddenWindows
Source: A Taxonomy of Window Manager User Interfaces
hideWindowOp: optional
Hide a window beneath all other windows.
Parent:stackingOrder
Source: X10/uwm window manager experience
highlightInputFocus: optional
Highlight the current input focus.
Parent:changeFocusOp
Source: A Taxonomy of Window Manager User Interfaces
128 CMU/SEI-90-TR-21
highlightMethod: mandatory
The way highlighting is done.
Parent:highlightInputFocus
Source: Motif window manager experience
highlightedAreas: mandatory
Where the current input focus is highlighted.
Parent:highlightInputFocus
Source: A Taxonomy of Window Manager User Interfaces
iconBox: optional
Icons are stored in an icon box (or manager).
Parent:hasIcons
Source: Motif window manager experience
Rules: requires iconBoxDeiconifiedIcons
iconBoxDeiconifiedIcons: alternative
Deiconified icons go into an icon box.
Parent:deiconifiedIconDisplay
Source: Motif window manager experience
Rules: requires iconBox
iconFocus: optional
An icon may be the current input focus.
Parent:activeIcons
Source: A Taxonomy of Window Manager User Interfaces
Rules: requires changeFocusOp
iconIO: mandatory
The way icons deal with input/output.
Parent:hasIcons
Source: A Taxonomy of Window Manager User Interfaces
iconOperationFeedback: optional
Visible feedback for iconify/deiconify icon operations.
Parent:operationFeedback
Source: X10/uwm window manager experience
iconUsage: mandatory
The way icons are used in the window manager.
Parent:hasIcons
Source: A Taxonomy of Window Manager User Interfaces
iconifyWindowOp: mandatory
Turn a main window into an icon.
Parent:hasIcons
Source: General
inputFocusSelection: mandatory
The way the user selects the input focus.
Parent:windowManager
CMU/SEI-90-TR-21 129
Source: A Taxonomy of Window Manager User Interfaces
interactiveFeedback: mandatory
The user feedback during a move or resize.
Parent:moveResizeFeedback
Source: X10/uwm window manager experience
interiorHighlight: optional
Highlight the interior of the window.
Parent:highlightedAreas
Source: A Taxonomy of Window Manager User Interfaces
keyboardAccelerators: optional
Keyboard equivalents for commands normally run from menus.
Parent:windowManager
Source: A Taxonomy of Window Manager User Interfaces
largerThanScreenWindows: optional
The ability to create windows larger than the screen.
Parent:partiallyOffScreenWindows
Source: X10/uwm window manager experience
listenerMode: alternative
Click to type.
Parent:inputFocusSelection
Source: A Taxonomy of Window Manager User Interfaces
mandatoryFocus: optional
The need for a designated input focus at all times.
Parent:changeFocusOp
Source: A Taxonomy of Window Manager User Interfaces
Rules: requires listenerMode
moveErasure: optional
Erase the old window at start or end of move.
Parent:moveWindowOp
Source: VMS window system experience
moveIcon: optional
Move an icon to a new location.
Parent:moveWindowOp
Source: A Taxonomy of Window Manager User Interfaces
Rules: requires hasIcons
moveResizeFeedback: mandatory
Visible feedback for move/resize operations.
Parent:operationFeedback
Source: X10/uwm window manager experience
moveWindowColumnOp: optional
Move a window from one column to another.
130 CMU/SEI-90-TR-21
Parent:moveWindowOp
Source: A Taxonomy of Window Manager User Interfaces
Rules: requires tiledColumns
moveWindowOp: mandatory
Move a window to a new location.
Parent:windowManager
Source: General
multipleInputFoci: optional
The ability to have multiple simultaneous input foci.
Parent:changeFocusOp
Source: A Taxonomy of Window Manager User Interfaces
multipleObjectSelection: optional
The ability to select multiple windows (or other objects).
Parent:windowManager
Source: A Taxonomy of Window Manager User Interfaces
newIconPlacement: mandatory
Where newly created icons are placed.
Parent:hasIcons
Source: VMS window system experience
nextOnStackingOrder: alternative
The input focus switches to the next on the stacking order.
Parent:revertToNewFocus
Source: VMS window system experience
Rules: requires overlappedLayout
objectAction: alternative
First the window, then the command.
Parent:selectionOrder
Source: Open Look GUI documentation
onePlaceResize: alternative
Users may select only the lower right corner to resize the window.
Parent:resizeInput
Source: A Taxonomy of Window Manager User Interfaces
opaqueFeedback: alternative
The complete window displayed for feedback.
Parent:interactiveFeedback
Source: X10/uwm window manager experience
Rules: mutex with moveErasure
openAreaIconPlacement: alternative
In an arbitrary open area.
Parent:newIconPlacement
Source: VMS window system experience
CMU/SEI-90-TR-21 131
operationFeedback: mandatory
Visible feedback for users when operations are performed.
Parent:windowManager
Source: X10/uwm window manager experience
overlappedLayout: alternative
Overlapped presentation.
Parent:windowLayout
Source: A Taxonomy of Window Manager User Interfaces
parentNewFocus: alternative
The input focus switches to the parent.
Parent:revertToNewFocus
Source: X11 Xlib documentation
partiallyOffScreenWindows: optional
The ability to place windows partially off the screen.
Parent:overlappedLayout
Source: A Taxonomy of Window Manager User Interfaces
passiveIcons: alternative
An icon may *not* display data from an application.
Parent:iconIO
Source: A Taxonomy of Window Manager User Interfaces
patternHighlight: alternative
Highlighting via a pattern.
Parent:highlightMethod
Source: X10/uwm window manager experience
pointerPositionIconPlacement: alternative
The current pointer position.
Parent:newIconPlacement
Source: X10/uwm window manager experience
processIcons: alternative
Icons represent executing processes/applications.
Parent:iconUsage
Source: A Taxonomy of Window Manager User Interfaces
quitWindowSystem: optional
Quit the window system.
Parent:windowManager
Source: SunView window system experience
realEstateMode: alternative
Point to type.
Parent:inputFocusSelection
Source: A Taxonomy of Window Manager User Interfaces
rectangularShape: alternative
132 CMU/SEI-90-TR-21
Windows must be rectangular.
Parent:windowShape
Source: X10/uwm window manager experience
refreshAllWindowsOp: optional
Redraw all windows.
Parent:windowManager
Source: X10/uwm window manager experience
refreshWindowOp: optional
Redraw the window.
Parent:windowManager
Source: SunView window system experience
resizeIcon: optional
Resize an icon.
Parent:resizeWindowOp
Source: General
Rules: requires hasIcons
resizeInput: mandatory
The way the user provides the resizing information.
Parent:resizeWindowOp
Source: A Taxonomy of Window Manager User Interfaces
resizeWindowOp: mandatory
Change the dimensions of a window.
Parent:windowManager
Source: General
revertToNewFocus: mandatory
The way a new input focus is chosen when the current one is deleted.
Parent:listenerMode
Source: X11 Xlib documentation
rootNewFocus: alternative
The input focus switches to the root.
Parent:revertToNewFocus
Source: X11 Xlib documentation
scrollbarHighlight: optional
Highlight the scroll bar.
Parent:highlightedAreas
Source: Symbolics window system experience
selectionOrder: mandatory
The order in which the command and the window are chosen.
Parent:windowManager
Source: Open Look GUI documentation
specialAreaIconPlacement: alternative
CMU/SEI-90-TR-21 133
In a special area.
Parent:newIconPlacement
Source: Macintosh window system experience
Rules: requires specialIconAreas
specialAreas: optional
Reserved regions on the screen.
Parent:windowManager
Source: A Taxonomy of Window Manager User Interfaces
specialAreasCoverable: optional
Special areas may be covered.
Parent:specialAreas
Source: A Taxonomy of Window Manager User Interfaces
Rules: requires overlappedLayout
specialAreasRemovable: optional
Special areas may be removed.
Parent:specialAreas
Source: A Taxonomy of Window Manager User Interfaces
specialCommandAreas: optional
Special areas for commands.
Parent:specialAreas
Source: A Taxonomy of Window Manager User Interfaces
specialIconAreas: optional
Special areas for icons.
Parent:specialAreas
Source: A Taxonomy of Window Manager User Interfaces
Rules: requires hasIcons
specialPromptInputAreas: optional
Special areas for prompts and input.
Parent:specialAreas
Source: A Taxonomy of Window Manager User Interfaces
stackingOrder: mandatory
The stacking order for overlapping windows.
Parent:overlappedLayout
Source: A Taxonomy of Window Manager User Interfaces
textCursorHighlight: optional
Highlight the text cursor.
Parent:highlightedAreas
Source: A Taxonomy of Window Manager User Interfaces
tiledArbitrary: alternative
Window layout is tiled arbitrarily (windows not placed in columns).
Parent:tiledLayout
Source: A Taxonomy of Window Manager User Interfaces
134 CMU/SEI-90-TR-21
tiledColumns: alternative
Window layout is tiled in columns.
Parent:tiledLayout
Source: A Taxonomy of Window Manager User Interfaces
tiledLayout: alternative
Tiled presentation.
Parent:windowLayout
Source: A Taxonomy of Window Manager User Interfaces
titleBars: optional
Title bars are used on windows.
Parent:windowManager
Source: A Taxonomy of Window Manager User Interfaces
titlebarDeiconifiedIcons: alternative
A windows title bar is its icon.
Parent:deiconifiedIconDisplay
Source: Andrew window manager experience
Rules: requires titleBars
requireshasIcons
titlebarHighlight: optional
Highlight the title bar.
Parent:highlightedAreas
Source: A Taxonomy of Window Manager User Interfaces
Rules: requires titleBars
unchangedDeiconifiedIcons: alternative
Icons remain visible as before.
Parent:deiconifiedIconDisplay
Source: A Taxonomy of Window Manager User Interfaces
undoOp: optional
Undo the last operation.
Parent:windowManager
Source: A Taxonomy of Window Manager User Interfaces
unmappedDeiconifiedIcons: alternative
Icons are made invisible by unmapping them.
Parent:deiconifiedIconDisplay
Source: X10/uwm window manager experience
updateHiddenWindows: optional
The ability to update windows which are hidden.
Parent:overlappedLayout
Source: A Taxonomy of Window Manager User Interfaces
upperLeftCornerIconPlacement: alternative
Upper left-hand corner.
Parent:newIconPlacement
CMU/SEI-90-TR-21 135
Source: X10/uwm window manager experience
warpToWindow: optional
Change the current input focus to the deiconified window.
Parent:deiconifyIconOp
Source: X11/twm documentation
Rules: requires changeFocusOp
windowConfiguration: optional
Numerical feedback about the window’s position, size, and shape.
Parent:moveResizeFeedback
Source: X10/uwm window manager experience
windowLayout: mandatory
The overriding display philosophy of the window manager.
Parent:windowManager
Source: A Taxonomy of Window Manager User Interfaces
windowManager: mandatory
The Window Manager
Parent:top
Source: General
windowPositionIconPlacement: alternative
The current window position.
Parent:newIconPlacement
Source: SunView window system experience
windowShape: mandatory
The allowable shapes for windows.
Parent:windowManager
Source: NeWS window system documentation
zapEffectIcons: alternative
Temporary lines flashed to show the results of icon operations.
Parent:iconOperationFeedback
Source: X10/uwm window manager experience
Rules: requires hasIcons
zapEffectMoveResize: optional
Lines flashed to show the results of move and resize operations.
Parent:moveResizeFeedback
Source: X10/uwm window manager experience
Rules: requires ghostFeedback
requireseraseAfter
zoomEffectIcons: alternative
A visual effect used to show the results of icon operations.
Parent:iconOperationFeedback
Source: X11/twm documentation
Rules: requires hasIcons
136 CMU/SEI-90-TR-21
Appendix F:  Hierarchical Window Manager Feature
Listing
In the following listing indentation is used to show the hierarchical (parent/child) structure
among the features. The numbers on the left indicate the indentation level. This diagramcould be converted directly into the form of a feature diagram. To do so, the symbols shouldbe interpreted as follows:
•Asterisks (" *") indicate optional features
•Bar ("|") indicates alternative features
•Dash ("-") indicates that the feature is applicable to this subtree
•All other features are mandatory
0 windowManager
1 createWindowOp2 * createIconified1 destroyWindowOp1 moveWindowOp2 - partiallyOffScreenWindows2 - zapEffectMoveResize2 - windowConfiguration2 - windowLayout2 - interactiveFeedback2 * moveIcon2 * constrainedMove2 * moveWindowColumnOp2 * abortMoveOp2 * moveErasure3 | eraseBefore3 | eraseAfter2 * exposeAfterMove1 changeFocusOp2 * highlightInputFocus3 highlightedAreas4 * borderHighlight4 * titlebarHighlight4 * textCursorHighlight4 * scrollbarHighlight4 * interiorHighlight4 * commandAreaHighlight4 * dimmedHighlight3 highlightMethod4 | patternHighlight4 | colorHighlight2 * focusBeforeCommand2 * mandatoryFocus2 * multipleInputFoci2 * exposeAfterChangeFocus1 resizeWindowOp
CMU/SEI-90-TR-21 137
2 - largerThanScreenWindows
2 - interactiveFeedback2 - windowConfiguration2 - zapEffectMoveResize2 * resizeIcon2 resizeInput3 | onePlaceResize3 | cornersAndHandlesResize3 * expandWindowOp2 * abortResizeOp2 * exposeAfterResize1 * hasIcons2 iconifyWindowOp3 - zapEffectIcons3 - zoomEffectIcons3 * exposeAfterIconify2 deiconifyIconOp3 - zapEffectIcons3 - zoomEffectIcons3 * warpToWindow3 * exposeAfterDeiconify2 * iconBox2 iconUsage3 | processIcons3 | dataIcons2 deiconifiedIconDisplay3 | unmappedDeiconifiedIcons3 | titlebarDeiconifiedIcons3 | dimmedDeiconifiedIcons3 | unchangedDeiconifiedIcons3 | iconBoxDeiconifiedIcons2 iconIO3 | activeIcons4 * iconFocus3 | passiveIcons2 newIconPlacement3 | upperLeftCornerIconPlacement3 | pointerPositionIconPlacement3 | windowPositionIconPlacement3 | openAreaIconPlacement3 | specialAreaIconPlacement1 windowLayout2 | tiledLayout3 | tiledColumns4 | fixedNumberColumns4 | arbitraryNumberColumns3 | tiledArbitrary2 | overlappedLayout3 * partiallyOffScreenWindows4 * largerThanScreenWindows3 * updateHiddenWindows
138 CMU/SEI-90-TR-21
4 * hiddenInputFocus
3 stackingOrder4 exposeWindowOp4 * hideWindowOp4 * circulateUpWindowsOp4 * circulateDownWindowsOp1 * refreshWindowOp1 * refreshAllWindowsOp1 * undoOp1 * quitWindowSystem1 operationFeedback2 * iconOperationFeedback3 | zapEffectIcons3 | zoomEffectIcons2 moveResizeFeedback3 * windowConfiguration3 * zapEffectMoveResize3 interactiveFeedback4 | ghostFeedback4 | opaqueFeedback1 windowShape2 | rectangularShape2 | arbitraryShape1 * specialAreas2 * specialPromptInputAreas2 * specialAreasCoverable2 * specialAreasRemovable2 * specialCommandAreas2 * specialIconAreas1 inputFocusSelection2 | listenerMode3 revertToNewFocus4 | parentNewFocus4 | rootNewFocus4 | nextOnStackingOrder2 | realEstateMode1 * titleBars1 * dropShadowsEffect1 * keyboardAccelerators1 * multipleObjectSelection1 selectionOrder2 | objectAction2 | actionObject
CMU/SEI-90-TR-21 139
140 CMU/SEI-90-TR-21
Appendix G:  Window Manager Entity Attributes
1.Icon attributes:
•Window Operations:
•Deiconify
2.Main window attributes:
•Window Operations:
•Resize
•Iconify
•Expose
•Hide
•Circulate
•Internals:
•Window gravity
3.Pointer attributes:
•Position
4.Screen attributes:
•Size
•Shape
•Resolution
5.Window attributes:
•Window Operations:
•Create
•Destroy
•Move
•Refresh
•Internals:
•ID
•Valid events (event suppression mask)
•Parent window
•ID of associated main window or icon
•Application processes
CMU/SEI-90-TR-21 141
•Configuration/Geometry:
•Position
•Shape
•Size
•Border width
•Stacking order position
•Visual attributes:
•Cursor picture
•Source bitmap
•Shape bitmap
•Pair of colors
•Mapping (mapped/unmapped)
142 CMU/SEI-90-TR-21
References
[American 85] American Heritage.
The American Heritage Dictionary.Houghton Mifflin, Boston, MA, 1985.
[Andribet 90] Pierre Andribet.
Cost Effectiveness of Using Ada in Air Traffic Control Systems.In Barry Lynch (editor), Ada: Experiences and Prospects- Proceedings of
the Ada-Europe International Conference , pages 11-23.  Cambridge
University Press, Cambridge, UK, June, 1990.
[Arango 88a] Guillermo F. Arango.
Domain Engineering for Software Reuse .
PhD thesis, University of California at Irvine, 1988.
[Arango 88b] Guillermo F. Arango.
Evaluation of a Reuse-Based Software Construction Technology.InProceedings of the Second IEE/BCS Conference:  Software Engineer-
ing 88 , pages 85-92.  IEE, London, UK, July, 1988.
[Arango 88c] Guillermo F. Arango & Eiichi Teratsuji.
Notes on the Application of the COBWEB Clustering Function to the
Identification of Patterns of Reuse .
Technical report ASE-RTP-87, ICS, University of California, Irvine, CA,
July, 1988.
[Arango 89] Guillermo F. Arango.
Domain Analysis - From Art Form to Engineering Discipline.InProceedings of the Fifth International Workshop on Software Specifi-
cation and Design , pages 152-159.  IEEE Computer Society,
Washington, DC, May, 1989.
[Bailin 88] Sidney C. Bailin.
Semi-Automatic Development of Payload Operations Control Center
Software .
Report prepared for NASA Goddard Space Flight Center, CTA Incorpo-
rated, Laurel, MD, October, 1988.
[Bailin 89] John M. Moore & Sidney C. Bailin.
The KAPTUR Environment: An Operations Concept .
Report prepared for NASA Goddard Space Flight Center, CTA Incorpo-
rated, Rockville, MD, June, 1989.
[Baldo 89] James Baldo Jr. (editor).
Reuse in Practice Workshop Summary .
Institute for Defense Analyses, Pittsburgh, PA, 1989.
[Barstow 85] David R. Barstow.
Domain-Specific Automatic Programming.IEEE Transactions on Software Engineering SE-11(11):1321-1336,
November, 1985.
IEEE. Reprinted with permission.
CMU/SEI-90-TR-21 143
[Batory 88a] Don S. Batory.
Building Blocks of Database Management Systems .
Technical report TR-87-23, University of Texas, Austin, TX, February,
1988.
[Batory 88b] Don S. Batory.
Concepts for a Database System Compiler .
Technical report TR-88-01, University of Texas, Austin, TX, January,
1988.
[Batory 88c] Don S. Batory, J. R. Barnett, J. Roy, B. C. Twichell & Jorge F. Garza.
Construction of File Management Systems from Software Components .
Technical report TR-88-36 REV, University of Texas, Austin, TX, Oc-
tober, 1988.
[Begeman 88] Michael L. Begeman & Jeff Conklin.
The Right Tool for the Job.Byte 13(10):255-266, October, 1988.
[Biggerstaff 89a] Ted J. Biggerstaff.
Design Recovery for Maintenance and Reuse.Computer 22(7):36-49, July, 1989.
[Biggerstaff 89b] Ted J. Biggerstaff.
Reuse and Design Recovery in MCC/STP .
Slides from Technical Presentation, Microelectronics and Computer
Technology Corporation, Austin, TX, June, 1989.
[Booch 87] Grady Booch.
Software Components with Ada: Structures, Tools, and Subsystems.Benjamin/Cummings, Menlo Park, CA, 1987.
[Borgida 84] Alexander Borgida, John Mylopoulos & Harry K. T. Wong .
Generalization/Specialization as a Basis for Software Specifications.On Conceptual Modeling.Springer-Verlag, New York, NY, 1984, pages 87-117.
[Bruns 88] Glenn Bruns & Colin Potts.
Domain Modeling Approaches to Software Development .
Technical report STP-186-88, Microelectronics and Computer Technol-
ogy Corporation, Austin, TX, June, 1988.
[Chen 76] P. P. Chen.
The Entity-Relationship Model- Toward a Unified View of Data.ACM Transactions on Database Systems 1(1):9-36, March, 1976.
[Coad 89] Peter Coad & Edward Yourdon.
Object-oriented Analysis.Prentice Hall, Englewood Cliffs, NJ, 1989.
[Codd 70] E. F. Codd.
A Relational Model of Data for Large Shared Data Banks.Communications of the ACM 13(6):377-387, June, 1970.
144 CMU/SEI-90-TR-21
[Conklin 88] Jeff Conklin & Michael L. Begeman.
gIBIS: A Hypertext Tool for Exploratory Policy Discussion.ACM Transactions on Office Information Systems 6(4):303-331, October,
1988.
[Cross 89] Nigel Cross.
Engineering Design Methods.John Wiley & Sons, 1989.
[D’Ippolito 89] Richard S. D’Ippolito.
Using Models in Software Engineering.InProceedings of Tri-Ada ’89 , pages 256-265.  Association for Comput-
ing Machinery, New York, NY, October, 1989.
[Firth 87] Robert Firth, William G. Wood, Richard D. Pethia, L. Roverts, et al.
A Classification Scheme for Software Development Methods .
Technical report CMU/SEI-87-TR-41 (ADA200606), Software Engineer-
ing Institute, Pittsburgh, PA, November, 1987.
[Gilroy 89] Kathleen A. Gilroy, Edward R. Comer, J. Kaye Grau & Patrick J. Merlet.
Impact of Domain Analysis on Reuse Methods .
Final Report C04-087LD-0001-00, U.S. Army Communications-
Electronics Command, Ft. Monmouth, NJ, November, 1989.
[Goguen 84] Joseph A. Goguen.
Parameterized Programming.IEEE Transactions on Software Engineering SE-10(5):528-543, Septem-
ber, 1984.
[Gomaa 84] Hasan Gomaa.
A Software Design Method for Real-Time Systems.Communications of the ACM 27(9):938-949, September, 1984.
[Harel 89] David Harel & Sarah Rolph.
Modeling and Analyzing Complex Reactive Systems:  The Statemate Ap-
proach.
InProceedings of the AIAA Computers in Aerospace VII Conference ,
pages 239-246.  The American Institute of Aeronautics andAstronautics, Washington, DC, October, 1989.
[Hess 90] James A. Hess, William E. Novak, Patrick C. Carroll, Sholom G. Cohen,
Robert R. Holibaugh, Kyo C. Kang & A. Spencer Peterson.A Domain Analysis Bibliography .
Special report CMU/SEI-90-SR-3, Software Engineering Institute, Pitts-
burgh, PA, July, 1990.
[IEEE 89] Ada as a Program Design Language
3rd revised edition, IEEE, Washington, DC, 1989.ANSI/IEEE standard 990-1986.
CMU/SEI-90-TR-21 145
[Jaworski 90] Allan Jaworski, Fred Hills, Thomas A. Durek, Stuart Faulk & John
E. Gaffney.A Domain Analysis Process .
Interim Report 90001-N (Version 01.00.03), Software Productivity Con-
sortium, Herndon, VA, January, 1990.
[Lanergan 79] Robert G. Lanergan & Brian A. Poynton.
Reusable Code: The Application Development Technique of the Future.InProceedings of the IBM SHARE/GUIDE Software Symposium , pages
127-136. IBM, Monterey, CA, October, 1979.
[Lee 88] Kenneth J. Lee, et al.
An OOD Paradigm for Flight Simulators, 2nd Edition .
Technical report CMU/SEI-88-TR-30 (ADA204849), Software Engineer-
ing Institute, Pittsburgh, PA, September, 1988.
[Lubars 87] Mitchell D. Lubars.
Wide-Spectrum Support for Software Reusability.InProceedings of the Workshop on Software Reusability and
Maintainability . National Institute of Software Quality and Produc-
tivity, Washington, DC, October, 1987.
[Lubars 88] Mitchell D. Lubars.
Domain Analysis and Domain Engineering in IDeA .
Technical report STP-295-88, Microelectronics and Computer Technol-
ogy Corporation, Austin, TX, September, 1988.
[Maher 86] Mary Lou Maher & Panayiotis Longinos.
Development of an Expert System Shell for Engineering Design.Carnegie Mellon University Engineering Design Research Center , Pitts-
burgh, PA, 1986.
[Matsumoto 84] Yoshihiro Matsumoto.
Some Experiences in Promoting Reusable Software:  Presentation in
Higher Abstract Levels.
IEEE Transactions on Software Engineering SE-10(5):502-513, Septem-
ber, 1984.
[McLeod 78] Dennis McLeod.
A Semantic Data Base Model and its Associated Structured User
Interface .
PhD thesis, Massachusetts Institute of Technology, 1978.
[McNicholl 86] Daniel G. McNicholl, et al.
Common Ada Missile Packages (CAMP) - Volume I:  Overview and Com-
monality Study Results .
Technical report AFATL-TR-85-93, McDonnell Douglas Astronautics
Company, St. Louis, MO, May, 1986.
[McNicholl 88] Daniel G. McNicholl, Sholom G. Cohen, Constance Palmer, et al.
Common Ada Missile Packages - Phase 2 (CAMP-2) - Volume I: CAMP
Parts and Parts Composition System .
Final Report AFAL-TR-88-62, Vol. I, McDonnell Douglas Astronautics
Company, St. Louis, MO, November, 1988.
146 CMU/SEI-90-TR-21
[Moore 89] John M. Moore, Richard Bentz, Manju Bewtra & Sidney C. Bailin.
Generic POCC Architectures .
Report prepared for NASA Goddard Space Flight Center, CTA Incorpo-
rated, Laurel, MD, April, 1989.
[Myers 88] Brad A. Myers.
A Taxonomy of Window Manager User Interfaces.IEEE Transactions on Computer Graphics & Applications 8(5):65-84,
September, 1988.
IEEE. Reprinted with permission.
[Nahaboo 89] Colas Nahaboo & Vania Joloboff.
GWM, The Generic X11 Window Manager.InProceedings of XHIBITION ’89 . Integrated Computer Solutions, Inc.,
June, 1989.
[Neighbors 80] James M. Neighbors.
Software Construction Using Components .
PhD thesis, University of California at Irvine, 1980.
[Neighbors 87] James M. Neighbors.
Report on the Domain Analysis Working Group Session.InProceedings of the Workshop on Software Reuse . Rocky Mountain
Institute of Software Engineering, Boulder, CO, October, 1987.
[Peterson 86] James L. Peterson.
Design Issues for Window Managers .
Technical report STP-266-86, Microelectronics and Computer Technol-
ogy Corporation, Austin, TX, August, 1986.
[Prieto-Diaz 87] Ruben Prieto-Diaz.
Domain Analysis for Reusability.InProceedings of COMPSAC 87:The Eleventh Annual International
Computer Software & Applications Conference , pages 23-29.  IEEE
Computer Society, Washington, DC, October, 1987.
[Prieto-Diaz 90] Ruben Prieto-Diaz.
Domain Analysis: An Introduction.ACM SIGSOFT Software Engineering Notes 15(2):47-54, April, 1990.
[Shlaer 90] Sally Shlaer & Stephen J. Mellor.
Recursive Design.Computer Language 7(3):53-65, March, 1990.
[Wirth 71] Niklaus Wirth.
Program Development by Stepwise Refinement.Communications of the ACM 14(4):221-227, April, 1971.
[Yourdon 78] Edward Yourdon and L. Constantine.
Structured Design.Yourdon Press, New York, NY, 1978.
CMU/SEI-90-TR-21 147
148 CMU/SEI-90-TR-21
Table of Contents
1. Introduction 1
1.1. Scope 11.2. Domain Analysis Concepts 2
1.2.1. Domain Analysis Process 41.2.2. Domain Analysis Products 6
1.3. Feasibility Study Overview 71.4. Successful Application of Domain Models 9
2. Review of Domain Analysis Methods 11
2.1. Evaluation of Methods 122.2. Comparative Study 13
2.2.1. The Genesis System 132.2.2. MCC Work 15
2.2.2.1. The DESIRE Design Recovery Tool 152.2.2.2. Domain Analysis Method 16
2.2.3. CTA Work 162.2.4. SPS Work 18
3. Overview of the Feature-Oriented Domain Analysis (FODA) Method 21
3.1. Method Concepts 21
3.1.1. Modelling Primitives 213.1.2. Product Parameterization 223.1.3. Levels of Abstraction 24
3.2. Information Sources 253.3. Activities and Products 27
4. FODA Context Analysis 31
4.1. Purpose 314.2. Model Description 314.3. Model Usage 324.4. Process and Guidelines 33
5. FODA Domain Modelling 35
5.1. Feature Analysis 35
5.1.1. Purpose 355.1.2. Model Description 355.1.3. Model Usage 375.1.4. Process and Guidelines 38
5.1.4.1. Feature Identification 385.1.4.2. Feature Abstraction, Classification, and Modelling 395.1.4.3. Model Validation 39
CMU/SEI-90-TR-21 i
5.2. Entity-Relationship Modelling 40
5.2.1. Purpose 405.2.2. Model Description 405.2.3. Model Usage 415.2.4. Process and Guidelines 41
5.3. Functional Analysis 42
5.3.1. Purpose 425.3.2. Model Description 425.3.3. Model Usage 445.3.4. Process and Guidelines 44
6. FODA Architecture Modelling 47
6.1. Purpose 476.2. Model Description 476.3. Model Usage 506.4. Process and Guidelines 51
7. Application of Domain Analysis to Window Management Systems 53
7.1. Definition of a Window Management System 53
7.1.1. Window Manager Capabilities 56
7.2. Scoping the Window Management System Domain 587.3. Domain Model 59
7.3.1. Entity-Relationship Model 607.3.2. Feature Model 63
7.3.2.1. Feature Diagram 647.3.2.2. Composition Rules 657.3.2.3. Issues and Decisions 667.3.2.4. System Feature Catalogue 677.3.2.5. Model Validation 697.3.2.6. Automated Tool Support for Features 70
7.3.3. Functional Model 72
7.3.3.1. Specification of Behavior −State Transition View 73
7.3.3.2. Specification of Function −Data Flow View 79
7.3.3.3. Validation of Functional Model 827.3.3.4. Application of Functional Model 84
8. Discussion of the FODA Method 87
8.1. Limitations of the FODA Method 87
8.1.1. Methods for Representing Generalization/Specialization 878.1.2. Composition Rules vs. And-Or of Features 878.1.3. Manual vs. Automated Methods 87
8.2. Future Directions 88
8.2.1. Near-Term 88
ii CMU/SEI-90-TR-21
8.2.1.1. Formalization of Features 88
8.2.1.2. Formalization of Issues/Decisions 898.2.1.3. Tool Support for Domain Analysis 898.2.1.4. Handling the Feature Binding Time Attribute 90
8.2.2. Long-Term 91
8.2.2.1. Justifying Domain Analysis Economically 918.2.2.2. Automating Support of the User Decision-Making Process 918.2.2.3. Merging Domain Analysis and Other Reuse Methods 92
9. Conclusions 93Appendix A. Forms 95
A.1. Feature Definition Form 95A.2. Entity Description Form 95A.3. Attribute Description Form 96A.4. Relationship Type Forms 96
A.4.1. Relationship Type is-aForm 97
A.4.2. Relationship Type consists-of Form 98
A.5. Issue Description Form 98
Appendix B. Domain Terminology Dictionary 101Appendix C. System Feature Catalogue 117Appendix D. Issues and Decisions 121Appendix E. Window Manager Features 125Appendix F. Hierarchical Window Manager Feature Listing 137Appendix G. Window Manager Entity Attributes 141
CMU/SEI-90-TR-21 iii
iv CMU/SEI-90-TR-21
List of Figures
Figure 1-1: Participants in the Domain Analysis Process 4
Figure 1-2: Tailoring the Products to Enhance the Domain Analysis 5
Figure 1-3: Phases and Products of Domain Analysis 7
Figure 1-4: Domain Analysis Supports Software Development 8
Figure 2-1: Participants in CTA’s Reuse-Based Development Process 17
Figure 3-1: Types of Development Decisions 24
Figure 3-2: Model Abstraction 25
Figure 3-3: Model Reuse 26
Figure 3-4: Use of Domain Analysis Products in Software Development 29
Figure 5-1: Example Showing Features of a Car 36
Figure 5-2: Processing of Features 38
Figure 5-3: Parameterization: An Illustration 43
Figure 6-1: Architectural Layers 48
Figure 6-2: Window Management Subsystem Design Structure 49
Figure 7-1: Function of a Window Manager 55
Figure 7-2: Sample User Features Found in Window Managers 57
Figure 7-3: Structure Diagram: Relationship of Window Managers to 60
Window Management Systems
Figure 7-4: Context Diagram: Major Data Flows of Window Management 61
Systems
Figure 7-5: Window Manager Entity-Relationship Diagram 62
Figure 7-6: Features for the Window Manager Move Operation 64
Figure 7-7: Comparison of Move Operation Features in X10/uwm and 65
SunView
Figure 7-8: Statechart Illustrating Behavioral View of a System 73
Figure 7-9: Statechart Illustrating Behavioral View of Window Manager 74
Figure 7-10: Statechart Illustrating Basic Move Behavior 77
Figure 7-11: Statechart Illustrating Details of Move Behavior 78
Figure 7-12: Activitychart Illustrating Functional Specification 80
Figure 7-13: Activitychart Illustrating MOVE_GHOST Activities 81
Figure 7-14: Activitychart Illustrating DRAW_WNDW Activities 82
Figure 7-15: Statechart Illustrating X10/uwm Specification 84
Figure 7-16: Statechart Illustrating SunView Specification 85
Figure 8-1: Levels of Domain Analysis Tool Support 90
CMU/SEI-90-TR-21 v
vi CMU/SEI-90-TR-21
List of Tables
Table 3-1: Domain Analysis Information Sources 26
Table 3-2: A Summary of the FODA Method 28
Table 7-1: Window Operation Functionality 68
Table 7-2: X11/twm Profile Options Related to Features 69
Table 7-3: Features and State Transitions 75
Table C-1: Window Manager Features I 118
Table C-2: Window Manager Features II 119
CMU/SEI-90-TR-21 vii
