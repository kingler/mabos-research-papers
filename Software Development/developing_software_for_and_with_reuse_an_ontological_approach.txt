Developing Software for and with Reuse: An Ontological Approach 
 
 
Ricardo A. Falbo1, Giancarlo Guizzardi2, Katia C. Duarte1, Ana Candida C. Natali1 
 
1Computer Science Department, Federal University of Espírito Santo  
Fernando Ferrari Avenue, CEP 29060-900, Vitória - ES - Brazil 
falbo@inf.ufes.br 
 
2Centre for Telematics and Information Technology, University of Twente 
Enschede, The Netherlands 
guizzard@cs.utwente.nl 
 
Abstract 
Software reuse has been pointed as one of the most 
promising technique to deal with quality and productivity 
problems. To support reuse, software processes have to 
consider two facets: develo ping for reuse and developing 
with reuse. In this paper we present an ontology-based 
approach for software reuse and discuss how ontologies 
can support several tasks of a reuse-based software process. 
 
Keywords : Software Reuse, Software Engineering Tools 
and Techniques, Software Process, Ontologies. 
 
 
1. Introduction 
 
 Software reuse is considered to be one of the most 
promising techniques to improve software quality and 
productivity. Effective software  reuse requires collections 
of designed-for-reuse software components and 
mechanisms to retrieve reuse candidates, adapt them and 
even create new ones using th e information provided by 
similar components [1]. Moreover, we need to bind those 
elements using a software process that really let to 
software reuse. This process must consider two different 
perspectives: developing reusable assets (developing for 
reuse) and developing using those reusable assets 
(developing with reuse). 
 In this context, ontologies can play an important role. 
An ontology can promote common understanding among 
developers, and can be used as a basis for software 
specification and development. Also, it can be used to 
improve access to information. However, one of the major 
drawbacks to a wider use of ontologies in Software Engineering is the lack of approaches to insert ontologies in a more conventional software development process. 
 In this paper, we propose an ontology-based approach for developing software for and with reuse. Section 2 
discusses ontology applications and their relation with 
software reuse. In section 3, we discuss briefly a method 
for engineering ontologies and some aspects that you believe are essential to get the major benefits of the use of 
ontologies in software development. Since the current 
leading paradigm in Software Engineering is the object 
technology, we also present a systematic approach to 
derive object models from ontologies in order to derive 
reusable assets. A study case using our approach in the 
software quality domain is presented in sections 4 and 5. 
Section 6 discusses related works. Finally, in section 7, 
we report our conclusions. 
 
2. Ontologies and software reuse 
 
Ontologies are becoming an important mechanism for 
building software, since they can be used to overcome 
barriers created by disparate vocabularies, representations  
and tools.  
According to Uschold [2], “an ontology may take a 
variety of forms, but necessarily it will include a 
vocabulary of terms, and some specification of their 
meaning. This includes definitions and an indication of 
how concepts are inter-related which collectively impose 
a structure on the domain and constrain the possible 
interpretations of terms”. Thus, an ontology consists of 
concepts and relations, and their definitions, properties 
and constrains expressed as axioms. An ontology is not only an hierarchy of terms, but a fully axiomatized theory 
about the domain [3]. 
Jasper and Uschold [4] classified applications of 
ontologies in four main categories, emphasizing that an application may integrate more than one of these 
categories: 
• Neutral Authoring: an ontology is developed in a 
single language and it is translated into different 
formats and used in multiple target applications. 
• Ontology as Specification: an ontology of a given 
domain is created and it provides a vocabulary for 
specifying requirements for one or more target 
applications. In fact, the ontology is used as a 
basis for specification and development of some 
software, allowing knowledge reuse. 
• Common Access t o Information: an o ntology is 
used to enable multiple tar get ap plication s (or 
humans) t o have access t o heterogene ous s ources  
of information that are ex pressed using diverse 
voca bulary or inaccessible format. 
• Ontology-based Searc h: an ontology is used for 
searchi ng a n information reposi tory for desired 
resources, i mproving precision a nd re ducing the 
overall amount of time spent  searchi ng. 
Although we are m ost interested in the use of 
ontologies as s pecification, we also a gree that an ontology 
almost always h as multiple purposes. This is sp ecially  
highlighte d in the case of software reuse . It is clear that 
the use of ontology a s a specification is  the basis for 
software  reuse. But we have  to regard other scenari os.  
The ne utral authoring sce nario is also im portant, 
main ly wh en app licatio ns will b e developed using 
different technology (e.g., objects and logics). This 
insight shows t hat we nee d to define different approach es 
to im plement ont ologies, each one s uitable to the 
corres ponding technology. 
Comm on access to i nform ation sc enario is essential to 
avoid misunde rstanding am ong developers. It is vital for 
reuse  tasks , such as a dapting com ponent s and c reating 
new assets b ased on existing ones, as well as for selectin g 
black-box components an d for  providing access to  shared 
data and services. 
Finally, an ont ology-based search has great pote ntial to 
improve structuring and searching in compone nt libraries.  
As p ointed by Jaspe r and Uschold [4], an ontology may 
play sev eral ro les to  assist search : (i) it can  be used for 
semantically stru cturing  and o rganizing the in form ation 
repository (in our case, a  component  library); (ii) it may 
be use d as a conce ptual framework to developers t hink 
about this repository and  form ulate queries; (iii) it can  be 
used for refining queries; and (iv) it may be use d to 
perform inference t o improve  the query. 
Analyzing thes e scenarios, we  can notice that softwa re 
reuse ca n take several advantages from the use of 
ontologies. Howeve r, the ontology development process  
must be flexible eno ugh to con sider all th ese scen arios.  
 
3. Using ontologies in domain engineering 
 
Seve ral process m odels have been proposed for 
software reu se, almost always  estab lishing parallel track s 
for domain engineeri ng a nd s oftware  engi neering. 
Dom ain engi neeri ng co ncerns t he w ork requi red t o 
establish a set of software art ifacts that can be re used by 
the software engineer [5], as shown in figure 1. 
 The p urpose of domain engi neering is to identify, 
model, const ruct, cat alog and dissem inate a set  of 
software artifacts th at can  be app lied to ex isting and 
future software in a particular ap plication domain [5] . In 
the domain engineering  track, on tologies ca n act as both a  domain model and a component  in the repository. It can 
also be used for structuring the rep ository, as mentioned  
above.  
In this paper we are p articularly in terested  in the use of 
an o ntology as a dom ain model and how to derive 
compone nts from it. Then, i n the following subsections 
we di scuss a n app roach for building ontologies and for 
deriving object fram eworks from them. It should be 
noticed  that, to reg ard all po tential scen arios discussed in 
section 2,  we need  an approach t hat gui des the ontol ogy 
devel oper to achieve t hese goals. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 1 - A pr ocess model that emphasi zes reuse  [5]. 
 
3.1 A systematic approac h for buildin g ontol ogies 
 
 Basically, the pr oposed approach enc ompasses t he 
following  activ ities [3 ] as sh own in figure 2: purpose 
identification and re quirement speci fication, ontology 
capture, ontology formalization, integratin g existing 
ontologies, and ontology evaluation a nd documentation. 
The dotted lines indicate  that there is a constant  Domain 
analysis 
Software 
archi tecture 
development
Reusable 
artifact 
development
Repositor y 
of 
ComponentsDomain 
model 
Structural 
model 
Domain En gineerin g 
Trac k System 
analysis 
Analy sis 
model 
Design 
Design 
model 
Construction
Software 
application Software En gineerin g 
Trac k 
interactio n, alb eit weak er, be tween the as sociated steps . 
The filled  lines sh ow th e main work flow i n the ontology 
building pr ocess. Th e box in volving the cap ture and 
form alization steps e nhances the stro ng interactio n, an d 
consequ ently iteratio n, betwee n the se steps. 
 The first activ ity - Purp ose id entificatio n and  
requirem ent specification  - concerns to clearly id entify 
the ont ology purpose a nd its intended use s, that is, the 
competence of the ont ology. To  do that, we sugg est the 
use of com petency questions [6]. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 2 - Steps in the ontology development process . 
 
 In ontology capture, th e goal is to  capture the domain 
conceptualizatio n based on  the ontology c ompetence. The  
relev ant concepts and  relation s shou ld be identified  and 
organized. A model using a grap hical langua ge, with a 
dictionary o f terms, sh ould be used to facilitate the 
communication wi th the domain expe rts. As a graphical 
language fo r expressing ont ologies, we proposed LINGO 
[3]. LINGO basically  repres ents a m eta-ontology, and 
thus, it defi nes the basi c not ations t o represent a dom ain 
conceptualizatio n. Th at is, in  its sim plest form , its  
notation s represen t on ly concepts  and relations. 
Neve rtheless, some types of rel ations have a st rong 
semantics and, i ndee d, hide a gene ric ontology. In such 
cases, specialized notations  have been  proposed. This is 
the striking feature of LINGO and what  makes i t different 
from other graphical representations: any notation bey ond 
the basic no tations for concepts and  relatio ns aim s to 
incorporate a  theory. T his way, axi oms can be 
autom atically gene rated. T hese axi oms conce rn sim ply 
the structure of the conce pts and are sai d epistemo logical 
axioms. Figure 3 shows part  of LINGO not ation and som e 
of the axioms imposed by the whole-part relation. T hese axiom s form  the core of the mereological th eory as 
presented in  [7].  
Besid es the episte mological axioms, other axioms can 
be used to represent  knowledge at a signification level. 
These a xioms can be of two types: consolidation axi oms 
and ontological a xioms [3]. The form er aim s to im pose 
constrain ts that must be satisfied  for a relatio n to be 
consisten tly estab lished. Th e latter in tends to represen t 
declarative  knowle dge that i s able to derive knowledge 
from the factual k nowledg e represen ted in the ontology, 
descri bing domain signification constraints.  
 Purpose Identif ication 
and Requ iremen t 
Specification concep t relation  
 
  
Aggregation  
 
 
 
 
 
 
 
 
 
 
 
 
Figure 3 - LINGO main notation and some axioms. 
 
Someone co uld arg ue that anot her g raphical langua ge 
is unnecessary. Cran efield  and P urvis [8], for exam ple, 
advocate the use of UML  as an ontol ogy modeling 
language. We p artially agree with  their argumen ts, but we 
decided not to use som e existing graphical language due 
two main relat ed reaso ns. First, an  important criterio n to 
evaluate on tology design quality is minimum ontological 
commitments [9]. Base d on th is princi ple, a graphical 
language i n this cont ext must embody  only notations that 
are necessa ry to express ontologies . This is not the case of 
UML and majority graphical language s available. Sec ond, 
since an ontology intends t o be a f ormal model of a  
domain, it is important that the language used to desc ribe 
it has form al semantics. Ag ain, this is no t the case of th e 
majority graphical langua ges avai lable, including UML. 
However, we cann ot ignore that UM L is a stan dard and 
its use is wide ly diffuse d. M oreover, t here are efforts to 
define UM L semantics, suc h as p UML [10]. Based on 
that, we are n ow studying to define a sub set of UM L that 
can play th e same role of LINGO following  the same 
thread of [8].  
Backing to our ontology development process, t he 
form alizatio n activ ity ai ms to explicitly rep resent the 
conce ptualization ca ptured in a form al language . Again, 
based on the minimum ontological commitment criterion, Ontolog y 
Capture 
Ontolog y 
Formalizat ion 
Forma l 
Ontolog y Integrating 
Existing 
Ontologies Evaluation and 
Docum entation  
(A1) ∀x  ¬partOf(x,x) 
(A2) ∀x,y  partOf(y,x) ↔ wholeOf(x,y ) 
(A3) ∀x,y  partOf(y,x) → ¬ partOf(x,y)        
(A4) ∀x,y,z  partOf(z,y ) ∧ partO f(y,x) → partOf( z,x) 
(A5) ∀x,y  disjo int(x,y )  → ¬∃z partOf(z,x) ∧ partOf(z,y )
(A6) ∀x  atomic(x)  → ¬∃y partOf(y,x)   
Part 1  
Part N  
Super-ty pe
 
Sub-ty pe 1  
Sub-ty pe N
we argue that, when it is not necessary any special 
commitment with a specific meta-ontology that proves 
itself to be adequate to the ontology in development, first 
order logic should be the preferred formalism, since it is 
such a formalism that embeds less ontological 
commitments.  
 During the capture and/or formalization steps, it could 
be necessary to integrate the current ontology with 
existing ones, in order to seize previously established 
conceptualizations. Indeed, it is a good practice to 
develop general modular ontologies, more widely 
reusable, and to integrate them, when necessary, to obtain 
the desired result. 
 Finally, the ontology must be evaluated to check whether it satisfies the specification requirements. It 
should also be evaluated in relation to the ontology 
competence and some design quality criteria, such those 
proposed by Gruber [9]. It should be noticed that the competency questions play an essential role in the 
evaluation of the completeness of the ontology, specially 
when considering its axioms. 
 All the ontology development must be documented, 
including purposes, requirements and motivating 
scenarios, textual descriptions of the conceptualization, 
the formal ontology and the adopted design criteria. A 
potential approach to document an ontology is to use a 
hypertext, allowing browsing along term definitions, 
examples and its formalizati on, including the axioms. The 
use of XML can be worthwhile.  
 We advocate, based on our experience in ontology development, that the approach described easies the 
development of quality ontologies, specially in those 
aspects concerning minimu m ontological commitments 
criterion. However, when considering ontology as a specification, this striking feat ure is also a problem, since 
the ontology is built generally in a high abstraction level 
to be directly reused in software development. We have 
experimented to reuse ontologies in the development of 
knowledge-based systems, information systems (using 
object technology) and hype rmedia systems. Except for 
the first case, we identify a n eed to lower the abstraction 
level of our ontologies to actually put them in practice. To 
deal with this problem, we have been working in ways to 
create more reusable assets from the ontologies. Next, we 
present our approach to derive  object-based artifacts from 
ontologies. 
 
3.2 From domain ontologies to objects 
 
To support ontologies to Java-objects mapping, we 
proposed a systematic approach that is composed of a set 
of directives, design patterns and transformation rules 
[11]. The directives are used to guide the mapping from 
the epistemological structur es of the domain ontology 
(concepts, relations, properties and roles) to their counterparts in the object-oriented paradigm (classes, associations, attributes and roles). Contrariwise, design 
patterns and transformation rules are applied in the 
ontological and consolidation axioms mapping, respectively. The application of  these guidelines is also 
supported by a Java-framework that implements the 
mathematical type Set.  
To derive objects from domain ontologies, it is 
worthwhile to adopt a formalism that lies at an 
intermediate abstraction level between first-order logics 
and objects. For this purpose, we used a hybrid approach 
based on pure first-order logic, relational theory and, 
predominantly, set theory [11]. So, the first step in our 
approach is the complete axiomatization of the domain 
theory using the set-based formalism. 
Once defined the Set-based axioms, we can initiate the 
object mapping. Concepts and relations are naturally 
mapped to classes and associations in an object model, 
respectively. Furthermore, methods are created in both 
classes involved in an associ ation. Properties of a concept 
shall be mapped to attributes of the class that is mapping 
the concept. Although this approach works well in most 
cases, it is important to point some exceptions that we 
have found: 
• some concepts can be better mapped to attributes 
of a class in an object model because they do not 
have a meaningful state in the sense of an object 
model; 
• some concepts should not be mapped to an object 
model because they were defined only to clarify 
some aspect of the ontology, but they do not enact 
a relevant role in an object model; 
• relations involving a concept that is mapped to an 
attribute (or that is not considered in the mapping) 
should not be mapped to the object model. 
Subsumption relations do not require any additional 
implementation, i.e., subtype-of relations among concepts can be directly mapped to generalization/specialization 
relations among classes. However, it is not the case of 
Whole-Part relations. The UML notation for aggregation 
does not guarantee the fulfillment of the mereology theory 
constraints. To deal with this problem, we developed a 
design-pattern (whole-part design pattern) [11]. 
Considering consolidation axioms, we identified two 
cases to address. First, cons olidation axioms that concern 
to object types, do not need any mapping since we are 
working with a strongly typed language – Java. Second, 
we developed a design pattern (consolidation pattern) to 
deal with consolidation axioms whose purpose is to 
describe preconditions that must be satisfied or properties 
that must hold so that a relation could be established 
between two elements. 
Finally, it is necessary to map ontological axioms to 
the object model. These axioms  are formalized to answer 
to the competency questions of the ontology. Methods are 
derived from ont ological axi oms, usi ng a set  of 
transformation rul es [11]. 
 
3.3 Fina l regards about o ur approach 
 
We ha ve been using the approach described in seve ral 
domains, s uch as s oftware process  modeling [11], 
software quality an d video on demand. To show the 
application of our approach, in the next two sect ions we 
present part of th e work done in the software qu ality 
domain. Differen t CASE too ls can  be thought in this 
domain, such as to ols for quality p lanning and track ing 
and a knowledge managem ent system. In fact , we ha ve 
already  de veloped t wo appl ications usi ng t he 
infrastructure derived: a tutorial to guide novice so ftware 
in learn ing about software quality an d ControlQ, a too l to 
support quality planning and tracking. 
 
4. Developing for reuse: an experience in 
softw are quality domain 
 
As p ointed by  Crosby , cited by Pressm an [5] , “the 
problem of quality management is no t what people don’t 
know abo ut it. Th e prob lem is wh at th ey th ink they do  
know”. Bef ore we can devise a str ategy for producing 
quality so ftware, we m ust understan d wh at software 
quality m eans. Bu t this is not an easy task . There are 
several  information so urces (books, standa rds, papers, 
expe rts, and so on) using many different terms with no 
clear sem antics estab lished. There is not a conse nsus 
about th e ter minology u sed, what cau ses 
misunde rstandi ng and se veral problem s in the definition 
of a qu ality p rogram. To deal with  these p roblems, we 
developed an ontology of so ftware quality. Sev eral books, 
standa rds, and expe rts were  consulted during the ontology 
devel opment process  and a consensus pr ocess  was 
conducted. Due to limitation s of space, we  prese nt only  
part of this ontology, concer ning only the fo llowing 
competency questions:  
1. Which is the nature of a quality ch aracteristic?  
2. In which su b-characterist ics can  a q uality 
characte ristic be dec omposed ? 
3. Whic h cha racteristics are rel evant to e valuate a  
given software  artifact? 
4. Which metrics can be use d to qua ntify a gi ven 
characte ristic? 
To addre ss these com petency questions, the conce pts 
and relations sho wn in figure 4 were  considered. As 
shown in this figure, a so ftware qu ality ch aracteristic can  
be classified a ccording to tw o criteria. The  first one say s 
if a q uality ch aracteristic can  be directly m easured or no t.  
A non mensurable characteristic must be decomposed i nto 
subcharacteristics to be c omputed by the aggregation of 
their subc haracteristic measure s. A mensura ble 
characte ristic can be directl y measured a pplying som e metric. The s econd classi fication e nforces that product 
characte ristics shoul d only be used to e valuate software  
artifacts. Artifact is h ighlighted since it is a  concept from 
the software process o ntology [3], wh ich were integrated 
with the quality o ntology been presented. 
From LINGO notation , the following epistemological 
axioms can be deri ved: 
(∀ qc) (nmensqc( qc) → qchar(qc))      (E1 ) 
(∀ qc) (mensqc(qc ) → qcha r(qc))      (E2 ) 
(∀ qc) (prodqc(qc) → qcha r(qc) )       (E3 ) 
(∀ qc1, qc 2) (subqc(qc1, qc 2) →  ¬ subqc(qc2 , qc1))  (E4) 
(∀ qc1, qc 2) (subqc(qc1, qc 2) ↔  superqc(qc2 , qc1))  (E5) 
(∀ qc1, qc 2, qc 3) (subqc(qc1, qc 2) ∧ subq c(qc2, qc 3) →  
subqc (qc1 , qc3 ))        ( E6) 
(∀ qc) (m ensqc (qc) ↔ ¬ (∃ qc1) (subqc(qc 1, qc)))  (E7) 
(∀ qc) (nmensqc( qc) → (∃ qc1) (subqc(qc1, qc)))   (E8) 
(∀qc,m)(mensqc( qc) → (∃ m) (quant(m, qc))   (E9) 
(∀qc,a)(prodqc(qc) → (∃ a) (relev(a,  qc))         (E10) 
 
where the predicates qchar , nmensqc, mensqc and prodqc 
form alize th e con cepts of quality ch aracteristic, no n 
mensurable quality ch aracteristic, m ensurable quality 
characteristic an d pro duct q uality ch aracterist ic, 
respectively, a nd the predicates subqc/super qc, quant and 
relev  form alize the whol e-part, qua ntification a nd 
relev ance relatio ns, respectiv ely. 
 Axioms (E1)  to (E3) are derived by the subsum ption 
theory. Axioms (E4) to (E7) are som e imposed by the 
whole-part relation. Fi nally, axi oms (E8)  to (E10) are  
given by card inality co nstraints. 
 1,n  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 4 – Part of th e software qu ality o ntology. 
  
Seve ral consolidation axioms were  defined, such as: 
(∀qc,qc1)(subqc(qc 1,qc)∧ prodqc(qc)→ prodqc(qc1)) (C1) Quality 
characte ristic  Non mensurable 
quality 
characte ristic subcha racterist ic 
1,n
1,1
Metric quantificatio nMensurable 
quality 
characte ristic 
1,n
relevance Produ ct quality 
characte ristic  
Artifact 
 This ax iom says th at if a prod uct quality ch aracteristic  
(qc) is d ecomposed in subcharacteristics (q c1), then these 
subcharacteristics sh ould also be product characteristics. 
 From  the ont ology prese nted, we de rived a framework, 
shown in Figure 5, following the approach described in 
subsectio n 3.2. All classes d erived directly fro m the 
ontology are prefixed by the character “K” , indicating t hat 
their objects represe nt know ledge about  the softwa re 
quality do main. The rem ainder classes are fro m the 
Whole-Part design pat tern used. The  Whole class,  for 
instance, is a handler that main tains a referen ce to  the 
parts ass ociated to this whol e. The interfac es IWhole and 
IPart must be im plemented by  the concret e classes  
(KNonMea surableQC and KQua lityCh aracteristic , 
respect ively). The methods whole() and part() on these 
interfaces provide access to its respective handlers (Whole 
and Part).  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 5 – Part of the Knowledge Package. 
 
 The c onsolidation axiom (C1) was i mplemented by the 
method addSup erQC, using the con solidation pattern, as 
shown in Figure 6. Due to s pace lim itation, we do not 
discuss  the ontological axioms mapping here. 
 
addSuperQC (KNonMeasur ableQC: qc): boolean 
{ 
 boolean  result = false; 
 if (result = (qc.isProductQC && this.isProductQ C)) 
 { 
  superQC.add(qc); 
  qc.addSubQC(th is); 
 } 
 return result; 
} 
 Figure 6 – Consolidation axiom mapping. 
 
5. Developing w ith reuse: a tool to support 
quality planning 
 
In this section , we discuss b riefly ho w the qu ality 
fram ework was use d in the devel opment of ControlQ, a 
tool that su pports quality co ntrol. The goal is to  allo w 
quality p lanning and  track ing. Con trolQ’s fu nctionality 
includes:     
• quality ch aracteristic an d m etric k nowledg e 
managem ent;     
• quality p lanning, allo wing to define quality 
evaluation activ ities th at will b e carried  along  the 
project.  The quality manager de fines for each 
one of t hese activ ities: when and what will be 
evaluated, w hich quality ch aracteristics  will b e 
evaluated an d fr om whi ch metrics these 
characteristics will b e computed;     Knowledge   
  
• quality co ntrol, allo wing to  reg ister th e 
measurem ent results.     
As pointed above, ControlQ was developed from the 
quality fram ework.  Based  on this framework, th e too l 
architecture was composed of two pac kages:  Knowledge 
packa ge, shown in Figure  5, and Quality Evaluation 
packa ge, shown in Figure 7.   
The Knowledge  packa ge directly reflects the conce pts 
of the ontology, r epresenting th e common knowledge of 
this domain. Howev er, to support qu ality p lanning and 
control, other classes are necessary  beyond those shaped. 
To address the speci fic Cont rolQ’s requirem ents, we  
devel oped the Quality Evaluation package. The classes of 
this package represent specific conc epts of the  
application, necessary to accom plish its goal s.   
As shown in Figure 7, a quality control plan defines all 
quality eva luation activities  of a proj ect. Theses activ ities 
define not  only what will be ev aluated (an artifact), but 
also how this ev aluation will o ccur, i.e. which quality 
characteristics  will b e used to evaluate the artifact. 
A non measurable characteristic must be decom posed  
into subcharacteristics to be computed by  the aggregation 
of their subcharacteristic  measures . For eac h one of these 
subcha racteristics,  it is necessary to  define its weight in 
the m easurement. A measurable characteristic can be 
directly measured choosing a metric to quan tify it. Fo r 
each choice, indicating which metric  will b e used to 
quantify ea ch measurable ch aracteristic, the 
corres ponding measure value  is store d. 
We can  notice th at th e Quality Ev aluation Pack age 
requests se rvices from  the Knowle dge Packa ge, as s hown 
in Figure 8. It is not only a hazard. In fact, we claim  that 
this two-layered  arch itectu ral style is at the core of a 
devel oping with reuse a pproach . The a pplication level 
conce rns ap plication cl asses which address th e app licatio n KMetric   
quantification()
KMeasurableQC   
quantification()0..*0..*    
1 1    name IPart<<Interf ace>>
  description   
part() : Part
KArtifact    0.. *0..*      0..*0..*      
KQualit yChar acteristi c   
 isProductQC : boolean  relev ance()    superQC() :  Set  t      relevance() : SePart
IWhole    
whole( ) : Whole   <<I nterf ace>>   
Whole    
part : Se t   KNonMeasurableQC    
subQC() : Set    part() :  Part    whole : Set addSuper QC() : boolean  
1..* 1..*      
0..*0..*      
requirements. Th e kno wledge lev el defines do main 
knowledge, which can  be used by several  applications. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 7 – Part of th e Qu ality Ev aluation Pack age. 
 
 
 
 
 
 
 
 
 
 
 
Figure 8 – ControlQ’s two-layer ed architectur e. 
 
6. Related w ork 
 
There a re seve ral works that are related to s ome part of 
our a pproach, mainly when consi dering ontol ogies 
devel opment. Usch old and King [12] proposed w hat they 
called “a s keletal methodology for building ontologies”, 
defining a sm all num ber of  stages t hat they believed 
would be required for any future c omprehensive 
methodology. In this sense , the method here proposed 
followed  some of their gu idelines an d stretch ed it toward s 
a more syste matic ap proach for building ontologies.  In the TOVE (TOronto Vir tual E nterpris e) Project, 
Grüninger and Fox [13] proposed a method f or building 
ontologies that prese nts som e features t hat are ve ry proper 
to its co ntext, th e en terprise m odeling. In fact, we 
considered it an  applied approach and not a g eneral one. 
Neve rtheless, many guidelines su ggested by this method 
are interesting, suc h as the use of c ompetency questions to  
guide the development, and were incorporated in the 
proposal  presented here. 
In [ 14] a set  of desi gn patterns for con straint 
representation in JavaB eans com pone nts is present ed. 
Constraints are equi valent to what we cal l cons olidation 
axioms and our app roach to i mplement these ax ioms is 
also base d on desi gn patterns. Howeve r, these axi oms 
represe nt only  a subset of the knowledge  that must be  
made expl icit at the ont ological level. Thu s we nee d other 
mechanism s to capture, for e xample, ont ological axiom s, 
such as the transformation rules we have proposed [11]. 
 
7. Conclusions 
 
Ontologies have great potential to  deal wi th software 
reuse problems. In t his paper we p resented an approach to 
systematically devel op ontologies an d to deri ve o bject 
frameworks from them. Th is app roach is, in  fact, an 
ontology-based approach  for devel oping for reuse. We 
show its ap plicatio n in the software qu ality d omain. We  
also di scussed how to devel op with reuse when using a 
fram ework derived fr om this approach . 
 
References  
 
[1] P.A. González and C . Fernández, “A Kn owledge-based  
Approach to Support Software  Reuse in  Object-oriented 
Librar ies”, in Proceed ings of the SEKE’97, 1997 . 
[2]  M. Uschol d, “Knowledge level modelling : concep ts and 
terminolog y”, Knowledge Eng ineering R eview, vol. 13 , no. 1 , 
1998. 
[3] R.A. Falbo, C.S. Menezes, and A.R.C. Roch a, “A Systematic 
Approach for Building Ontologies”, in Proceedings of the 
IBERAMIA’98, Lisbon, Portug al, 1998 . 
[4] R. Jasper , and M. Uschold, “A Framework for  
Understanding and Classif ying Onto logy Applic ations” , in Pro c. 
of the 12th Workshop on Knowl edge Acquisition , Modeling and  
Management (KAW’99), Alberta, C anada, 1999. 
[5] R. S. Pre ssman, "Software  Engine ering: A Pract itioner's 
Approach" , 5th Edition , New  York: McGraw-Hill , 2000 . 
[6] M. Grüninger and M.S. F ox, “Methodolog y for the Design 
and Evalu ation of Ontologies”, Techn ical Repor t, University  of 
Toronto, April 1 995. 
[7] W.N. Borst, "Construction of Engineering Ontologies for  
Knowledge Sharing and  Reuse", PhD Thesis, University  of 
Twente, Enschede, Th e Neth erlands, 1997. 
[8] S. Cranefie ld and M. Purvis, “ UML as an Ontolog y 
Modelling Lang uage”, in Proc. of the IJCAI’99 Workshop on 
Intelligen t Infor mation Integr ation, Stockho lm, Sweden, 1999 . Applicatio n Lev elKnowledge LevelKnowledge 
Quality 
Evaluation 0..*Artifac t 
+eva luatedArtif act 1 
Qualit yContro lPlan 
KMetric 
(from Knowledge) 1 
0..* 0..* 
1 1 Qualit yEvaluationActivit y 
1 0..* 0..* 
Choice Weight KQualit yChar acteristi c 0..* 
measure value (from Knowled ge) 1 
0..* 0..* 
1 1 
KNonMeasurableQC KMeasurableQC  
(from Knowled ge) (from Knowledge) 
[9] T.R. Gruber; “Towards principles for the design of 
ontologies used for knowledge sharing”, Int. Journal of Human-
Computer Studies, vol. 43, no. 5/6, 1995. 
[10] A.S.Evans and S.Kent, “Meta-modelling semantics of 
UML: the pUML approach”, in Proc. of the 2nd International 
Conference on the Unified Modeling Language. Editors: 
B.Rumpe and R.B.France, Colorado, LNCS 1723, 1999. 
[11] G. Guizzardi, R. A. Falbo and J.G. Pereira Filho, “Using Objects and Patterns to Implement Domain Ontologies”, in Proc. 
of the 15th Brazilian Symposium on Software Engineering, Rio 
de Janeiro, Brazil, 2001. 
[12] M. Uschold and M. King,  “Towards a Methodology for 
Building Ontologies”, in Proc. Workshop on Basic Ontological 
Issues in Knowledge Sharing, IJCAI’95, 1995. 
[13] M. Grüninger and M.S. F ox, “Methodology for the Design 
and Evaluation of Ontologies”, Technical Report, University of 
Toronto, April 1995. 
[14] H. Knublauch, M. Sedlmayr  and T. Rose, “Design Patterns 
for the Implementation of Constraints on JavaBeans”, in Proc. of 
the Net Object Days 2000,  Erfurt, Germany, 2000. 
 
 
 
 
 
 
