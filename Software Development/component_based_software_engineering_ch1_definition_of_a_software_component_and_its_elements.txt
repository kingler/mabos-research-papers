Chapter 1
Definition ofa
Software Component
andItsElements
BillCouncill
GeorgeT.Heineman
1.1Introduction
Thegoalofthischapteristorigorously definetermsthatdescribethe
bestpractices ofcomponent-based software engineering (CBSE).We
willdevelopanddescribeindetailthetermsoftware component andits
constituent elements toprovide clear,unambiguous, andrational
meanings tothetermsusedtodescribe CBSE.Youwillfindsome
termsusedhereforthefirsttime.Thereasonforthisissimple:many
termsinsoftware engineering emerged withoutprecisedefinitions in
publication andweresubsequently usedwithoutreflection orscien­
tificreview.Weavoidtheuseofanytermsthat,although popular, are
notrigorously defined, arecircularly referenced, oraresimplyI'
5

6 CHAPTER1DEFINITION OFASOFTWARE COMPONENT ANDITsELEMENTS
descriptions ofsoftware engineering phenomena. Whennonrigorous
termsareusedwerelyontheengineering sciences,particularly indus­
trialandcivilengineering, whichrequireprecisedefinitions becauseof
thedemands forsafetyandpublicwelfareinherentintheirdisciplines.
Fortoolongaso-called engineering discipline hasnottrainedits
practitioners inengineering practices, notsubjected itsstudents to
internships andthentestedtheirknowledge andexpertise, andnot
prevented untrained andundisciplined employees fromtakingjobsof
authority. Meanwhile, projectmanagers arenotengineering-trained
software engineers ormanagers withfullknowledge ofthecomplete
lifecycle.Weareatacrossroads. Projectmanagers mustknowthe
intricacies ofdesign,development, testing,andcomponent manage­
menttosuccessfully managetheassembly ofcomplex components
andtheirevenmorecomplicated maintenance. Thesemanagers must
alsobeawareoftheneedforsecond-andthird-party certification and
contractual relationships.
1.1.1Background
Wefirstdefineasetofbasictermsrequired toexplainthecharacteris­
ticsassigned tothedefinitions. Softwareisconstructed toexecuteona
general-purpose vonNeumann computing device(henceforth, a
machine). Asoftware elementcontainssequences ofabstractprogram
statements thatdescribecomputations tobeperformed byamachine.
Asoftware elementismachine-executable if:(1)themachine directly
executes theprogram statements or(2)amachine-executable inter­
preterdirectlyunderstands theprogram statements andthemachine
directlyexecutestheinterpreter.
Thesourcecodeforsoftware isthesetofmachine-readable filescon­
tainingprogram statements writteninaprogramming language.
Thesestatements areeithercompiled intomachine-executable state­
mentsusingacompiler orexecuted byaninterpreter.
1.2Definition
Asoftware component simplycannotbedifferentiated fromother
software elements bytheprogramming language usedtoimplement

·\
DEFINITION
thecomponent. Thedifference mustbeinhowsoftware components
areused.Software comprises manyabstract, qualityfeatures, thatis,
thedegreetowhichacomponent orprocessmeetsspecified require­
ment(IEEEStd610.12-1990). Forexample, anefficient component will
receivemoreusethanasimilar, inefficient component. Itwouldbe
inappropriate, however, todefineasoftware component as"aneffi­
cientunitoffunctionality." Elements thatcomprise thefollowing defi­
nitionofthetermsoftware component aredescribed inthe"Terms"
sidebar.
Asoftware component isasoftware element thatconforms toacom­
ponentmodelandcanbeindependently deployed andcomposed
without modification according toacomposition standard.
Acomponent modeldefinesspecific interaction andcomposition
standards. Acomponent modelimplementation isthededicated setof
executable software elements required tosupport theexecution of
components thatconform tothemodel.
Asoftware component infrastructure isasetofinteracting software
components designed toensurethatasoftware systemorsub­
systemconstructed usingthosecomponents andinterfaces willsat­
isfyclearlydefinedperformance specifications.
Thesedefinitions demonstrate theimportant relationship between
asoftware component infrastructure, software components, anda
component model.
1.2.1Interaction Standard
Oneunderlying concept ofacomponent isthatithasclearlydefined
interfaces. Wepatternourdefinition fortheterminterfaceaftertheobject
composition modelforReference ModelofOpenDistributed Processing
(RM-ODP). Ajointeffortofinternational standards bodies,theRM­
ODPdescribes aframework andsupporting infrastructure thatenables
theintegration ofdistribution, internetworking, interoperability, and
portability ofapplications ([Raymond, 1995][ISO/ITU OpenDistrib­
utedProcessing-Reference Model-Part 2:Foundations, 1995b].An
interface standard isthemandatory requirements employed andenforced
toenablesoftware elements todirectlyinteractwithothersoftware ele­
ments.Aninterface standard declares whatcancomprise aninterface.7

8 CHAPTER1
Standard·.
DEFINITION OFASOFIWARE COMPONENT ANDITSELEMENTS
Terms
Anobjectorqualityormeasure
servingasabasistowhichothers
shouldconform, orbywhichthe
accuracy orqualityofothersis
judged(bypresent-day standards).
Thistermincludes proprietary
vendorandproducer standards as
wellasnational andinternational
standards produced byrecognized
standards bodies.
Software element
Interface
Interaction
CompositionAsequence ofabstract program
statements thatdescribe
computations tobeperformed bya
machine.
Anabstraction ofthebehavior ofa
component thatconsists ofasubset
oftheinteractions ofthatcomponent
together withasetofconstraints
describing whentheymayoccur.
Theinterface describes thebehavior
ofacomponent thatisobtained by
considering onlytheinteractions of
thatinterface andbyhidingallother
interactions.
Anactionbetween twoormore
software elements.
Thecombination oftwoormore
software components yieldinganew
component behavior atadifferent
levelofabstraction. The
characteristics ofthenew
component behavior aredetermined
bythecomponents beingcombined
andbythewaytheyarecombined.
Acomponent supports aprovided interfaceifthecomponent con­
tainsanimplementation ofalloperations definedbythatinterface.
Theinterface hidesthecomponent implementation. Acomponent
needsarequired interfaceifthecomponent requests aninteraction
definedinthatinterface andthecomponent expectssomeothersoft-

DEFINITION
wareelementtosupportthatinterface. Acomponent maybeunableto
provideaninterface ifoneofitsrequired interfaces isunfulfilled. A
component shouldideallydeploywithdescriptive information that
completely specifiesallprovided andrequired interfaces.
Software elements interactwithacomponent usingthecompo­
nent'sclearlydefinedanddocumented interfaces. Aninteraction stan­
darddefinestheelements ofaninterface. Ifthecomponent can
performitsfunctiononlybyinteracting withothersoftware elements,
allexplicitcontextdependencies shouldbeclearlyspecified inthe
component's documentation. Aninteraction standard isactuallya
superset oftheinterface standard previously discussed. Theinterac­
tionstandard coversbothdirectandindirectinteractions thatmay
existbetweencomponents.
Acomponent mayhaveanexplicitcontextdependency ontheoperat­
ingsystem,asoftware component, orsomeothersoftware element.
Aninteraction standardspecifies thetypeofexplicitcontextdependen­
ciesacomponent mayhave.Another formofexplicitcontextdepen­
dencyoccurswhenacomponent mustexecuteonacomputer witha
specificclockspeedtoachieveitsperformance objective. Ifthecompo­
nentmustinteractwithahardware devicethecomponent usesappli­
cationprogramming interfaces provided bytheoperating systemor
aninterface provided bythecomponent modelimplementation. In
bothcasesthedescriptive information forthecomponent mustclearly
definetheexplicitcontextdependency. Toenablereuseandintercon­
nectionofcomponents, component producers andconsumers often
agreeonasetofinterfaces beforethecomponents aredesigned. These
mutualagreements canleadtostandardized interfaces.
1.2.2Composition Standard
Forindependent deployment acomponent mustbeclearlyseparate
fwmanoperating systemandothercomponents. Thus,thecompo­
nentencapsulates thenecessary dataandalgorithms toperform its
tasks.Thewayinwhichacomponent isdeployed isdetermined bythe
component modelandtypically involvesthreesteps.
1.Installing thecomponent inpreparation foritsuse.9

10 CHAPTER1DEFINITION OFASOFTWARE COMPONENT ANDITSELEMENTS
2.Configuring thecomponent andperhaps theoperating system
wherethecomponent willbeexecuted tomakethecomponent
available.
3.Instantiating thecomponent foruse.
Thesourcecodeforasoftware component isthefullsetof
machine-readable software files(containing procedures andmodules)
andmachine-executable files(containing run-time librariesandpre­
compiled objectcode)required topackage thesoftware component
intoamachine-readable softwareelement.Asoftwarecomponent may
bepackaged inbinaryformto:
•Protecttheproprietary intellectual property ofthesoftware com­
ponentproducer becauseitisnearlyimpossible toreverse-engi­
neerthesourcecodeforacomponent fromitsbinarypackaged
form
•Decrease installation anddeployment costs
•Reduceexplicitcontextdependencies (theconsumer, forexample,
musthaveGnuC++compiler version2.8.1)
Thecomponent producer willdecidewhether thesourcecode
shouldbedeployed withthecomponent. Itispossiblethataconsumer
orthird-party certifierwillrequireaccesstothesourcecode.
Acomposition standard defineshowcomponents canbecom­
posedtocreatealargerstructure andhowaproducer cansubstitute
onecomponent toreplaceanotherthatalreadyexistswithinthestruc­
ture.Wepatternourdefinition forthetermcomposition intheTerms
sidebarafterRM-ODP.
Inaddition toaninterface description, thecomponent producer
shouldprovidesufficient descriptive documentation toenableacom­
ponentconsumer toassemble thecomponent intoatargetapplication.
Third-party certifiers willalsousethedocumentation toverifythe
processusedtodevelopthecomponent andensurethatthefinalprod­
uctfulfillsthespecifications. Thecomponent producer orthethird­
partycertification organization willdecidethemostappropriate form
forthedocumentation, thatis,whethertostoreitwiththecomponent,
ineithersourceorbinaryformat,orprovideitseparately. Theformsof
documentation generally deemedmostadvantageous tocomponent
consumers are

DEFINITION 11
•Business rules
•Business processes
•Functional requirements
•Nonfunctional requirements
•Usecasescenarios
•Designdocumentation usingUnified Modeling Language dia­
gramsandObjectConstraint Language
•Preconditions
•Postconditions
•Designcontracts
1.2.3Component Model
Acomponent modeloperates ontwolevels.First,acomponent model
defines howtoconstruct anindividual component. Forexample,
Microsoft's Component ObjectModel(COM)requires eachCOMcom­
ponenttoprovide anIUnknown interface. Second, acomponent model
canenforceglobalbehavior onhowasetofcomponents inacompo­
nent-based systemwillcommunicate andinteractwitheachother.A
component modelenables composition bydefining aninteraction
standard thatpromotes unambiguously specified interfaces. Acompo­
nentcanbecomposed withanother component orothersoftware ele­
ment(forexample, legacycode)bycreating assembled orintegrated
connections respectively.
Thecomponent modeldefinesthepermitted mechanisms forcreat­
ingassembled orintegrated connections. D'Souza andWills(1999)
observethat"plug-in compatibility" onlysucceeds ifacomponent can
accurately declareitsexpectations oftheothercomponent towhichit
isconnected. Theprocessofassembly maybeascomplicated asneces­
sarytoachieve thegoalofprecisespecifications. Weusetheterm
assernbly toinclude themanydifferent formsinwhichcomponents
compose, suchaswrapping, staticanddynamic linking, and"plug­
and-play".
Thecomponent modelmaydefinecustomization mechanisms that
describe howcomponents canbeextended without modification. We
treatcustomization asanadvanced formofinteraction. Acomponent
modelmayalsodefinemandatory component properties, suchascod-

12 CHAPTER1DEFINITION OFASOFIWARE COMPONENT ANDITsELEMENTS
ingformats, documentation standards, orobligatory producer-inde­
pendentinterfaces.
1.2.4Component ModelImplementation
Thecomponent modelimplementation isthededicated setofexecut­
ablesoftware elements necessary tosupporttheexecution ofcompo­
nentswithinacomponent model.Anoperating system(OS)could
embedthecomponent modelimplementation butthatwouldonlyfur­
thercomplicate theasandmightrestricttheapplicability ofthecom­
ponentmodel.Thecomponent modelimplementation istypically a
thinlayerthatexecutes ontopofanas.Multiple asscanportthis
layertoensuremaximum applicability ofthecomponent model.
Theinteraction standard foracomponent modeldetermines
whether aninterface mustberegistered withthecomponent model
implementation priortouse.Interfaces aretypically definedbyusing
aninterface definition language (IDL)andregistered withaninterface
repository associated withthecomponent modelimplementation. The
composition standard foracomponent modeldetermines whethera
component mustberegistered withthecomponent modelimplemen­
tationpriortoitsuse.Thevendorofacomponent modelimplementa­
tionmayprovide toolssuchasanIDLcompiler tosupport the
development ofcomponents.
Thecomponent modelimplementation makesitpossible toexe­
cutecomponents thatconform tothecomponent model.TheObject
Management Group's (OMG's) Common ObjectRequest Broker
Architecture (CORBA), forexample, functions inanopendistributed
processing systemusingObjectRequestBrokers,softwareapplications
thatexecuteonasssuchasMicrosoft Windows orUNIX.CORBAis
anopenstandard, whichmeansthattheOMGpromotes thestandard
butisnotacomponent producer thatprovides thecomponent model
implementation. Whentheproducer ofacomponent modelimple­
mentation isalsothedesigner ofthecomponent model,thecompo­
nentmodelcouldbeproprietary (thatis,onlyonecomponent model
implementation isavailable).

DEFINITION 13
1.2.5Summary
Ourdefinitions anddescriptions ofcomponents, component models,
component infrastructures, andcomponent modelimplementations
donotexplainhowsoftware engineers shoulddesignandconstruct
components. Assoftware engineers wemustonlypromote newtech­
nologiesthatprovidestate-of-the-art designanddeployment method­
ologiesforsoftware systems tosupport immediate empiricism.
Eventually Engineering scrutinywilleventually beappliedtodesign
anddeployment methodologies.
Onemoredefinition mustbeaddedatthispointtodifferentiate
software development andthecomponent lifecycle.Inatraditional
software development lifecycledevelopers areoftenanalysts, design­
ers,anddevelopers. Aprojecthasawell-defined beginning, when
requirements areelicited,andawell-defined ending,whenthefinal
software systemisdelivered. Component production isdifferent. Con­
siderably moretimeisdevoted tobusiness rules,business process
modeling, analysis, anddesign.Muchlesstimeisspentindevelop­
mentwhiletestingoccursthroughout. Accordingly, weintroduce the
following definition
Thecomponent-based software lifecycle(CSLC)isthelifecyclepro­
cessforasoftware component withanemphasis onbusinessrules,
business processmodeling, design,construction, continuous test­
ing,deployment, evolution, andsubsequent reuseandmainte­
nance.
TheanalysisanddesignphasesforaCSLCaresignificantly longer
thanduringatraditional software development lifecycle.Atleastone
verification activityisconducted attheendofeachCSLCphase.While
recommended invarioussoftware engineering guidesandstandards,
verification isanabsolute necessity throughout theanalysis and
designtoensureasuccessful construction andunittestingphase.Dur­
ingdevelopment unittesting,usingthe"onebestway,"(seeChapter
37)isimplemented andtested.Testingagainsteachcomponent willbe
performed separately. Software testersparticipate inintegration and
systemtestingcooperatively withallteammembers. Maintenance is
designed intothecomponent forevolution thatmayoccuryearsaway.
Thecomponent modelimplementation thatsupports interaction
andcomposition mustalsoenableengineers tocreatedomain-specific
software component infrastructures whosecomponents interactto

14 CHAPTER 1DEFINITION OFASOFTWARE COMPONENT ANDITSELEMENTS
realizethefunctionality andbehavior ofadesiredsystemduringthe
CSLC.Thenextsectiondescribes ourvisionconcerning howtosuc­
cessfully integrate component-based technology intoexistingsoftware
development processes.
1.3TheMasterSoftware Development Plan
1.3.1Background
Software engineering literature commonly definesthetermsoftware
component bydescribing "software component framework" or"soft­
warearchitecture." Indeed,itisoftendifficult todescribe thedetailsof
asmallerpartwithout referring tothegreaterwholetowhichitulti­
matelybelongs. Afteranexhaustive literature reviewwediscovered
thatauthors generally usethetermsarchitecture andframework (often
without definition) interchangeably andinavarietyofdissimilar
ways.Bothterms,however, areusedsolelywithinthesoftware engi­
neeringcommunity andnotinotherengineering disciplines.
Software architecture andframeworks areessentially synonymous
withtheelicitation ofthehighestlevelsofdesignelements forsoftware
systems. Insteadofcreating moreconfusion bytryingtodifferentiate
thesetermsandtheircomplementary theories, wedescribe asimpler
concept, thatofincreasingly discreteanddetailed design.Westartwith
theconceptofamastersoftware development planborrowed fromthe
well-established practicewithinindustrial engineering.
1.3.2Definition
Inanymeaningful engineering endeavor aleadengineer orcompo­
nent-based software projectmanager (hereafter, engineer) establishes
thescopeoftheproject,generally according toanRFP,identifies the
performance specifications ofthefinished product, anddetermines
howtovalidate thesuccessoftherequested product. Whenestablish­
ingtheproduct's scopetheleadengineer dividestheworkintosub­
projects, self-contained processes ofanalysis anddesignthatproduce
elements thatwillbeincorporated intothefinaldesign.Theelements
fromallsubprojects aremanaged bysubproject engineers andcustom-

THEMASTER SOFIWARE DEVELOPMENT PLAN 15
izedtoimplement anintegrated designthatwillsatisfytheperfor­
mancespecifications. InCBSEandsoftware reuseweusethe
engineering termperformance specification ratherthanrequirements
specification becausethetermforeshadows theneedfordecomposing
aproblemintosubproblems tobesolved,whilerequirements areoften
globalinscopeandcan'tbereusedeasily.
Aperformance specification definesthefunctional requirements fora
product, theenvironment inwhichitmustoperate,andanyinter­
faceandinterchangeability requirements. Itprovides criteriafor
verifying compliance, butitdoesnotstatemethods forachieving
results. (www.dsp.dla.mil/documents/sd-15.html).
Inthefieldofsoftware engineering themastersoftware develop­
mentplancreatedbytheleadengineer ensuresthesuccessofthe
projectanditssubprojects.
Amastersoftware development plandescribes themethods adopted
bytheleadsoftware engineer ormanager forasystem's composi­
tionandinteraction. Itisaconceptual planthatdefinesthebound­
ariesofthesystem,itselements, interactions, andconstraints on
theseelements andinteractions. Themastersoftware development
planconsistsofaglobaldesignthatidentifies discreteandman­
ageablesubprojects.
1.3.3Description
Theleadengineer isresponsible forensuring thesuccessoftheproject
byadapting existingmodelstofittheneedsofthesoftware under
development. Traditional professional engineering practices require
thattheprocesses necessary foreachprojectaredetermined bythe
leadengineer basedupontheperformance specifications ofthe
project.Whilenationally orinternationally prescribed organizational
processes arehelpful-such astheSoftware Engineering Institute's
Capability Maturity Modeling andtheInternational Standards Orga­
nization (ISO)900l-the leadengineer isresponsible fortheproject
andsubprojects. Engineers arealsoresponsible forcompliance with
lawsandregulations aswellasindustrystandards.
Realization ofacomprehensive andfrequently complex master
software development planresultsinthedesignofasoftware compo­
nentinfrastructure. Thecomponent infrastructure embodies the

16 CHAPTER1DEFINITION OFASOFTWARE COMPONENT ANDITsELEMENTS
designdecisions andtrade-offs oftheproject.Theleadengineer
ensuresthatdescriptive documentation isdeveloped thatprecisely
describes theinteractions amongcomponents inthesoftware compo­
nentinfrastructure. Through increasingly detaileddesignthecompo­
nentinfrastructure isrefinedandacomponent modelisselected. The
finalimplemented components intheinfrastructure willconform to
thiscomponent model.Thecomponent modelimplementation enables
theinteraction andcomposition ofthecomponents inthesoftware
component infrastructure
Theleadengineer mayselectanexistingcomponent model,design
andimplement aproprietary component model,ordevelopacompo­
nentmodelimplementation foranexistingcomponent model.The
component modelimplementation willsupporttheexecution ofthe
components inthesoftware component infrastructure. Leadengineers
donotworkinisolation; theyrelyonthejudgment ofsubproject engi­
neersandtheanalysisanddesignteam.Therefore, thechoiceisbased
onbestpractices, according totheprofessional assessment ofthelead
engineer-as influenced byengineering anddesignstaff-to satisfy
theoriginaldesigngoalsofthedesiredsystemwithinexistingbudget
andstaffingconstraints.
Theleadengineer maychoosetodesignasoftware component
infrastructure thatincludes components thatconform todifferent
component models.Inthiscasetheleadengineer mustensurethe
interoperability oftherespective component modelimplementations
ofthesecomponent models.
Becauseofthedifferent typesofperformance specifications asys­
temmustsatisfy(suchasefficiency, useofresources, andintegration
withlegacydata),software engineers, analysts, anddesigners benefit
from"visualizing" anyproposed software systemfromavarietyof
viewpoints. Thesoftware component infrastructure thatsupports the
mastersoftware development plancanbeanalyzed frommultiple
viewpoints toevaluate globalperformance requirements. Wederive
ourviewpoints fromtheRM-ODP standard (ISO/ITUOpenDistrib­
utedProcessing-Reference Model-Part 2:Foundations, 1995b).The
RM-ODP framework iscomposed offiveviewpoints thatprovidesets
ofconcepts, structures, andrules.Theseviewpoints areusedtospecify
ODPsystems.Theyarealsoapplicable tocomponent-based systems

THEMASTERSOFIWARE DEVELOPMENT PLAN 17
•Enterprise (purpose, scope,andpolicies) -Anenterprise specifica­
tioncontains policies determined bytheorganization ratherthan
imposed ontheorganization bytechnology choices.
•Information (semantics ofinformation andinformation processing)
-Theindividual components mustshareacommon understand­
ingoftheinformation theycommunicate whentheyinteract.
•Computational (functional decomposition) -Thecomputational
specification describes howtheoverallfunctionality ofanapplica­
tionisdistributed between thecomponents.
•Engineering (infrastructure support) -Theengineering specifica­
tiondescribes thedesignthatenables communication between
components.
•Technology (choices oftechnology forimplementation) -Thetech­
nologyspecification describes theimplementation ofthesystem
andtheinformation required fortesting.
Moreinformation isavailable abouteachoftheviewpoints inthe
ISOflECOverview document (ISOfITUReference ModelofOpenDis­
tributed Processing -Part1:Overview, 1995a).
Wehavebeeninfluenced bytheRM-ODP definitions ofcomposi­
tion,interfaces, andviewpoints because thereference modelisan
international standard developed jointlybyISOandITU-Ttosupport
thedistribution, internetworking, interoperability, andportability of
ODP.Although developed toprovide a"bigpicture" toorganize
piecesofanobject-oriented ODPsystemintoacoherent whole,the
RM-ODP isdesigned asanabstract standard because itcarefully
avoidsprescribing animplementation.
Manysetsofviewpoints areavailable fordecomposing, analyzing,
anddistributing systems' functions andcomponents. Incorporating a
setofconcepts andrulesforeachoftheviewpoints, theRM-ODP pro­
videsamethod tospecifysystems fromparticularly important soft-
owareengineering viewpoints. TheRM-ODP isappealing because it
offerslanguages foranalyzing andresolving therequirements ofbusi­
nessesforsoftware basedontheseviewpoints, although thelanguages
areobject-specific. WefindthatCBSE,ingeneral, hassimilarneeds,
andthisbookprovides manychapters tohelpyouunderstand itscom­
plexities.

18 CHAPTER1DEFlNlTION OFASOFTWARE COMPONENT ANDITSELEMENTS
1.4TheBigPicture
Figure1-1graphically demonstrates therelationships amongthemas­
tersoftware development planandsoftware components, software
component models,software component modelimplementations, and
software component infrastructures. Theleadengineer isresponsible
forselecting thecomponent modelthatcanbestimplement thelogical
designasdescribed bythesoftware component infrastructure created
forthemastersoftware development plan.Thedesignelements pro­
ducedbythesubprojects mustinteracteffectively andefficiently to
achievetheoverallprojectgoalandsoftware engineers mustdeter­
minehowtomapthelogicalelements intophysicalcomponents. The
RM-ODP viewpoints canhelpengineers makesuccessful decisions for
theproducer orconsumer. Therefore, actualimplementation ofthe
systembecomes anengineering endeavor.
Legend
D«ompose
pt't:Jbkminro
P'OiKtsond.-.'
Dnignlo9icol
"''''pon.'''
in"Qitructu~MasterSoftw<lf'e
Development
Plan
Figure1-1:Thebigpicture.•
Proj«t
o
Subproject
Component
Interaction
......~
Viewpoint
Asasmallexample, consider acomponent producer thathaswon
acompetitive bidfordesigning anddeploying acomponent-based
generalledgersystem.Theleadengineer firstdecomposes theproject
intoitsconstituent subprojects, suchasinventory, accounts receivable,
andmerchandise distribution. Thebusiness orcontracting organiza­
tionmayalreadyhavealegacyinventory system.Therefore, asub-

CONCLUSION 19
projectengineer isassigned thetaskofdesigning acomponent that
effectively wrapsthelegacysystemandprovides aninterface thatcon­
formstothecomponent modelusedbytheothersystemcomponents.
Thentheleadengineer wouldprobably schedule adesigninspection
witheveryone involved intheinitialdesigntoverifythatallcompo­
nentsinteractandintegrate logicallyaccording tothemastersoftware
development plan.
Thecomponent infrastructure inFigure1-1istheresultofthe
designprocessfollowed bytheprojectengineers anddesignteam.
Through increasingly detailed refinement thesoftware component
infrastructure isimplemented andformsthebasisforthedesiredsoft­
waresystem.
1.5Conclusion
Oneofourgoalsincreatingthisbookwastodevelopasetofrigorous
definitions thatclarifymanyofthetermsusedintheCBSEliterature.
CBSEisachallenge evenforexperienced software projectteammem­
bersbecauseofthelackofrigorous definitions, theuseofconfusing
andcirculardefinitions, anddescriptions passingfordefinitions. We
haveensuredthatallthechaptersinthisbookconform tothedefini­
tionspresented inthischapter.Thetermsoftware component hasthe
samemeaning inthischapterasineveryotherchapterinthisbook.
Achieving thesedefinitions wasmorethananacademic exercise_it
wasanecessary stepindefiningtheemerging fieldofCBSE.Wehave
devotedconsiderable energyindeveloping thesedefinitions andwe
expectyouwillfindthemextremely usefulasyoudevelopyourCBSE
vocabulary andskills.

