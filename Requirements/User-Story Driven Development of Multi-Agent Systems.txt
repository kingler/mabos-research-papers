See discussions, st ats, and author pr ofiles f or this public ation at : https://www .researchgate.ne t/public ation/318308642
User-Story Driven Development of Multi-Agent Systems: A Process Fragment
for Agile Methods
Article Â Â  inÂ Â Comput er Languag es Syst ems & Struct ures Â· July 2017
DOI: 10.1016/ j.cl.2017.06.007
CITATIONS
18READS
291
4 author s, including:
Some o f the author s of this public ation ar e also w orking on these r elat ed pr ojects:
Using Go al-Orient ed R equir ements Engineering in Agile Me thods f or Lar ge Sc ale U ser St ory Manag ement  View pr oject
Using the UML Not ation f or Go al-Orient ed R equir ements Engineering  View pr oject
Yves W autelet
KU Leuven
82 PUBLICA TIONS Â Â Â 282 CITATIONS Â Â Â 
SEE PROFILE
Samedi Heng
Univ ersity of LiÃ¨ ge
21 PUBLICA TIONS Â Â Â 126 CITATIONS Â Â Â 
SEE PROFILE
Manuel K olp
Univ ersitÃ© Catholique de L ouv ain - UCL ouv ain
187 PUBLICA TIONS Â Â Â 2,631  CITATIONS Â Â Â 
SEE PROFILE
All c ontent f ollo wing this p age was uplo aded b y Yves W autelet on 11 July 2017.
The user has r equest ed enhanc ement of the do wnlo aded file.
User-Story Driven Development of Multi-Agent
Systems: A Process Fragment for Agile Methods
Abstract
Agile software development methods are mostly built as a set of man-
agerial guidelines and development concepts on how to handle a software
development but are not bounded to software development paradigms like
object or agent orientation. Some methods, like eXtreme Programming and
SCRUM are driven by operational requirements representation models called
User Stories. These User Stories can be used as an anchoring point to agile
methods; this means that we could take a User Stories set to drive a software
transformation approach embedded in a particular development paradigm.
This paper presents a process fragment for Multi-Agent Systems develop-
ment with agile methods based on User Stories sets. The process fragment
indeed takes advantage of an initial set of User Stories to build a reasoning
model (called the Rationale Tree; typically several of these are built for a sin-
gle project) that documents decompositions and means-end alternatives in
scenarios for requirements realization. A Rationale Tree can then be aligned
with a Multi-Agent design and implemented in an agent-oriented develop-
ment language. In this paper the transformation is targeted to the JAVA
Agent DEvelopment (JADE) framework. The process fragment (at least
partially) covers the Requirements Analysis ,Multi-Agent System Design and
Multi-Agent System Implementation phases. Transformation from one phase
to the other is overseen and illustrated on an example.
Keywords: Agent Software Engineering, Agile Development, User Story,
Multi-Agent System, Process Fragment, Rationale Tree, JAVA Agent
DEvelopment Framework, JADE, i*-based software process modeling
Preprint submitted to Computer Languages, Systems and Structures June 18, 2017
1. Introduction
1.1. Research Focus and Scope
Agile software development methods are nowadays well known and widely
used in the software industry [1]. They are based on a set of principles and
assumptions (described in [2, 3]) that work particularly well for the develop-
ment of software applications for which innovation is a key aspect [4]. Such
methods do not imply heavy requirements analysis and rigid software archi-
tecture; they rather encourage building exible software that is continuously
modied and rened during the project due to the strong involvement of end
users and other stakeholders. They thus require the fast development of soft-
ware prototypes or units to be tested in early phases of the project life cycle.
Flexibility and change management of the software under development are
key aspects to allow implementing modications and increments rapidly and
easily.
Agile methods like eXtreme Programming (XP) [5] and SCRUM [6] mostly
use sets of User Stories (US) as main requirement artifacts. User stories are
short, simple descriptions of a feature told from the perspective of the person
who desires the new capability, usually a user or customer of the system [7].
They dynamically describe actions performed by roles involved in the proper
execution of the produced software; they are thus driven by run-time system
behavior. US are, in this perspective, particularly well suited to describe
software systems in which human and organizational aspects play a key role
like for example nowadays' mobile apps.
We suggest to extend US-based agile software development methods with
the adoption of Multi-Agent Systems (MAS ) technology at the design and
implementation stages. We will show that a precise study of US elements
and interdependencies enriched with further domain knowledge allows to
build a reasoning model that can ultimately be mapped to run-time MAS
behavior. The transformation process of a consistent US set into a MAS
design can then lead to the fast development of exible prototypes; the so-
developed software thus integrates the overall benets of MAS technology.
Therefore, this paper introduces a (software development) process fragment
for agent-based development in agile methods. As an initial US set is used
to build a graphical model that is then transformed into a MAS design and
implementation, it can be characterized as model-driven (see [8]).
In the context of this paper, we adopt the denition of Seidita et al. [9]
for aProcess Fragment , i.e. a portion of design process adequately created
2
and structured for being reused during the composition and enactment of new
design processes both in the eld of agent oriented software engineering and
in other ones . Although we do not fully instantiate each concept dened
in Seidita et al. [9], we rely on their terminology when dening our process
fragment (see Section 4). When, in this paper, the concepts from [9] are rstly
used and instanciated to our process fragment, we have put the concept in
italic and bold (this way concepts from their process engineering framework
are recognizable at rst sight). We systematically invite the reader to refer to
that source for further explanation of each concept; each instantiated concept
denition is nevertheless transcripted in Section 4.
1.2. Contributions and Discussion
The paper constitutes a rst attempt to integrate agent-technology with
agile software development. The contribution of the present paper is the
process fragment itself. Table 1 of Section 4 summarizes the meta-model
process fragment elements of [9] that are instantiated to our particular case.
All of these instances are necessary for implementing the process fragment
and constitute a whole for its proper application.
A subset of these elements are depicted in the form of an i* Strategic
Rationale diagram [10, 11, 12]. This allows to show the dependencies and
place where each of these elements need to be used. The i* diagram also
constitutes a reference for practitioners or researchers willing to apply our
contribution.
More importantly, the application of the process fragment induces the
transformation from requirements models to MAS design and implementa-
tion. To this end, rules (called Composition Guidelines ) to transform el-
ements from the US unied model of [13] (i.e. the requirements meta-model)
to the JAVA Agent DEvelopment (JADE ) framework meta-model of [14] are
dened in the paper. These two models are System Meta-Model Con-
structs (SMMC ) of the process fragment and the Composition Guide-
lines constitute another of our main contributions.
For a proper integration of the process fragment within an agile method
we only point to one prerequisite: a US set expressed through a WHO, WHAT
and WHY dimension describing the main aspects of the system to-be . One
might argue that we could have given up US in agile development and point to
building other kinds of requirements artifacts specically targeted to the de-
velopment of MAS. Nevertheless, US writing remains a fundamental practice
in agile methods [15] so we believe that it constitutes the adequate anchoring
3
point for further agent-based development. The prerequisite is met by most
of agile developments based on XP and SCRUM.
Finally, a specic Computer-Aided Software Engineering (CASE) tool
has also been developed to support the use of our process fragment.
1.3. Paper Structure
The paper is structured as follows. Section 2 depicts the research con-
text. Section 3 the applied research method. Section 4 depicts the agent
development process fragment for agile methods that constitutes the core
contribution of the paper. Section 5 overviews the mapping rules { referred
to as composition guidelines for the process fragment { of the Rationale Tree
elements with the ones of the JADE framework as well as the specically
developed CASE-Tool. Section 6 illustrates the proposal on the development
of a carpooling example. Section 7 describes the related work. Section 8
discusses the validity, the threats to the validity, as well as the scalability of
the approach and future work. Finally, Section 9 concludes the paper.
2. Research Context
Currently, there is no unication in the use of US templates [13]. Indeed,
the commonly used pattern (which is the one tackled in this paper with no
further extensions) relates a WHO, a WHAT and possibly a WHY dimension1
(Appendix A documents how we decompose US), but several concepts can
be found in literature or blogs to represent these dimensions (e.g., Mike
Cohn's As a<type of user >, I want <some goal >so that <some reason >
[7]). Moreover, no denitions (i.e. semantics) are ever associated to these
concepts (see Wautelet et al. [13]). Consequently, in 2013, Wautelet et
al. [13] collected an exhaustive set of US templates used by practitioners
classied them and related denitions to each concept. These denitions
were found in various sources and frameworks, i.e. [10, 16, 17, 18]; some
are based on Goal-Oriented Requirements Engineering (GORE, see [19]).
After removing redundant concepts, a unied model for US templates was
built (see Appendix A.2). Most of the denitions and concepts of this unied
model come from the i* framework. The reader interested in the full research
process to build the unied US model is invited to refer to Wautelet et al.
[13].
1Examples are provided in Table 2.
4
A US tagged with the unied model evoked in previous section furnishes
information on the nature and granularity of the US element in the WHAT
and/or WHY dimensions. If the tagging is done by respecting the denitions
associated to the concepts as well as the internal consistency of the US set, we
can structure the set of US and use it to build a graphical model. Granularity
identication of US has been identied in literature as an issue to be solved
for an adequate structuring of requirements [20]. In an agile project, we can
better support requirements engineering by enhancing the structure of the to-
be software system when the exact granularity of a US element is determined.
Through domain analysis, US elements can also be linked towards means-
end and other decomposition links to depict scenarios of behaviors solving
parts of the software problem. This was shown in [21] through the building
of a graphical model of which the instance is called a Rationale Tree (see
Appendix A.3 for more information). The graphical analysis of the US set
using a Rationale Tree not only allows us to structure requirements but also
allows to evaluate the consistency of the US set.
A consistent Rationale Tree built out of the requirements analysis de-
scribes (part of) a software solution behavior that can be aligned with the
design of a MAS. Such a MAS is thus intended to map human behavior with
system run-time behavior. The process fragment developed in this paper
aims to rst build the Rationale Tree for a specic project and map it to a
MAS design compliant to the JADE framework.
3. Research Method
The present research is built as design science meaning that we do not
try to understand reality as in social sciences but rather to build a framework
that can serve human purposes [22]. We have thus proceeded to a problem
identication namely the integration of agent software development in agile
and US-based development ; this constitutes the process fragment Goal . The
process fragment itself is a solution for it.
To such an extend, we have rstly dened an abstract view of the pro-
cess fragment using an i* strategic rationale diagram [10]. This view has
been built by identifying the principal stakeholders involved in a traditional
agile development and enhancing it with the practices and models required
for agent-oriented development. The process elements have been kept mini-
mal and serve as a guidance for development. A specic software engineer-
ing meta-model like the Software & Systems Process Engineering Metamodel
5
(SPEM ) [23] could have been used to make such a description (see for exam-
ple [24, 25] for an application in the eld of agent software development) but
we wanted to keep the Description light and limited to essentials. Also, we
wanted to explicitly show the dependencies of Work Products among the
Roles which is easier with i* (by nature driven by elements dependencies
and decompositions) then with meta-models like for example the SPEM.
Then, we have dened transformation Composition Guidelines from
the Rationale Tree developed in previous works to a MAS architecture in
JADE. These Composition Guidelines have been built by making a
Cartesian product between the elements of the Rationale Tree as presented
in Wautelet et al. [21] and the elements of the JADE framework as presented
in Bellifemine et al. [14]. This allowed to determine the best possible map-
ping to implement a Rationale Tree and its reasoning abilities as a MAS in
JADE.
As evoked in Section 2, the research to build a process for integrating MAS
in agile development is based on previously validated works. The unied
model for US templates as well as the related Rationale Tree are two previous
contributions.
4. Agent Development Process Fragment: a Description
Table 1 documents all of the process fragment elements dened in Seidita
et al. [9] that are instantiated onto our contribution.
Table 1: Instantiation of our Process Fragment.
Element Denition (from [9]) Instantiation to our process frag-
menti* Rep-
resen-
tation
Design
Pro-
cessDesign process from
which the fragment
has been extracted.User Story based Agile Methods
like XP or SCRUM .N/A
Phase A specication of the
fragment position in
the design workow.
Usually referring to a
taxonomy .Requirements Analysis ,Multi-
Agent System Design ,Multi-
Agent System Implementation .Goal
6
Goal The process-oriented
objective of the frag-
ment .The integration of agent soft-
ware development in agile and
US-based development.N/A
Activity A portion of work
assignable to to a per-
former (role) .Build Rationale Tree ,Tag User
Story elements ,Link User Story
Elements ,Remove redundant re-
quirements ,Identify missing re-
quirements ,Align Multi-Agent
System Design with Rationale
Tree,Dene Multi-Agent Sys-
tem structure ,Specify tempo-
ral exchange of messages ,Im-
plement software in an agent-
oriented programming language .Task
Work
Prod-
uctThe resulting product
of the work done in
the fragment; it can
be realized in dierent
ways also depending
on the specic adopted
notation .Structured User Story ,Initial
User Story Set ,Rened User
Story Set ,Consistent Rationale
Tree,Multi-Agent System De-
sign,Software Unit ,Rened
User Story Subset .Resource
Role The stakeholder per-
forming the work in
the process and re-
sponsible of producing
a work product (or
part of it) .Agile Product Owner ,Software
Analyst ,Software Designer ,
Software Developer ,System
Tester ,User.Actor
System
Meta-
Model
Con-
structThe concept of the
fragment deals with,
for instance a frag-
ment aimaing at
dening the system
requirements has to
dened and to iden-
tify the concept or
requirements .The Unied User Story Model
(from [13]), The JADE Meta-
Model (from [14]).N/A
7
Descrip-
tionIt is the textual and
pictural description of
the fragment; it pro-
vides a bird-eye on the
whole process the frag-
ments come from and
the fragment overview
in terms of tasks to be
performed, roles and
work product kind to
be delivered .The i* Process Model of Figure
1.A
Strate-
gic
Ratio-
nale
Dia-
gram
Compos-
ition
Guide-
lineA set of guidelines for
assembling/composing
the fragments with
others .The transformation rules ex-
pressed in Section 5.N/A
As already evoked, to show the Roles involved in the process fragment,
theirWork Product dependencies and their , we use a pictorial Descrip-
tion using the i* framework in Figure 1. For the sake of clarity, we insist
that each of the Roles can, of course, be played by several individuals in
a same project; similarly a same individual can play dierent Roles in a
project.
We distinguish several types of stakeholders, all having various objectives
and expectations, i.e.:
The Agile Product Owner (APO )Role is a senior manager that is
mainly in charge of developing a vision of the software system that
needs to be built and propagate that vision over the development team;
it is a key stakeholder of the project. His/her Activities are essen-
tially outside the scope of our process fragment and are guided by the
adopted agile method; we nevertheless identify and represent the APO
Role here because the output of some of his/her activities are required
by our process fragment. The APO Role indeed uses the product
backlog (see [26, 27]) to store the Initial User Story Set Work Prod-
uct. The Software Modeler Role thus depends on the APO Role for
obtaining the Initial User Story Set Work Product ; that is why it is
8
represented as a Resource dependency in the i* diagram of Figure 1.
This Initial User Story Set is required for composition with our pro-
cess fragment; it is typically collected over several future system (end)
Users Role in the form of a Structured User Story Work Product .
The APO Role thus depends on the (end) User Role for obtaining
theStructured User Story Work Product ; that is why it is repre-
sented as a Resource dependency in the i* diagram of Figure 1. At the
end of the Requirements Analysis Phase , the Software Analyst Role
furnishes a Rened User Story Set Work Product to the APO Role
(see next bullet);
The Software Analyst Role is in charge of understanding the software
problem by studying the application domain as well as to prepare a
structured view and specication of user requirements. The rst pro-
cess fragment Activities are performed by this role. These are per-
formed in the context of the Requirements Analysis Phase which is
represented as an i* Goal in Figure 1. A means-end decomposition
then allows to rene the i* Goal representing the Phase . Indeed, to
fulll this i* Goal, the Software Analyst Role performs the Activity
Build Rationale Tree . In itself, the latter Activity requires a set of
other Activities to be achieved (as shown through the decomposi-
tions in Figure 1). The rst one is to Tag the user story elements of
theInitial User Story Set Work Product ). Then, the Software An-
alyst Role , can Link the User Story elements in the Rationale View
of the CASE-Tool (see Section 5). The purpose of this Activity is to
link related US elements in the Rationale View through means-end and
traditional decompositions (see Appendix A.3) to build a rst version
of the Rationale Tree. More domain knowledge is usually needed to
fully perform this Activity so that the Software Analyst Role needs
to discuss elements with the APO Role or immediately with (end)
Users . Simultaneously, the Software Analyst Role needs to Ensure
consistency in the User Story set and to Identify missing requirements ;
these are two other Activities of the process fragment represented as
i* Tasks in Figure 1. Concretely, several US elements may express the
same requirement and some elements are not expressed in US yet are
needed to ensure a consistent system. The purpose of these two last
Activities is to solve these issues. As an output, the Software Ana-
lystRole sets at disposal of the APO Role aRened User Story Set
9
Work Product and at disposal of the Software Architect aConsistent
Rationale Tree (for both of these Work Products see the i* Resource
dependencies between the two related roles in Figure 1);
The Software Designer Role is in charge of transforming software spec-
ications to a software architecture and design. Activities of the pro-
cess fragment are performed by this role in the context of the Multi-
Agent System Design Phase which is represented as an i* Goal in
Figure 1. A means-end decomposition then allows to rene the i* Goal
representing the Phase . Indeed, to fulll this i* Goal, the Software De-
signer Role performs the Activity Align Multi-Agent System Design
with Rationale Tree . In itself, the latter Activity requires two other
Activities to be achieved (as shown through the decompositions in
Figure 1). The rst one is to Dene the Multi-Agent System Structure .
In our case, we point to the use of the transformation rules depicted in
Section 5; these are specic to the JADE framework but other agent-
oriented languages could also be adopted. Then, the Software Designer
Role , can Specify the temporal exchange of messages in order to give
further documentation on the execution of user (or business) processes
to the Software Developper . Both of these atomic Activities are sup-
ported in the Design View of the CASE-Tool (also depicted in Section
5). The Multi-Agent System Design Work Product is transmitted to
theSoftware Developer Role for further implementation;
The Software Developer Role is in charge of associating code (JADE
code in our case) to the Multi-Agent System Design .Activities of
the process fragment are performed by this role in the context of the
Multi-Agent System Implementation Phase which is represented as
an i* Goal in Figure 1. A means-end decomposition then allows to
rene the i* Goal representing the Phase . Indeed, to fulll this i*
Goal, the Software Developer Role performs the Activity Implement
software in an agent-oriented programming language . This Activity
requires specic technical knowledge of the agent-oriented development
language in use (JADE in our case). As output, the Software Developer
Role furnishes a Software Unit Work Product to the System Tester .
The latter Work Product can be a prototype of a dened module
addressing specic requirements or a (partial) nal implementation to
be validated. In any case it must be an executable release on which
10
feedback can be collected;
The System Tester is in charge of ensuring the system tests for the
Software Unit Work Product is valid. We thus focus here on eval-
uation related to the (end) User only. The System Tester Activities
are outside the scope of our process fragment and are guided by the
adopted agile method;
The (end) UserRole uses the software application and is thus in charge
of providing the Feedback on Software Unit Work Product . The
portion of the Rationale Tree covered by the Software Unit Work
Product (implementation) is rened on the basis of the (end) User
Role Feedback on Software Unit Work Product furnished by the
System Tester Role to the Software Analyst Role in the form of a
Rened User Story Subset Work Product . The Software Analyst
Role then renes the Rationale Tree on this basis (the Build Rationale
TreeActivity ).
5. Composition Guidelines for Transformation and CASE-Tool
Figure 2 graphically illustrates the transformation Composition Guide-
lines. As already said, the meta-model for the requirements analysis phase
has been developed in Wautelet et al. [13]. The meta-model for the MAS
Design and MAS Implementation phases is taken from Bellifemine et al. [14].
The mapping has been built following the method evoked in the Section 3.
The US unied model Role element represents the actions and social
behavior taken by an individual or a system; it consequently aligns with
the Agent concept. Roles distinguished in US (so in the Requirements
Analysis Phase ) thus transform into JADE Agents in the Multi-Agent
System Design Phase . In the Multi-Agent System Implementation
Phase , each instance of the Role will be a new system Agent (e.g.,
each individual Driver instantiates a new Driver Agent);
Hard-goals represent the most abstract and coarse-grained functional
elements present in the US. We suggest as a good practice during re-
quirements analysis to always dene a counterpart to the Hard-goal in
the form of a Task that realizes that particular US element Hard-goal.
In other words, our point is that the Hard-goal is part of the problem
11
Software 
Analyst
Agile 
Product 
Owner
Identify 
missing 
requirements
Software 
DesignerRemove 
redundant 
requirements
UserInitial User 
Story Set
Refined User 
Story Set
Tag User 
Story 
elements
Consistent
Rationale
Tree
Software 
Developer
Defin e Multi -Agent 
System structureRequirements 
Analysis
Build Rationale Tree
Align Multi -Agent 
System Design with 
Rationale Tree
Specify temporal 
exchange of 
messagesMulti -Agent 
System DesignImplement  software  in an 
agent -oriented programming 
languageLink User Story 
elements
ActorActor 
BoundaryGoal Task ResourceLegend :
Softgoal
Dependency LinkAND 
decompositionMeans -End 
decompositionSoftware Unit
System
TesterMulti -Agent System 
Design
Multi -Agent System 
Implementation
Feedback on 
Software UnitStructured
User StoryRefined User 
Story SubsetFigure 1: Process (fragment) for Integrating Agent-Oriented Development in Agile
Projects.
domain so that we do not transform it as such to the MAS design; the
Task corresponding to a solution to the Hard-goal and thus part of the
solution domain will be transformed to the MAS design;
Tasks and Capabilities represent (operational) functional elements of
the software solution. In other words, they describe how a Role per-
forms actions to achieve an Hard-goal or contribute to a Soft-goal.
These elements constitute the core of the (future) Agent behavior; that
is why they become JADE Behaviors in the MAS. There is neverthe-
less a dierence between the transformation of Tasks and Capabilities
toJADE Behaviors . Indeed, since the Task is, by nature, complex so
not atomic, it is transformed into a CompositeBehaviour (itself com-
posed of other behaviors) and the Capability { by nature atomic { is
12
 
 
 
 
 
 
  
 
 
 
  
 
 
 
 
 
 
 
 
 
 Requirements Analysis  MAS Design/ Implementation  
JADE Framework  Unified User Story  Model  Figure 2: Transformation from US elements to MAS Design (adapted from [13, 14]).
transformed in a SimpleBehaviour ;
Soft-goals have no clear cut criteria to be achieved, they are considered
as being \satisced" if achieved to a degree considered acceptable [13].
The choices that will be made in the software solution and in the MAS
design will thus have a positive or negative impact on the resolution
of the Soft-goal itself. The Soft-goal is thus not transformed as such
to the MAS design but the impact (positive or negative) of design
choices could be traced from design elements like JADE Behaviors to
the Soft-goal. This could for example be done using the Rationale tree
in the fashion of the NFR framework (see [28]). This is, however, not
currently supported and left for future work.
In order to support the editing of US sets on US cards as well as the
Rationale Tree, we have built an add-on to the cloud version of our Descartes
13
Architect CASE-Tool [29]. Figure 3 illustrates two screens of the CASE-tool;
for the purpose of the process fragment, three views are relevant:
theUser Story View (USV ) to edit US through virtual US cards. Each
US element in a dimension must be tagged with a concept of the unied
model;
theRationale View (RV) to edit Rationale Trees following the speci-
cation made in [21] and in this paper. The graphical elements can be
automatically generated from the US dened in the USV; the modeler
is then in charge of further editing the links between elements. When
changes are made to graphical elements in the RV, the elements are
automatically updated in the USV and vice-versa. These do indeed
form a same logical element represented in dierent views;
theDesign View (DV) to edit a JADE Class diagrams;
next to this, we can also edit classical UML diagrams.
Once again, as a prerequisite, the set of US needs to be tagged to start
the transformation and round-trip between the views. The editing process
is continuous and intensive over the Requirements Analysis Phase2and to
a certain extend over the entire project life cycle (see Rened User Story
Work Product in Section 4). This is of course fully supported by the
tool and leads to automatic updates of complementary views; consistency
is ensured by separating the conceptual element in the CASE-Tool memory
from its representation in a view so that if a change is made to an element in
one view it is automatically impacted to the same element in the other view.
6. Illustrative Example
Our proposal will be illustrated using a running example about carpool-
ing. Carpooling deals with sharing car journeys so that more than one person
travels within a car. It, indeed, becomes increasingly important to save gas,
2In practice, during Requirements Analysis some US elements are \retagged" in an ad-
hoc manner in later modeling stages. Indeed, the composition of the Rationale Tree mostly
leads to reconsider the nature of some elements (of which the granularity and structure
was hard to determine when only seen in an isolated manner in the rst stages) like in
most modeling approaches.
14
(a) User Story View 
(b) Rationale View 
1Figure 3: The supporting CASE-Tool.
reduce trac, save driving time and control pollution. ClubCar [30] is a
multi-channel application available as an Android application, SMS service
and IVR system. Users of ClubCar are riders and/or drivers that can register
by SMS, voice or through an Android app. Roughly speaking, the software
allows drivers to propose rides and submit their details with dates ,times ,
15
sources and destinations while riders can search for available rides.
The solution presented here is not considered as a full case study since the
solution was designed ex-post of the solution built in [31]. This means that
we took over the US set and made another development based on a MAS and
that the MAS was not the original solution proposed for this problem. Nev-
ertheless, this illustrative example contributes to showing the applicability
and performance of the approach.
At the beginning of the Requirements Analysis Phase , the responsibility
and accountability (in the sense dened in [32]) of our process fragment
starts up. The illustrative example consequently starts with that Phase .
Similarly, it nishes with the Multi-Agent System Implementation Phase ;
ex-post activities are outside the responsibility and accountability of the
process fragment and are dependent on the agile method the process fragment
is embedded in.
6.1. Phase: Requirements Analysis
6.1.1. Activity: Tag User Story elements
Table 2 shows a sample of the Initial User Story Set Work Product that
has been furnished by the APO Role . To save some space, the US presented
in the Table have already been associated with a tag; this was thus the rst
Activity of the Software Analyst Role . The reader should keep in mind that
there are much more US written for this project and that the scope of the
project is much broader. We have made here an ad-hoc selection of a sample
related to specic modules (and thus Rationale Trees decompositions). The
sample of the US of the ClubCar application has indeed been selected to
illustrate at best the research developed in this paper.
Table 2: US sample of the ClubCar application.
Dimen-
sionElement DC Type
WHO As a RIDER, Role
WHAT I want to register to the ClubCar service, Task
WHY so that I can have access to rides from A to B. Hard-goal
WHO As a RIDER, Role
WHAT I want to see the list of rides based on my criteria, Capability
WHY so that I can choose the one I prefer. Soft-goal
16
WHO As a RIDER, Role
WHAT I want to get access to the details of a ride, Capability
WHY so that I can choose the one I prefer. Soft-goal
WHO As a RIDER, Role
WHAT I can cancel a ride, Capability
WHY so that the DRIVER knows about it. Hard-goal
WHO As a RIDER, Role
WHAT I can access to the history of rides I got, Capability
WHY so that I have visibility. Soft-goal
WHO As a RIDER, Role
WHAT I want to rate a DRIVER and share comments, Capability
WHY so that others can use that information. Soft-goal
WHO As a RIDER, Role
WHAT I want to search for a ride, Capability
WHY so that I can go from A to B. Soft-goal
WHO As a DRIVER, Role
WHAT I want to log in to the platform, Capability
WHY so that I can register to the service. Task
WHO As a DRIVER, Role
WHAT I want to propose a ride from A to B with the price,
location and time of departure, and number of seats
available.Task
WHO As a DRIVER, Role
WHAT I want to select the ride characteristics. Capability
WHO As a DRIVER, Role
WHAT I want to conrm the proposal. Capability
WHO As a DRIVER, Role
WHAT I want to register to the ClubCar service, Capability
WHY so that I can propose ride to go from A to B. Soft-goal
6.1.2. Activity: Link User Story elements
After the tagging of the Initial User Story Set , the rst Rationale Tree
can be produced. Out of the Initial User Story Set we generate the rst
Rationale Tree that is represented in Figure 4. At this preliminary stage, the
dierent US elements are not yet interlinked.
17
Figure 4: Initial Rationale Tree Built from the US set.
Figure 5 represents the Rationale Tree obtained after the US elements
have been linked3.). Further domain analysis is usually required to achieve
such a stage, it includes more discussions with users, clients and other stake-
holders. In practice, during this stage { when using the CASE-Tool { there
is continuous round-trip between the US View and the Rationale View.
Rider 
login to the 
platform search for ride access to 
rides from A to B 
see the list of rides 
based on my criteria get access to the 
details of a ride access to the 
history of rides choose 
preferred ride order a ride via 
ClubCar 
Choose ride 
enter source, 
destiation, date, etc. cancel a ride others can use 
that information 
share comments rate a DRIVER register to the 
ClubCar service get a ride via 
ClubCar Driver 
register to the 
ClubCar service share a ride from 
A to B 
confirm a ride 
request login to the 
platform submit ride 
proposal accept ride 
requests 
see list of rides 
requests refuse a ride 
request know about 
accepted ride 
cancelation 
propose ride 
via ClubCar 
select the ride 
characteristics (source, 
destination, date, price, nb 
of seats) driver 1 
others can use 
that information 
rate a RIDER 
share comments RIDER knows 
about it 
cancel a ride 
propose a ride from A to B 
with the price, location and time 
of departure, and number of 
seats available access to the 
history of rides 
I gave have visibility 
about me 
rider 1 
contact a possible DRIVER 
directly though the car 
pooling system using SMS or 
calling the DRIVER pay for the carpooling 
service in function of the 
country I'm traveling in 
pay by credicard Pay by SMS in 
domestic country 
define the amount 
and the driver select the 
payment 
desiderata about:blank 
1 of 1 16/08/2016 14:26 
Figure 5: Rened Rationale Tree Built from the US set.
3In order to save space, the diagram also includes elements added during the Activities
of Section 6.1.3
18
6.1.3. Activities: Remove redundant requirements & Identify missing require-
ments
Building a consistent Rationale Tree leads, for instance, to include the
US containing the Task \propose ride via ClubCar" for the Role \Driver".
This Task is required for linking the (more abstract) Hard-goal \share a ride
from A to B" { that is part of the problem domain { to the solution domain
in a means-end analysis fashion. Other US derived from elements added in
the Rationale Tree are also included.
AConsistent Rationale Tree is the Work Product that will be used in
the next stage for transformation to MAS design.
6.2. Phase: Multi-Agent System Design
6.2.1. Activity: Dene Multi-Agent System Architecture
As discussed, the transformation process to the MAS Design takes roots
in the Rationale Tree; elements are transformed following the rules seen
previously in Section 5.
<<CompositeBehaviour>> 
SubmitRideProposal 
<<OneShotBehaviour>> 
LoginClubCar <<SimpleBehaviour>> 
SelectRiderCharacteristic <<CompositeBehaviour>> 
RegisterToClubCar 
<<CompositeBehaviour>> 
AcceptRideRequests <<SimpleBehaviour>> 
SeeListOfRideRequest 
<<SimpleBehaviour>> 
RefuseRideRequest <<SimpleBehaviour>> 
ConfirmRideRequest <<CompositeBehaviour>> 
ProposeRideFromAtoB 
<<OneShotBehaviour>> 
SubmitRide 
Figure 6: ClubCar JADE (Partial) Class Diagram.
The roles Driver and Rider are transformed in individual agents (i.e.,
Driver and Rider) in JADE. For illustrating our approach, we show here
the transformed architecture for the agent Driver only. Figure 6 presents
the internal architecture of the Driver agent transformed from the Rationale
Tree. Typically, the Task Propose ride via ClubCar is transformed to a
CompositeBehaviour ProposeRideFromAtoB . In addition, the latter behav-
ior is composed of three other CompositeBehaviours SubmitRideProposal ,
RegisterToClubCar , and AcceptRideRequest which are respectively trans-
formed from Tasks SubmitRideProposal ,Register to ClubCar service
19
and accept ride requests . However, within our illustrative example we
only focus on the SubmitRideProposal behavior. The SubmitRideProposal
behavior is further composed of two SimpleBehaviours SelectRideCharacteristic
andLoginClubCar which are respectively transformed from the Capabilities
Select the ride characteristics andlogin to the platform .
The architecture obtained through the transformation process and illus-
trated in Figure 6 only provides the signature of the behaviors of the Driver
agent; but not how this agent it eectively behaves (and thus reacts) when
anACLMessage is received; this is determined and described by the analyst
on a case by case basis through domain knowledge (so not on the basis of
the user stories themselves).
6.2.2. Activity: Specify temporal exchange of messages
Other diagrams like communication and dynamic diagrams (see [32]) al-
low to visualize the interaction between the agents when they send ACLMessage s.
By doing so, we can we further discover the interaction between agents. This
aspect remains out of the scope of the present paper because we focus on the
software development process and transformation abilities.
6.3. Phase: Multi-Agent System Implementation
6.3.1. Activity: Implement software in an agent-oriented programming lan-
guage
We have basically adopted the client-server architecture for implementing
the ClubCar system as shown in Figure 7. The GUI constitutes the client
side for interacting with the MAS implemented as a mobile application. The
MAS constitutes the server side implemented with the JADE framework.
The JADE MAS, thus the server side constitutes the part transformed
from the Rationale Tree. JADE uses the Java language for implementing
agents and uses ACLMessage s for communicating between agents.
When a mobile application is launched by the end-user, an Agent is cre-
ated within the JADE platform for handling all the requests from that (end)
User (in our implementation we create a session for each application launched
and the ID session has become the Agent ID for the corresponding Agent in
the JADE platform). For an eective execution of the application we need
to allow the mobile application to communicate directly with the Agents
present in the JADE platform. When an action is performed at the level of
the GUI, the Agent concerned with the transaction receives what the mobile
application has sent. We propose in our implementation an encapsulation
20
ClubCar Architecture:   
Multi -Agent System  
RiderA 
DriverA 
Gateway  
JADE -base agent  Platform  
DF Agent  
 AMS  Agent  
 RMA  Agent  
ClubCar  
Ride  
Payment  
UserManager 
DriverA  
Persona l  
Agent  
RiderA 
RiderB  
Legend : 
Agent  
Message 
 Interaction Server Web  
Apache 
Tomcat Figure 7: ClubCar Architecture.
mechanism that allows the mobile application to send or receive content
to/from the concerned agent directly. This means that the agents send and
receive the requests composed within the client (meaning at the level of the
GUI) in real-time. We use JSON formats for communication between the
mobile application and the MAS since this format is popular in web tech-
nologies and light weight compared to other formats like XML. In addition,
it allows the mobile application to directly update its interface after getting
the data from the corresponding agent. In order to achieve this, the request
of the client is, as a rst step, encapsulated in the HTTP request. When the
Servlet receives any HTTP request from the client, it reads the content of
this request in JSON data format and writes it into a Java Object. Then, as
a second step, it sends that object to the JADE gateway.
Finally, the Gateway reads the JSON data from the Java Object sent
and builds the ACLMessage using the JSON data. The ACLMessage is sent
to the corresponding agent. Since JSON can also be operated in JADE, we
do not re-translate the client content into the XML format that is normally
used in the JADE platform. An example of the JSON format encapsulated
inACLMessage is given in Figure 8. The ontology-based communication is
out of the scope of this paper and implementation.
7. Related Work
First of all, in line with [8, 33], our work can be said to be model-driven
because the MAS implementation is partially built and deduced from a high
21
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
 ProposeRideRequest  
SelectRideCharateristic  
RideInfo  
ProposedRi deAccepted  
and  InformClient  
{ 
"AID":"211EC73FA5CD0B4045A024CF93E27240", 
"action":"RideInfoResponse",  
"data": 
            { 
              "departure":"Louvain-La-Neuve",       
              "arrival":"Paris", 
             "date":"2016-08-30",     
              "time":"10:00.00",  
              "price":20, 
              "nbride":3 
            } 
} Figure 8: ClubCar Application.
level analysis model, the Rationale Tree. We thus start with further studying
the model driven software development for MAS.
Hahn et al. [34] propose a meta-model for agent systems that abstracts
from existing agent-oriented methodologies, programming languages and plat-
forms. It denes the abstract syntax of a proposed domain specic modeling
language for MAS; the latter is a base to generate code in agent-oriented
languages like JACK [35] or JADE. Their approach is not immediately com-
parable to ours since we directly aim to generate code in a specic language
without having an in-depth platform independent MAS design. The idea of
such a middle layer has been studied in [36] but we aim to generate code as
fast as possible to be complied with agile principles. Similarly, [37, 38, 33]
have built a domain specic modeling language for abstracting and sup-
porting the development of a MAS. Their approach is nevertheless deeply
22
anchored in the semantic web paradigm because it specically takes into ac-
count the interactions of semantic web agents with semantic web services. It
is thus more specic than for example [34]. Besides, [37, 38, 33] also depict
MAS analysis in terms of high level structures like Roles, Goals, Plans or
even Capabilities. Nevertheless they devote specic eort to design a seman-
tic web solution. Once again, we do not spend time making an enhanced
design stage and turn immediately to code.
Then, [39] proposes a meta-model for the integration of diverse agent-
oriented modeling languages that use the powertype pattern (e.g., Tropos,
Prometheus, Ingenias and AUML). Our unied model for user story based
modeling could be an instance of the inter-methodology MAS metamodel pro-
posed in [39]. This shows the suitability of the analysis stage to be aligned
with a MAS implementation. Moreover, [40] extends the MAS-ML meta-
model and enhance its tool to support the modeling of not only proactive
agents but also several other architectures described in the literature. Their
contribution is mainly located in the detailed design of MAS and goes deep
in the possible agents description. We do not intend to do this to keep our
practices as agile as possible and immediately target a specic implementa-
tion language. Also, their aim is the integration of heterogeneous sources;
we essentially target collaborating agents in an homogeneous environment.
We can also focus on the use of US in agent methods. In Agile PASSI
[41], US are used as requirement artifact for communication but it is their
only usage. US, specically in MaSE [42], is one source of requirements for
capturing the goal of the agent [43] but without formal transformation. [44]
uses fuzzy theory to provide a systematic and methodical approach to ex-
plore various dependencies such as goal, task, resource or Soft-goal from US.
Again, the technique is limited to the analysis stage with no transformation
to design. In contrast, Tenso et al .[45] adopt agent-oriented modeling in
agile development. They provide a method for decomposing a goal into sub-
goals and link them to US elements. Carrera et al. [46] use US as testing
mechanism for agent-oriented software development. Only one US template
is used and aligned to JBehave (http://jbehave.org).
Prometheus and INGENIAS [47] are two agent-oriented methods allowing
to generate JADE code on the basis of a MAS design. We do not recommend
to build a full generic MAS architecture like in these methods before gener-
ating code but rather to faster go to the basic code produced and complete it
immediately in the JADE development language to be consistent with agile
principles.
23
Finally, our work can also be compared to Tropos [48, 49] because Tro-
pos builds a MAS out of an i* Strategic Rationale Diagram [10] (SRD). Our
Rationale Tree is largely inspired by the SRD structure. Nevertheless, Tro-
pos distinguishes explicitly a set of design artifacts that need to be built as
a middle layer before implementing the MAS. We do not point to such a
stage but rather immediately bridge our Rationale Tree to a specic MAS
implementation language (JADE in our case) for fast implementation and
agility.
8. Validity, Threats to the Validity, Scalability of the Approach
and Future Work
As already evoked, the prerequisite to the use of our approach is to tag
the US when setting them up. For this rst specic task, in terms of time, the
investment is limited: at most a few minutes per US, including the task to
encode them in the CASE-Tool. More time would then be necessary to create
and edit the links between US elements in the RV. This is, however, similar
to classical software solution modeling. Moreover, we dispose of a clustering
algorithm based on US syntax that allows to make clusters of relating US as
a rst step in the analysis process; our approach is comparable to [50]. This
allows to start modeling on the basis of clusters of US that are rather similar
which can save considerable time when compared to building Rationale Trees
on the basis of a random organization of US. This allows a more consistent
rst basis for US elements structuring and grouping.
A few threats to validity could also be pointed out and should be claried
in later validation of the work:
Accuracy in US tagging could impact building a consistent Rationale
Tree. A study on the perception of US elements' granularity using the
unied model has been performed in [51]. The study has distinguished
dierent groups of users from students to software development profes-
sionals. The results were better with experienced modelers, but iden-
tifying granularity did not lead to major issues in any group with the
condition that the set of US was taken as a consistent whole. This, in-
deed, allows to evaluate the relative links and hierarchy of US elements
leading to adequate granularity identication and thus US elements
tagging. As \stand alone" elements, granularity identication makes
no sense and is almost random;
24
Accuracy of the Rationale Tree with respect to the understanding of
user requirements . The Rationale Tree is built out of the initial US
set thus derived from the primary source of requirements in the agile
project. As said, further domain analysis is made during the Require-
ments Analysis Phase in order to establish dependencies between US
elements and identify gaps in the software solution. The Rationale Tree
is not an adequate Work Product to be used for requirements vali-
dation with Users; nevertheless early prototypes generated on its basis
can be quickly validated by users in order to evaluate its adequacy and
possible changes to be made in the requirements and their understand-
ing. The highly iterative nature of agile methods thus limit this second
threat to validity.
The technique of transforming a set of US into Rationale Trees is virtually
applicable to all sizes of projects. The complexity of the Rationale Trees
may then vary from project to project and the larger the number of US, the
larger the modeling eort required. The tricky question of scalability can
thus legitimately be posed. The requirements analysis stage of our technique
could be compared to User Story Mapping (USM [52]); the latter is applied
to projects of any size. Splitting US through their three dimensions will
induce more modeling eort but using the CASE-Tool will save eort by
adding exibility in model management comparing to build a USM on a
board or on the ground as it is the case for larger projects. Building Rationale
Trees requires time from the software development team so that the time
spend during the requirements analysis stage will be increased. Nevertheless,
the time for the design and implementation will be lowered thanks to this
modeling and structuring eort.
Experience of the process application on multiple US sets showed us that
the key to the successful application of the method is the distance between
theInitial User Story set and reaching a Consistent Rationale Tree . The
latter indeed constitutes the required artifact for be transformed into an
intelligent system: if it cannot be reached, the transformation will not deliver
a satisfying prototype. More work should then be made on the building of the
Consistent Rationale Tree . So far we considered reaching consistency in the
Rationale Tree through domain analysis, fast(er) prototyping should/could
also be envisaged to reach such results. The Rationale Tree could then evolve
from iteration to iteration in order to reach consistency. In any case, at
least basic domain analysis is required to link elements to reduce the eld
25
of possible organizations between US elements and rapidly converge to a
relevant solution.
Future work also includes the application of the technique on more real-
life case studies. We will notably proceed to a statistical analysis of the
stakeholder's perception of the relevancy and contribution of the Rationale
Tree for projects they have worked on as well as the pros and cons of the
agent-oriented prototype. The cost of the approach in terms of time and
resources and eort also still needs to be evaluated.
9. Conclusion
Agile development methodologies mostly focus on techniques to manage a
software project in a very intuitive and down to earth way; they are not bound
to a particular implementation technology or paradigm. Since requirements
are expressed in a very informal and operational way through US, lots of
elements relative to the software problem and solution are mixed into the
project backlog. What, at rst, may seem to be a huge drawback in the
perspective of structuring and studying requirements can in fact also be seen
as an interesting advantage. Indeed, US are expressed in a directive way close
to the way users and other stakeholders behave in a real life organizational
environment. If the US set's elements interdependency can be established,
realization scenarios can be built. The completeness and redundancy of these
scenarios can be overseen as well as means-end alternatives. This is precisely
the way abstract intelligent reasoning systems work and, with the use of
agent-technology, we can map organizational and system behavior. US sets,
made consistent in the Rationale Tree, can thus be aligned with an MAS
design and be implemented in an agent-oriented development language like
JADE.
The process fragment overviewed in this paper takes advantage of the
organizational and operational aspects of US to build a model-driven soft-
ware development methodology. As evoked in the paper, the success of the
method's application is mainly dependent on the quality of the rst US set
used as input; preliminary work is thus required from the APO Role to
deliver a qualitative US set. Further work includes the evaluation of the
maximum distance between the initial US set and a consistent Rationale
Tree for the process fragment to deliver value successfully. Current ndings
have been illustrated on the development of an android app for carpooling.
26
Appendix A. Requirements Analysis: Building a Consistent Ra-
tionale Tree from a User Story Set
This section positions the use that we make in our agent process fragment
of previous contributions at the level of the requirements analysis stage. First
of all, Section Appendix A.1 positions the US concept and how we tackle
US sets. The goal is to start from US sets and to develop a consistent re-
quirements model providing reasoning abilities that can lead to the design
(and implementation) of a MAS. To this end, we tag the US set using the
unied model of US templates (see Section Appendix A.2) and generate a
rst Rationale Tree (see Section Appendix A.3) that provides the relation-
ships between US elements. Further domain analysis is required to enhance
the Rationale Tree since the initial US set cannot furnish all the required in-
formation for building a consistent Rationale Tree: round-tripping between
the US-set view and the Rationale Tree view is then made (see Section 6.1).
Appendix A.1. Research Structure: Decomposing a User Story in Descrip-
tive Concepts
Figure A.9 depicts a meta-model that describes the conceptual founda-
tions of the requirements analysis stage of our process fragment. A full
description of the meta-model can be found in [21], we only point here out
the following elements.
When eliciting requirements, we do not take US as a whole but decompose
it on the basis of their WHO ,WHAT and { when available { WHY dimen-
sions. These elements are all referred to as Descriptive Concepts (DC) in our
research. When a US set is decomposed into DC, possible (decomposition)
relationships between various DCare identied through domain analysis
(see Appendix A.2). To represent the fact that various DCcan be linked,
theLink class is introduced in the meta-model. The possible instances of
theLink class are dened in Appendix A.3.
Appendix A.2. Unied-Model of User Stories' Descriptive Concepts
As evoked, [13] suggests to build a unied model for designing US tem-
plates. The interested reader can refer to the latter reference for the re-
search details and process, and we use this model as reference. Figure A.10
shows the meta-model of US templates. A US template can be designed
taking an element from the WHO, WHAT and possibly WHY dimensions.
27
Link
type : String
sibling : Descriptive_ConceptAcceptanceTest Feature Theme
EpicDescriptive_Concept
dimension : ENUM{WHO,WHAT,WHY}syntax : Stringsemantic : String
0..n1
0..n1User_Story
priority : Integer
amountOfPoints : Integerstatus : ENUM{0_US,IP_US,C_US}conversation : Text11..n
11..n
Fulfills
1..n1..nRequiresn
groups
1..n
0..11..n
0..1is refined in2..3 1..n 2..31..n
includes0..n0..nFigure A.9: A Meta-Model for User Story Structuring (from [21]).
The link between the classes conceptually represents the link from one di-
mension to the other. Concretely, the unidirectional association from the
Role to one of the Capability ,Task orGoal classes implies that the tar-
get class instantiates an element of the WHAT dimension (always tagged as
wants/wants to/needs/can/would like in the model). This means that \As
aRole, I want/want to/need/can/would a Capability /Task /Goal " are three
possible instances of US template valid with respect to the unied US model;
theRole is thus in the WHO dimension and the Capability ,Task orGoal is
in the WHAT dimension of the US. Then, the unidirectional association from
one of these classes instantiating the WHAT dimension to one of the classes
instantiating the WHY dimension (always tagged as so that into the model)
implies that the target class possibly (since 0 is the minimal cardinality) in-
stantiates an element of the WHY dimension. In other words, the templates
\As a Role, I want/want to/need/can/would a Capability " and \As a Role, I
want/want to/need/can/would a Capability so that Goal " are two valid tem-
plates of the US model. The second one includes a WHY dimension and the
rst one not. Another US template supported by our model is for instance:
As a<Role>, I would like <Task>so that <Hard-goal >.
Each concept is associated with a particular syntax (identical to the name
of the class in Figure A.10) and a semantic. The syntax and semantics of the
model are summarized here. As a result of the research conducted in [13],
the couples syntax/semantic are the following:
A Role is an abstract characterization of the behavior of a social actor
28
Soft_Goal
dimension : Enum{WHAT,WHY}
name : StringHard_Goal
dimension : Enum{WHAT,WHY}name : String
0..n 0..n 0..n 0..nso thatCapability
name : String
dimension : String = WHATRole
name : Stringdimension : String = WHO
0..n1..n
0..n1..n
wants/wants to/needs/can/would likeTask
name : String
dimension : Enum{WHAT,WHY}0..n 1..n 0..n1..nwants/wants to/needs/can/would like
0..n
0..n0..n
0..nso that0..n0..n
0..nso that0..nGoal
0..n
0..n0..n
0..nso that0..n1..n
0..n1..nwants/wants to/needs/can/would like
0..n 0..n 0..n 0..nso thatFigure A.10: Unied Model for User Story Descriptive Concepts (from [13]).
within some specialized context or domain of endeavor ;
A Task species a particular way of attaining a goal ;
A Capability represents the ability of an actor to dene, choose, and ex-
ecute a plan for the fulllment of a goal, given certain world conditions
and in the presence of a specic event ;
A Hard-goal is a condition or state of aairs in the world that the
stakeholders would like to achieve ;
A Soft-goal is a condition or state of aairs in the world that the actor
would like to achieve. But unlike a hard-goal, there are no clear-cut
criteria for whether the condition is achieved, and it is up to the de-
veloper to judge whether a particular state of aairs in fact achieves
suciently the stated Soft-goal .
More information about the elements, their granularity and relative po-
sition can be found in [13, 21, 53].
Appendix A.3. A Rationale Tree for User Story Sets Representation
[21] has developed a graphical representation in the form of a Rationale
Tree for US sets tagged with the unied model for US templates depicted
previously. These used icons as well as the possible links between the US
elements are summarized in Figure A.11.
Further comments and explanations can be given about the dierent rela-
tionships (links) that we can have between the dierent US elements. These
are links between elements of the WHAT and/or of the WHY dimension.
[21] distinguishes 3 types of links:
29
 
 
 
 
 
 
 
 
 
 
 
 
 
 
b) 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Â² 
 
 
 
 
 
  
 
 
 
  Role_1  
Task_1 Hard_Goal_1 
Capability_1 Task_2 
Soft_Goal_1  
Capability_2 Task_3 
Hard_Goal_2 
Capability_3 US2: As Role_1, I want Capability_1, 
so that Task_2 
US3: As Role_1, I want Soft_Goal_1, US1: As Role_1, I want Task_1, so 
that Hard_Goal_1 
US4: As Role_2, I want Capability_2, 
so that Task_3 
US5: As Role_2, I want Capability_3, 
so that Hard_Goal_2 
User Stories (US) Strategic Rational Diagram (SRD) 
(SRD)  Role_2 are part of 
Elements Links 
Task  Hard-goal Capability Role Boundary Role  
WHO WHAT WHY User Story 
Soft-goal  Decomposition link Means-end link 
Contribution link(+,-) Figure A.11: Icons Used Within the Representation of the US Elements Using the Strategic
Rationale Reasoning (from [21]).
Means-end links which indicate a relationship between an end, and a
means for attaining it. The \means" is expressed in the form of a task,
since the notion of task embodies how to do something, with the \end"
is expressed as a goal. In the graphical notation, the arrowhead points
from the means to the end [10];
Decomposition links are more specically associated to tasks, indeed
a task element is linked to its component nodes by decomposition links
[10]. Moreover, A task can be decomposed into four types of elements:
a Sub-goal, a Sub-task, a Resource, and/or a Soft-goal - corresponding
to the four types of elements. The task can be decomposed into one to
many of these elements... [10];
Contribution links for contributions to Soft-goals, indeed any of these
Contribution Links can be used to link any of the elements to a Soft-goal
to model the way any of these Elements contributes to the satisfaction
or fulllment of the Soft-goal [10].
The modeler has to create the links between the DCin function of the
requirements/domain analysis. The study and linking of elements lead to a
tree hierarchy. That way, an analysis (i) of the alternatives (means-end), (ii)
of the possibly missing elements and (iii) of the possible redundant elements
(in the decompositions) can be performed.
30
References
[1] T. Dingsyr, S. P. Nerur, V. Balijepally, N. B. Moe, A decade
of agile methodologies: Towards explaining agile software develop-
ment, Journal of Systems and Software 85 (6) (2012) 1213{1221.
doi:10.1016/j.jss.2012.02.033.
URL http://dx.doi.org/10.1016/j.jss.2012.02.033
[2] D. E. Turk, R. B. France, B. Rumpe, Assumptions underlying agile
software-development processes, J. Database Manag. 16 (4) (2005) 62{
87. doi:10.4018/jdm.2005100104.
URL https://doi.org/10.4018/jdm.2005100104
[3] D. Turk, R. B. France, B. Rumpe, Assumptions underlying agile soft-
ware development processes, CoRR abs/1409.6610.
URL http://arxiv.org/abs/1409.6610
[4] J. Highsmith, A. Cockburn, Agile software development: The
business of innovation, IEEE Computer 34 (9) (2001) 120{122.
doi:10.1109/2.947100.
URL http://dx.doi.org/10.1109/2.947100
[5] K. Beck, C. Andres, Extreme Programming Explained: Embrace
Change (2Nd Edition), Addison-Wesley Professional, 2004.
[6] K. Vlaanderen, S. Jansen, S. Brinkkemper, E. Jaspers, The agile require-
ments renery: Applying scrum principles to software product man-
agement, Information and Software Technology 53 (1) (2011) 58 { 70.
doi:10.1016/j.infsof.2010.08.004.
[7] M. Cohn, Succeeding with Agile: Software Development Using Scrum,
1st Edition, Addison-Wesley Professional, 2009.
[8] A. R. da Silva, Model-driven engineering: A survey supported by the
unied conceptual model, Computer Languages, Systems & Structures
43 (2015) 139{155. doi:10.1016/j.cl.2015.06.001.
URL https://doi.org/10.1016/j.cl.2015.06.001
[9] V. Seidita, M. Cossentino, A. Chella, A proposal of process fragment
denition and documentation, in: M. Cossentino, M. Kaisers, K. Tuyls,
31
G. Weiss (Eds.), Multi-Agent Systems - 9th European Workshop, EU-
MAS 2011, Maastricht, The Netherlands, November 14-15, 2011. Re-
vised Selected Papers, Vol. 7541 of Lecture Notes in Computer Science,
Springer, 2011, pp. 221{237.
[10] E. Yu, P. Giorgini, N. Maiden, J. Mylopoulos, Social Modeling for Re-
quirements Engineering, MIT Press, 2011.
[11] E. S. K. Yu, Social modeling and i*, in: Conceptual Modeling: Founda-
tions and Applications - Essays in Honor of John Mylopoulos, 2009, pp.
99{121.
[12] E. S. K. Yu, Towards modeling and reasoning support for early-phase
requirements engineering, in: 3rd IEEE International Symposium on
Requirements Engineering (RE'97), January 5-8, 1997, Annapolis, MD,
USA, IEEE Computer Society, 1997, pp. 226{235.
[13] Y. Wautelet, S. Heng, M. Kolp, I. Mirbel, Unifying and extending
user story models, in: M. Jarke, J. Mylopoulos, C. Quix, C. Rolland,
Y. Manolopoulos, H. Mouratidis, J. Horko (Eds.), CAiSE 2014, Thes-
saloniki, Greece, June 16-20, 2014. Proceedings, Vol. 8484 of LNCS,
Springer, 2014, pp. 211{225.
[14] F. Bellifemine, G. Caire, D. Greenwood, Developing multi-agent systems
with JADE, Vol. 5, Wiley, 2007.
[15] G. Lucassen, F. Dalpiaz, J. M. E. M. van der Werf, S. Brinkkemper, The
use and eectiveness of user stories in practice, in: M. Daneva, O. Pas-
tor (Eds.), Requirements Engineering: Foundation for Software Quality
- 22nd International Working Conference, REFSQ 2016, Gothenburg,
Sweden, March 14-17, 2016, Proceedings, Vol. 9619 of Lecture Notes in
Computer Science, Springer, 2016, pp. 205{222.
[16] A. Van Lamsweerde, Requirements engineering: From System Goals to
UML Models to Software Specications, Wiley, 2009.
[17] OMG, Business Process Model and Notation (BPMN). version 2.0.1,
Tech. rep., Object Management Group (2013).
[18] M. Glinz, A glossary of requirements engineering terminology, version
1.4 (2012).
32
[19] A. van Lamsweerde, Goal-oriented requirements enginering: A
roundtrip from research to practice, in: 12th IEEE International
Conference on Requirements Engineering (RE 2004), 6-10 Septem-
ber 2004, Kyoto, Japan, IEEE Computer Society, 2004, pp. 4{7.
doi:10.1109/RE.2004.25.
URL http://doi.ieeecomputersociety.org/10.1109/RE.2004.25
[20] O. Liskin, R. Pham, S. Kiesling, K. Schneider, Why we need a gran-
ularity concept for user stories, in: G. Cantone, M. Marchesi (Eds.),
Agile Processes in Software Engineering and Extreme Programming -
15th International Conference, XP 2014, Rome, Italy, May 26-30, 2014.
Proceedings, Vol. 179 of LNBIP, Springer, 2014, pp. 110{125.
[21] Y. Wautelet, S. Heng, M. Kolp, I. Mirbel, S. Poelmans, Building a
rationale diagram for evaluating user story sets, in: Tenth IEEE In-
ternational Conference on Research Challenges in Information Science,
RCIS 2016, Grenoble, France, June 1-3, 2016, IEEE, 2016, pp. 1{12.
doi:10.1109/RCIS.2016.7549299.
URL http://dx.doi.org/10.1109/RCIS.2016.7549299
[22] H. A. Simon, The Sciences of the Articial (3rd Ed.), MIT Press, Cam-
bridge, MA, USA, 1996.
[23] Anonymous, Software & systems process engineering meta-model spec-
ication. version 2.0, Tech. rep., Object Management Group (2008).
[24] S. Faulkner, M. Kolp, Y. Wautelet, Y. Achbany, A formal description
language for multi-agent architectures, in: M. Kolp, B. Henderson-
Sellers, H. Mouratidis, A. Garcia, A. Ghose, P. Bresciani (Eds.), Agent-
Oriented Information Systems IV, 8th International Bi-Conference
Workshop, AOIS 2006, Hakodate, Japan, May 9, 2006 and Luxembourg,
Luxembourg, June 6, 2006, Revised Selected Papers, Vol. 4898 of Lec-
ture Notes in Computer Science, Springer, 2006, pp. 143{163.
[25] M. Kolp, S. Faulkner, Y. Wautelet, Social structure based design pat-
terns for agent-oriented software engineering, IJIIT 4 (2) (2008) 1{23.
doi:10.4018/jiit.2008040101.
URL https://doi.org/10.4018/jiit.2008040101
33
[26] F. Paetsch, A. Eberlein, F. Maurer, Requirements engineering and agile
software development, in: 12th IEEE International Workshops on En-
abling Technologies (WETICE 2003), Infrastructure for Collaborative
Enterprises, 9-11 June 2003, Linz, Austria, IEEE Computer Society,
2003, pp. 308{313.
[27] H. F. Cervone, Understanding agile project management methods using
scrum, OCLC Systems & Services 27 (1) (2011) 18{22.
[28] L. Chung, J. C. S. do Prado Leite, On non-functional requirements in
software engineering, in: Conceptual Modeling: Foundations and Ap-
plications - Essays in Honor of John Mylopoulos, 2009, pp. 363{379.
[29] The descartes architect case-tool (2016).
URL http://www.isys.ucl.ac.be/descartes/
[30] M. P. K. Shergill, C. Schar, Developing multi-channel mobile solu-
tions for a global audience: The case of a smarter energy solution,
SARNOFF'12, New Jersey.
[31] C. Schar, S. Heng, V. Kulkarni, On the diculties for students
to adhere to scrum on global software development projects: pre-
liminary results, in: S. R. Faulk, D. M. Weiss, M. Young, L. Yu
(Eds.), Proceedings of the Second International Workshop on Collab-
orative Teaching of Globally Distributed Software Development, CT-
GDSD 2012, Zurich, Switzerland, June 9, 2012, IEEE, 2012, pp. 25{29.
doi:10.1109/CTGDSD.2012.6226946.
URL http://dx.doi.org/10.1109/CTGDSD.2012.6226946
[32] Y. Wautelet, M. Kolp, Business and model-driven development
of BDI multi-agent systems, Neurocomputing 182 (2016) 304{321.
doi:10.1016/j.neucom.2015.12.022.
URL http://dx.doi.org/10.1016/j.neucom.2015.12.022
[33] M. Challenger, M. Mernik, G. Kardas, T. Kosar, Declarative specica-
tions for the development of multi-agent systems, Computer Standards
& Interfaces 43 (2016) 91{115. doi:10.1016/j.csi.2015.08.012.
URL http://dx.doi.org/10.1016/j.csi.2015.08.012
[34] C. Hahn, C. Madrigal-Mora, K. Fischer, A platform-independent meta-
model for multiagent systems, Autonomous Agents and Multi-Agent
34
Systems 18 (2) (2009) 239{266. doi:10.1007/s10458-008-9042-0.
URL http://dx.doi.org/10.1007/s10458-008-9042-0
[35] M. Winiko, Jacktmintelligent agents: An industrial strength platform,
in: Bordini et al. [54], pp. 175{193.
[36] Y. Wautelet, S. Heng, M. Kolp, C. Schar, Towards an agent-driven
software architecture aligned with user stories, in: H. J. van den
Herik, J. Filipe (Eds.), Proceedings of the 8th International Confer-
ence on Agents and Articial Intelligence (ICAART 2016), Volume 2,
Rome, Italy, February 24-26, 2016., SciTePress, 2016, pp. 337{345.
doi:10.5220/0005706103370345.
URL http://dx.doi.org/10.5220/0005706103370345
[37] M. Challenger, S. Demirkol, S. Getir, M. Mernik, G. Kardas, T. Kosar,
On the use of a domain-specic modeling language in the develop-
ment of multiagent systems, Eng. Appl. of AI 28 (2014) 111{141.
doi:10.1016/j.engappai.2013.11.012.
URL http://dx.doi.org/10.1016/j.engappai.2013.11.012
[38] S. Getir, M. Challenger, G. Kardas, The formal semantics
of a domain-specic modeling language for semantic web en-
abled multi-agent systems, Int. J. Cooperative Inf. Syst. 23 (3).
doi:10.1142/S0218843014500051.
URL http://dx.doi.org/10.1142/S0218843014500051
[39] I. Garc a-Magari~ no, Towards the integration of the agent-oriented mod-
eling diversity with a powertype-based language, Computer Standards
& Interfaces 36 (6) (2014) 941{952. doi:10.1016/j.csi.2014.02.002.
URL http://dx.doi.org/10.1016/j.csi.2014.02.002
[40] E. J. T. Gon calves, M. I. Cort es, G. A. L. de Campos, Y. S. Lopes,
E. S. S. Freire, V. T. da Silva, K. S. F. de Oliveira, M. A. de Oliveira,
MAS-ML 2.0: Supporting the modelling of multi-agent systems with
dierent agent architectures, Journal of Systems and Software 108 (2015)
77{109. doi:10.1016/j.jss.2015.06.008.
URL http://dx.doi.org/10.1016/j.jss.2015.06.008
[41] A. Chella, M. Cossentino, L. Sabatucci, V. Seidita, Agile passi: An agile
process for designing agents, International Journal of Computer Systems
Science & Engineering 21 (2) (2006) 133{144.
35
[42] S. A. DeLoach, E. T. Matson, Y. Li, Applying agent oriented software
engineering to cooperative robotics., in: FLAIRS Conference, 2002, pp.
391{396.
[43] M. F. Wood, S. A. DeLoach, An overview of the multiagent systems
engineering methodology, in: Agent-Oriented Soft. Eng., Springer, 2001,
pp. 207{221.
[44] V. Gaur, A. Soni, A novel approach to explore inter agent dependencies
from user requirements, Procedia Technology 1 (2012) 412{419.
[45] T. Tenso, K. Taveter, Requirements engineering with agent-oriented
models., in: ENASE, 2013, pp. 254{259.
[46] A. Carrera, C. A. Iglesias, M. Garijo, Beast methodology: An agile
testing methodology for multi-agent systems based on behaviour driven
development, Info. Syst. Frontiers 16 (2) (2014) 169{182.
[47] J. M. Gascue~ na, A. Fern andez-Caballero, Prometheus and INGENIAS
agent methodologies: A complementary approach, in: M. Luck, J. J.
G omez-Sanz (Eds.), Agent-Oriented Software Engineering IX, 9th In-
ternational Workshop, AOSE 2008, Estoril, Portugal, May 12-13, 2008,
Revised Selected Papers, Vol. 5386 of Lecture Notes in Computer Sci-
ence, Springer, 2008, pp. 131{144.
[48] P. Bresciani, A. Perini, P. Giorgini, F. Giunchiglia, J. Mylopoulos,
Tropos: An agent-oriented software development methodology, Au-
tonomous Agents and Multi-Agent Systems 8 (3) (2004) 203{236.
[49] J. Castro, M. Kolp, J. Mylopoulos, Towards requirements-driven infor-
mation systems engineering: the tropos project, Inf. Syst. 27 (6) (2002)
365{389.
[50] G. Lucassen, F. Dalpiaz, J. M. E. M. van der Werf, S. Brinkkemper,
AQUSA: the automatic quality user story artisan for agile software de-
velopment, in: Joint Proceedings of REFSQ-2016 Workshops, Doctoral
Symposium, Research Method Track, and Poster Track co-located with
the 22nd International Conference on Requirements Engineering: Foun-
dation for Software Quality (REFSQ 2016), Gothenburg, Sweden, March
14, 2016., 2016.
36
[51] M. Velghe, Requirements engineering in agile methods: Contributions
on user story models, Master's thesis, KU Leuven, Belgium (2015).
URL http://www.isys.ucl.ac.be/descartes/ThesisMattijs.pdf
[52] J. Patton, P. Economy, User Story Mapping: Discover the Whole Story,
Build the Right Product, 1st Edition, O'Reilly Media, Inc., 2014.
[53] Y. Wautelet, S. Heng, D. Hintea, M. Kolp, S. Poelmans, Bridging user
story sets with the use case model, in: S. Link, J. Trujillo (Eds.),
Advances in Conceptual Modeling - ER 2016 Workshops, AHA, Mo-
BiD, MORE-BI, MReBA, QMMQ, SCME, and WM2SP, Gifu, Japan,
November 14-17, 2016, Proceedings, Vol. 9975 of Lecture Notes in Com-
puter Science, 2016, pp. 127{138.
[54] R. H. Bordini, M. Dastani, J. Dix, A. E. Fallah-Seghrouchni (Eds.),
Multi-Agent Programming: Languages, Platforms and Applications,
Vol. 15 of Multiagent Systems, Articial Societies, and Simulated Orga-
nizations, Springer, 2005.
37
View publication statsView publication stats
