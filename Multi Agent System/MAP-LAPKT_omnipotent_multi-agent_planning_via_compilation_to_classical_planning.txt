MAP-LAPKT: Omnipotent Multi-Agent Planning via
Compilation to Classical Planning
Christian Muise, Nir Lipovetzky, Miquel Ramirezy
Department of Computing and Information Systems, University of Melbourne
yCollege of Engineering and Computer Science, Australian National University
fchristian.muise,nir.lipovetzky g@unimelb.edu.au,ymiquel.ramirez@anu.edu.au
Introduction
In this paper we describe three related entries submitted to
the CoDMAP planning contest (Stolba, Komenda, and Ko-
vacs 2015). All three entries are conﬁgurations of the classi-
cal planning framework LAPKT (Ramirez, Lipovetzky, and
Muise 2015), and all three use the same pre-compiled input.
Our approach is based on the following insight:
The task of planning for multiple agents with heteroge-
neous access to ﬂuent observability can be solved by
classical planners using the appropriate encoding.
The general approach is quite simple: we convert the un-
factored domain and problem ﬁle into a classical planning
problem such that the privacy of ﬂuents and objects are re-
spected. The translation is both sound and complete, and
we solve the encoded problem using a centralized classical
planner. None of the factorization is passed to the classical
planner, because the encoded problem contains all the nec-
essary information as part of the problem itself.
In the remainder of the document, we outline (1) the sim-
ple encoding that we use to create a classical planning prob-
lem, (2) the planning framework that we use to solve the
encoded problems, and (3) the conﬁgurations that we sub-
mitted to the CoDMAP contest.
Encoding
The model of privacy used for the CoDMAP contest restricts
the number of objects and ﬂuents that an agent has access to.
Any action that uses a ﬂuent or object (in a precondition or
eect) that is not either (1) private to agent ior (2) public
to all agents, cannot be executed by agent i. That is, every
ﬂuent and object mentioned in an action in order for agent
ito execute must be known by that agent. Crucially, the
privacy of objects and ﬂuents are static, and thus we can
use classical planning techniques as long as any action that
violates the privacy restrictions is not allowed to occur .
We have two options for ﬁltering out any action that vio-
lates the multi-agent privacy: (1) modify the planner to use
only those actions that adhere to the privacy; and (2) modify
the domain description so that any valid grounding respects
the privacy. We chose the latter option for our approach.
Every object oand agent agin the domain has a corre-
sponding ﬂuent (K-obj ag o) added. If an action that is ex-
ecuted by agent aguses object o, then a precondition of theaction is for (K-obj ag o) to hold. Similarly, we add ﬂuents
(K-ﬂuent-foo ag) for every agent agand ﬂuent f ooin the
domain, and update the action preconditions accordingly.
The ﬁnal step is to translate the privacy model provided in
the multi-agent description of the domain (unfactored rep-
resentation), into the initial state that fully deﬁnes which
agents have access to which ﬂuents and objects. Everything
added to the model is encoded as action preconditions and
initial state ﬂuents, and any modern classical planner will
strip away these auxiliary ﬂuents because they are all static.
Any classical planner can use the resulting encoding, and
the solutions that the planner produces will correspond pre-
cisely to those plans for the original domain that do not vi-
olate the privacy model for the agents. While simple con-
ceptually, this transformation makes it possible to apply any
existing classical planner to the multi-agent setting used for
the centralized track of the CoDMAP competition.
LAPKT Planner Description:
Heuristic and Search Description
The algorithm Iterated Width , orIW, consists of a sequence
of calls IW(i) for i=0;1; : : : ;jFjuntil the problem is solved.
Each iteration IW(i) is a breadth-ﬁrst search that imme-
diately prunes any states that do not pass a novelty test;
namely, for a state sinIW(i)notto be pruned there must
be a tuple tof at most iatoms such that sis the ﬁrst state
generated in the search that makes ttrue. The time com-
plexities of IW(i) and IWareO(ni) and O(nw) respectively
where nisjFjandwis the problem width. The width of ex-
isting domains is low for atomic goals, and indeed, 89% of
the benchmarks can be solved by IW(2) when the goal is set
to any one of the atoms in the goal (Lipovetzky and Ge ner
2012). The width of the benchmark domains with conjunc-
tive goals, however, is not low in general, yet such problems
can be serialized.
Serialized Iterative Width , orSIW, uses IWfor serializing
a problem into subproblems and for solving the subprob-
lems. SIW uses IW greedily to achieve one atomic goal
at a time until all atomic goals are achieved jointly. In be-
tween, atomic goals may be undone, but after each invoca-
tion of IW, each of the previously achieved goals must hold.
SIW will never call IW more than jGjtimes wherejGjis the
number of atomic goals. SIW compares surprisingly well
to a baseline heuristic search planner using greedy best-ﬁrst
search and the haddheuristic (Bonet and Ge ner 2001), but
does not approach the level of performance of the most re-
cent planners. Nonetheless, SIW competes well in domains
with no dead-ends and simple serializations.
While the blind-search SIW procedure competes well
with a greedy best-ﬁrst planner using the additive heuris-
tic, neither planner is state-of-the-art. To narrow the perfor-
mance gap, we use two simple extensions. The ﬁrst involves
computing a relaxed plan once before moving on to the next
subgoal. This makes the pruning in the breadth-ﬁrst proce-
dure less aggressive, while keeping IW exponential in the
width parameter. This new procedure called IW+(i), com-
putes a relaxed plan once from the initial state sso that
states s0generated by IW+(i) keep a count on the number
of atoms min the relaxed plan from sachieved on the way
tos0. For the state s0in the breadth-ﬁrst search underly-
ingIW+(i)notto be pruned, there must be a tuple twith
at most iatoms, such that s0is the ﬁrst state among the
states in the search that achieved m ﬂuents from the initial
relaxed plan that makes the tuple ttrue. The serialized al-
gorithm SIW that uses IW+is called SIW+. The second ex-
tension involves changing the greedy search for achieving
the goals one at a time, by a depth-ﬁrst search that is able
to backtrack. The planner that incorporates both extensions
is called DFS+(Lipovetzky and Ge ner 2014). Notice that
while DFS+computes a relaxed plan once for each IW+call,
DFS+does not use the relaxed plan for computing heuris-
tic estimates. Thus, DFS+remains a blind search planner,
which does not use any standard techniques such as heuris-
tics, multiple-search queues, helpful actions or landmarks.
In contrast with DFS+, we developed an additional stan-
dard forward-search best-ﬁrst planner guided by an eval-
uation function that combines the notions of novelty and
helpful actions (Lipovetzky and Ge ner 2012; Ho mann
and Nebel 2001). In this planner, called BFS(f) (Lipovetzky
and Ge ner 2012), ties are broken lexicographically by two
other measures: (1) the number of subgoals not yet achieved
up to a node in the search, and (2) the additive heuristic, hadd.
The additive heuristic is delayed for non-helpful actions.
Implementation
All the planners have been implemented using the automated
planning toolkit LAPKT1(Ramirez, Lipovetzky, and Muise
2015). The toolkit is an extensible C++framework that de-
couples search and heuristic algorithms from P ddlparsing
and grounding modules, by relying on planner ”agnostic”
data structures to represent (ground) ﬂuents and actions. We
consider LAPKT to be a valuable contribution in itself since
it enables the community to develop planners, while rely-
ing on a collection of readily available implementations of
search algorithms and planning heuristics. These resulting
planners are independent from speciﬁc parsing modules and
grounding algorithms. For planners that acquire descriptions
of planning tasks from P ddlspeciﬁcations, the toolkit pro-
vides the means to plug in either FF (Ho mann and Nebel
2001) or F ast-Downward (Helmert 2006) parsers. Alterna-
1Source code available from http://www.lapkt.orgtively, and more interestingly, the planner can be embedded
into complex applications, directly , if the “host” application
is written in C++, orindirectly when the host is written in
an interpreted language, such as P ython , by wrapping the
planner with suitably generated marshalling code.
Entry Variations
Three variations of the LAPKT planning framework were
submitted to test their distinctive behaviour on the encoded
domains. Here, we brieﬂy describe each in turn:
1. Anytime-LAPKT: The ﬁrst conﬁguration is sought by
SIW+. Failing this, BFS( f) is called. After a ﬁrst solu-
tion is computed, RWA* is invoked with the appropriate
bound, and solution quality is improved iteratively. The
motivation behind this conﬁguration is to try and ﬁnd high
quality plans within the time limit. This variation is both
sound and complete. In the limit, it is also optimal.
2. SIW+-then-BFS( f): The second conﬁguration attempts
ﬁrst to solve the problem using SIW+. Failing this,
BFS( f) is invoked and will run until a solution is found.
The motivation behind this conﬁguration is to try and ﬁnd
a solution as fast as possible, while retaining complete-
ness. This variation is both sound and complete.
3. DFS+: The third and ﬁnal conﬁguration tries to ﬁnd a so-
lution extremely quickly using only DFS+. The motiva-
tion behind the third conﬁguration is to see how many
problems can be solved using this simple approach. This
ﬁnal variation is sound, but incomplete.
Summary
We have described three variations of a planner submitted
to the CoDMAP contest. All three take as input a converted
version of the multi-agent problem such that the privacy of
objects and ﬂuents are respected by any plan. Each varia-
tion has a di erent motivation that explores aspects such as
striving for plan quality versus speed to completion.
The speciﬁc characteristics that our planners have, as de-
ﬁned by the CoDMAP organizers, are as follows:
1. Planner complete? Conﬁgurations 1 and 2 are complete.
2. Planner optimal? Conﬁguration 1 is optimal in the limit.
3. Is the agent factorization in the MA-PDDL ﬁles used?
Yes, the translation uses the agent factorization to deter-
mine which agents can execute the appropriate actions.
4. Is the private /public separation presented in the MA-
PDDL ﬁles used? Yes, the translation uses this informa-
tion to determine the initial conﬁguration of K-obj and
K-ﬂuent ﬂuents.
5. Is the planner using MA-STRIPS private /public separa-
tion? Yes, as part of the translation.
6. What private information (or its derivative), in what form,
and how is it communicated in the planner? Nothing,
other than the newly encoded problem (i.e., the planner
is unaware it is solving a multi-agent planning problem).
7. What is the architecture of the planner (centralized or dis-
tributed; single or multi-threaded)? Centralized and sin-
gle thread for all three conﬁgurations.
Acknowledgements This research is partially funded
by Australian Research Council Discovery Grant
DP130102825, Foundations of Human-Agent Collabo-
ration: Situation-Relevant Information Sharing and the
Australian Research Council Linkage Grant LP11010015,
Making the Pilbara Blend: Agile Mine Scheduling through
Contingent Planning .
References
Bonet, B., and Ge ner, H. 2001. Planning as heuristic
search. Artiﬁcial Intelligence 129:5–33.
Helmert, M. 2006. The Fast Downward planning system.
Journal of Artiﬁcial Intelligence Research 26:191–246.
Homann, J., and Nebel, B. 2001. The FF planning system:
Fast plan generation through heuristic search. Journal of
Artiﬁcial Intelligence Research 14:253–302.
Lipovetzky, N., and Ge ner, H. 2012. Width and serializa-
tion of classical planning problems. In Proc. ECAI , 540–
545.
Lipovetzky, N., and Ge ner, H. 2014. Width-based algo-
rithms for classical planning: New results. In Proc. ECAI ,
1059–1060.
Ramirez, M.; Lipovetzky, N.; and Muise, C. 2015.
Lightweight Automated Planning ToolKiT. http://
lapkt.org/ . Accessed: 2015-05-19.
Stolba, M.; Komenda, A.; and Kovacs, D. L. 2015. Compe-
tition of Distributed and Multiagent Planners (CoDMAP).
http://agents.fel.cvut.cz/codmap/ . Accessed:
2015-05-24.
