Implementing reactive BDI agents with user-given
constraints and objectives
Aniruddha Dasgupta
Decision Systems Lab
School of Computer Science and Software
Engineering
University of Wollongong
Wollongong, NSW 2522, Australia
ad844@uow.edu.auAditya K.Ghose
Decision Systems Lab
School of Computer Science and Software
Engineering
University of Wollongong
Wollongong, NSW 2522, Australia
aditya@uow.edu.au
ABSTRACT
CASO is an agent-oriented programming language based
on AgentSpeak(L), one of the most inuential abstract lan-
guages based on the BDI (Beliefs-Desires-Intentions) archi-
tecture. For many applications, it is more convenient to let
the user provide in real time, a more elaborate specication
consisting of constraints and preferences over possible goal
states. Then, let the system discover a plan for the most de-
sirable among the feasible goal states. CASO incorporates
constraints and objectives into the symbolic approach of re-
active BDI model which lead to better expressive capabili-
ties as well as more ecient computation. Jason is a fully-
edged interpreter for a much improved version of AgentS-
peak(L). In this work we modify Jason to incorporate the
operational semantics of CASO. CASO also uses ECLiPSe,
an open source constraint solver, to apply constraint solving
techniques. Our preliminary results show that CASO can
be used as a powerful multi agent programming language in
solving problems in complex application domains.
1. INTRODUCTION
Agent-oriented programming is highly suited for appli-
cations which are embedded in complex dynamic environ-
ments, and is based on human concepts, such as beliefs,
goals and plans. This allows a natural specication of so-
phisticated software systems in terms that are similar to
human understanding, thus permitting programmers to con-
centrate on the critical properties of the application rather
than getting absorbed in the intricate detail of a complicated
environment. One of the most popular and successful frame-
work for Agent technology is that of Rao and George [11],
in which the notions of Belief ,Desire and Intention orBDI
are central. Beliefs represent the agent's current knowledge
about the world, including information about the current
state of the environment inferred from perception devices
and messages from other agents, as well as internal infor-
mation. Desires represent a state which the agent is trying
to achieve. Intentions are the chosen means to achieve the
agent's desires, and are generally implemented as plans and
Jung, Michel, Ricci & Petta (eds.): AT2AI-6 Working Notes, From
Agent Theory to Agent Implementation, 6th Int. Workshop,
May 13, 2008, AAMAS 2008, Estoril, Portugal, EU.
Not for citationpost-conditions. As in general an agent may have multiple
desires, an agent can have a number of intentions active at
any one time. These intentions may be thought of as run-
ning concurrently, with one chosen intention active at any
one time. Besides these components, the BDI model in-
cludes a plan library, namely a set of "recipes" representing
the procedural knowledge of the agent, and an event queue
where both events (either perceived from the environment or
generated by the agent itself to notify an update of its belief
base) and internal subgoals (generated by the agent itself
while trying to achieve a desire) are stored. Usually, BDI-
style agents do no adopt rst principles planning at all, as
all plans must be generated by the agent programmer at de-
sign time. The planning done by agents consists entirely of
context-sensitive subgoal expansion, which is deferred until
a point in time at which the subgoal is selected for execution.
The BDI model provides that all the knowledge of a rational
agent about the world is organized in statements that are its
beliefs. An agent's desires depict some states of the world
that the agent "would like" to be realized. In the multi-agent
systems (MAS) community each agent is given the mandate
to achieve dened goals. To do this, it autonomously selects
appropriate actions, depending on the prevailing conditions
in the environment, based on its own capabilities and means
until it succeeds, fails, needs decisions or new instructions
or is stopped by its owner.
In this paper present an implementation our design of CASO
agent [7], discussing in more detail: (a) the requirements
specication with respect to CASO; (b) an implementation
of the CASO design; (c) some example exploring the CASO
design and and nally (d) the strengths and weaknesses of
our design. From an implementation point of view the ex-
istence of special libraries or dedicated programming lan-
guages that provide data and control structures for manip-
ulating agent specic properties allows for an easy imple-
mentation of agent models. The remainder of this article is
organized as follows. Section 2 gives a brief introduction of
popular BDI language AgentSpeak(L) [10] as well as talks
briey about Jason [5], an interpreter of AgentSpeak(L);
section 3 discusses ECLiPSe [2], a constraint programming
toolkit respectively; section 4 describes the language CASO
and gives an overview of its operational semantics; section
5 describes the implementation details; section 6 gives an
example of using CASO and section 7 provides some ex-
perimental results. Finally, the last section describes some
related work and gives concluding remarks.
2. AGENTSPEAK(L)
AgentSpeak(L) is an agent framework/language with ex-
plicit representations of beliefs and intentions for agents.
This agent programming language was initially introduced
by Rao [10]. AgentSpeak(L) is a programming language
based on a restricted rst-order language with events and
actions. The behaviour of the agent (i.e., its interaction
with the environment) is dictated by the programs written
in AgentSpeak(L). The beliefs, desires, and intentions of the
agent are not explicitly represented as modal formulas. In-
stead, designers can ascribe these notions to agents written
in AgentSpeak(L). The current state of the agent, which is
a model of itself, its environment, and other agents, can be
viewed as its current belief state; states which the agent
wants to bring about based on its external or internal stim-
uli can be viewed as desires; and the adoption of programs
to satisfy such stimuli can be viewed as intentions.
AgentSpeak(L) agent is described as a set of
hE;B;P;I;A;SE;SO;SIiwhere:
Eis a set of events.
Bis a set of base beliefs.
Pis a set of plans.
Iis a set of intentions.
Ais a set of atomic actions.
SEselects an event from the set E.
SOselects a plan from the set P.
SIselects an intention from the set I.
The alphabet of the formal language consists of variables,
constants, function symbols, predicate symbols, action sym-
bols, connectives, quantiers, and punctuation symbols. Apart
from rstorder connectives, AgentSpeak(L) uses ! (for achieve-
ment), ? (for test), ; (for sequencing), and  (for impli-
cation). There are two types of goals in AgentSpeak(L).
An \achievement goal" (a predicate prexed with \!"), states
that the agent wishes to achieve a state of the world in which
the associated predicate is true. A \test goal" (a predicate
prexed with \?"), states that the agent wishes to test if
the associated predicate is a true. Events in AgentSpeak(L)
might be external or internal. External events represent the
changes in the state of the world that should be handled by
the agent. On the other hand, internal events are triggered
from within the agent as a result of executing a plan. An
agent must have pre-designed plans in its plan library to
handle the incoming internal or external events. Plans are
the central concept to the abilities of an agent. They are
means that enable an agent to respond to the changes in its'
environment.
One of the most popular fully-edged interpreter of AgentS-
peak(L) is Jason . Jason has many extensions making up
for a very expressive programming language for cognitive
agents. It implements the operational semantics of that
language, and provides a platform for the development of
multi-agent systems, with many user-customisable features.
Jason is implemented in Java (thus multi-platform) and is
available Open Source, distributed under GNU LGPL.3. ECLIPSE: A CONSTRAINT SOLVER
Constraint satisfaction is a powerful computational paradigm
which proposes techniques to nd assignments for problem
variables subject to constraints on which only certain com-
binations of values are acceptable. The success and the
increasing application of this paradigm in various domains
mainly derive by the fact that many combinatorial problems
can be expressed in a natural way as a Constraint Satisfac-
tion Problem (CSP), and can subsequently be solved by ap-
plying powerful CSP techniques.
ECLiPSe is a software system for the cost-eective devel-
opment and deployment of constraint programming appli-
cations, e.g. in the areas of planning, scheduling, resource
allocation, timetabling, transport etc. It is also ideal for
teaching most aspects of combinatorial problem solving, e.g.
problem modelling, constraint programming, mathematical
programming, and search techniques. It contains several
constraint solver libraries, a high-level modelling and con-
trol language, interfaces to third-party solvers, an integrated
development environment and interfaces for embedding into
host environments.
4. CASO: A REACTIVE BDI LANGUAGE
The concept of using constraints and explicit objectives in
a high-level agent specication language like Agentspeak(L),
yields signicant advantages in terms of both expressivity
and eciency as shown in our previous work in [8]. The
improvised technique applies constraint and objective di-
rected solving on the context section of a BDI agent's plan
specication in order to determine an application plan to
re. CASO ( Constraint AgentSpeak(L) with Objective)
is a programming language based on the popular BDI lan-
guage AgentSpeak(L)which incorporates constraints and ob-
jectives into the symbolic approach of BDI model. CASO
incorporates Constraint Solving and Optimization (CSOP)
techniques where the optimization is based on the objective
function (softgoal).
In CASO, one can express agents' goals quantitatively - for
example, agents can have some utility (objective) function
which needs to be maximized. Incorporating constraints
into a reactive BDI agent programming language can lead to
better expressive capabilities as well as more ecient com-
putation (in some instances). More interestingly, the use of
constraint-based representations can make it possible to deal
with explicit agent objectives (as distinct from agent goals)
that express the things that an agent may seek to optimize
at any given point in time. CASO also incorporates ecient
option selection (selecting the best plan to use to deal with
the current event) with parametric look-ahead techniques,
i.e., techniques where the extent of look-ahead style delib-
eration can be adjusted. The typical CASO execution cycle
is characterized by the following steps:
1. observe the world and the agent's internal state, and
update the event queue consequently;
2. generate possible new plan instances whose trigger event
matches an event in the event queue (relevant plan
instances) and whose precondition (beliefs and con-
straints in plan body) is satised (applicable plan in-
stances); plan selection is based on the satisability of
the current set of constraints as well as the one which
maximizes the current objective(using look-ahead tech-
niques);
3. select for execution one instance from the set of appli-
cable plan instances;
4. push the selected instance onto an existing or new in-
tention stack, according to whether or not the event is
a (sub)goal;
5. select an intention stack, take the topmost plan in-
stance and execute the next step of this current in-
stance: if the step is an action, perform it, otherwise,
if it is a subgoal, insert it on the event queue.
Informally, an agent program in CASO consists of a set of
beliefs B, a set of constraints C, an objective function O,
a set of events E, a set of intention I, a plan library P, a
constraint store CS, an objective store OS and three selec-
tion functions SE;SP;SIto select an event , a plan and an
intention respectively to process and npandniare the two
parameters which denote the number of steps to look-ahead
for plan and intentions selection respectively.
Denition :A CASO agent program is a tuple
fB;P;E;I;C;O;S O;SE;SI;np;ni;CS;OSgwhere
B is a set of Beliefs.
P is agent plan repository, a library of agent plans.
E is set of events (including external and internal).
I is a set of intentions.
C is a set of constraints.
O is an objective function.
SEis a selection function which selects an event to
process from set E of events.
SOis a selection function which selects an applicable
plan to a trigger tfrom set P of plans.
SIis a selection function which selects an intention to
execute from set I of intentions
CS is a constraint store which stores constraints which
come as events.
OS is an objective store which stores the objective func-
tion which comes as an event.
npis an integer which denotes the number of steps
required to look-ahead for plan selection.
niis an integer which denotes the number of steps re-
quired to look-ahead for intention selection.
In CASO, a constraint directed improvisation is incorpo-
rated into the computation strategy employed during the in-
terpretation process. Constraint logic programming (CLP)
combines the exibility of logic with the power of search
to provide high-level constructs for solving computationally
hard problems such as resource allocation.
Formally, a language CLP(X) is dened by
constraint domain X,
solver for the constraint domain X and
simplier for the constraint domain XA CASO plan p is of the form t:b1^b2^^bn^c1^
c2^^cm sg1;sg 2;;sgkwhere tis the trigger; each
birefers to a belief; each ciis an atomic constraint; each sg
is either an atomic action or a subgoal.
For brevity we will use BContext(p ) to denote the belief
context of plan p. Thus
BContext (p)b1^b2^^bn
Similarly, we will use CContext(p) to denote the constraint
context of plan p. Thus
CContext (p)c1^c2^^cm
Transition of agent program to process events depends on
the event triggers. An event trigger, t, can be addition(+)
or removal(-) of an achievement goal( !gi) or a belief(bi).
4.1 Informal Semantics
The CASO interpreter manages set of events, a constraint
store, a objective store and a set of intentions with three se-
lection functions. Intentions are particular courses of actions
to which an agent has committed in order to handle certain
events. Each intention is a stack of partially instantiated
plans. Events, which may start o the execution of plans
that have relevant triggering events, can be external when
originating from perception of the agents S environment (i.e.,
addition and deletion of beliefs based on perception are ex-
ternal events) ; or internal, when generated form the agent Ss
own execution of a plan (i.e., as subgoal in a plan generates
an event of the type addition of an achievement goal).
In the latter case, the event is accompanied with the inten-
tion which generated it (as the plan chosen for that event
will be pushed on top of that intention). External events
create new intentions, representing separated focuses of at-
tention for the agent Ss acting on the environment.
The constraint store is initialized by the relevant constraints
whenever a trigger contains a constraint in its context. At
every cycle of the interpreter, the constraint store is en-
hanced with new constraints when applicable selected plan
is executed. These incremental constraints collecting pro-
cess eventually leads to a nal consistent constraints set.
Constraint solving is applied to the context of each plan
to determine applicable plans as well as to generate solu-
tions for subsequent actions. Similarly, the objective store
contains the set of objective functions that need to be max-
imized (or minimized) which are part of the event context
and is similarly updated at each cycle. Plan Selection is de-
scribed in detail in the next subsection.
At every interpretation cycle of an agent program, CASO
updates a list of events, which may be generated from per-
ception of the environment, or from the execution of inten-
tions (when subgoals are specied in the body of plans).
It is assumed that beliefs are updated from perception and
whenever there are changes in the agents beliefs, this im-
plies the insertion of an event in the set of events. On top
of the selected intention there is a plan, and the formula in
the beginning of its body is taken for execution. This im-
plies that either a basic action is performed by the agent
on its environment, an internal event is generated (in case
the selected formula is an achievement goal denoted by ! gi),
or a test goal is performed (which means that the set of
beliefs has to be checked). If the intention is to perform a
basic action or a test goal denoted by ? gi, the set of inten-
tions needs to be updated. In the case of a test goal, the
belief base will be searched for a belief atom that unies
with the predicate in the test goal. If that search succeeds,
further variable instantiation will occur in the partially in-
stantiated plan which contained that test goal (and the test
goal itself is removed from the intention from which it was
taken). In the case where a basic action is selected, the
necessary updating of the set of intentions is simply to re-
move that action from the intention (the interpreter informs
to the architecture component responsible for the agent ef-
fectors what action is required). When all formulae in the
body of a plan have been removed (i.e., have been executed),
the whole plan is removed from the intention, and so is the
achievement goal that generated it (if that was the case).
This ends a cycle of execution, and CASO starts all over
again, checking the state of the environment after agents
have acted upon it, generating the relevant events, and so
forth.
4.2 Plan selection with parametric look-ahead
AfterSEhas selected an event, CASO has to unify that
event with triggering events in the heads of plans. This gen-
erates a set of all relevant plans . The constraints (if any)
that are included in the constraint part of the context are
put in the constraint store . The context part of the plans
is unied against the agents beliefs. Constraint solving is
now performed on these relevant plans to determine whether
the constraint(s) in the context of the plan is (are) consis-
tent with the constraints already collected in the constraint
store . This results in a set of applicable plans (plans that
can actually be used at that moment for handling the chosen
event).
The objective store maintains a set of objective function
which may be present in the event context. At each in-
terpreter cycle, the objective store is also updated with an
objective function for maximizing (or minimizing).
Given plans p1andp2in the plan library, and given a
current constraint store C and a current objective store O,
p1optp2if and only if: OptSol (C[CContext (p1);OS)
OptSol (C[CContext (p2);O) .
OptSol (Constraints;Objective ) denotes the value of the
objective function when applied to the optimal solution to
the problem denoted by the pair (Constraints, Objective).
We assume of course that C[CContext (p1) and
C[CContext (p2) are solvable.
Optimization techniques are now applied by the optimizer
to each of the applicable plan to determine an optimal solu-
tion. In eect we are solving a 'Constraint Satisfaction Op-
timisation Problem' (CSOP) which consists of a standard
'Constraint Satisfaction Problem' (CSP) and an optimisa-
tion function that maps every solution (complete labelling
of variables) to a numerical value. SOnow chooses this op-
timal solution from that set, which becomes the intended
means for handling that event, and either pushes that plan
on the top of an existing intention (if the event was an inter-
nal one), or creates a new intention in the set of intentions
(if the event was external, i.e., generated from perception of
the environment). One of the properties of CASO is that
since CSOP is solved at various steps using a solver, all the
beliefs and constraints must be global variables. Plan selec-
tion is dened as follows:Given a trigger t and a set of applicable plans AppPlans (t)
for t, a plan p2AppPlans (t)is referred to as an O-preferred
plan if and only if: poptpifor allpi2AppPlans (t).
The agent program is also responsible for making sure that
the objective store is consistent at any point of time. Dur-
ing each cycle of the interpreter, new objectives are added
into the objective store and hence a consistency checker is
used to maintain consistency. Formally a consistent objec-
tive store is dened as below.
Given an objective store OSand a new objective f, the
result of augmenting OSwithf, denoted by OS
f, is dened
as(MaxCons (OS[f))whereis a choice function and
MaxCons (X)is the set of all xXsuch that
1.xis consistent and
2. there exists no x0such thatxx0Xandx0is
consistent
The new objective store is now given by (MaxCons (OS[
O)\OS) whereis the choice function, OSis the objective
store andOis the negation of the objective O.
Selection of O-preferred plan can be further enhanced by
usingnpthe look-ahead parameter form plan selection. In
casenp=0, no look-ahead is performed and maximizing the
objective function on the set of applicable plans would re-
sult in an O-preferred plan as described earlier. However, if
np>0 then a look-ahead algorithm (used for choosing the
next move in a two-player game) is performed to select the
O-preferred plan.
We assume that the agent is trying maximize its objective
function and the environment may change in the worst pos-
sible way which would minimize the objective function. The
goal of the agent would be to select a plan which would max-
imize the minimum value of the objective function resulting
from the selection of plans which may occur due to the set of
new possible events that may come from the environment.
We follow the denition of goal-plan tree given in [13] to de-
compose the set of plans into a tree structure. In CASO,
goals are achieved by executing plans and each goal has at
least one plan, if not many, that can be used to satisfy the
goal. Each plan can include sub-goals, but need not have
any. The leaf nodes of the tree are plan-nodes with no chil-
dren (i.e., no sub-goals).
Each goal-plan tree consists of - a number of 'AND' nodes
which are subgoals that must be executed sequentially for
the goal to succeed; and a number of 'OR' nodes which are
subgoals any one of which must be executed for the goal to
succeed. Given a set of applicable plans, an agent would
always try to achieve this objective at every decision step.
However, there could be unforeseen situations which may
result in the agent changing its normal course of action at
any of these decision points. Thus the strategy for the agent
is to compute in advance the worst case scenario that may
occur due to the change in the highly dynamic environment.
Figure 1 shows the tree decomposition for plan P depicting
all possible choices (OR nodes). The numbers corresponding
to the leaf nodes are the values of the optimization function
(say, f) which we are trying to maximize. Using the LookA-
headPlanSelection look-ahead algorithm shown in Algorithm
1, we obtain the value of 3 at the root node which suggest
that the agent should follow plan P2.
Figure 1: Plan Tree
5. IMPLEMENTING CASO
Figure 2: Operational Semantics of CASO
In this section we give some more details on the imple-
mentation of a CASO interpreter, which is clearly depicted
in Figure 2 (modied from [5]). The pictorial description of
such interpreter, greatly facilitates the understanding of the
interpreter. In the gure, sets (of beliefs, events, plans, and
intentions) are represented as rectangles. Diamonds repre-
sent selection (of one element from a set). Circles repre-
sent some of the processing involved in the interpretation
of CASO programs. The 3-d box represents the ECLiPSe
CLP solver that is plugged into the system which is respon-
sible for the option selection function based on the set of
objectives and beliefs and/or constraints.
5.1 ECLiPSe plug-in for option selection func-
tion
As mentioned in earlier sections, we use ECLiPSe for op-
tion selection function SO. A CASO agent has a set of
constraints/beliefs in its belief base and a set of objective
functions at any point in time during the execution cycle.
When an agent tries to select a plan from a possible set of
applicable plans , it invokes the ECLiPSe constraint solver to
determine the O-preferred plan . The ability for an user to
add and remove objectives is a unique feature of a CASO
agent which is not embedded inside the selection functions.
Beliefs in CASO are written as ECLiPSe CLP programsAlgorithm 1 LookAheadPlanSelection(int n, state S, Ob-
jectiveStore OS, ConstraintStore CS)
1: Generate goal-plan tree up tonlevels from current state
Scomprising of subgoals of AND and OR nodes with
subplans.
2: Start from the root node.
3: Let constraint store at node p=cp.
4: Letopdenote the value of objective function at node p.
5: For each node pin the goal plan tree set cp CS
6:ifnode p has child nodes p1;p2;pkin an AND struc-
turethen
7: Apply constraint solving at each piwith the current
constraint store cpiand the set of constraints for pito
obtainopi.
8: Setcpi+1 cpifor alli1.
9: Initialize constraint store for all child nodes of each pi
withcpi.
10:end if
11:ifnode p has child nodes p1;p2;pkin an OR struc-
turethen
12: Compute the objective function and update the con-
straint store for each pi.
13: Initialize constraint store for all child nodes of each pi
withcpi.
14:end if
15:whilen6= 1do
16: Propagate minimum value of objective function up to
each parent node starting from the leaf node.
17:n=n 1.
18:end while
19: Propagate the maximum value of its children for state
S.
20: At state S, the best plan is the child with the maximum
value.
as shown in gure 3 below where Vars represent the set
of variables. Constraints are dened on the variables as
shown below. In the example below, let us assume that
the belief resource available() is a part of the agent belief
base. As per CASO, this belief is stored as in a le re-
source available.ecl . In this example, when the predicate
resource available() is executed as a query, the solver would
solve the optimization as per the objective shown in the
gure and generate a solution. The solver rst calls the
eplex (External CPLEX Solver Interface) library which al-
lows an external Mathematical Programming (MP) solver
to be used by ECLiPSe. eplex is one of the most widely
distributed, scaleable and ecient packages incorporating a
linear constraint solver. A problem in ECLiPSe is modeled
by a set of simultaneous equations: an objective function
that is to be minimized or maximized, subject to a set of
constraints on the problem variables, expressed as equali-
ties and inequalities. The eplex library allows for the user
to write programs that combines MP's global algorithmic
solving techniques with the local propagation techniques of
Constraint Logic Programming. The result of the objec-
tive function along with the instantiated variables (Vars)
is stored in an output le resource available.txt . A CASO
agent may not have any objective function initially in which
case there would be no function to minimize and the solver
may choose to instantiate the variables with a possible set
of variable instantiation based on the set of constraints. In
case the objective comes externally from the environment,
the le resource available.ecl is modied and specic objec-
tive function is written into the le. When the objective
changes, i.e. a new objective comes to the objective store,
this le is re-written with the new objective function. The
text le ( resource available.txt ), containing the output from
the ECLiPSe solver is read by SOand if there are several
applicable plans to pursue, SOwould choose the plan which
produces the highest value of the objective function and is
then pushed as an intention. In case there are actions asso-
ciated with plan whose parameters are part of the ECLiPSe
CLP, the variable values are also pushed along with the in-
tention.
Belief :
resource available() :-
Vars = [A1,A2,A3,B1,B2,B3,C1,C2,C3,D1,D2,D3],
Vars :: 0..inf,
integers(Vars),
(A1 + A2 + A3 = 21),
(B1 + B2 + B3 = 40),
(C1 + C2 + C3 = 34),
(D1 + D2 + D3 = 10),
(A1 + B1 + C1 + D1 = <50),
(A2 + B2 + C2 + D2 = <30),
(A3 + B3 + C3 + D3 = <40).
Optimization function:
optimize(max(1*A1 + 7*A2 + 200*A3 + 8*B1
+ 5*B2 + 2*B3 + 5*C1 + 5*C2
+ 1*C3 + 6*D1 + 4*D2 + 1*D3))
Figure 3: CASO Belief and Objective function writ-
ten in ECLiPSe CLP style
5.2 Modifying Jason
We are not going into the details of our modications but
we only describe the important changes to Jason in this sec-
tion. Since we have kept the essence of Jason interpreter,
the only notable change we did has been with regards to
the new operational semantics that has been described ear-
lier. In particular, our main modications to Jason are the
following:
CLP-style beliefs (with constraints and objectives) are
now written in a separate le that can be modied
by an external event when a new objective is added
or deleted. The ECLiPSe solver reads this le and
generates output.
TransitionSystem.java which is part of the asSeman-
ticspackage on Jason, is modied to call the external
ECLiPSe solver and does the new le handling oper-
ation. It also implements the look-ahead function for
option selection which can be added as a parameter.
Any application that can be deployed in Jason can also be
deployed in CASO with the added benet of application of
an objective function that can be user dened which can
change with every interpretation of CASO execution cycle
by an external event.6. EXAMPLE: USING CASO IN REAL-TIME
DECISION MAKING FOR BIOMASS SUP-
PLY CHAIN
Our implementation of CASO as described earlier, can be
shown by the following example where we try to describe
the benet of using CLP in agent paradigm. The example
is chosen from a supply chain system where we describe the
optimizations carried out by a single agent.
The supply chain considerations and costs of using biomass
fuel on a large scale for electricity generation at power sta-
tions is quite complex and is made up of a range of dierent
activities which is described in detail in [1]. The activi-
ties can include ground preparation and planting, cultiva-
tion, harvesting, handling, storage, in-eld/forest transport,
road transport and utilisation of the fuel at the power sta-
tion. Moreover, the options for supplying the end user with
biomass fuel of the right specication, in the right quantity
at the right time from resources which are typically diverse
and often seasonally dependent. Also, given the typical lo-
cations for biomass fuel sources (i.e. on farms and in forests)
the transport infrastructure is usually such that road trans-
port will be the only potential mode for collection of the fuel.
In order to supply biomass from its point of production to
a power station the following activities are necessary:
Harvesting of the biomass in the eld/forest.
In-eld/forest handling and transport to move the biomass
to a point where road transport vehicles can be used
Storage of the biomass. Many types of biomass will
be harvested at a specic time of year but will be re-
quired at the power station on a year round basis, it
will therefore be necessary to store them. The storage
point can be located on the farm/forest, at the power
station or at an intermediate site.
Loading and unloading road transport vehicles. Once
the biomass has been moved to the roadside it will
need to be transferred to road transport vehicles for
conveyance to the power station. At the power station
the biomass will need to be unloaded from the vehicles.
Transport by road transport vehicle using heavy goods
vehicles for transport to the power station is used due
to the average distance from farms to power station,
and the carrying capacity and road speed of such ve-
hicles.
Processing of the biomass to improve its handling e-
ciency and the quantity that can be transported. This
can involve increasing the bulk density of the biomass
(e.g. processing forest fuel or coppice stems into wood
chips) or unitising the biomass (e.g. processing straw
or miscanthus in the swath into bales). Processing can
occur at any stage in the supply chain but will often
precede road transport and is generally cheapest when
integrated with the harvesting
Figure 4 describes the various options faced in the Biomass
SCM. The gure shows that there are several decision points
in the SCM which aect the nal outcome. As an example,
trees grown on farmland on a short rotation coppice basis
can either be harvested as ve meter whole sticks or cut and
immediately processed into wood chips. Dierent harvesting
Figure 4: Decision making in Biomass Supply Chain
machinery is required for each of these harvesting systems.
While sticks can be stored on the edge of elds without ex-
periencing decomposition, chips need to be stored on at least
a hard standing, and in a covered environment if decomposi-
tion is to be prevented. Therefore, the storage requirements
for the two products are very dierent. Similarly, sticks
and chips require very dierent transport systems in terms
of both handling (i.e. loading and unloading vehicles) and
suitable transport vehicle bodies for carrying them.. The
easiest and most cost eective harvesting system can result
in the need for expensive storage systems and can even lead
to an inability to supply fuel of the desired quality to the
power station.
The SCM as shown in the gure can be represented by a
CASO agent program (Figure 5) which has several plans
at its disposal and can choose one of the possible alternate
plans based on the current set of constraints as well as the
current objective that the SCM is trying to optimize. If we
look into Plan#1, we can see that one of the subgoals of stick
harvesting is to either chip on eld or transport the sticks
as denoted by eldChipOrTransport() . These two subgoals
are further elaborated in plans Plan#2 and Plan#3 where
two possible course of action could take place depending on
whether transport to power station is available or chipping
on farm is possible. These two possible options are denoted
bytransportAvailableToPowerStationFromField() and chip-
pingPossibleOnFarm() as two beliefs which can be written
in ECLiPSe style CLP and is shown in Figure 6. For the
sake of simplicity, let us assume that the objective function
(minimize cost) is given by:
optimize(min(50*StickDeliveryTrucksReqd +
60*LoadingRobotReqd + 75*StickAsseblersReqd + 50*ChipDe-
liveryTrucksReqd + 70*ChippingMachineReqd +
65*ChipLoadersReqd)) .
The numbers denote the $costand the variables (shown in
gure 6) denote the quantity of each resource required. The
rst 3 variables are related to stick transport and the last
3 are related to chipping on eld. If we look carefully into
the two beliefs, we see that when the agent tries to select
either of plans Plan#2 and Plan#3 in gure 5, it evaluates
the context of each plan as given by beliefs Belief#1 and Be-
lief#2 in gure 6, and nds out that both plans can equally
be selected as all constraints are satised. However, once thePlan #1:
+!stickHarvesting : eldAvailableToUnload()
 unloadInField(); inFieldTransport();onFarmStorage();
!eldChipOrTransport().
Plan #2:
+! eldChipOrTransport():
transportAvailableToPowerStationFromField()
 tranportSticksToPowerStationFromField();
centralizedChipping();
Plan #3:
+! eldChipOrTransport(): chippingPossibleOnFarm()
 onFarmChipping();
transportChipsToPowerStationFromField().
Plan #4:
+!stickHarvesting : headlandAvailableToUnload()
 unloadOnHeadland(); storeOnHeadland();
!headlandChipOrTransport().
Plan #5:
+!headlandChipOrTransport() : chipPossibleOnHeadland()
 chipOnHeadland(); inFieldChipTransport();
transportChipsToPowerStationFromHeadland().
Plan #6:
+!headlandChipOrTransport() :
transportAvailableToAccessPoint()
 inFieldStickTransportToAccessPoint();
!accessPointChippingOrTransport().
Plan #7:
+!accessPointChippingOrTransport():
chipPossibleAtAccessPoint()
 onFarmChipping();
transportChipsToPowerStationFromAccessPoint().
Plan #8:
+!accessPointChippingOrTransport():
transportAvailableToPowerStation()
 transportSticksToPowerStationFromAccessPoint().
Figure 5: Plans related to a CASO Stick Harvesting
Agent
objective function is taken into consideration, the solution
obtained from evaluating Belief#1 gives a value of 245 of the
objective function and that from Belief#2 gives a value of
185. Based on the current scenario, the agent would choose
Plan#1 as it gives lower cost. Tables 1 and 2 show the value
of the objective function together with the value of the vari-
ables. Now, if the objective function changes at any point,
the result obtained may be dierent and the agent would
then choose a dierent plan based on the circumstances. As
an example, the current objective is a function of cost but
it can equally be made into a function of time. Thus, if
the consideration is to minimize the amount of time that is
required to carry out either of the two plans without any re-
gards to the cost, a new objective function (minimize) could
be written which is a function of time. The value of the
variables are passed to the intention stack in the CASO in-
terpreter cycle, and are used to initialize the parameters as
described earlier. Also, the above example showed only 1-
step look-ahead - however, one can easily go to reasonable
desired depth of the decision tree (AND/OR goal-plan tree),
and obtain all possible values of the objective function. The
agent would then choose the plan that would be the best out
BELIEF #1
transportAvailableToPowerStationFromField() :-
% integer variables
Vars = [StickDeliveryTrucksReqd, LoadingRobotReqd,
StickAsseblersReqd],
integers(Vars),
%constants
StickDeliveryTrucksAvail=2,
LoadingRobotAvail =2,
StickAsseblersAvail =2,
%inequality constraints
%enough trucks for transportation
StickDeliveryTrucksReqd <=StickDeliveryTrucksAvail,
%enough robots for loading sticks onto truck
LoadingRobotReqd <=LoadingRobotAvail,
%enough persons to assemble the sticks
StickAsseblersReqd <=StickAsseblersAvail,
%at least 3 robots + stick assemblers are required
LoadingRobotReqd + StickAsseblersReqd >=3,
%at least 1 delivery truck is required
StickDeliveryTrucksReqd >=1,
%equality constraints :total number of resources required
StickDeliveryTrucksReqd + LoadingRobotReqd + Stick-
AsseblersReqd =4
BELIEF #2
chippingPossibleOnFarm() :-
%integer variables
Vars = [ChipDeliveryTrucksReqd, ChippingMachineReqd,
ChipLoadersReqd],
integers(Vars),
%constants
ChipDeliveryTrucksAvail =2,
ChippingMachineAvail =2,
ChipLoadersAvail =2,
%inequality constraints
%enough trucks for transportation
ChipDeliveryTrucksReqd <=ChipDeliveryTrucksAvail,
%enough chipping machines
ChippingMachineReqd <=ChippingMachineAvail,
%enough persons to load the sticks into chipping machine
ChipLoadersReqd <=ChipLoadersAvail,
%at least 1 machine, 1 loader and 1 delivery truck are
required
ChippingMachineReqd = >1,
ChipLoadersReqd >=1,
ChipDeliveryTrucksReqd >=1,
%equality constraints :total number of resources required
ChipDeliveryTrucksReqd + ChippingMachineReqd +
ChipLoadersReqd =4
Figure 6: Partial Set of beliefs related to a CASO
Stick Harvesting AgentBelief#1
StickDeliveryTrucksReqd =1
LoadingRobotReqd =2
StickAsseblersReqd =1
Objective =245
Table 1: Value of variables and objective function
for Belief#1
Belief#2
ChipDeliveryTrucksReqd =1
ChippingMachineReqd =1
ChipLoadersReqd =1
Objective =185
Table 2: Value of variables and objective function
for Belief #2
of all possible worst cases as described in earlier section. It
should also be noted here that the we are currently depict-
ing only one agent in a multi-agent scenario which is doing
decision making. However, this can easily be extended to a
fully edged MAS where several agents interact with each
other and take their own decisions for optimizing their own
objectives.
7. EXPERIMENTAL RESULTS
We ran a series of experiments to nd out how the quickly
the system could nd the optimal plan. Our goal is to show
that with a reasonable number of look-ahead steps and with
moderate number of plans/actions, the CASO agent would
bereactive enough (i.e., perform plan selection in real-time).
The experiments were conducted on Intel dual-core machine
using complex set of constraints with linear objective func-
tions which were basically solved by the ECLiPSe solver.
For any given CASO program, the following parameters can
greatly aect the way plan selection is done:
1. The branching factor of the goal-plan tree (i.e., the
number of OR nodes that are present for each plan).
2. The look-ahead depth (or level) of the goal-plan tree
up to which CSOP technique will be applied.
3. The number of constraints for each plan.
4. The number of variables in the CASO program. Note
that the list of variables in the program has to be glob-
ally dened.
We randomly generated CASO programs and tested the plan
selection function by xing some parameters and varying
other parameters as given above.
Experiment 1 Given a plan in a CASO program with mul-
tiple subplans, we calculated the time taken to nd
the optimum plan among the choices by xing the
branching factor, number of constraints per plan and
the number of variables for a given objective function
and varying the depth of look-ahead. We set branch-
ing factor = 3, number of constraints/plan = 2 and
number of variables =5 .
Experiment 2 Given a plan in a CASO program with mul-
tiple subplans, we calculated the time taken to nd the
optimum plan among the choices by xing the look-
ahead depth, the branching factor, number of con-
straints per plan variables and varying the number of
variables . Note that for this experiment, we generated
a number of CASO programs with the same set of plans
having same head and body, but dierent context (dif-
ferent set of variables). Also, we used similar objective
function with lesser variables. We set branching factor
= 3,number of constraints/plan = 2 and look-ahead
depth =3 .
Experiment 3 Given a plan in a CASO program with mul-
tiple subplans, we calculated the time taken to nd the
optimum plan among the choices by xing the look-
ahead depth, the branching factor, number of variables
and the same objective function and varying the num-
ber of constraints per plan . Note that for this experi-
ment, we generated a number of CASO programs with
the same set of plans having same head and body, but
dierent context (dierent number of constraints per
plan). We set branching factor = 3 ,look-ahead depth
= 3 and number of variables =5 .
Experiment 4 Given a plan in a CASO program with mul-
tiple subplans, we calculated the time taken to nd
the optimum plan among the choices by xing the
look-ahead depth, number of variables, the number
of constraints per plan and the same objective func-
tion and varied the branching factor . Note that for
this experiment, we generated a number of CASO pro-
grams with dierent set of plans. We set look-ahead
depth = 3 ,number of variables =5 andnumber of con-
straints/plan = 2 .
Figure 7: Graphs showing experimental results
Figure 7 depict the results for each of the above ex-periments. As we can see that with increasing depth
for the same set of plans, the time taken to nd the
optimal plan increases. Similar trend is noted when
the number of number of variables orconstraints per
plan is increased although the dierence is not that
signicant as with varying depth. Finally, if branching
factor is increased the time taken to nd the optimal
plan increases as more combinations have to be gen-
erated. It is to be noted here though that for every
run, we are generating a dierent set of plans (a dif-
ferent CASO program), solving LP for each of these
programs is quite dierent each time and there is no
consistency among them. Thus, for some CASO pro-
grams, it might be such that nding a solution may be
faster with a higher branching factor than one with a
lower factor. for this reason, we randomly generated
100 CASO programs with dierent branching factors
keeping all other parameters constant and found that
on an average, with an increase in the branching factor,
the time taken to nd the optimal plan also increases
(Figure 7).
Overall we can see that the times take (in ms.) are
quite small and we can select an optimal very quickly
using ECLiPSe together with Jason in our implemen-
tation of CASO.
8. RELATED WORK AND CONCLUSION
Decision agents can be designed to provide interactive de-
cision aids for end-users by eliciting their preferences and
then recommending matching products. In [6] constraint
logic programming and data model approach is used within
BDI agent framework. However, this work speaks of BDI
agents in general and does not integrate with any BDI pro-
gramming language. AgentSpeak(XL) programming lan-
guage [4] integrates AgentSpeak (L) with the TAEMS sched-
uler in order to generate the intention selection function. It
also describes a precise mechanism for allowing programmers
to use events in order to handle plan failures which is not
included in AgentSpeak(L). This work, however, adds prior-
ity to the tasks. Some related theoretical work on selecting
new plans in the context of existing plans is presented in [9].
Another related work on detecting and resolving conicts be-
tween plans in BDI agents is presented in [14]. The "degree
of boldness" of an agent is dened in [12] which represents
he maximum number of plan steps the agent executes be-
fore re-considering its intentions. However in this case it is
assumed that the agent would backtrack if the environment
changes after it has started executing the plans.
Our implementation of CASO provides the user with the
exibility of adding explicit objectives and constraints to
achieve nal goals. CASO uses a modied version of Jason,
the well-known BDI AgentSpeak(L) interpreter, together
with another open-source constraint solver ECLiPSe thereby
combining reactive combining agent programming with con-
straint solving techniques. CASO is based on the strong
theoretical foundations of BDI and in the simple example
described in earlier section, we can see that CASO can in-
deed be deployed in many agent application domains like
supply chain, health care etc. as well as used in the design
and simulation of such applications where several types of
decision making and optimizations may be required. More-
over, the time taken to select a particular plan in real-time is
very small (with a reasonable look-ahead depth) and is only
depended on the constraint-solver that we use. In future
we plan to extend CASO to incorporate user preferences as
c-semiring [3] and implement the design to create a more ro-
bust and powerful MAS which can be deployed in complex
applications.9. REFERENCES
[1] J. Allen, M. Browne, A. Hunter, J. Boyd, and
H. Palmer. Logistics management and costs of biomass
fuel supply . MCB UP Ltd., 1998.
[2] K. R. Apt and M. Wallace. Constraint Logic
Programming using Eclipse . Cambridge University
Press, 2007.
[3] S. Bistarelli, U. Montanary, and F. Rossi.
Semiring-based constraint satisfaction and
optimisation. In Journal of ACM . ACM Press, 1997.
[4] R. Bordini, A. Bazzan, R. Jannone, D. Basso,
R. Vicari, and V. Lesser. AgentSpeak(XL):Ecient
intention selection in BDI agents via decision-theoretic
task scheduling . ACM Press, 2002.
[5] R. Bordini, J. Hubner, and M. Wooldridge.
Programming Multi-Agent Systems in AgentSpeak
Using Jason . John Wiley & Sons, Ltd, 2007.
[6] S. Chalmers and P. M. D. Gray. Bdi agents and
constraint logic. In AISB Journal Special Issue on
Agent Technology , 2001.
[7] A. Dasgupta and A. K. Ghose. Dealing with objectives
in a constraint-based extension to agentspeak(l). In
Proc. of the Pacic Rim International Workshop on
Multi-Agents , 2005.
[8] A. Dasgupta and A. K. Ghose. Caso: A framework for
dealing with objectives in a constraint-based extension
to agentspeak(l). In Proc. of the 2006 Australasian
Computer Science Conference , 2006.
[9] J. Horty and M. Pollack. Evaluating new options in
the context of existing plans. In Artical Intelligence ,
2001.
[10] A. Rao. Agentspeak(l): Bdi agents speak out in a
logical computable language. In Agents Breaking
Away: Proceedings of the 7th European WS on
Modelling Autonomous Agents in a Multi-Agent
World . Springer-Verlag: Heidelberg,Germany, 1996.
[11] A. Rao and M. George. BDI Agents: from theory to
practice . San Fransisco, USA, 1995.
[12] M. Schut and M. Wooldridge. Intention
reconsideration in complex environments. In
Proceedings of International Conference on
Autonomous Agents , Varcelona, Spain, 2000.
[13] J. Thangarajah. Managing the concurrent execution of
goals in intelligent agents. In Phd. Thesis . RMIT,
2004.
[14] J. Thangarajah, L. Padhgam, and M. Winiko.
Detecting and avoiding interference between goals in
intelligent agents. In G. Gottlob and T. Walsh, editors,
Proceedings of the International Joint Conference on
Articial Intelligence . Academic Press, 2003.
