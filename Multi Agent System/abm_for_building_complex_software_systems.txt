Building high-quality, industrial-
strength software is difficult.Indeed, it has been argued thatdeveloping such software indomains like telecommunications,
industrial control, and business process manage-ment represents one of the most complex construc-tion tasks humans undertake. Against thisbackground, a wide range of software engineeringparadigms have been devised.Each successive developmenteither claims to make the engi-neering process easier orpromises to extend the complex-ity of applications that can feasi-bly be built. Although evidence is emerging to support theseclaims, researchers continue tostrive for more effective techniques. To this end, thisarticle will argue that analyzing, designing, andimplementing complex software systems as a collec-tion of interacting, autonomous agents (that is, as amultiagent system [4]) affords software engineers anumber of significant advantages over contemporarymethods. This is not to say that agent-oriented soft-ware engineering represents a silver bullet [2]—thereis no evidence to suggest it will represent an order ofmagnitude improvement in productivity. However,the increasing number of deployed applications [4,8] bears testament to the potential advantages thataccrue from such an approach. 
In seeking to demonstrate the efficacy of agent-ori-ented techniques, the most compelling argument
would be to quantitatively show how their adoptionimproved the development process in a range of proj-ects. However, such data is simply not available (as itis not for approaches like patterns, application frame-works, and componentware). Given this situation,the best that can be achieved is a qualitative justifica-tion of why agent-oriented approaches are well suitedto engineering complex, distributed software systems. 
Managing Complexity in
Software Systems
Industrial-strength software is
complex: it has a large number ofparts that have many interactions[9]. Moreover this complexity isnot accidental [2], it is an innateproperty of large systems. Given
this situation, the role of software engineering is toprovide structures and techniques that make it eas-ier to handle complexity. Fortunately for designers,this complexity exhibits a number of important regularities [9]: 
• Complexity frequently takes the form of a hierar-
chy. That is, a system composed of interrelatedsubsystems, each of which is in turn hierarchic instructure, until the lowest level of elementary sub-system is reached. The precise nature of these orga-nizational relationships varies between subsystems,however, some generic forms (such as client/server,peer, team, and so forth) can be identified. These
COMMUNICATIONS OF THE ACM April  2001/Vol. 44, No. 4 35AN AGENT-BASED APPROACH FOR
BUILDING COMPLEX 
SOFTWARE SYSTEMS
NICHOLAS R. J ENNINGS/ornament22/ornament22WHY AGENT -ORIENTED APPROACHES ARE WELL SUITED FOR
DEVELOPING COMPLEX , DISTRIBUTED SYSTEMS . 
36 April  2001/Vol. 44, No. 4 COMMUNICATIONS OF THE ACMrelationships are not static: they often vary over
time. • The choice of which components in the systemare primitive is relatively arbitrary and is definedby the observer’s aims and objectives.• Hierarchic systems evolve more quickly thannonhierarchic ones of comparable size (that is,complex systems will evolve from simple systemsmore rapidly if there are clearly identifiable stable
intermediate forms than if there are not). 
• It is possible to distinguish between the interac-tions among subsystems and those within subsys-tems. The latter are both more frequent (typically atleast an order of magnitude more) and more pre-dictable than the former. This gives rise to the viewthat complex systems are nearly decomposable : sub-
systems can be treated almost as if they are inde-pendent, but not quite since there are someinteractions between them. Moreover, althoughmany of these interactions can be predicted atdesign time, some cannot. 
Drawing these insights together, it is possible to
define a canonical view of a complex system (see Fig-ure 1). The system’s hierarchical nature is expressedthrough the “related to” links, components within asubsystem are connected through “frequent interac-tion” links, and interactions between components areexpressed through “infrequent interaction” links. 
Given these observations, software engineers have
devised a number of fundamental tools of the tradefor helping to manage complexity [1]:
Decomposition: The most basic technique for
tackling large problems is to divide them intosmaller, more manageable chunks, each of whichcan then be dealt with in relative isolation (notethe nearly decomposable subsystems in Figure 1).Decomposition helps tackle complexity because itlimits the designer’s scope.Abstraction: The process of defining a simplified
model of the system that emphasizes some of thedetails or properties, while suppressing others.Again, this works because it limits the designer’sscope of interest at a given time. Organization
1:The process of defining and man-
aging the interrelationships between the variousproblem-solving components (note the subsystemand interaction links of Figure 1). The ability tospecify and enact organizational relationships helpsdesigners tackle complexity by: enabling a numberof basic components to be grouped together and
treated as a higher-level unit of analysis, and pro-viding a means of describing the high-level rela-tionships between various units. 
The Case for Agent-Oriented Software
Engineering 
The first step in arguing for an agent-oriented
approach to software engineering involves identify-ing the key concepts of agent-based computing. Thefirst such concept is that of an agent: an agent is anencapsulated computer system situated in someenvironment and capable of flexible, autonomous
action in that environment in order to meet its
design objectives [10].
There are a number of points about this definition
that require elaboration. Agents are: clearly identifi-able problem-solving entities with well-definedboundaries and interfaces; situated (embedded) in aparticular environment over which they have partialcontrol and observability—they receive inputs relatedto the state of their environment through sensors andthey act on the environment through effectors;designed to fulfill a specific role—they have particularobjectives to achieve; autonomous—they have con-trol both over their internal state and over their ownbehavior; capable of exhibiting flexible problem-solv-ing behavior in pursuit of their design objectives—being both reactive (able to respond in a timelyfashion to changes that occur in their environment)and proactive (able to opportunistically adopt goalsand take the initiative) [11].
When adopting an agent-oriented view, it soon
becomes apparent that most problems require orinvolve multiple agents: to represent the decentralizednature of the problem, the multiple loci of control,the multiple perspectives or the competing interests.Moreover, the agents will need to interact with oneanother: either to achieve their individual objectivesFigure 1.  View of a canonical complex system.
subsystem
subsystem
componentrelated to
frequent interactioninfrequent 
interaction
1Booch actually uses the term “hierarchy” [1]; however, this invariably gives the con-
notation of control. Hence the more neutral term “organization” is used here.
or to manage the dependencies that ensue from being
situated in a common environment. These interac-tions can vary from simple semantic interoperation,through traditional client/server-type interactions, torich social interactions (the ability to cooperate, coor-dinate, and negotiate about a course of action). 
Whatever the nature of the social process, how-
ever, there are two points that qualitatively differenti-ate agent interactions from those that occur in othersoftware engineering paradigms. First, agent-orientedinteractions generally occur through a high-level(declarative) agent communication language (oftenbased on speech act theory [6]). Consequently, inter-
actions are conducted at the knowledge level [5]: in
terms of which goals should be followed, at whattime and by whom (compare this with method invo-cation or function calls that operate at a purely syn-tactic level). Secondly, as agents are flexibleproblem-solvers, operating in an environment inwhich they have only partial control and observabil-ity, interactions need to be handled in a similarly flex-ible manner. Thus, agents need the computationalapparatus to make context-dependent decisionsabout the nature and scope of their interactions andto initiate (and respond to) interactions that were notforeseen at design time. 
Since agents act either on behalf of individuals or
companies or as part of some wider initiative, there istypically some underpinning organizational contextto agents’ interactions. This context defines the natureof the relationship between the agents. For example,they may be peers working together in a team or onemay be the manager of the others. To capture suchlinks, agent systems have explicit constructs for mod-eling organizational relationships (manager, teammember). In many cases, these relationships are sub-ject to ongoing change: social interaction means exist-ing relationships evolve (a team of peers may elect aleader) and new relations are created (a number ofagents may form a team to deliver a service that no
one individual can offer). The temporal extent ofthese relationships can also vary enormously, rangingfrom providing a service as a one-off option to a per-manent bond. To cope with this variety and dynam-ics, agent researchers have devised protocols thatenable organizational groupings to be formed and dis-banded, specified mechanisms to ensure groupings acttogether in a coherent fashion, and developed struc-tures to characterize the macro behavior of collectives[4, 11].
Drawing these points together (see Figure 2), it can
be seen that adopting an agent-oriented approach tosoftware engineering means decomposing the prob-lem into multiple, autonomous components that canact and interact in flexible ways to achieve their setobjectives. The key abstraction models that define theagent-oriented mindset are agents, interactions, andorganizations. Finally, explicit structures and mecha-nisms are often used to describe and manage the com-plex and changing web of organizational relationshipsthat exist between the agents.
The argument in favor of an agent-oriented
approach to software engineering includes:
• Show that agent-oriented decompositions are an
effective way of partititioning the problem space ofa complex system;• Show that the key abstractions of the agent-ori-ented mindset are a natural means of modelingcomplex systems; and • Show that the agent-oriented philosophy formodeling and managing organizational relation-ships is appropriate for dealing with the dependen-cies and interactions that exist in complex systems.
The Merits of Agent-Oriented 
Decompositions
Complex systems consist of a number of related sub-
systems organized in a hierarchical fashion (see Fig-ure 1). At any given level, subsystems work togetherto achieve the functionality of their parent system.Moreover, within a subsystem, the constituent com-ponents work together to deliver the overall func-tionality. Thus, the same basic model of interactingcomponents, working together to achieve particularobjectives occurs throughout the system. Given thisfact, it is entirely natural to modularize the compo-nents in terms of the objectives they achieve.
2In
other words, each component can be thought of asachieving one or more objectives. A second impor-
COMMUNICATIONS OF THE ACM April  2001/Vol. 44, No. 4 37agent
interactionorganizational
relationship
Sphere of
visibility andinfluence
EnvironmentFigure 2. Canonical view of a multiagent system.
2The view that decompositions based upon functions/actions/processes are more intu-
itive and easier to produce than those based upon data/objects is even acknowledgedwithin the object-oriented community (see [7]).
tant observation is that complex systems have mul-
tiple loci of control: “real systems have no top” [7].Applying this philosophy to objective-achievingdecompositions means the individual componentsshould localize and encapsulate their own control.Thus, entities should have their own thread of con-trol (that is, they should be active) and they shouldhave control over their own actions (that is, theyshould be autonomous). 
For the active and autonomous components to ful-
fill both their individual and collective objectives, theyneed to interact (recall complex systems are only nearlydecomposable). However the system’s inherent com-plexity means it is impossible to a priori know about allpotential links: interactions will occur at unpredictabletimes, for unpredictable reasons, between unpre-dictable components. For this reason, it is futile to tryand predict or analyze all the possibilities at designtime. It is more realistic to endow the components withthe ability to make decisions about the nature andscope of their interactions at runtime. From this, it fol-lows that components need the ability to initiate (andrespond to) interactions in a flexible manner.
The policy of deferring to runtime decisions about
component interactions facilitates the engineering ofcomplex systems in two ways. First, problems associ-ated with the coupling of components are signifi-cantly reduced (by dealing with them in a flexible anddeclarative manner). Components are specificallydesigned to deal with unanticipated requests and canspontaneously generate requests for assistance if theyfind themselves in difficulty. Moreover because theseinteractions are enacted through a high-level agentcommunication language, coupling becomes aknowledge-level issue. At a stroke this removes syn-tactic concerns from the types of errors caused byunexpected interactions. Secondly, the problem ofmanaging control relationships between the softwarecomponents (a task that bedevils traditional objec-tive-based decompositions) is significantly reduced.All agents are continuously active and any coordina-tion or synchronization that is required is handledbottom-up through interagent interaction. 
From this discussion, it is apparent that the natural
way to modularize a complex system is in terms ofmultiple autonomous components that can act andinteract in flexible ways in order to achieve their setobjectives. Given this, the agent-oriented approach issimply the best fit to this ideal. 
The Suitability of Agent-Oriented
Abstractions
A significant part of the design process is finding
the right models for viewing the problem. In gen-eral, there will be multiple candidates and the dif-
ficult task is picking the most appropriate one.When designing software, the most powerfulabstractions are those that minimize the semanticgap between the units of analysis that are intu-itively used to conceptualize the problem and theconstructs present in the solution paradigm. In thecase of complex systems, the problem to be charac-terized consists of subsystems, subsystem compo-nents, interactions and organizationalrelationships. Taking each in turn:
• Subsystems naturally correspond to agent organi-
zations. They involve a number of constituentcomponents that act and interact according to theirrole within the larger enterprise. • The case for viewing subsystem components asagents has been made previously. 
The interplay between the subsystems and
between their constituent components is most natu-rally viewed in terms of high-level social interactions:“in a complex system…at any given level of abstrac-tion, we find meaningful collections of objects thatcollaborate to achieve some higher-level view” [1].This view accords precisely with the knowledge-leveltreatment of interaction afforded by the agent-oriented approach. Agent systems are invariablydescribed in terms of “cooperating to achieve com-mon objectives,” “coordinating their actions” or“negotiating to resolve conflicts.” 
Complex systems involve changing webs of rela-
tionships between their various components. Theyalso require collections of components to be treated asa single conceptual unit when viewed from a differentlevel of abstraction. Here again the agent-orientedmindset provides suitable abstractions. A rich set ofstructures are available for explicitly representingorganizational relationships. Interaction protocolsexist for forming new groupings and disbandingunwanted ones. Finally, structures are available formodeling collectives. The latter point is especiallyuseful in relation to representing subsystems sincethey are nothing more than a team of componentsworking together to achieve a collective goal. 
The Need for Flexible Management of
Changing Organizational Structures
Organizational constructs are first-class entities in
agent systems—explicit representations are made oforganizational relationships and structures. More-over, agent-oriented systems have the concomitantcomputational mechanisms for flexibly forming,maintaining, and disbanding organizations. This
38 April  2001/Vol. 44, No. 4 COMMUNICATIONS OF THE ACM
representational power enables agent systems to
exploit two facets of the nature of complex systems.First, the notion of a primitive component can bevaried according to the needs of the observer. Thusat one level, entire subsystems can be viewed as sin-gletons, alternatively teams or collections of agentscan be viewed as primitive components, and so onuntil the system eventually bottoms out. Secondly,such structures provide the stable intermediate formsthat are essential for the rapid development of com-plex systems. Their availability means that individ-ual agents or organizational groupings can bedeveloped in relative isolation and then added intothe system in an incremental manner. This, in turn,ensures there is a smooth growth in functionality.
Will Agent-Oriented T echniques Be
Widely Adopted?
There are two key pragmatic issues that will deter-
mine whether agent-oriented approaches catch on asa software engineering paradigm: the degree towhich agents represent a radical departure from current software engineering thinking and thedegree to which existing software can be integratedwith agents. 
A number of trends become evident when examin-
ing the evolution of programming models. There hasbeen an inexorable move from languages that havetheir conceptual basis determined by the underlyingmachine architecture, to languages that have their keyabstractions rooted in the problem domain. Here theagent-oriented world view is perhaps the most naturalway of characterizing many types of problems. Just as
the real-world is populated with objects that haveoperations performed on them, so it is equally full ofactive, purposeful agents that interact to achieve theirobjectives (see the sidebar for more detailed compari-son). Indeed, many object-oriented analyses start fromprecisely this perspective: “we view the world as a set ofautonomous agents that collaborate to perform somehigher level function” [1]. 
The basic building blocks of the programming
models exhibit increasing degrees of localization andencapsulation [8], and agents follow this trend bylocalizing purpose inside each agent, by giving eachagent its own thread of control, and by encapsulatingaction selection. Additionally, ever-richer mechanismsfor promoting reuse are being provided. Here, theagent view also reaches new heights. Rather thanstopping at reuse of subsystem components (designpatterns and componentware) and rigidly preor-dained interactions (application frameworks), agentsenable whole subsystems and flexible interactions tobe reused. In the former case, agent designs andimplementations are reused within and betweenapplications. Consider, for example, the class of agentarchitectures that have beliefs (what the agent knows),desires (what the agent wants) and intentions (whatthe agent is doing) at its core. Such architectures havebeen used in a wide variety of applications includingair traffic control, process control, fault diagnosis andtransportation [4, 8]. In the latter case, flexible pat-terns of interaction such as the Contract Net Proto-col (an agent with a task to complete advertises this
COMMUNICATIONS OF THE ACM April  2001/Vol. 44, No. 4 39Although there are certain sim-
ilarities between object- and
agent-oriented approaches (bothadhere to the principle of informa-tion hiding and recognize theimportance of interactions), thereare also a number of importantdifferences [10]. First, objects aregenerally passive in nature: theyneed to be sent a message beforethey become active. Secondly,although objects encapsulatestate and behavior realization,they do not encapsulate behavioractivation (action choice). Thus,any object can invoke any publiclyaccessible method on any otherobject. Once the method is
invoked, the corresponding actionsare performed. Additionally,object-orientation fails to providean adequate set of concepts andmechanisms for modeling complexsystems: for such systems “we findthat objects, classes, and modulesprovide an essential yet insuffi-cient means of abstraction” [1].Individual objects represent too
fine a granularity of behavior andmethod invocation is too primitive amechanism for describing the typesof interactions that take place.Recognition of these facts led tothe development of more powerfulabstraction mechanisms such as
design patterns, application frame-works, and componentware.Although these are undoubtedly astep forward, they fall short of thedesired characteristics for complexsystem development. By their verynature, they focus on generic sys-tem functions and the mandatedpatterns of interaction are rigid andpredetermined. Finally, object-ori-ented approaches provide only min-imal support for specifying andmanaging organizational relation-ships (basically relationships aredefined by static inheritance hierarchies).
cComparing Object- and Agent-based Approaches
fact to others who it believes are capable of perform-
ing it, these agents may submit a bid to perform thetask if they are interested, and the originator thendelegates the task to the agent that makes the bestbid) and various forms of resource-allocation auction(for example, English, Dutch, Vickrey) have beenreused in significant numbers of applications. Inshort, agent-oriented techniques represent a naturalprogression of current software engineering thinkingand, for this reason, the main concepts and tenets ofthe approach should be readily acceptable to softwareengineering practitioners. 
The second factor in favor of a widespread incor-
poration of agents is that their adoption does notrequire a revolution in terms of an organization’s soft-ware capabilities. Agent-oriented systems are evolu-tionary and incremental as legacy (non-agent)software can be incorporated in a relatively straight-forward manner. The technique used is to place wrap-ping software around the legacy code. The wrapperpresents an agent interface to the other software com-ponents. Thus from the outside it looks like any otheragent. On the inside, the wrapper performs a two-waytranslation function: taking external requests fromother agents and mapping them into calls in thelegacy code, and taking the legacy code’s externalrequests and mapping them into the appropriate setof agent communication commands. This ability towrap legacy systems means agents may initially beused as an integration technology. However, as newrequirements are placed on the system, agents may bedeveloped and added. This feature enables a complexsystem to grow in an evolutionary fashion (based onstable intermediate forms), while adhering to theimportant principle that there should always be aworking version of the system available. Case Study: Provisioning a Virtual 
Private Network
As an exemplar of a complex, distributed system
consider the task of dynamically provisioning apublic communication network (such as the Inter-net) as a virtual private network for end users. To bemore definitive, let the task in question be settingup a videoconferencing meeting [3]. This applica-tion involves a variety of different individuals andorganizations (see Figure 3). There are the end usersthat are each represented by their personal commu-nication agent (PCA). The providers of services on
the network (such as setting up avideoconference, for example) areeach represented by a serviceprovider agent (SPA). Finally,there are the agents that representthe network provider on whosetelecommunications infrastruc-ture the services will actually bedelivered (each represented by anetwork provider agent (NPA)).In setting up a videoconferencecall, the various PCAs negotiate,on behalf of their particular users,with one another in order to finda suitable time for the call. Whenthey come to an agreement, oneof the PCAs then contacts, and
subsequently negotiates with, the various SPAs thatoffer the videoconference service (not all SPAs willdo this). This negotiation revolves around the costof the conference call and the quality of service thatis desired. The SPA that wins the contract thennegotiates with the various NPAs to determinewhich of them can deliver the desired quality andbandwidth at the best price.
This application highlights many of the benefits
that are have been claimed for an agent-orientedapproach to software engineering. Autonomousagents are the most natural means of representing thedistinct individuals and organizations that are presentin the application. Each such entity is an active prob-lem-solver that has its own objectives to achieve andhas control over the actions it chooses and theresources that it expends. The agents need to beresponsive to changes in their environment (for exam-ple, a NPA may need to arrange additional networkcapacity from another NPA in order to maintain itsagreed upon quality of service if part of its networkfails) and they need to be able to opportunisticallyadopt new goals as they present themselves (for exam-ple, two SPAs may discover they have complementaryservice capabilities and may decide to act together in
40 April  2001/Vol. 44, No. 4 COMMUNICATIONS OF THE ACMFigure 3. Dynamic provisioning of virtual 
private networks by end users.
Locate videoconference provider negotiation
Select network provider negotiationEnd Users
Service
Providers
Network
ProvidersGroup that 
wants to make call
NPA NPA NPA NPASPA SPA SPAPCA PCA
negotiationAgree time
order to offer a new service). 
A second factor is the agents’ need to engage in
knowledge-level interactions in order to achieve theirindividual objectives. In this case, agents typically rep-resent self-interested entities and so the main form ofinteraction is negotiation. Thus, to set the time of thevideoconference or to select a particular service or net-work provider the agents make proposals, trade offers,make concessions and, hopefully, come to agree-ments. This rich form of interaction is necessarybecause the agents represent autonomous stakeholdersand also to ensure that agents can arrange their activ-ities in a manner that is appropriate to their prevailingcircumstances. 
Finally, there is a very clear and explicit notion of
organizational context. The application involves anumber of different real-world organizations: individ-ual end users, companies that provide the differenttypes of services, and network providers that controlthe underlying telecommunications infrastructure.These relationships directly affect the agents’ behavior.For example, if a SPA and a NPA are in fact part ofthe same organization, then their negotiations aremore cooperative in nature than if they represent twounrelated companies. Similarly, the PCAs that haveagreed to hold a conference call act as a team ratherthan a collection of individuals. Additionally, duringthe ongoing operation of the application new organi-zational groupings can appear and then disband. ThePCAs of distinct end users form themselves into col-lectives when they require a particular service (forexample, all the participants of the videoconference).Individual SPAs combine their capabilities to offernew services that are beyond the scope of any individ-ual provider. Competing NPAs form themselves intotemporary coalitions in order to respond to particu-larly large requests for network resources.
3
Conclusion 
Agent-oriented techniques are being increasinglyused in a range of telecommunication, commercial,and industrial applications. However, if they are toenter the mainstream of software engineering it isvital that clear arguments are advanced as to theirsuitability for solving large classes of problems (asopposed to specific point solutions). To this end, thisarticle has sought to justify precisely why agent-ori-ented approaches are appropriate for developing
complex, distributed software systems. These generalpoints are then made more concrete by showing howthey apply in a specific telecommunications applica-tion. In making these arguments, it is possible forproponents of other software engineering paradigmsto claim that the key concepts of agent-orientedcomputing can be reproduced using their tech-nique—this is undoubtedly true. Agent-orientedsystems are, after all, computer programs and all pro-grams have the same set of computable functions.However, this misses the point. The value of a para-digm is the mindset and the techniques it providesto software engineers. In this respect, agent-orientedconcepts and techniques are both well suited todeveloping complex, distributed systems and anextension of those currently available in other paradigms.
References
1. Booch, G. Object-Oriented Analysis and Design with Applications. Addi-
son Wesley, 1994.
2. Brooks, F.P. The Mythical Man-Month. Addison Wesley, 1995.
3. Faratin, P., Jennings, N.R., Buckle, P. and Sierra, C. Automated nego-
tiation for provisioning virtual private networks using FIPA-compliantagents. In Proceedings of the 5th International Conference on Practical
Application of Intelligent Agents and Multi-Agent Systems. Manchester,
UK, 2000, p. 185–202. 
4. Jennings, N.R. and Wooldridge, M., Eds. Agent Technology: Founda-
tions, Applications and Markets. Springer Verlag, 1998. 
5. Newell, A. The knowledge level. Artificial Intelligence 18, 1982,
87–127. 
6. Mayfield, J., Labrou, Y., and Finin, T. Evaluating KQML as an agent
communication language in M. Wooldridge, J.P. Müller, and M.Tambe, Eds., Intelligent Agents II , Springer, 1995, 347–360.
7. Meyer, B. Object-Oriented Software Construction. Prentice Hall, 1988. 
8. Parunak, H.V.D. Industrial and practical applications of distributed
AI. In G. Weiss, Ed., Multi-Agent Systems. MIT Press, 1999, 377-421.
9. Simon, H.A. The Sciences of the Artificial. MIT Press, 1996.
10. Wooldridge, M. Agent-based software engineering. In IEE Proceedings
of Software Engineering 144 , 1997, 26–37. 
11. Wooldridge, M. and Jennings, N.R. Intelligent agents: Theory and
practice. The Knowledge Engineering Review 10 , 2 (1995), 115–152. 
Nicholas R. Jennings (nrj@ecs.soton.ac.uk) is a professor in the
Department of Electronics and Computer Science at the University ofSouthampton, UK. 
Permission to make digital or hard copies of all or part of this work for personal or class-
room use is granted without fee provided that copies are not made or distributed forprofit or commercial advantage and that copies bear this notice and the full citation onthe first page. To copy otherwise, to republish, to post on servers or to redistribute tolists, requires prior specific permission and/or a fee. 
© 2001 ACM 0002-0782/01/0400 $5.00c
COMMUNICATIONS OF THE ACM April  2001/Vol. 44, No. 4 413In contrast, an object-oriented approach is less suitable for this problem because: it
cannot naturally represent the autonomous problem-solving behavior of the con-stituent components (recall objects do not encapsulate action choice); it has nothingto say about the design of flexible problem-solvers that balance reactive and proactiveproblem-solving nor about interagent negotiation (other than the fact that it involvesmessage exchanges), and it has no innate mechanism for representing and reasoningwith the fact that the agents represent different stakeholder organizations (other thanthe fact that they are different classes). 
