UML 2.0 Superstructure Specification
This OMG document replaces the submission document (ad/03-04-01) and the Draft Adopted 
specification (ptc/03-07-06). It is an OMG Final Adopted Specification and is currently in the 
finalization phase. Comments on the content of this document are welcomed, and should be directed to issues@omg.org  by September 8, 2003.
You may view the pending issues for this specification from the OMG revision issues web page 
http://www.omg.org/issues/ ; however, at the time of this writing there were no pending issues. 
The FTF Recommendation and Report for this specification will be published on April 30, 2004. If 
you are reading this after that date, please download the available specification from the OMG 
Specifications Catalog.
OMG Adopted Specification
ptc/03-08-02

Date : August 2003
Unified Modeling Language:  Superstructure
version 2.0
Final Adopted Specification
ptc/03-08-02
                                                    
Copyright © 2001-2003 Adaptive Ltd. 
Copyright © 2001-2003 Alcatel Copyright © 2001-2003 Borland Software Corporation Copyright © 2001-2003 Computer Associates International, Inc. Copyright © 2001-2003 Telefonaktiebolaget LM Ericsson Copyright © 2001-2003 Fujitsu Copyright © 2001-2003 Hewlett-Packard Company Copyright © 2001-2003 I-Logix Inc. Copyright © 2001-2003 International Business Machines Corporation Copyright © 2001-2003 IONA Technologies Copyright © 2001-2003 Kabira Technologies, Inc. Copyright © 2001-2003 MEGA International Copyright © 2001-2003 Motorola, Inc. 
Copyright © 1997-2001 Object Management Group.
Copyright © 2001-2003 Oracle Corporation Copyright © 2001-2003 SOFTEAM Copyright © 2001-2003 Telelogic ABCopyright © 2001-2003 Unisys Copyright © 2001-2003 X-Change Technologies Group, LLC 
USE OF SPECIFICATION - TERMS, CONDITIONS & NOTICES
The material in this document details an Object Management Group specification in accordance with the terms, 
conditions and notices set forth below. This document does not represent a commitment to implement any portion of this specification in any company's products. The information contained in this document is subject to change without notice.
LICENSES
The companies listed above have granted to the Object Management Group, Inc. (OMG) a nonexclusive, royalty-free, 
paid up, worldwide license to copy and distribute this document and to modify this document and distribute copies of the modified version. Each of the copyright holders listed above has agreed that no person shall be deemed to have infringed the copyright in the included material of any such copyright holder by reason of having used the specification set forth herein or having conformed any computer software to the specification.
Subject to all of the terms and conditions below, the owners of the copyright in this specification hereby grant you a 
fully-paid up, non-exclusive, nontransferable, perpetual, worldwide license (without the right to sublicense), to use this specification to create and distribute software and special purpose specifications that are based upon this specification, and to use, copy, and distribute this specification as provided under the Copyright Act; provided that: (1) both the copyright notice identified above and this permission notice appear on any copies of this specification; (2) the use of the specifications is for informational purposes and will not be copied or posted on any network computer or broadcast in any media and will not be otherwise resold or transferred for commercial purposes; and (3) no modifications are made to this specification. This limited permission automatically terminates without notice if you breach any of these terms or conditions. Upon termination, you will destroy immediately any copies of the specifications in your possession or control. 
PATENTS
The attention of adopters is directed to the possibility that compliance with or adoption of OMG specifications may 
require use of an invention covered by patent rights. OMG shall not be responsible for identifying patents for which a license may be required by any OMG specification, or for conducting legal inquiries into the legal validity or scope of those patents that are brought to its attention. OMG specifications are prospective and advisory only. Prospective 
                                                    users are responsible for protecting themselves against liability for infringement of patents.
GENERAL USE RESTRICTIONS
Any unauthorized use of this specification may violate copyright laws, trademark laws, and communications 
regulations and statutes. This document contains information which is protected by copyright. All Rights Reserved. No part of this work covered by copyright herein may be reproduced or used in any form or by any means--graphic, electronic, or mechanical, including photocopying, recording, taping, or information storage and retrieval systems--without permission of the copyright owner.
DISCLAIMER OF WARRANTY
WHILE THIS PUBLICATION IS BELIEVED TO BE ACCURATE, IT IS PROVIDED "AS IS" AND MAY 
CONTAIN ERRORS OR MISPRINTS. THE OBJECT MANAGEMENT GROUP AND THE COMPANIES 
LISTED ABOVE MAKE NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS 
PUBLICATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF TITLE OR OWNERSHIP, IMPLIED WARRANTY OF MERCHANTABILITY OR WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE. IN NO EVENT SHALL THE OBJECT MANAGEMENT GROUP OR ANY OF THE COMPANIES LISTED ABOVE BE LIABLE FOR ERRORS CONTAINED HEREIN OR FOR DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL, RELIANCE OR COVER DAMAGES, INCLUDING LOSS OF PROFITS, REVENUE, DATA OR USE, INCURRED BY ANY USER OR ANY THIRD PARTY IN CONNECTION WITH THE FURNISHING, PERFORMANCE, OR USE OF THIS MATERIAL, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
The entire risk as to the quality and performance of software developed using this specification is borne by you. This 
disclaimer of warranty constitutes an essential part of the license granted to you to use this specification.
RESTRICTED RIGHTS LEGEND
Use, duplication or disclosure by the U.S. Government  is subject to the restrictions set forth in subparagraph (c) (1) 
(ii) of The Rights in Technical Data and Computer Software Clause at DFARS 252.227-7013 or in subparagraph (c)(1) and (2) of the Commercial Computer Software - Restricted Rights clauses at 48 C.F.R. 52.227-19 or as specified in 48 C.F.R. 227-7202-2 of the DoD F.A.R. Supplement and its successors, or as specified in 48 C.F.R. 12.212 of the Federal Acquisition Regulations and its successors, as applicable. The specification copyright owners are as indicated above and may be contacted through the Object Management Group, 250 First Avenue, Needham, MA 02494, U.S.A.
TRADEMARKS
The OMG Object Management Group Logo®, CORBA®, CORBA Academy®, The Information Brokerage®, 
XMI® and IIOP® are registered trademarks of the Object Management Group. OMG™, Object Management Group™, CORBA logos™, OMG Interface Definition Language (IDL)™, The Architecture of Choice for a Changing World™, CORBAservices™, CORBAfacilities™, CORBAmed™, CORBAnet™, Integrate 2002™, Middleware That's Everywhere™, UML™, Unified Modeling Language™, The UML Cube logo™, MOF™, CWM™, The CWM Logo™, Model Driven Architecture™, Model Driven Architecture Logos™, MDA™, OMG Model Driven Architecture™, OMG MDA™ and the XMI Logo™ are trademarks of the Object Management Group. All other products or company names mentioned are used for identification purposes only, and may be trademarks of their respective owners. 
COMPLIANCE
The copyright holders listed above acknowledge that the Object Management Group (acting itself or through its 
designees) is and shall at all times be the sole entity that may authorize developers, suppliers and sellers of computer software to use certification marks, trademarks or other special designations to indicate compliance with these materials.
Software developed under the terms of this license may claim compliance or conformance with this specification if 
and only if the software compliance is of a nature fully matching the applicable compliance points as stated in the specification. Software developed only partially matching the applicable compliance points may claim only that the software was based on this specification, but may not claim compliance or conformance with this specification. In the event that testing suites are implemented or approved by Object Management Group, Inc., software developed using this specification may claim compliance or conformance with the specification only if the software satisfactorily completes the testing suites.
ISSUE REPORTING
All OMG specifications are subject to continuous review and improvement. As part of this process we encourage 
readers to report any ambiguities, inconsistencies, or inaccuracies they may find by completing the Issue Reporting Form listed on the main web page http://www.omg.org, under Documents & Specifications, Report a Bug/Issue. 
                                                    
UML Superstructure 2.0 Draft Adopted Specification        iTable of Contents
1 Scope ........................................................................................................................ ........................................ 1
2 Conformance .................................................................................................................. ................................... 1
3 Normative references ......................................................................................................... ............................... 3
4 Terms and definitions ........................................................................................................ ................................ 4
5 Symbols ...................................................................................................................... ..................................... 18
6 Additional information ....................................................................................................... ............................... 18
6.1 Changes to Adopted OMG Specifications ...................................................................................... ....  18
6.2 Architectural Alignment and MDA Support .................................................................................... .....  18
6.3 How to Read this Specification ............................................................................................. ..............  18
6.4 Acknowledgements........................................................................................................... ..................  19
Part I -  Structure ........................................................................................................... ......................................... 23
7 Classes ...................................................................................................................... ...................................... 25
7.1 Overview................................................................................................................... ..........................  25
7.2 Kernel – the Root Diagram .................................................................................................. ...............  27
7.2.1 Comment (from Kernel) ................................................................................................. 287.2.2 DirectedRelationship (from Kernel) ............................................................................... 287.2.3 Element (from Kernel) ................................................................................................... 2 9
7.2.4 Relationship (from Kernel) ............................................................................................ 30
7.3 Kernel – the Namespaces Diagram............................................................................................ ........  31
7.3.1 ElementImport (from Kernel) ......................................................................................... 317.3.2 NamedElement (from Kernel, Dependencies) .............................................................. 337.3.3 Namespace (from Kernel) ............................................................................................. 357.3.4 PackageableElement (from Kernel) .............................................................................. 377.3.5 PackageImport (from Kernel) ........................................................................................ 387.3.6 VisibilityKind (from Kernel) ............................................................................................ 3 9
7.4 Kernel – the Multiplicities Diagram ........................................................................................ .............  40
7.4.1 MultiplicityElement (from Kernel) .................................................................................. 407.4.2 Type (from Kernel) ....................................................................................................... .4 3
7.4.3 TypedElement (from Kernel) ......................................................................................... 44
7.5 Kernel – the Expressions Diagram ........................................................................................... ..........  45
7.5.1 Expression (from Kernel) .............................................................................................. 457.5.2 OpaqueExpression (from Kernel) .................................................................................. 467.5.3 InstanceValue (from Kernel) ......................................................................................... 477.5.4 LiteralBoolean (from Kernel) ......................................................................................... 487.5.5 LiteralInteger (from Kernel) ........................................................................................... 497.5.6 LiteralNull (from Kernel) ................................................................................................ 49
7.5.7 LiteralSpecification (from Kernel) .................................................................................. 507.5.8 LiteralString (from Kernel) ............................................................................................. 5 1
7.5.9 LiteralUnlimitedNatural (from Kernel) ............................................................................ 517.5.10 ValueSpecification (from Kernel) ................................................................................... 52
7.6 Kernel – the Constraints Diagram........................................................................................... ............  53
7.6.1 Constraint (from Kernel) ................................................................................................ 5 4
7.7 Kernel – the Instances Diagram ............................................................................................. ............  57
7.7.1 InstanceSpecification (from Kernel) .............................................................................. 577.7.2 Slot (from Kernel) ....................................................................................................... ... 60
7.8 Kernel – the Classifiers Diagram ........................................................................................... .............  61
7.8.1 Classifier (from Kernel, Dependencies, PowerTypes) .................................................. 61
ii                 UML Superstructure 2.0 Draft Adopted Specification7.8.2 Generalization (from Kernel, PowerTypes) ................................................................... 66
7.8.3 RedefinableElement (from Kernel) ................................................................................ 70
7.9 Kernel – the Features Diagram.............................................................................................. .............  71
7.9.1 BehavioralFeature (from Kernel) ................................................................................... 727.9.2 Feature (from Kernel) .................................................................................................... 73
7.9.3 Parameter (from Kernel) ............................................................................................... 737.9.4 ParameterDirectionKind (from Kernel) .......................................................................... 747.9.5 StructuralFeature (from Kernel) .................................................................................... 75
7.10 Kernel – the Operations Diagram ........................................................................................... ..........  76
7.10.1 Operation (from Kernel) ................................................................................................ 7 6
7.11 Kernel – the Classes Diagram .............................................................................................. ............  80
7.11.1 AggregationKind (from Kernel) ...................................................................................... 80
7.11.2 Association (from Kernel) .............................................................................................. 8 1
7.11.3 Class (from Kernel) ..................................................................................................... .. 86
7.11.4 Property (from Kernel, AssociationClasses) .................................................................. 89
7.12 Kernel – the DataTypes Diagram............................................................................................ ..........  94
7.12.1 DataType (from Kernel) ................................................................................................. 9 5
7.12.2 Enumeration (from Kernel) ............................................................................................ 967.12.3 EnumerationLiteral (from Kernel) .................................................................................. 977.12.4 PrimitiveType (from Kernel) .......................................................................................... 98
7.13 Kernel – the Packages Diagram ............................................................................................. ..........  99
7.13.1 Package (from Kernel) .................................................................................................. 9 9
7.13.2 PackageMerge (from Kernel) ...................................................................................... 101
7.14 Dependencies.............................................................................................................. ...................  105
7.14.1 Abstraction (from Dependencies) ................................................................................ 1077.14.2 Classifier (from Dependencies) ................................................................................... 1077.14.3 Dependency (from Dependencies) ............................................................................. 1087.14.4 NamedElement (from Dependencies) ......................................................................... 1097.14.5 Permission (from Dependencies) ................................................................................ 1097.14.6 Realization (from Dependencies) ................................................................................ 1107.14.7 Substitution (from Dependencies) ............................................................................... 1107.14.8 Usage (from Dependencies) ....................................................................................... 111
7.15 Interfaces ................................................................................................................ ........................  112
7.15.1 BehavioredClassifier (from Interfaces) ........................................................................ 1137.15.2 Implementation (from Interfaces) ................................................................................ 1137.15.3 Interface (from Interfaces) ........................................................................................... 11 4
7.16 AssociationClasses........................................................................................................ .................  117
7.16.1 AssociationClass (from AssociationClasses) .............................................................. 118
7.17 PowerTypes................................................................................................................ ....................  120
7.17.1 Classifier (from PowerTypes) ...................................................................................... 1217.17.2 Generalization (from PowerTypes) ............................................................................. 1217.17.3 GeneralizationSet (from PowerTypes) ........................................................................ 121
7.18 Diagrams.................................................................................................................. .......................  128
8 Components ................................................................................................................... ............................... 133
8.1 Overview................................................................................................................... ........................  133
8.2 Abstract syntax ............................................................................................................ .....................  134
8.3 Class Descriptions ......................................................................................................... ...................  136
8.3.1 Component ................................................................................................................ .. 136
8.3.2 Connector (from InternalStructures, as specialized) ................................................... 1438.3.3 Realization (from Dependencies, as specialized) ....................................................... 146
8.4 Diagrams ................................................................................................................... .......................  147
UML Superstructure 2.0 Draft Adopted Specification        iii9 Composite Structures ......................................................................................................... ........................... 151
9.1 Overview................................................................................................................... ........................  151
9.2 Abstract syntax ............................................................................................................ .....................  151
9.3 Class Descriptions ......................................................................................................... ...................  156
9.3.1 Class (from StructuredClasses, as specialized) .......................................................... 1569.3.2 Classifier (from Collaborations, as specialized) .......................................................... 1579.3.3 Collaboration (from Collaborations) ............................................................................ 1579.3.4 CollaborationOccurrence (from Collaborations) .......................................................... 1609.3.5 ConnectableElement (from InternalStructures) ........................................................... 1639.3.6 Connector (from InternalStructures) ............................................................................ 1639.3.7 ConnectorEnd (from InternalStructures, Ports) ........................................................... 165
9.3.8 EncapsulatedClassifier (from Ports) ............................................................................ 166
9.3.9 InvocationAction (from Actions, as specialized) .......................................................... 1679.3.10 Parameter (Collaboration, as specialized) .................................................................. 1679.3.11 Port (from Ports) ....................................................................................................... ... 167
9.3.12 Property (from InternalStructures, as specialized) ...................................................... 1719.3.13 StructuredClassifier (from InternalStructures) ............................................................. 1739.3.14 Trigger (from InvocationActions, as specialized) ........................................................ 1779.3.15 Variable (from StructuredActivities, as specialized) .................................................... 178
9.4 Diagrams ................................................................................................................... .......................  178
10 Deployments ................................................................................................................. ................................ 181
10.1 Overview.................................................................................................................. .......................  181
10.2 Abstract syntax ........................................................................................................... ....................  181
10.3 Class Descriptions ........................................................................................................ ..................  184
10.3.1 Artifact ................................................................................................................ ......... 184
10.3.2 CommunicationPath .................................................................................................... 18610.3.3 DeployedArtifact ........................................................................................................ .. 187
10.3.4 Deployment .............................................................................................................. ... 187
10.3.5 DeploymentTarget ....................................................................................................... 1 89
10.3.6 DeploymentSpecification ............................................................................................. 19010.3.7 Device .................................................................................................................. ....... 191
10.3.8 ExecutionEnvironment ................................................................................................ 19210.3.9 InstanceSpecification (from Kernel, as specialized) .................................................... 19410.3.10 Manifestation .......................................................................................................... ..... 194
10.3.11 Node ................................................................................................................... ......... 195
10.3.12 Property (from InternalStructures, as specialized) ...................................................... 197
10.4 Diagrams .................................................................................................................. ......................  198
10.5 Graphical paths........................................................................................................... ....................  199
Part II -  Behavior ........................................................................................................... ...................................... 201
11 Actions ..................................................................................................................... ...................................... 203
11.1 Overview.................................................................................................................. .......................  203
11.2 Abstract Syntax........................................................................................................... ....................  205
11.3 Class Descriptions ........................................................................................................ ..................  216
11.3.1 AcceptCallAction ........................................................................................................ .2 1 6
11.3.2 AcceptEventAction ...................................................................................................... 2 17
11.3.3 AddStructuralFeatureValueAction ............................................................................... 21911.3.4 AddVariableValueAction ............................................................................................. 22011.3.5 ApplyFunctionAction ................................................................................................... 22 2
11.3.6 BroadcastSignalAction ................................................................................................ 22311.3.7 CallAction .............................................................................................................. ...... 224
11.3.8 CallBehaviorAction ...................................................................................................... 224
iv                 UML Superstructure 2.0 Draft Adopted Specification11.3.9 CallOperationAction .................................................................................................... 2 27
11.3.10 ClearAssociationAction ............................................................................................... 22 8
11.3.11 ClearStructuralFeatureAction ...................................................................................... 22911.3.12 ClearVariableAction .................................................................................................... 230
11.3.13 CreateLinkAction ....................................................................................................... .. 231
11.3.14 CreateLinkObjectAction .............................................................................................. 23211.3.15 CreateObjectAction ..................................................................................................... 233
11.3.16 DestroyLinkAction ...................................................................................................... .2 3 4
11.3.17 DestroyObjectAction ................................................................................................... 2 35
11.3.18 InvocationAction ....................................................................................................... ... 236
11.3.19 LinkAction ............................................................................................................. ....... 236
11.3.20 LinkEndCreationData .................................................................................................. 23 7
11.3.21 LinkEndData ............................................................................................................ .... 239
11.3.22 MultiplicityElement (as specialized) ............................................................................ 24011.3.23 PrimitiveFunction ...................................................................................................... ... 240
11.3.24 QualifierValue ......................................................................................................... ..... 241
11.3.25 RaiseExceptionAction ................................................................................................. 24 2
11.3.26 ReadExtentAction ....................................................................................................... 243
11.3.27 ReadIsClassifiedObjectAction ..................................................................................... 24311.3.28 ReadLinkAction ......................................................................................................... .. 244
11.3.29 ReadLinkObjectEndAction .......................................................................................... 24611.3.30 ReadLinkObjectEndQualifierAction ............................................................................. 24711.3.31 ReadSelfAction ......................................................................................................... .. 248
11.3.32 ReadStructuralFeatureAction ...................................................................................... 24911.3.33 ReadVariableAction .................................................................................................... 2 50
11.3.34 ReclassifyObjectAction ............................................................................................... 25 1
11.3.35 RemoveStructuralFeatureValueAction ........................................................................ 25211.3.36 RemoveVariableValueAction ...................................................................................... 25311.3.37 ReplyAction ............................................................................................................ ..... 254
11.3.38 SendObjectAction ....................................................................................................... 254
11.3.39 SendSignalAction ....................................................................................................... .2 5 5
11.3.40 StartOwnedBehaviorAction ......................................................................................... 25711.3.41 StructuralFeatureAction .............................................................................................. 25 8
11.3.42 TestIdentityAction ..................................................................................................... ... 259
11.3.43 VariableAction ......................................................................................................... .... 260
11.3.44 WriteStructuralFeatureAction ...................................................................................... 26011.3.45 WriteLinkAction ........................................................................................................ ... 261
11.3.46 WriteVariableAction .................................................................................................... .2 6 2
11.4 Diagrams.................................................................................................................. .......................  263
12 Activities .................................................................................................................. ...................................... 265
12.1 Overview.................................................................................................................. .......................  265
12.2 Abstract Syntax........................................................................................................... ....................  267
12.3 Class Descriptions ........................................................................................................ ..................  280
12.3.1 Action .................................................................................................................. ........ 280
12.3.2 Activity ................................................................................................................ ......... 283
12.3.3 ActivityEdge ............................................................................................................ .... 293
12.3.4 ActivityFinalNode ....................................................................................................... .2 9 8
12.3.5 ActivityGroup ........................................................................................................... .... 301
12.3.6 ActivityNode ............................................................................................................ .... 302
12.3.7 ActivityParameterNode ............................................................................................... 30412.3.8 ActivityPartition ....................................................................................................... ..... 307
UML Superstructure 2.0 Draft Adopted Specification        v12.3.9 CentralBufferNode ...................................................................................................... 3 11
12.3.10 Clause ................................................................................................................. ........ 313
12.3.11 ConditionalNode ........................................................................................................ .. 313
12.3.12 ControlFlow ............................................................................................................ ..... 315
12.3.13 ControlNode ............................................................................................................ .... 316
12.3.14 DataStoreNode .......................................................................................................... .3 1 8
12.3.15 DecisionNode ........................................................................................................... ... 319
12.3.16 ExceptionHandler ....................................................................................................... .3 2 2
12.3.17 ExecutableNode ......................................................................................................... .3 2 4
12.3.18 ExpansionKind .......................................................................................................... .. 324
12.3.19 ExpansionNode .......................................................................................................... .3 2 5
12.3.20 ExpansionRegion ........................................................................................................ 325
12.3.21 FinalNode .............................................................................................................. ...... 331
12.3.22 FlowFinalNode .......................................................................................................... .. 333
12.3.23 ForkNode ............................................................................................................... ..... 334
12.3.24 InitialNode ............................................................................................................ ....... 335
12.3.25 InputPin ............................................................................................................... ........ 336
12.3.26 InterruptibleActivityRegion .......................................................................................... 33 6
12.3.27 JoinNode ............................................................................................................... ...... 338
12.3.28 LoopNode ............................................................................................................... ..... 341
12.3.29 MergeNode .............................................................................................................. ... 343
12.3.30 ObjectFlow ............................................................................................................. ..... 344
12.3.31 ObjectFlowEffectKind .................................................................................................. 3 49
12.3.32 ObjectNode ............................................................................................................. .... 349
12.3.33 ObjectNodeOrderingKind ............................................................................................ 35212.3.34 OutputPin .............................................................................................................. ...... 352
12.3.35 Parameter (as specialized) ......................................................................................... 35212.3.36 ParameterSet ........................................................................................................... ... 354
12.3.37 Pin .................................................................................................................... ........... 355
12.3.38 StructuredActivityNode ................................................................................................ 3 61
12.3.39 ValuePin ............................................................................................................... ....... 363
12.3.40 Variable ............................................................................................................... ........ 363
12.4 Diagrams .................................................................................................................. ......................  364
13 Common Behaviors ............................................................................................................ ........................... 369
13.1 Overview.................................................................................................................. .......................  369
13.2 Abstract syntax ........................................................................................................... ....................  374
13.3 Class Descriptions ........................................................................................................ ..................  378
13.3.1 Activity (from BasicBehaviors) .................................................................................... 37813.3.2 AnyTrigger (from Communications) ............................................................................ 37913.3.3 Behavior (from BasicBehaviors) .................................................................................. 37913.3.4 BehavioralFeature (from BasicBehaviors, Communications, specialized) .................. 38213.3.5 BehavioredClassifier (from BasicBehaviors) ............................................................... 38313.3.6 CallConcurrencyKind (from Communications) ............................................................ 38413.3.7 CallTrigger (from Communications) ............................................................................ 38513.3.8 ChangeTrigger (from Communications) ...................................................................... 38513.3.9 Class (from Communications, specialized) ................................................................. 38613.3.10 Duration (from Time) ................................................................................................... 387
13.3.11 DurationConstraint (from Time) ................................................................................... 38813.3.12 DurationInterval (from Time) ....................................................................................... 38913.3.13 DurationObservationAction (from Time) ...................................................................... 39013.3.14 Interface (from Communications, specialized) ............................................................ 391
vi                 UML Superstructure 2.0 Draft Adopted Specification13.3.15 Interval (from Time) ................................................................................................... .. 391
13.3.16 IntervalConstraint (from Time) .................................................................................... 39113.3.17 MessageTrigger (from Communications) .................................................................... 39213.3.18 OpaqueExpression (from BasicBehaviors, specialized) .............................................. 39313.3.19 Operation (from Communications, as specialized) ...................................................... 39313.3.20 Reception (from Communications) .............................................................................. 39413.3.21 Signal (from Communications) .................................................................................... 39513.3.22 SignalTrigger (from Communications) ......................................................................... 39613.3.23 TimeConstraint (from Time) ........................................................................................ 39613.3.24 TimeExpression (from Time) ....................................................................................... 39713.3.25 TimeInterval (from Time) ............................................................................................. 39 8
13.3.26 TimeObservationAction (from Time) ........................................................................... 399
13.3.27 TimeTrigger (from Communications) ........................................................................... 39913.3.28 Trigger (from Communications) .................................................................................. 400
14 Interactions ................................................................................................................ .................................... 403
14.1 Overview.................................................................................................................. .......................  403
14.2 Abstract syntax ........................................................................................................... ....................  404
14.3 Class Descriptions ........................................................................................................ ..................  409
14.3.1 CombinedFragment (from Fragments) ........................................................................ 40914.3.2 Continuation (from Fragments) ................................................................................... 41414.3.3 EventOccurrence (from BasicInteractions) ................................................................. 41614.3.4 ExecutionOccurrence (from BasicInteractions) ........................................................... 41714.3.5 Gate (from Fragments) ................................................................................................ 41814.3.6 GeneralOrdering (from BasicInteractions) .................................................................. 41814.3.7 Interaction (from BasicInteraction, Fragments) ........................................................... 41914.3.8 InteractionConstraint (from Fragments) ...................................................................... 42114.3.9 InteractionFragment (from Fragments) ....................................................................... 42214.3.10 InteractionOccurrence (from Fragments) .................................................................... 42314.3.11 InteractionOperand (from Fragments) ......................................................................... 42514.3.12 InteractionOperator (from Fragments) ........................................................................ 42614.3.13 Lifeline (from BasicInteractions, Fragments) ............................................................... 42714.3.14 Message (from BasicInteractions) ............................................................................... 42814.3.15 MessageEnd (from BasicInteractions) ........................................................................ 43114.3.16 PartDecomposition (from Fragments) ......................................................................... 43114.3.17 StateInvariant (from BasicInteractions) ....................................................................... 43314.3.18 Stop (from BasicInteractions) ...................................................................................... 434
14.4 Diagrams.................................................................................................................. .......................  435
15 State Machines .............................................................................................................. ................................ 455
15.1 Overview.................................................................................................................. .......................  455
15.2 Abstract Syntax........................................................................................................... ....................  456
15.3 Class Descriptions ........................................................................................................ ..................  459
15.3.1 ConnectionPointReference (from BehaviorStatemachines) ........................................ 45915.3.2 Interface (from ProtocolStatemachines, as specialized) ............................................. 46115.3.3 FinalState (from BehaviorStatemachines) .................................................................. 46215.3.4 Port ( (from ProtocolStatemachines, as specialized) .................................................. 46315.3.5 ProtocolConformance (from ProtocolStatemachines) ................................................. 46315.3.6 ProtocolStateMachine (from ProtocolStatemachines) ................................................. 46415.3.7 ProtocolTransition (from ProtocolStateMachines) ....................................................... 46615.3.8 PseudoState (from BehaviorStatemachines) .............................................................. 46915.3.9 PseudoStateKind (from BehaviorStatemachines) ....................................................... 47515.3.10 Region (from BehaviorStatemachines) ....................................................................... 476
UML Superstructure 2.0 Draft Adopted Specification        vii15.3.11 State (from BehaviorStatemachines) .......................................................................... 477
15.3.12 StateMachine (from BehaviorStatemachines) ............................................................. 48915.3.13 TimeTrigger ( from BehaviorStatemachines, as specialized) ...................................... 49815.3.14 Transition (from BehaviorStatemachines) ................................................................... 49815.3.15 Vertex (from BehaviorStatemachines) ........................................................................ 50515.3.16 TransitionKind ......................................................................................................... .... 506
15.4 Diagrams .................................................................................................................. ......................  507
16 Use Cases ................................................................................................................... .................................. 511
16.1 Overview.................................................................................................................. .......................  511
16.2 Abstract syntax ........................................................................................................... ....................  511
16.3 Class Descriptions ........................................................................................................ ..................  512
16.3.1 Actor (from UseCases) ................................................................................................ 512
16.3.2 Classifier (from UseCases, as specialized) ................................................................. 51416.3.3 Extend (from UseCases) ............................................................................................. 51516.3.4 ExtensionPoint (from UseCases) ................................................................................ 51616.3.5 Include (from UseCases) ............................................................................................ 51716.3.6 UseCase (from UseCases) ......................................................................................... 519
16.4 Diagrams .................................................................................................................. ......................  523
Part III -  Supplement ........................................................................................................ ................................... 529
17 Auxiliary Constructs ........................................................................................................ ............................... 531
17.1 Overview.................................................................................................................. .......................  531
17.2 InformationFlows .......................................................................................................... ..................  531
17.2.1 InformationFlow (from InformationFlows) .................................................................... 53217.2.2 InformationItem (from InformationFlows) .................................................................... 533
17.3 Models .................................................................................................................... ........................  535
17.3.1 Model (from Models) ................................................................................................... 53 5
17.4 PrimitiveTypes ............................................................................................................ ....................  537
17.4.1 Boolean (from PrimitiveTypes) .................................................................................... 53817.4.2 Integer (from PrimitiveTypes) ...................................................................................... 53817.4.3 String (from PrimitiveTypes) ........................................................................................ 53917.4.4 UnlimitedNatural (from PrimitiveTypes) ...................................................................... 540
17.5 Templates ................................................................................................................. ......................  541
17.5.1 ParameterableElement ............................................................................................... 54317.5.2 TemplateableElement ................................................................................................. 54517.5.3 TemplateBinding ......................................................................................................... 547
17.5.4 TemplateParameter .................................................................................................... 54817.5.5 TemplateParameterSubstitution .................................................................................. 54917.5.6 TemplateSignature ...................................................................................................... 5 50
17.5.7 Classifier (as specialized) ........................................................................................... 55 2
17.5.8 ClassifierTemplateParameter ...................................................................................... 55617.5.9 RedefinableTemplateSignature ................................................................................... 55717.5.10 Package (as specialized) ............................................................................................ 55817.5.11 NamedElement (as specialized) ................................................................................. 56017.5.12 Operation (as specialized) .......................................................................................... 56317.5.13 Operation (as specialized) .......................................................................................... 56317.5.14 OperationTemplateParameter ..................................................................................... 56417.5.15 ConnectableElement (as specialized) ......................................................................... 56517.5.16 ConnectableElementTemplateParameter ................................................................... 56617.5.17 Property (as specialized) ............................................................................................. 5 67
17.5.18 ValueSpecification (as specialized) ............................................................................. 568
18 Profiles .................................................................................................................... ...................................... 569
viii                 UML Superstructure 2.0 Draft Adopted Specification18.1 Overview.................................................................................................................. .......................  569
18.2 Abstract syntax ........................................................................................................... ....................  570
18.3 Class descriptions........................................................................................................ ...................  570
18.3.1 Extension (from Profiles) ............................................................................................. 57 0
18.3.2 ExtensionEnd (from Profiles) ...................................................................................... 57318.3.3 Class (from Constructs, Profiles) ................................................................................ 57418.3.4 Package (from Constructs, Profiles) ........................................................................... 57518.3.5 Profile (from Profiles) ................................................................................................. .5 7 5
18.3.6 ProfileApplication (from Profiles) ................................................................................. 57818.3.7 Stereotype (from Profiles) ........................................................................................... 580
18.4 Diagrams.................................................................................................................. .......................  583
Part IV -  Appendices ......................................................................................................... .................................. 585
Appendix A. Diagrams ........................................................................................................... ..............................  587
Appendix B. Standard Stereotypes............................................................................................... .......................  593
B.1 Basic...................................................................................................................... ...........................  593
B.2 Intermediate............................................................................................................... .......................  596
B.3 Complete ................................................................................................................... .......................  597
Appendix C.  Component Profile Examples........................................................................................ .................  599
C.1 J2EE/EJB Component Profile Example ......................................................................................... ..  599
C.2 COM Component Profile Example .............................................................................................. .....  600
C.3 .NET Component Profile Example ............................................................................................. ......  600
C.4 CCM Component Profile Example .............................................................................................. .....  601
Appendix D.  Tabular Notations ................................................................................................. ..........................  603
D.1 Tabular Notation for Sequence Diagrams..................................................................................... ...  603
D.2 Tabular Notation for Other Behavioral Diagrams .............................................................................  605
Appendix E.  Classifiers Taxonomy .............................................................................................. .......................  607
Appendix F. XMI Serialization and Schema....................................................................................... ..................  609
Index ......................................................................................................................... ........................................... 611
UML Superstructure 2.0 Draft Adopted Specification        11 Scope
This UML 2.0: Superstructure  is the second of two complementary specifications that represent a major revision to the Object 
Management Group’s Unified Modeling Language (UML), for which the most current version is UML v1.4. The first specification, which serves as the architectural foundation for this specification, is the UML 2.0: Infrastructure .
This UML 2.0: Superstructure  defines the user level constructs required for UML 2.0.  It is complemented by UML 2.0: 
Infrastructure which defines the foundational language constructs required for UML 2.0. The two complementary 
specifications constitute a complete specification for the UML 2.0 modeling language. 
Editorial Comment: The FTF needs to review and complete this section -- this version was derived by a literal 
copying of the “Introduction” section of the Preface in the Draft Adopted Specification
2 Conformance
Editorial Comment: The FTF needs to review and complete this section -- this version was derived by literal 
copying the “Compliance Points” section of the Preface in the Draft Adopted Specification
The basic units of compliance for UML are the packages which define the UML metamodel. Unless otherwise qualified, complying with a package requires complying with its abstract syntax, well-formedness rules, semantics, notation and XMI schema. Complying with a particular package requires complying with any packages on which the particular package depends via a package merge or import relationship
In the case of the UML Superstructure, the metamodel is organized into medium-grain packages (compare the InfrastructureLibrary’s fine-grained packages) that support flexible compliance points. All UML 2.0 compliant implementations are required to implement the UML::Classes::Kernel package. All other UML Superstructure packages are optional compliance points.
The following table summarizes the compliance points of the UML 2.0: Superstructure, where the following compliance options are valid:
 no compliance: Implementation does not comply with the abstract syntax, well-formedness rules, semantics and nota-
tion of the package.
 partial compliance: Implementation partially complies with the abstract syntax, well-formedness rules, semantics and 
notation of the package.
 compliant compliance: Implementation fully complies with the abstract syntax, well-formedness rules, semantics and 
notation of the package
 interchange compliance: Implementation fully complies with the abstract syntax, well-formedness rules, semantics, 
notation and XMI schema of the package.
2                 UML Superstructure 2.0 Draft Adopted SpecificationTable 1 Summary of Compliance Points
Compliance Level Compliance Point Valid Options
Basic (Level 1) Classes::Kernel complete, interchange
Basic (Level 1) Activities::BasicActivities no, partial, complete, interchangeBasic (Level 1) AuxiliaryConstructs::Primitives no, partial, complete, interchangeBasic (Level 1) Classes::Dependencies no, partial, complete, interchangeBasic (Level 1) Classes::Interfaces no, partial, complete, interchangeBasic (Level 1) CommonBehaviors::
BasicBehaviorsno, partial, complete, interchange
Basic (Level 1) CompositeStructures::
InternalStructuresno, partial, complete, interchange
Basic (Level 1) Interactions::BasicInteractions no, partial, complete, interchange
Basic (Level 1) AuxiliaryConstructs::
PrimitiveTypesno, partial, complete, interchange
Basic (Level 1) UseCases no, partial, complete, interchange
Intermediate (Level 2) Actions::IntermediateActions no, partial, complete, interchangeIntermediate (Level 2) Activities::
IntermediateActivitiesno, partial, complete, interchange
Intermediate (Level 2) Activities::
StructuredActivitiesno, partial, complete, interchange
Intermediate (Level 2) CommonBehaviors::
Communicationsno, partial, complete, interchange
Intermediate (Level 2) CommonBehaviors::Time no, partial, complete, interchange
Intermediate (Level 2) Components::BasicComponents no, partial, complete, interchangeIntermediate (Level 2) CompositeStructures::Actions no, partial, complete, interchangeIntermediate (Level 2) CompositeStructures::Ports no, partial, complete, interchangeIntermediate (Level 2) CompositeStructures::
StructuredClassesno, partial, complete, interchange
Intermediate (Level 2) Deployments::Artifacts no, partial, complete, interchange
Intermediate (Level 2) Deployments::Nodes no, partial, complete, interchangeIntermediate (Level 2) Interactions::Fragments no, partial, complete, interchangeIntermediate (Level 2) Profiles no, partial, complete, interchangeIntermediate (Level 2) StateMachines::
BehaviorStateMachinesno, partial, complete, interchange
UML Superstructure 2.0 Draft Adopted Specification        33 Normative references
The following normative documents contain provisions which, through reference in this text, constitute provisions of this 
specification . For dated references, subsequent amendments to, or revisions of, any of these publications do not apply. 
 UML 2.0 Superstructure RFP
 UML 2. Infrastructure Specification
 MOF 2.0 Specification
 
Editorial Comment: The FTF needs to review and complete this sectionIntermediate (Level 2) StateMachines::
MaximumOneRegionno, partial, complete, interchange
Complete (Level 3) Actions::CompleteActions no, partial, complete, interchange
Complete (Level 3) Activities::CompleteActivities no, partial, complete, interchangeComplete (Level 3) Activities::
CompleteStructuredActivitiesno, partial, complete, interchange
Complete (Level 3) Activities::
ExtraStructuredActivitiesno, partial, complete, interchange
Complete (Level 3) AuxiliaryConstructs::
InformationFlowsno, partial, complete, interchange
Complete (Level 3) AuxiliaryConstructs::
Modelsno, partial, complete, interchange
Complete (Level 3) AuxiliaryConstructs::Templates no, partial, complete, interchange
Complete (Level 3) Classes::
AssociationClassesno, partial, complete, interchange
Complete (Level 3) Classes::
PowerTypesno, partial, complete, interchange
Complete (Level 3) CompositeStructures::
Collaborationsno, partial, complete, interchange
Complete (Level 3) Components::
PackagingComponentsno, partial, complete, interchange
Complete (Level 3) Deployments::
ComponentDeploymentsno, partial, complete, interchange
Complete (Level 3) StateMachines::ProtocolStateMachines no, partial, complete, interchangeTable 1 Summary of Compliance Points
4                 UML Superstructure 2.0 Draft Adopted Specification4 Terms and definitions
Editorial Comment: The FTF needs to review and complete this section -- the version in this document was 
produced by literal copying of the contents of the Glossary from the Draft Adopted Spec (Appendix G) into this 
section.
For the purposes of this specification, the terms and definitions given in the normative references and the following apply.
(Note: The following conventions are used in the term definitions below:
 The entries usually begin with a lowercase letter. An initial uppercase letter is used when a word is usually capitalized 
in standard practice. Acronyms are all capitalized, unless they traditionally appear in all lowercase.
 When one or more words in a multi-word term is enclosed in brackets, it indicates that those words are optional when referring to the term. For example, use case [class]  may be referred to as simply use case .
 A phrase of the form “Contrast: <term>” refers to a term that has an opposed or substantively different meaning.
  A phrase of the form “See: <term>” refers to a related term that has a similar, but not synonymous meaning.
  A phrase of the form “Synonym: <term>” indicates that the term has the same meaning as another term, which is ref-
erenced.
  A phrase of the form “Acronym: <term>” indicates that the term is an acronym. The reader is usually referred to the spelled-out term for the definition, unless the spelled-out term is rarely used.)
abstract class
A class that cannot be directly instantiated. Contrast: concrete class .
abstraction
The result of empasizing certain features of a thing while de-emphasizing other features that are not relative. An 
abstraction is definedrelative to the perspective of the viewer. 
action
A fundamental unit of behavior specification that represents some transformation or processing in the modeled system, be it a computer system or a real-world system. Actions are contained in activities, which provide their context. See: activity .
action sequence
An expression that resolves to a sequence of actions.
action state
A state that represents the execution of an atomic action, typically the invocation of an operation.
activation
The initiation of an action execution.
active class
A class whose instances are active objects. See: active object.  
active object
An object that may execute its own behavior without requiring method invocation. This is sometimes referred to as 
“the object having its own thread of control.” The points at which an active object responds to communications from other objects are determined solely by the behavior of the active object and not by the invoking object. This implies that an active object is both autonomous and interactive to some degree. See: active class, thread.
activity
A specification of parameterized behavior that is expressed as a flow of execution via a sequencing of subordinate 
units (whose primitive elements are individual actions). See actions . 
activity diagram
UML Superstructure 2.0 Draft Adopted Specification        5A diagram that depicts behavior using a control and data-flow model. 
actor
A construct that is employed in use cases that define a role that a user or any other system plays when interacting 
with the system under consideration. It is a type of entity that interacts, but which is itself external to the subject. Actors may represent human users, external hardware, or other subjects. An actor does not necessarily represent a specific physical entity. For instance, a single physical entity may play the role of several different actors and, conversely, a given actor may be played by multiple physical entities.
actual parameter
Synonym: argument .
aggregate
A class that represents the “whole” in an aggregation (whole-part) relationship. See: aggregation .
aggregation
A special form of association that specifies a whole-part relationship between the aggregate (whole) and a 
component part. See: composition .
analysis
The phase of the system development process whose primary purpose is to formulate a model of the problem 
domain that is independent of implementation considerations. Analysis focuses on what to do; design focuses on how to do it. Contrast: design .
analysis time
Refers to something that occurs during an analysis phase of the software development process. See: design time, 
modeling time. 
argument
A binding for a parameter that is resolved later. An independent variable.
artifact
A physical piece of information that is used or produced by a development process. Examples of Artifacts include models, source files, scripts, and binary executable files. An artifact may constitute the implementation of a deployable component. Synonym: product . Contrast: component .
association
A relationship that may occur between instances of classifiers.
association class
A model element that has both association and class properties. An association class can be seen as an 
association that also has class properties, or as a class that also has association properties. 
association end
The endpoint of an association, which connects the association to a classifier. 
attribute
A structural feature of a classifier that characterizes instances of the classifier. An attribute relates an instance of a classifier to a value or values through a named relationship.
auxiliary class
A stereotyped class that supports another more central or fundamental class, typically by implementing secondary logic or control flow. Auxiliary classes are typically used together with focus classes, and are particularly useful for specifying the secondary business logic or control flow of components during design. See also: focus .
behavior
The observable effects of an operation or event, including its results. It specifies the computation that generates the 
effects of the behavioral feature. The description of a behavior can take a number of forms: interaction, statemachine, activity, or procedure (a set of actions). 
behavior diagram
A form of diagram that depict behavioral features.
behavioral feature
A dynamic feature of a model element, such as an operation or method.
behavioral model aspect
A model aspect that emphasizes the behavior of the instances in a system, including their methods, collaborations, 
6                 UML Superstructure 2.0 Draft Adopted Specificationand state histories. 
binary association
An association between two classes. A special case of an n-ary association.
binding
The creation of a model element from a template by supplying arguments for the parameters of the template.
boolean
An enumeration whose values are true and false. 
boolean expression
An expression that evaluates to a boolean value. 
cardinality
The number of elements in a set. Contrast: multiplicity .
child
In a generalization relationship, the specialization of another element, the parent. See: subclass , subtype . 
Contrast: parent .
call
An action state that invokes an operation on a classifier.
class
A classifier that desctibes of a set of objects that share the same specifications of features, constraints, and 
semantics.
classifier
A collection of instances that have something in common. A classifier can have features that characterize its instances. Classifiers include interfaces, classes, datatypes, and components.
classification
The assignment of an instance to a classifier. See dynamic classification , multiple classification  and static 
classification . 
class diagram
A diagram that shows a collection of declarative (static) model elements, such as classes, types, and their contents 
and relationships. 
client
A classifier that requests a service from another classifier. Contrast: supplier.  
collaboration
The specification of how an operation or classifier, such as a use case, is realized by a set of classifiers and 
associations playing specific roles used in a specific way. The collaboration defines an interaction. See: interaction . 
collaboration occurrence
A particular use of a collaboration to explain the relationships between the parts of a classifier or the properties of 
an operation. It may also be used to indicate how a collaboration represents a classifier or an operation. A collaboration occurrence indicates a set of roles and connectors that cooperate within the classifier or operation according to a given collaboration, indicated by the type of the collaboration occurrence. There may be multiple occurrences of a given collaboration within a classifier or operation, each involving a different set of roles and connectors. A given role or connector may be involved in multiple occurrences of the same or different collaborations. See: collaboration . 
communication diagram
A diagram that focuses on the interaction between lifelines where the architecture of the internal structure and how 
this corresponds with the message passing is central. The sequencing of messages is given through a sequence numberering scheme. Sequence diagrams and communication diagrams express similar information, but show it in different ways. See: sequence diagram . 
compile time
Refers to something that occurs during the compilation of a software module. See: modeling time, run time .
component
A modular part of a system that encapsulates its contents and whose manifestation is replaceable within its 
environment. A component defines its behavior in terms of provided and required interfaces. As such, a component 
UML Superstructure 2.0 Draft Adopted Specification        7serves as a type, whose conformance is defined by these provided and required interfaces (encompassing both 
their static as well as dynamic semantics). 
component diagram
A diagram that shows the organizations and dependencies among components.
composite
A class that is related to one or more classes by a composition relationship. See: composition .
composite aggregation
Synonym: composition . 
composite state
A state that consists of either concurrent (orthogonal) substates or sequential (disjoint) substates. See: substate .
composite structure diagram
A diagram that depicts the internal structure of a classifier, including the interaction points of the classifier to other 
parts of the system. It shows the configuration of parts that jointly perform the behavior of the containing classifier. The architecture diagram specifies a set of instances playing parts (roles), as well as their required relationships given in a particular context.
composition
A form of aggregation which requires that a part instance be included in at most one composite at a time, and that the composite object is responsible for the creation and destruction of the parts. Composition may be recursive. 
Synonym: composite aggregation .
concrete class
A class that can be directly instantiated. Contrast: abstract class.
concurrency
The occurrence of two or more activities during the same time interval. Concurrency can be achieved by 
interleaving or simultaneously executing two or more threads. See: thread.  
concurrent substate
A substate that can be held simultaneously with other substates contained in the same composite state. See: 
composite state.  Contrast: disjoint substate.  
connectable element
An abstract metaclass representing model elements which may be linked via connector. See: connector .
connector
A link that enables communication between two or more instances. The link may be realized by something as 
simple as a pointer or by something as complex as a network connection. 
constraint
A semantic condition or restriction. It can be expressed in natural language text, mathematically formal notation, or in a machine-readable language for the purpose of declaring some of the semantics of a model element.
container
1. An instance that exists to contain other instances, and that provides operations to access or iterate over its contents. (for example, arrays, lists, sets). 
2. A component that exists to contain other components.
containment hierarchy
A namespace hierarchy consisting of model elements, and the containment relationships that exist between them. A containment hierarchy forms a graph.
context
A view of a set of related modeling elements for a particular purpose, such as specifying an operation. 
data type
A type whose values have no identity (i.e., they are pure values). Data types include primitive built-in types (such as integer and string) as well as enumeration types.
delegation
The ability of an object to issue a message to another object in response to a message. Delegation can be used as an alternative to inheritance. Contrast: inheritance .
dependency
8                 UML Superstructure 2.0 Draft Adopted SpecificationA relationship between two modeling elements, in which a change to one modeling element (the independent 
element) will affect the other modeling element (the dependent element). 
deployment diagram
A diagram that depicts the execution architecture of systems. It represents system artifacts as nodes, which are connected through communication paths to create network systems of arbitrary complexity. Nodes are typically defined in a nested manner, and represent either hardware devices or software execution environments. See: component diagrams .
derived element
A model element that can be computed from another element, but that is shown for clarity or that is included for 
design purposes even though it adds no semantic information. 
design
The phase of the system development process whose primary purpose is to decide how the system will be implemented. During design strategic and tactical decisions are made to meet the required functional and quality requirements of a system. 
design time
Refers to something that occurs during a design phase of the system development process. See: modeling time . 
Contrast: analysis time . 
development process
A set of partially ordered steps performed for a given purpose during system development, such as constructing 
models or implementing models. 
diagram
A graphical presentation of a collection of model elements, most often rendered as a connected graph of arcs (relationships) and vertices (other model elements). UML supports the diagrams listed in Appendix A.
disjoint substate
A substate that cannot be held simultaneously with other substates contained in the same composite state. See: composite state . Contrast: concurrent substate .
distribution unit
A set of objects or components that are allocated to a process or a processor as a group. A distribution unit can be 
represented by a run-time composite or an aggregate. 
domain
An area of knowledge or activity characterized by a set of concepts and terminology understood by practitioners in that area. 
dynamic classification
The assignment of an instance from one classifier to another. Contrast: multiple classification, static classification .
element
A constituent of a model. 
entry action
An action that a method executes when an object enters a state in a state machine regardless of the transition 
taken to reach that state.
enumeration
A data type whose instances a list of named values. For example, RGBColor = {red, green, blue}. Boolean is a predefined enumeration with values from the set {false, true}.
event
The specification of a significant occurrence that has a location in time and space and can cause the execution of an associated behavior. In the context of state diagrams, an event is an occurrence that can trigger a transition. 
exception
A special kind of signal, typically used to signal fault situations. The sender of the exception aborts execution and execution resumes with the receiver of the exception, which may be the sender itself. The receiver of an exception is determined implicitly by the interaction sequence during execution; it is not explicitly specified.
execution occurrence
A unit of behavior within the lifeline as represented on an interaction diagram.
UML Superstructure 2.0 Draft Adopted Specification        9exit action
An action that a method executes when an object exits a state in a state machine regardless of the transition taken 
to exit that state.
export
In the context of packages, to make an element visible outside its enclosing namespace. See: visibility.  Contrast: 
export  [OMA],  import . 
expression
A string that evaluates to a value of a particular type. For example, the expression “(7 + 5 * 3)” evaluates to a value 
of type number. 
extend
A relationship from an extension use case to a base use case, specifying how the behavior defined for the 
extension use case augments (subject to conditions specified in the extension) the behavior defined for the base 
use case. The behavior is inserted at the location defined by the extension point in the base use case. The base use case does not depend on performing the behavior of the extension use case. See extension point , include .
extension
An aggregation that is used to indicate that the properties of a metaclass are extended through a stereotype, and 
that gives the ability to flexibly add and remove stereotypes from classes.
facade
A stereotyped package containing only references to model elements owned by another package. It is used to provide a ‘public view’ of some of the contents of a package.
feature
A property, such as an operation or attribute, that characterizes the instances of a classifier.
final state
A special kind of state signifying that the enclosing
composite state or the entire state machine is completed.
fire
To execute a state transition. See: transition . 
focus class
A stereotyped class that defines the core logic or control flow for one or more auxiliary classes that support it. 
Focus classes are typically used together with one or more auxiliary classes, and are particularly useful for specifying the core business logic or control flow of components during design. See also: auxiliary class .
focus of control
A symbol on a sequence diagram that shows the period of time during which an object is performing an action, 
either directly or through a subordinate procedure. 
formal parameter
Synonym: parameter .
framework
A stereotyped package that contains model elements which specify a reusable architecture for all or part of a 
system. Frameworks typically include classes, patterns or templates. When frameworks are specialized for an application domain, they are sometimes referred to as application frameworks. See: pattern .
generalizable element
A model element that may participate in a generalization relationship. See: generalization . 
generalization
A taxonomic relationship between a more general classifier and a more specific classifier. Each instance of the 
specific classifier is also an indirect instance of the general classifier. Thus, the specific classifier indirectly has features of the more general classifier. See: inheritance.
guard condition
A condition that must be satisfied in order to enable an associated transition to fire.
implementation
A definition of how something is constructed or computed. For example, a class is an implementation of a type, a 
method is an implementation of an operation. 
10                 UML Superstructure 2.0 Draft Adopted Specificationimplementation class
A stereotyped class that specifies the implementation of a class in some programming language (e.g., C++, 
Smalltalk, Java) in which an instance may not have more than one class. An Implementation class is said to realize a type if it provides all of the operations defined for the type with the same behavior as specified for the type's operations. See also: type.
implementation inheritance
The inheritance of the implementation of a more general element. Includes inheritance of the interface. Contrast: 
interface inheritance . 
import
In the context of packages, a dependency that shows the packages whose classes may be referenced within a 
given package (including packages recursively embedded within it). Contrast: export . 
include
A relationship from a base use case to an inclusion use case, specifying how the behavior for the base use case 
contains the behavior of the inclusion use case. The behavior is included at the location which is defined in the base use case. The base use case depends on performing the behavior of the inclusion use case, but not on its structure (i.e., attributes or operations). See extend .
inheritance
The mechanism by which more specific elements incorporate structure and behavior of more general elements. 
See generalization .
initial state
A special kind of state signifying the source for a single transition to the default state of the composite state.
instance
An entity that has unique identity, a set of operations that can be applied to it, and state that stores the effects of the 
operations. See: object . 
interaction
A specification of how stimuli are sent between instances to perform a specific task. The interaction is defined in 
the context of a collaboration. See collaboration.
interaction diagram
A generic term that applies to several types of diagrams that emphasize object interactions. These include 
communication diagrams, sequence diagrams, and the interaction overview diagram.
interaction overview diagram
A disgram that depicts interactions through a variant of
activity diagrams in a way that promotes overview of
the control flow. It focuses on the overview of the flow of control where each node can be an interaction diagram.
interface
A named set of operations that characterize the behavior of an element.
interface inheritance
The inheritance of the interface of a more general element. Does not include inheritance of the implementation. Contrast: implementation inheritance . 
internal transition
A transition signifying a response to an event without changing the state of an object.
layer
The organization of classifiers or packages at the same level of abstraction. A layer may represent a horizontal 
slice through an architecture, whereas a partition represents a vertical slice. Contrast: partition .
lifeline
A modeling element that represents an individual participant in an interaction. A lifeline represents only one 
interacting entity. 
link
A semantic connection among a tuple of objects. An instance of an association. See: association . 
link end
An instance of an association end. See: association end . 
UML Superstructure 2.0 Draft Adopted Specification        11message
A specification of the conveyance of information from one instance to another, with the expectation that activity will 
ensue. A message may specify the raising of a signal or the call of an operation.
metaclass
A class whose instances are classes. Metaclasses are typically used to construct metamodels. 
meta-metamodel
A model that defines the language for expressing a metamodel. The relationship between a meta-metamodel and a metamodel is analogous to the relationship between a metamodel and a model. 
metamodel
A model that defines the language for expressing a model.
metaobject
A generic term for all metaentities in a metamodeling language. For example, metatypes, metaclasses, metaattributes, and metaassociations.
method
The implementation of an operation. It specifies the algorithm or procedure associated with an operation.
model aspect
A dimension of modeling that emphasizes particular qualities of the metamodel. For example, the structural model aspect emphasizes the structural qualities of the metamodel. 
model elaboration
The process of generating a repository type from a published model. Includes the generation of interfaces and implementations which allows repositories to be instantiated and populated based on, and in compliance with, the model elaborated. 
model element
An element that is an abstraction drawn from the system being modeled. Contrast: view element .
model library
A stereotyped package that contains model elements that are intended to be reused by other packages. A model 
library differs from a profile in that a model library does not extend the metamodel using stereotypes and tagged definitions. A model library is analogous to a class library in some programming languages.
modeling time
Refers to something that occurs during a modeling phase of the system development process. It includes analysis time and design time. Usage note: When discussing object systems, it is often important to distinguish between modeling-time and run-time concerns. See: analysis time, design time . Contrast: run time . 
multiple classification
The assignment of an instance directly to more than one classifier at the same time. See: static classification , 
dynamic classification . 
multiple inheritance
A semantic variation of generalization in which a type may have more than one supertype. Contrast: single 
inheritance . 
multiplicity
A specification of the range of allowable cardinalities that a set may assume. Multiplicity specifications may be 
given for association ends, parts within composites, repetitions, and other purposes. Essentially a multiplicity is a (possibly infinite) subset of the non-negative integers. Contrast: cardinality .   
n-ary association
An association among three or more classes. Each instance of the association is an n-tuple of values from the 
respective classes. Contrast: binary association . 
name
A string used to identify a model element. 
namespace
A part of the model in which the names may be defined and used. Within a namespace, each name has a unique 
meaning. See: name . 
node
12                 UML Superstructure 2.0 Draft Adopted SpecificationA classifier that represents a run-time computational resource, which generally has at least memory and often 
processing capability. Run-time objects and components may reside on nodes. 
note
An annotation attached to an element or a collection of elements. A note has no semantics. Contrast: constraint .
object
An instance of a class. See: class, instance . 
object diagram
A diagram that encompasses objects and their relationships at a point in time. An object diagram may be 
considered a special case of a class diagram or a communication diagram. See: class diagram, communication 
diagram. 
object flow state
A state in an activity diagram that represents the passing of an object from the output of actions in one state to the input of actions in another state.
object lifeline
A line in a sequence diagram that represents the existence of an object over a period of time. See: sequence 
diagram . 
operation
A feature which declares a service that can be performed by instances of the classifier of which they are instances.
package
A general purpose mechanism for organizing elements into groups. Packages may be nested within other 
packages.
package diagram
A diagram that depicts how model elements are organized into packages and the dependencies among them, including package imports and package extensions.
parameter
An argument of a behavioral feature. A parameter specifies arguments that are passed into or out of an invocation of a behavioral element like an operation. A parameter’s type restricts what values can be passed. Synonyms: formal parameter . Contrast: argument .
parameterized element
The descriptor for a class with one or more unbound parameters. Synonym: template .
parent
In a generalization relationship, the generalization of another element, the child. See: subclass , subtype . Contrast: 
child.
part
An element representing a set of instances that are owned by a containing classifier instance or role of a classifier. 
(See role.) Parts may be joined by attached connectors and specify configurations of linked instances to be created 
within an instance of the containing classifier.
participate
The connection of a model element to a relationship or to a reified relationship. For example, a class participates in an association, an actor participates in a use case.
partition
A grouping of any set of model elements based on a set of criteria.
1. activity diagram: A grouping of activity nodes and edges. Partitions divide the nodes and edges to constrain and show a view of the contained nodes. Partitions can share contents. They often correspond to organizational units in a business model. They may be used to allocate characteristics or resources among the nodes of an activity.
2. architecture: A set of related classifiers or packages at the same level of abstraction or across layers in a layered architecture. A partition represents a vertical slice through an architecture, whereas a layer represents a horizontal slice. Contrast: layer .
pattern
A template collaboration that describes the structure of
a design pattern. UML patterns are more limited than those used by the design pattern community. In general, 
UML Superstructure 2.0 Draft Adopted Specification        13design patterns involve many non-structural aspects, such as heuristics for their use and usage trade-offs. 
persistent object
An object that exists after the process or thread that created it has ceased to exist.
pin
A model element that represents the data values passed into a behavior upon its invocation as well as the data 
values returned from a behavior upon completion of its execution.
port
A feature of a classifier that specifies a distinct interaction point between that classifier and its environment or between the (behavior of the) classifier and its internal parts. Ports are connected to other ports through connectors through which requests can be made to invoke the behavioral features of a classifier. 
postcondition
A constraint expresses a condition that must be true at the completion of an operation. 
powertype
A classifier whose instances are also subclasses of another classifier. Power types, then, are metaclasses with an extra twist: the instances are also subclasses.
precondition
A constraint expresses a condition that must be true when an operation is invoked. 
primitive type
A pre-defined data type without any relevant substructure (i.e., is not decomposable) such as an integer or a string. It may have an algebra and operations defined outside of UML, for example, mathematically.
procedure
A set of actions that may be attached as a unit to other parts of a model, for example, as the body of a method. Conceptually a procedure, when executed, takes a set of values as arguments and produces a set of values as results, as specified by the parameters of the procedure.
process
1. A heavyweight unit of concurrency and execution in an operating system. Contrast: thread , which includes 
heavyweight and lightweight processes. If necessary, an implementation distinction can be made using stereotypes.
2. A software development process—the steps and guidelines by which to develop a system.
3. To execute an algorithm or otherwise handle something dynamically.
profile
A stereotyped package that contains model elements that have been customized for a specific domain or purpose using extension mechanisms, such as stereotypes, tagged definitions and constraints. A profile may also specify model libraries on which it depends and the metamodel subset that it extends.
projection
A mapping from a set to a subset of it. 
property
A named value denoting a characteristic of an element. A property has semantic impact. Certain properties are predefined in the UML; others may be user defined. See: tagged value .
pseudo-state
A vertex in a state machine that has the form of a state, but doesn’t behave as a state. Pseudo-states include initial 
and history vertices.   
physical system
1. The subject of a model. 
2. A collection of connected physical units, which can include software, hardware and people, that are organized to accomplish a specific purpose. A physical system can be described by one or more models, possibly from different viewpoints. Contrast: system .
qualifier
An association attribute or tuple of attributes whose values partition the set of objects related to an object across an 
association. 
realization
14                 UML Superstructure 2.0 Draft Adopted SpecificationA specialized abstraction relationship between two sets of model elements, one representing a specification (the 
supplier) and the other representing an implementation of the latter (the client). Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
receive [a message]
The handling of a stimulus passed from a sender instance. See: sender, receiver . 
receiver
The object handling a stimulus passed from a sender object. Contrast: sender . 
reception
A declaration that a classifier is prepared to react to the receipt of a signal.
reference
1. A denotation of a model element. 
2. A named slot within a classifier that facilitates navigation to other classifiers. Synonym: pointer .
refinement
A relationship that represents a fuller specification of something that has already been specified at a certain level of 
detail. For example, a design class is a refinement of an analysis class. 
relationship
An abstract concept that specifies some kind of connection between elements. Examples of relationships include associations and generalizations.
repository
A facility for storing object models, interfaces, and implementations.
requirement
A desired feature, property, or behavior of a system. 
responsibility
A contract or obligation of a classifier. 
reuse
The use of a pre-existing artifact. 
role
The named set of features defined over a collection of entities participating in a particlar context. 
Collaboration: The named set of behaviors possessed by a class or part participating in a particular context. 
Part: a subset of a particular class which exhibits a subset of features possessed by the class
Associations: A synonym for association end often referring to a subset of classifier instances that are participating in the association.
run time
The period of time during which a computer program or a systemexecutes. Contrast: modeling time .   
scenario
A specific sequence of actions that illustrates behaviors. A scenario may be used to illustrate an interaction or the 
execution of a use case instance. See: interaction.  
semantic variation point
A point of variation in the semantics of a metamodel. It provides an intentional degree of freedom for the 
interpretation of the metamodel semantics. 
send [a message]
The passing of a stimulus from a sender instance to a receiver instance. See: sender, receiver . 
sender
The object passing a stimulus to a receiver instance. Contrast: receiver . 
sequence diagram
A diagram that depicts an interaction by focusing on the sequence of messages that are exchanged, along with 
their corresponding event occurrences on the lifelines. 
Unlike a communication diagram, a sequence diagram includes time sequences but does not include object relationships. A sequence diagram can exist in a generic form (describes all possible scenarios) and in an instance form (describes one actual scenario). Sequence diagrams and communication diagrams express similar information, but show it in different ways. See: communication diagram .
UML Superstructure 2.0 Draft Adopted Specification        15signal
The specification of an asynchronous stimulus that triggers a reaction in the receiver in an asynchronous way and 
without a reply. The receiving object handles the signal as specified by its receptions. The data carried by a send request and passed to it by the occurrence of the send invocation event that caused the request is represented as attributes of the signal instance. A signal is defined independently of the classifiers handling the signal.
signature
The name and parameters of a behavioral feature. A signature may include an optional returned parameter.
single inheritance
A semantic variation of generalization in which a type may have only one supertype. Synonym: multiple inheritance 
[OMA]. Contrast: multiple inheritance .
slot
A specification that an entity modeled by an instance specification has a value or values for a specific structural 
feature. 
software module
A unit of software storage and manipulation. Software modules include source code modules, binary code modules, and executable code modules. 
specification
A set of requirements for a system or other classifier. Contrast: implementation . 
state
A condition or situation during the life of an object during which it satisfies some condition, performs some activity, 
or waits for some event. Contrast: state  [OMA]. 
state machine diagram
A diagram that depicts discrete behavior modeled through finite state-transition systems. In particular, it specifies 
the sequences of states that an object or an interaction goes through during its life in response to events, together with its responses and actions. See: state machine . 
state machine
A behavior that specifies the sequences of states that an object or an interaction goes through during its life in 
response to events, together with its responses and actions. 
static classification
The assignment of an instance to a classifier where the assignment may not change to any other classifier. Contrast: dynamic classification. 
stereotype
A class that defines how an existing metaclass (or stereotype) may be extended, and enables the use of platform 
or domain specific terminology or notation in addition to the ones used for the extended metaclass.
Certain stereotypes are predefined in the UML, others may be user defined. Stereotypes are one of the extensibility mechanisms in UML. See: constraint, tagged value. 
stimulus
The passing of information from one instance to another, such as raising a signal or invoking an operation. The 
receipt of a signal is normally considered an event. See: message .
string
A sequence of text characters. The details of string representation depend on implementation, and may include 
character sets that support international characters and graphics. 
structural feature
A static feature of a model element, such as an attribute. 
structural model aspect
A model aspect that emphasizes the structure of the objects in a system, including their types, classes, relationships, attributes, and operations. 
structure diagram
A form of diagram that depicts the elements in a specification that are irrespective of time. Class diagrams and component diagrams are examples of structure diagrams.
subactivity state
16                 UML Superstructure 2.0 Draft Adopted SpecificationA state in an activity diagram that represents the execution of a non-atomic sequence of steps that has some 
duration.
subclass
In a generalization relationship, the specialization of another class, the superclass. See: generalization . Contrast: 
superclass . 
submachine state
A state in a state machine that is equivalent to a
composite state but whose contents are described by another state machine.
substate
A state that is part of a composite state. See: concurrent state, disjoint state . 
subpackage
A package that is contained in another package.
subsystem
A unit of hierarchical decomposition for large systems. A subsystem is commonly instantiated indirectly. Definitions 
of subsystems vary widely among domains and methods, and it is expected that domain and method profiles will specialize this construct. A subsystem may be defined to have specification and realization elements.
subtype
In a generalization relationship, the specialization of another type, the supertype. See: generalization . Contrast: 
supertype . 
superclass
In a generalization relationship, the generalization of another class, the subclass. See: generalization.  Contrast: 
subclass . 
supertype
In a generalization relationship, the generalization of another type, the subtype. See: generalization . Contrast: 
subtype . 
supplier
A classifier that provides services that can be invoked by others. Contrast: client . 
synch state
A vertex in a state machine used for synchronizing the
concurrent regions of a state machine.
system
An organized array of elements functioning as a unit
Also, a top-level subsystem in a model. 
tagged value
The explicit definition of a property as a name-value pair. In a tagged value, the name is referred as the tag. Certain 
tags are predefined in the UML; others may be user defined. Tagged values are one of three extensibility mechanisms in UML. See: constraint, stereotype.  
template
Synonym: parameterized element . 
thread [of control]
A single path of execution through a program, a dynamic model, or some other representation of control flow. Also, 
a stereotype for the implementation of an active object as lightweight process. See process . 
time event
An event that denotes the time elapsed since the current state was entered. See:  event .
time expression
An expression that resolves to an absolute or relative value of time. 
timing diagram
An interaction diagram that shows the change in state or condition of a lifeline (representing a Classifier Instance or 
Classifier Role) over linear time. The most common usage is to show the change in state of an object over time in response to accepted events or stimuli.
top level
UML Superstructure 2.0 Draft Adopted Specification        17A stereotype denoting the top-most package in a containment hierarchy. The topLevel stereotype defines the outer 
limit for looking up names, as namespaces “see” outwards. For example, opLevel subsystem represents the top of the subsystem containment hierarchy.
trace
A dependency that indicates a historical or process relationship between two elements that represent the same concept without specific rules for deriving one from the other. 
transient object 
An object that exists only during the execution of the process or thread that created it.
transition
A relationship between two states indicating that an object in the first state will perform certain specified actions and enter the second state when a specified event occurs and specified conditions are satisfied. On such a change 
of state, the transition is said to fire. 
type
A stereotyped class that specifies a domain of objects together with the operations applicable to the objects, 
without defining the physical implementation of those objects. A type may not contain any methods, maintain its own thread of control, or be nested. However, it may have attributes and associations. Although an object may have at most one implementation class, it may conform to multiple different types. See also: implementation class  
Contrast: interface .
type expression
An expression that evaluates to a reference to one or more types. 
uninterpreted
A placeholder for a type or types whose implementation is not specified by the UML. Every uninterpreted value has 
a corresponding string representation. See: any [CORBA]. 
usage
A dependency in which one element (the client) requires the presence of another element (the supplier) for its 
correct functioning or implementation.
use case
The specification of a sequence of actions, including variants, that a system (or other entity) can perform, interacting with actors of the system. See: use case instances.  
use case diagram
A diagram that shows the relationships among actors and the subject (system), and use cases. 
use case instance
The performance of a sequence of actions being specified in a use case. An instance of a use case. See: use case 
class . 
use case model
A model that describes a system’s functional requirements in terms of use cases.
utility
A stereotype that groups global variables and procedures in the form of a class declaration. The utility attributes 
and operations become global variables and global procedures, respectively. A utility is not a fundamental modeling construct, but a programming convenience. 
value
An element of a type domain.
vertex
A source or a target for a transition in a state machine. A vertex can be either a state or a pseudo-state. See: state, 
pseudo-state.  
view
A projection of a model that is seen from a given perspective or vantage point and omits entities that are not 
relevant to this perspective. 
view element
A textual and/or graphical projection of a collection of model elements. 
view projection
18                 UML Superstructure 2.0 Draft Adopted SpecificationA projection of model elements onto view elements. A view projection provides a location and a style for each view 
element. 
visibility
An enumeration whose value (public, protected, or private) denotes how the model element to which it refers may be seen outside its enclosing namespace.
5 Symbols
Editorial Comment: The FTF needs to complete this section (or possibly eliminate it)
6 Additional information
6.1 Changes to Adopted OMG Specifications
This specification, in conjunction with the specification  that complements it, the UML 2.0: Infrastructure,  completely 
replaces the UML 1.4.1 and UML 1.5 with Action Semantics specifications, except for the “Model Interchange Using CORBA IDL” (see Chapter 5, Section 5.3 of the OMG UML Specification v1.4, OMG document ad/01-02-17). It is recommended that “Model Interchange Using CORBA IDL” is retired as an adopted technology because of lack of vendor and user interest.
6.2 Architectural Alignment and MDA Support
Chapter 1, “Language Architecture” of the UML 2.0: Infrastructure explains how the UML 2.0: Infrastructure  is 
architecturally aligned with the UML 2.0: Superstructure  that complements it. It also explains how the InfrastructureLibrary 
defined in the UML 2.0: Infrastructure can be strictly reused by MOF 2.0 specifications. 
It is the intent that the unified MOF 2.0 Core specification must be architecturally aligned with the UML 2.0: Infrastructure  
part of this specification. Similarly, the unified UML 2.0 Diagram Interchange specification must be architecturally aligned with the UML 2.0: Superstructure part of this specification.
The OMG’s Model Driven Architecture (MDA) initiative is an evolving conceptual architecture for a set of industry-wide 
technology specifications that will support a model-driven approach to software development. Although MDA is not itself a technology specification, it represents an important approach and a plan to achieve a cohesive set of model-driven technology specifications. This specification’s support for MDA is discussed in the UML 2.0: Infrastructure  Appendix B, “Support for 
Model Driven Architecture”.
6.3 How to Read this Specification
The rest of this document contains the technical content of this specification. As background for this specification, readers a re 
encouraged to first read the UML: Infrastructure  specification that complements this. Part I, “Introduction” of UML: 
Infrastructure explains the language architecture structure and the formal approach used for its specification. Afterwards the 
reader may choose to either explore the InfrastructureLibrary, described in Part II, “Infrastructure Library”, or the Classes::Kernel package which reuses it, described in Chapter 1, “Classes”. The former specifies the flexible metamodel library that is reused by the latter; the latter defines the basic constructs used to define the UML metamodel.
With that background the reader should be well prepared to explore the user level constructs defined in this UML: 
UML Superstructure 2.0 Draft Adopted Specification        19Superstructure specification. These concepts are organized into three parts: Part I - “Structure”, Part II - “Behavior”, and Part 
III - “Supplement”. Part I - “Structure” defines the static, structural constructs (e.g., classes, components, nodes artifacts)  used 
in various structural diagrams, such as class diagrams, component diagrams and deployment diagrams. Part II - “Behavior” specifies the dynamic, behavioral constructs (e.g., activities, interactions, state machines) used in various behavioral diagra ms, 
such as activity diagrams, sequence diagrams, and state machine diagrams. Part I - “Structure” defines auxiliary constructs (e.g., information flows, models, templates, primitive types) and the profiles used to customize UML for various domains, platforms and methods. 
Although the chapters are organized in a logical manner and can be read sequentially, this is a reference specification is intended to be read in a non-sequential manner. Consequently, extensive cross-references are provided to facilitate browsing and search.
6.4 Acknowledgements
The following companies submitted and/or supported parts of this specification:
 Adaptive
 Advanced Concepts Center LLC
 Alcatel
 Artisan
 Borland
 Ceira Technologies
 Commissariat à L'Energie Atomique
 Computer Associates
 Compuware
 DaimlerChrysler
 Domain Architects
 Embarcadero Technologies
 Enea Business Software
 Ericsson
 France Telecom
 Fraunhofer FOKUS
 Fujitsu
 Gentleware 
 Intellicorp
 Hewlett-Packard
 I-Logix
 International Business Machines
20                 UML Superstructure 2.0 Draft Adopted Specification IONA
 Jaczone
 Kabira Technologies
 Kennedy Carter
 Klasse Objecten
 KLOCwork
 Lockheed Martin
 MEGA International
 Mercury Computer
 Motorola
 MSC.Software
 Northeastern University
 Oracle
 Popkin Software
 Proforma
 Project Technology
 Sims Associates
 SOFTEAM
 Sun Microsystems
 Syntropy Ltd.
 Telelogic
 Thales Group
 TNI-Valiosys
 Unisys
 University of Kaiserslautern
 University of Kent
 VERIMAG
 WebGain
 X-Change Technologies
 7irene
 88solutions
UML Superstructure 2.0 Draft Adopted Specification        21The following persons were members of the core team that designed and wrote this specification: Don Baisley, Morgan 
Björkander, Conrad Bock, Steve Cook, Philippe Desfray, Nathan Dykman, Anders Ek, David Frankel, Eran Gery, Øystein Haugen, Sridhar Iyengar, Cris Kobryn, Birger Møller-Pedersen, James Odell, Gunnar Övergaard, Karin Palmkvist, Guus Ramackers, Jim Rumbaugh, Bran Selic, Thomas Weigert and Larry Williams.
In addition, the following persons contributed valuable ideas and feedback that significantly improved the content and the quality of this specification: Colin Atkinson, Ken Baclawski, Mariano Belaunde, Steve Brodsky, Roger Burkhart, Bruce Douglass, Karl Frank, William Frank, Sandy Friedenthal, Sébastien Gerard, Dwayne Hardy, Mario Jeckle, Larry Johnson, Allan Kennedy, Mitch Kokar, Thomas Kuehne, Michael Latta, Antoine Lonjon, Dave Mellor, Stephen Mellor, Joaquin Miller, Jeff Mischkinksky, Hiroshi Miyazaki, Jishnu Mukerji, Ileana Ober, Barbara Price, Tom Rutt, Kendall Scott, Oliver Sims, Cameron Skinner, Jeff Smith, Doug Tolbert, and Ian Wilkie.
22                 UML Superstructure 2.0 Draft Adopted Specification
                                                                                             
UML Superstructure 2.0 Draft Adopted Specification              23Part I - Structure
This part defines the static, structural constructs (e.g., classes, components, nodes artifacts) used in various structural 
diagrams, such as class diagrams, component diagrams and deployment diagrams. The UML packages that support 
structural modeling are shown in Figure 1.
The function and contents of these packages are described in following chapters, which are organized by major subject areas.Figure 1 - UML packages that support structural modelingClasses
ComponentsCompositeStructures
Deployments
24                 UML Infrastructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        257C l a s s e s
7.1 Overview
The Classes package contains subpackages that deal with the basic modeling concepts of UML, and in particular classes and 
their relationships.
Package Structure
Figure 2 describes the dependencies (i.e., package merges) between the subpackages of the package Classes. 
Due to the size of the Kernel package, this chapter has been divided according to diagrams, where each diagram of Kernel is turned into a separate section. 
 “Kernel – the Root Diagram” on page 27
 “Kernel – the Namespaces Diagram” on page 31
 “Kernel – the Multiplicities Diagram” on page 40
 “Kernel – the Expressions Diagram” on page 45
 “Kernel – the Constraints Diagram” on page 53
 “Kernel – the Instances Diagram” on page 57
 “Kernel – the Classifiers Diagram” on page 61
 “Kernel – the Features Diagram” on page 71
 “Kernel – the Operations Diagram” on page 76Figure 2 - The subpackages of the Classes package and their dependenciesKernel
DependenciesAssociationClasses
InterfacesPowerTypes«merge» «merge» «merge»
«merge»
26                 UML Superstructure 2.0 Draft Adopted Specification “Kernel – the Classes Diagram” on page 80
 “Kernel – the DataTypes Diagram” on page 94
 “Kernel – the Packages Diagram” on page 99
The packages AssociationClasses  and PowerTypes  are closely related to the Kernel diagrams, but are described in separate 
sections (See “AssociationClasses” on page 117 and “PowerTypes” on page 120, respectively). The packages Dependencies  
and Interfaces  are described in separate sections (See “Dependencies” on page 105 and “Interfaces” on page 112, 
respectively). 
In those cases where any of the latter four packages add to the definitions of classes originally defined in Kernel , the 
description of the additions is found under the original class.
Reusing packages from UML 2.0 Infrastructure
The Kernel  package represents the core modeling concepts of the UML, including classes, associations, and packages. This 
part is mostly reused from the infrastructure library, since many of these concepts are the same as those that are used in for example MOF. The Kernel  package is the central part of the UML, and primarily reuses the Constructs  and Abstractions 
packages of the InfrastructureLibrary.
The reuse is accomplished by merging Constructs  with the relevant subpackages of Abstractions . In many cases, the reused 
classes are extended in the Kernel  with additional features, associations, or superclasses. In subsequent diagrams showing 
abstract syntax, the subclassing of elements from the infrastructure library is always elided since this information only adds to 
the complexity without increasing understandability. Each metaclass is completely described as part of this chapter; the text from the infrastructure library is repeated here.
It should also be noted that while Abstractions  contained several subpackages, Kernel  is a flat structure that like Constructs  
only contains metaclasses. The reason for this distinction is that parts of the infrastructure library have been designed for flexibility and reuse, while the Kernel  in reusing the infrastructure library has to bring together the different aspects of the 
reused metaclasses. In order to organize this chapter, we therefore use diagrams rather than packages as the main grouping mechanism. 
The packages that are explicitly merged from the InfrastructureLibrary::Core are the following:
 Abstractions::Instances
 Abstractions::MultiplicityExpressions
 Abstractions::Literals
 Abstractions::Generalizations
 Constructs
UML Superstructure 2.0 Draft Adopted Specification        27All other packages of the InfrastructureLibrary::Core are implicitly merged through the ones that are explicitly merged.  
7.2 Kernel – the Root Diagram
The Root diagram of the Kernel package is shown in Figure 4. Figure 3 - The InfrastructureLibrary packages that are merged by Kernel; all 
dependencies in the picuture represent package merges
Figure 4 - The Root diagram of the Kernel packageKernelCore::
Abstractions::
Generalizations
Core::ConstructsCore::
Abstractions::
Instances «merge»«merge»«merge»«merge»Core::
Abstractions::
LiteralsCore::
Abstractions::
MultiplicityExpressions
«merge»
Elem ent
*0. .1
+/ownedElement
*{union}+/owner
0. .1 {union}
Commen t
0..1 * 0..1+ownedComment
* {s ubs ets  ownedElement}
DirectedRelationshipComment
body : Str ingRelationshipElem ent
1..*+/target
1..* {union,
s ubs ets  relatedElement}
1. .*+/so u r ce
1. .* {union,
subs ets  relatedElement}*+annotatedElement
*1..*+/relatedElement
1..* {union}
28                 UML Superstructure 2.0 Draft Adopted Specification7.2.1 Comment (from Kernel)
A comment is a textual annotation that can be attached to a set of elements.
Description
A comment gives the ability to attach various remarks to elements. A comment carries no semantic force, but may contain 
information that is useful to a modeler.
A comment can be owned by any element.
Attributes
 body: String Specifies a string that is the comment .
Associations
 annotatedElement: Element[*] References the Element(s) being commented.
Constraints
No additional constraints.
Semantics
A Comment adds no semantics to the annotated elements, but may represent information useful to the reader of the model.
Notation
A Comment is shown as a rectangle with the upper right corner bent (this is also known as a “note symbol”). The rectangle 
contains the body of the Comment. The connection to each annotated element is shown by a separate dashed line.
Presentation Options
The dashed line connecting the note to the annotated element(s) may be suppressed if it is clear from the context, or not important in this diagram.
Examples
7.2.2 DirectedRelationship (from Kernel)
A directed relationship represents a relationship between a collection of source model elements and a collection of target model elements.Figure 5 - Comment notationAccountThis class was added
by Alan Wright after
meeting with the
mission planning team.
UML Superstructure 2.0 Draft Adopted Specification        29Description
A directed relationship references one or more source elements and one or more target elements. Directed relationship is an 
abstract metaclass.
Attributes
No additional attributes.
Associations
 / source: Element [1..*] Specifies the sources of the DirectedRelationship. Subsets Relationship::relatedEle-
ment.  This is a derived union.
 / target: Element [1..*] Specifies the targets of the DirectedRelationship. Subsets Relationship::relatedElement.  
This is a derived union.
Constraints
No additional constraints.
Semantics
DirectedRelationship has no specific semantics. The various subclasses of DirectedRelationship will add semantics appropriate to the concept they represent.
Notation
There is no general notation for a DirectedRelationship. The specific subclasses of DirectedRelationship will define their own notation. In most cases the notation is a variation on a line drawn from the source(s) to the target(s).
7.2.3 Element (from Kernel)
An element is a constituent of a model. As such, it has the capability of owning other elements.
Description
Element is an abstract metaclass with no superclass. It is used as the common superclass for all metaclasses in the infrastructure library. Element has a derived composition association to itself to support the general capability for elements to own other elements.
Attributes
No additional attributes.
Associations
 ownedComment: Comment[*] The Comments owned by this element. Subsets Element::ownedElement .
 / ownedElement: Element[*] The Elements owned by this element. This is a derived union. / owner: Element [0..1] The Element that owns this element. This is a derived union.
30                 UML Superstructure 2.0 Draft Adopted SpecificationConstraints
[1]  An element may not directly or indirectly own itself.
not self.allOwnedElements()->includes(self)
[2] Elements that must be owned must have an owner.
self.mustBeOwned() implies  owner->notEmpty()
Additional Operations
[1]  The query allOwnedElements() gives all of the direct and indirect owned elements of an element.
Element::allOwnedElements(): Set(Element);
allOwnedElements = ownedElement->union(ownedElement->collect(e | e.allOwnedElements()))
[2] The query mustBeOwned() indicates whether elements of this type must have an owner. Subclasses of Element that do
not require an owner must override this operation.
Element::mustBeOwned() : Boolean;
mustBeOwned = true
Semantics
Subclasses of Element provide semantics appropriate to the concept they represent. The comments for an Element add no 
semantics but may represent information useful to the reader of the model.
Notation
There is no general notation for an Element. The specific subclasses of Element define their own notation.
7.2.4 Relationship (from Kernel)
Relationship is an abstract concept that specifies some kind of relationship between elements.
Description
A relationship references one or more related elements. Relationship is an abstract metaclass. 
Attributes
No additional attributes.
Associations
 / relatedElement: Element [1..*]Specifies the elements related by the Relationship. This is a derived union.
Constraints
No additional constraints.
Semantics
Relationship has no specific semantics. The various subclasses of Relationship will add semantics appropriate to the concept they represent.
Notation
There is no general notation for a Relationship. The specific subclasses of Relationship will define their own notation. In mos t 
cases the notation is a variation on a line drawn between the related elements.
UML Superstructure 2.0 Draft Adopted Specification        317.3 Kernel – the Namespaces Diagram
The Namespaces diagram of the Kernel package is shown in Figure 6. 
In order to locate the metaclasses that are referenced from this diagram,
 See “DirectedRelationship (from Kernel)” on page 28.
 See “Element (from Kernel)” on page 29.
 See “Package (from Kernel)” on page 99.
7.3.1 ElementImport (from Kernel)
An element import identifies an element in another package, and allows the element to be referenced using its name without a 
qualifier.
Description
An element import is defined as a directed relationship between an importing namespace and a packageable element. The name of the packageable element or its alias is to be added to the namespace of the importing namespace. It is also possible to  
control whether the imported element can be further imported.
Attributes
 visibility: VisibilityKind Specifies the visibility of the imported PackageableElement within the importing Package. 
The default visibility is the same as that of the imported element. If the imported element does not have a visibility, it is possible to add visibility to the element import.
 alias: String [0..1] Specifies the name that should be added to the namespace of the importing Pack-age in 
lieu of the name of the imported PackagableElement. The aliased name must not clash with any other member name in the importing Package. By default, no alias is used.Figure 6 - The Namespaces diagram of the Kernel packageNam edElem ent
name : String
vis ibility : Vis ibilityKind
/ qualifiedName : Str ing[0..1]
[0..1]
[0..1]Vis ibilityKind
public
privateprotected
pack age<<enumer ation>>Element
Direct e dRelatio nship
[0..1]
DirectedRe la t ionshi pPackageableElem entNam edElem ent
Elem entIm port
vis ibility : Vis ibilityKind
alias  : String1+impor tedElement
1{su bse ts targ et}PackageableElem ent
vis ibility : Vis ibilityKindNamespace
0..1 *+/names pace
0..1 { union,
subset s  owne r }+/ownedMember
*{u nio n,
s ubs ets  member ,
s ubs ets  ownedElement}*+/ member
*{u nio n}
1 *+impor tingNames pace
1{ subsets  s o urce,
s ubs ets  owner}+elem entIm port
*{ subsets  ownedElement}*+/importedMember
* { s ubs ets  member }
Pack ageImpor t
visibility : VisibilityKind1 *+impor tingNames pace
1 { s ubs ets  s our ce,
s ubs ets  owner }+pack ageImpor t
*{ s ubs ets  ownedElement}Pack age
1+impor tedPack age
1 {subsets target}[0 ..1 ]
32                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 importedElement: PackageableElement [1]Specifies the PackageableElement whose name is to be added to a Namespace. 
Subsets DirectedRelationship::target .
 importingNamespace: Namespace [1]Specifies the Namespace that imports a PackageableElement from another Package. 
Subsets DirectedRelationship::source  and Element::owner .
Constraints
[1]  The visibility of an ElementImport is either public or private.
self.visibility = #public or self.visibility = #private
[2] An importedElement has either public visibility or no visibility at all.
self.importedElement.visibility.notEmpty() implies  self.importedElement.visibility = #public
Additional Operations
[1]  The query getName() returns the name under which the imported PackageableElement will be known in the importing 
namespace.
ElementImport::getName(): String;
getName = 
if self.alias->notEmpty() then  
self.alias
else
self.importedElement.name
endif
Semantics
An element import adds the name of a packageable element from a package to the importing namespace. It works by 
reference, which means that it is not possible to add features to the element import itself, but it is possible to modify the referenced element in the namespace from which it was imported. An element import is used to selectively import individual elements without relying on a package import.
In case of a nameclash with an outer name (an element that is defined in an enclosing namespace is available using its unqualified name in enclosed namespaces) in the importing namespace, the outer name is hidden by an ele-ment import, and the unqualified name refers to the imported element. The outer name can be accessed using its qual-ified name.
If more than one element with the same name would be imported to a namespace as a consequence of element imports or package imports, the names of the imported elements must be qualified in order to be used and the ele-ments are not added to the importing namespace. If the name of an imported element is the same as the name of an element owned by the importing namespace, the name of the imported element must be qualified in order to be used and is not added to the importing namespace.
An imported element can be further imported by other namespaces using either element or member imports.
The visibility of the ElementImport may be either the same or more restricted than that of the imported element. 
Notation
An element import is shown using a dashed arrow with an open arrowhead from the importing namespace to the imported element. The keyword «import» is shown near the dashed arrow if the visibility is public, otherwise the key-word «access» is shown.
If an element import has an alias, this is used in lieu of the name of the imported element. The aliased name may be shown after or below the keyword «import».
UML Superstructure 2.0 Draft Adopted Specification        33Presentation options
If the imported element is a package, the keyword may optionally be preceded by element, i.e., «element import».
As an alternative to the dashed arrow, it is possible to show an element import by having a text that uniquely identifies the 
imported element within curly brackets either below or after the name of the namespace. The textual syntax is then:
{element import <qualifiedName>} or {element access <qualifiedName>}
Optionally, the aliased name may be show as well:
{element import <qualifiedName> as <alias>} or {element access <qualifiedName> as <alias>}
Examples
The element import that is shown in Figure 7 allows elements in the package Program to refer to the type Time in Types without qualification. However, they still need to refer explicitly to Types::Integer, since this element is not imported.
In Figure 8, the element import is combined with aliasing, meaning that the type Types::Real will be referred to as Double in the package Shapes.
7.3.2 NamedElement (from Kernel, Dependencies)
A named element is an element in a model that may have a name.Figure 7 - Example of element import
Figure 8 - Example of element import with aliasingTypes
«datatype»
Integer
«datatype»
Time«import»
Program
Types
Shapes
«datatype»
Real Circle
radius: Double«import»
Double
34                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
A named element represents elements that may have a name. The name is used for identification of the named element within 
the namespace in which it is defined. A named element also has a qualified name that allows it to be unambiguously identified within a hierarchy of nested namespaces. NamedElement is an abstract metaclass.
Attributes
 name: String [0..1] The name of the NamedElement.
 / qualifiedName: String [0..1] A name which allows the NamedElement to be identified within a hierarchy of nested 
Namespaces. It is constructed from the names of the containing namespaces starting at the root of the hierarchy and ending with the name of the NamedElement itself. This is a derived attribute.
 visibility: VisibilityKind [0..1] Determines the visibility of the NamedElement within different Namespaces within the 
overall model.
Package Dependencies (“Dependencies” on page 105)
 supplierDependency: Dependency [*]Indicates the dependencies that reference the supplier. clientDependency: Dependency[*]Indicates the dependencies that reference the client.
Associations
 / namespace: Namespace [0..1] Specifies the namespace that owns the NamedElement. Subsets Element::owner. This is a 
derived union.
Constraints
[1]  If there is no name, or one of the containing namespaces has no name, there is no qualified name.
(self.name->isEmpty() or self.allNamespaces()->select(ns | ns.name->isEmpty())->notEmpty())
implies  self.qualifiedName->isEmpty()
[2] When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the
names of the containing namespaces.
(self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()) implies
self.qualifiedName = self.allNamespaces()->iterate( ns : Namespace; result: String = self.name | 
ns.name->union(self.separator())->union(result))
[3] If a NamedElement is not owned by a Namespace, it does not have a visibility.
namespace->isEmpty() implies  visibility->isEmpty()
Additional Operations
[1]  The query allNamespaces() gives the sequence of namespaces in which the NamedElement is nested, working outwards.
NamedElement::allNamespaces(): Sequence(Namespace);
allNamespaces =
if self.namespace->isEmpty()
then  Sequence{}
else self.name.allNamespaces()->prepend(self.namespace)
endif
UML Superstructure 2.0 Draft Adopted Specification        35[2] The query isDistinguishableFrom() determines whether two NamedElements may logically co-exist within a Namespace.
By default, two named elements are distinguishable if (a) they have unrelated types or (b) they have related types but dif-ferent names.
NamedElement::isDistinguishableFrom(n:NamedElement, ns: Namespace): Boolean;
isDistinguishable =
if self.oclIsKindOf(n.oclType) or n.oclIsKindOf(self.oclType)
then  ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()
else true
endif
[3] The query separator() gives the string that is used to separate names when constructing a qualified name.
NamedElement::separator(): String; 
separator = ‘::’
Semantics
The name attribute is used for identification of the named element within namespaces where its name is accessible. Note that 
the attribute has a multiplicity of [ 0..1 ] which provides for the possibility of the absence of a name (which is different fr om 
the empty name).
The visibility attribute provides the means to constrain the usage of a named element in different namespaces within a model. It is intended for use in conjunction with import and generalization mechanisms.
Notation
No additional notation.
7.3.3 Namespace (from Kernel)
A namespace is an element in a model that contains a set of named elements that can be identified by name.
Description
A namespace is a named element that can own other named elements. Each named element may be owned by at most one namespace. A namespace provides a means for identifying named elements by name. Named elements can be identified by name in a namespace either by being directly owned by the namespace or by being introduced into the namespace by other means e.g. importing or inheriting. Namespace is an abstract metaclass.
A namespace can own constraints. The constraint does not necessarily apply to the namespace itself, but may also apply to elements in the namespace.
A namespace has the ability to import either individial members or all members of a package, thereby making it possible to refer to those named elements without qualification in the importing namespace. In the case of conflicts, it is necessary to us e 
qualified names or aliases to disambiguate the referenced elements.
Attributes
No additional attributes.
36                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 elementImport: ElementImport [*]References the ElementImports owned by the Namespace. Subsets Ele-
ment::ownedElement .
 / importedMember: PackageableElement [*] References the PackageableElements that are members of this Namespace as 
a result of either PackageImports or ElementImports. Subsets Namespace::member.
 / member: NamedElement [*] A collection of NamedElements identifiable within the Namespace, either by being owned 
or by being introduced by importing or inheritance. This is a derived union.
 / ownedMember: NamedElement [*]A collection of NamedElements owned by the Namespace. Subsets Ele-
ment::ownedElement  and Namespace::member . This is a derived union.
 ownedRule: Constraint[*] Specifies a set of Constraints owned by this Namespace. Subsets Namespace::owned-
Member .
 packageImport: PackageImport [*] References the PackageImports owned by the Namespace. Subsets Ele-
ment::ownedElement .
Constraints
[1]  All the members of a Namespace are distinguishable within it.
membersAreDistinguishable()
[2] The importedMember property is derived from the ElementImports and the PackageImports.
self.importedMember->includesAll(self.importedMembers(self.elementImport.importedElement.asSet()-
>union(self.packageImport.importedPackage->collect(p | p.visibleMembers()))))
Additional Operations
[1]  The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace. In general a 
member can have multiple names in a Namespace if it is imported more than once with different aliases. The query takes account of importing. It gives back the set of names that an element would have in an importing namespace, either because it is owned, or if not owned then imported individually, or if not individually then from a package.
Namespace::getNamesOfMember(element: NamedElement): Set(String);
getNamesOfMember = 
if self.ownedMember ->includes(element)
then  Set{}->include(element.name)
else let elementImports: ElementImport = self.elementImport->select(ei | ei.importedElement = element) in
if elementImports->notEmpty()
then  elementImports->collect(el | el.getName())
else 
self.packageImport->select(pi | pi.importedPackage.visibleMembers()->includes(element))->
collect(pi | pi.importedPackage.getNamesOfMember(element))
endif
endif
[2] The Boolean query membersAreDistinguishable() determines whether all of the namespace’s members are distinguisha-
ble within it.
Namespace::membersAreDistinguishable() : Boolean;
membersAreDistinguishable =self.member->forAll( memb |
self.member->excluding(memb)->forAll(other |
memb.isDistinguishableFrom(other, self)))
UML Superstructure 2.0 Draft Adopted Specification        37[3] The query importMembers() defines which of a set of PackageableElements are actually imported into the namespace.
This excludes hidden ones, i.e., those which have names that conflict with names of owned members, and also excludeselements which would have the same name when imported.
Namespace::importMembers(imps: Set(PackageableElement)): Set(PackageableElement);
importMembers = self.excludeCollisions(imps)->select(imp | self.ownedMember->forAll(mem | 
mem.imp.isDistinguishableFrom(mem, self)))
[4] The query excludeCollisions() excludes from a set of PackageableElements any that would not be distinguishable from
each other in this namespace.
Namespace::excludeCollisions(imps: Set(PackageableElements)): Set(PackageableElements);
excludeCollisions = imps->reject(imp1 | imps.exists(imp2 | not imp1.isDistinguishableFrom(imp2, self)))
Semantics
A namespace provides a container for named elements. It provides a means for resolving composite names, such as 
name1::name2::name3. The member  association identifies all named elements in a namespace called N that can be referred to 
by a composite name of the form N::<x>. Note that this is different from all of the names that can be referred to unqualified within N, because that set also includes all unhidden members of enclosing namespaces.
Named elements may appear within a namespace according to rules that specify how one named element is distinguishable from another. The default rule is that two elements are distinguishable if they have unrelated types, or related types but different names. This rule may be overridden for particular cases, such as operations which are distinguished by their signature.
The ownedRule constraints for a Namespace represent well formedness rules for the constrained elements. These constraints are evaluated when determining if the model elements are well formed.
Notation
No additional notation. Concrete subclasses will define their own specific notation.
7.3.4 PackageableElement (from Kernel)
A packageable element indicates a named element that may be owned directly by a package.
Description
A packageable element indicates a named element that may be owned directly by a package. 
Attributes
 visibility: VisibilityKind [1] Indicates that packageable elements must always have a visibility, i.e., visibility is not 
optional. Redefines N amedElement::visibility .
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
No additional semantics.
38                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
No additional notation.
7.3.5 PackageImport (from Kernel)
A package import is a relationship that allows the use of unqualified names to refer to package members from other 
namespaces.
Description
A package import is defined as a directed relationship that identifies a package whose members are to be imported by a namespace.
Attributes
 visibility: VisibilityKind Specifies the visibility of the imported PackageableElements within the import-ing 
Namespace, i.e., whether imported elements will in turn be visible to other packages that use that importingPackage as an importedPackage. If the PackageImport is public, the imported elements will be visible outside the package, while if it is private they will not. By default, the value of visibility is public.
Associations
 importedPackage: Package [1] Specifies the Package whose members are imported into a Namespace. Subsets Directe-
dRelationship::target .
 importingNamespace: Namespace [1]Specifies the Namespace that imports the members from a Package. Subsets Direct-
edRelationship::source  and Element::owner .
Constraints
[1]  The visibility of a PackageImport is either public or private.
self.visibility = #public or self.visibility = #private
Semantics
A package import is a relationship between an importing namespace and a package, indicating that the importing namespace 
adds the names of the members of the package to its own namespace. Conceptually, a package import is equivalent to having an element import to each individual member of the imported namespace, unless there is already a separately-defined element import.
Notation
A package import is shown using a dashed arrow with an open arrowhead from the importing namespace to the imported package. A keyword is shown near the dashed arrow to identify which kind of package import that is intended. The predefined keywords are «import» for a public package import , and «access» for a private package import.
Presentation options
As an alternative to the dashed arrow, it is possible to show an element import by having a text that uniquely identi-fies the imported element within curly brackets either below or after the name of the namespace. The textual syntax is then:
{import <qualifiedName>} or {access <qualifiedName>}
UML Superstructure 2.0 Draft Adopted Specification        39Examples
In Figure 9, a number of package imports are shown. The elements in Types are imported to ShoppingCart, and then further 
imported WebShop. However, the elements of Auxiliary are only accessed from ShoppingCart, and cannot be referenced using unqualified names from WebShop. 
7.3.6 VisibilityKind (from Kernel)
VisibilityKind is an enumeration type that defines literals to determine the visibility of elements in a model.
Description
VisibilityKind is an enumeration of the following literal values:
 public
p r i v a t e protected package
Additional Operations
[1]  The query bestVisibility() examines a set of VisibilityKinds that includes only public and private, and returns public as the 
preferred visibility.
VisibilityKind::bestVisibility(vis: Set(VisibilityKind)) : VisibilityKind;
pre: not vis->includes(#protected) and not  vis->includes(#package)
bestVisibility = if vis->includes(#public) then  #public else #private endif
Semantics
VisibilityKind is intended for use in the specification of visibility in conjunction with, for example, the Imports, 
Generalizations and Packages packages. Detailed semantics are specified with those mechanisms. If the Visibility package is used without those packages, these literals will have different meanings, or no meanings.
 A public element is visible to all elements that can access the contents of the namespace that owns it.
 A private element is only visible inside the namespace that owns it.
 A protected element is visible to elements that have a generalization relationship to the namespace that owns it.
 A package element is owned by a namespace that is not a package, and is visible to elements that are in the same pack-Figure 9 - Examples of public and private package importsAuxiliary
TypesShoppingCart
WebShop «import»«import»«access»
40                 UML Superstructure 2.0 Draft Adopted Specificationage as its owning namespace. Only named elements that are not owned by packages can be marked as having package 
visibility. Any element marked as having package element is visible to all elements within the nearest enclosing pack-age (given that other owning elements have proper visibility). Outside the nearest enclosing package, an element marked as having package visibility is not visible. 
In circumstances where a named element ends up with multiple visibilities, for example by being imported multiple times, 
public visibility overrides private visibility, i.e., if an element is imported twice into the same namespace, once using a 
public import and once using a private import, it will be public. 
7.4 Kernel – the Multiplicities Diagram
The Multiplicities diagram of the Kernel package is shown in Figure 10. 
In order to locate the metaclasses that are referenced from this diagram,
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “Element (from Kernel)” on page 29.
 See “ValueSpecification (from Kernel)” on page 52.
7.4.1 MultiplicityElement (from Kernel)
A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending 
with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable 
cardinalities for an instantiation of this element.Figure 10 - The Multiplicities diagram of the Kernel package.Element
ValueSpecificationMultiplicityElement
isOrdered : Boolean = false
isUnique : Boolean = true
/ upper : UnlimitedNatural
/ lower : Integer0..1 0..1+upperValue
0..1 {subsets ownedElement}+ownerUpper
0..1{subsets owner}
0..1 0..1+lowerValue
0..1{subsets ownedElement}+ownerLower
0..1{subsets owner}[0..1]
[0..1]
NamedElement
TypedElementType
0..1+type
0..1PackageableElem ent
UML Superstructure 2.0 Draft Adopted Specification        41Description
A MultiplicityElement is an abstract metaclass which includes optional attributes for defining the bounds of a multiplicity. 
A MultiplicityElement also includes specifications of whether the values in an instantiation of this element must be 
unique or ordered.
Attributes
 isOrdered: Boolean For a multivalued multiplicity, this attribute specifies whether the values in an instantia-
tion of this element are sequentially ordered. Default is false .
 isUnique : Boolean For a multivalued multiplicity, this attributes specifies whether the values in an instantia-
tion of this element are unique. Default is true.
 / lower : Integer [0..1] Specifies the lower bound of the multiplicity interval, if it is expressed as an integer. / upper : UnlimitedNatural [0..1]Specifies the upper bound of the multiplicity interval, if it is expressed as an unlimited 
natural. 
Associations
 lowerValue: ValueSpecification [0..1]The specification of the lower bound for this multiplicity. Subsets Ele-
ment::ownedElement .
 upperValue: ValueSpecification [0..1]The specification of the upper bound for this multiplicity. Subsets Ele-
ment::ownedElement .
Constraints
These constraint must handle situations where the upper bound may be specified by an expression not computable in the 
model. 
[1]  A multiplicity must define at least one valid cardinality that is greater than zero.
upperBound()->notEmpty() implies  upperBound() > 0
[2] The lower bound must be a non-negative integer literal.
lowerBound()->notEmpty() implies  lowerBound() >= 0
[3] The upper bound must be greater than or equal to the lower bound.
(upperBound()->notEmpty() and lowerBound()->notEmpty()) implies upperBound() >= lowerBound()
[4] If a non-literal ValueSpecification is used for the lower or upper bound, then evaluating that specification must not have
side effects.
Cannot be expressed in OCL.
[5] If a non-literal ValueSpecification is used for the lower or upper bound, then that specification must be a constant expres-
sion.
Cannot be expressed in OCL.
[6] The derived lower attribute must equal the lowerBound.
lower = lowerBound()
[7] The derived upper attribute must equal the upperBound.
upper = upperBound()
Additional Operations
[1]  The query isMultivalued() checks whether this multiplicity has an upper bound greater than one.
42                 UML Superstructure 2.0 Draft Adopted SpecificationMultiplicityElement::isMultivalued() : Boolean;
pre: upperBound()->notEmpty()
isMultivalued = (upperBound() > 1)
[2] The query includesCardinality() checks whether the specified cardinality is valid for this multiplicity.
MultiplicityElement::includesCardinality(C : Integer) : Boolean;
pre: upperBound()->notEmpty() and lowerBound()->notEmpty()
includesCardinality = (lowerBound() <= C) and (upperBound() >= C)
[3] The query includesMultiplicity() checks whether this multiplicity includes all the cardinalities allowed by the specified
multiplicity.
MultiplicityElement::includesMultiplicity(M : MultiplicityElement) : Boolean;
pre: self.upperBound()->notEmpty() and self.lowerBound()->notEmpty()
and M.upperBound()->notEmpty() and M.lowerBound()->notEmpty()
includesMultiplicity = (self.lowerBound() <= M.lowerBound()) and (self.upperBound() >= M.upperBound())
[4] The query lowerBound() returns the lower bound of the multiplicity as an integer.
MultiplicityElement::lowerBound() : [Integer];
lowerBound = if lowerValue->isEmpty() then  1 else lowerValue.integerValue() endif
[5] The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an unlimited natural.
MultiplicityElement::upperBound() : [UnlimitedNatural];
upperBound = if upperValue->isEmpty() then  1 else upperValue.unlimitedValue() endif
Semantics
A multiplicity defines a set of integers that define valid cardinalities. Specifically, cardinality C is valid for multiplicity  M if 
M.includesCardinality(C).
A multiplicity is specified as an interval of integers starting with the lower bound and ending with the (possibly infinite) up per 
bound.
If a MultiplicityElement specifies a multivalued multiplicity, then an instantiation of this element has a set of values. The multiplicity is a constraint on the number of values that may validly occur in that set.
If the MultiplicityElement is specified as ordered (i.e. isOrdered is true), then the set of values in an instantiation of this  
element is ordered. This ordering implies that there is a mapping from positive integers to the elements of the set of values. If 
a MultiplicityElement is not multivalued, then the value for isOrdered has no semantic effect.
If the MultiplicityElement is specified as unordered (i.e. isOrdered is false), then no assumptions can be made about the order  
of the values in an instantiation of this element.
If the MultiplicityElement is specified as unique (i.e. isUnique is true), then the set of values in an instantiation of this e lement 
must be unique. If a MultiplicityElement is not multivalued, then the value for isUnique has no semantic effect.
The lower and upper bounds for the multiplicity of a MultiplicityElement may be specified by value specifications, such as (side-effect free, constant) expressions.
Notation
The specific notation for a MultiplicityElement is defined by the concrete subclasses. In general, the notation will include a multiplicity specification is shown as a text string containing the bounds of the interval, and a notation for showing the optional ordering and uniqueness specifications.
The multiplicity bounds are typically shown in the format:
lower-bound..upper-bound
where lower-bound  is an integer and upper-bound  is an unlimited natural number. The star character (*) is used as part of a 
multiplicity specification to represent the unlimited (or infinite) upper bound.
UML Superstructure 2.0 Draft Adopted Specification        43If the Multiplicity is associated with an element whose notation is a text string (such as an attribute, etc.), the multiplicit y 
string will be placed within square brackets ([]) as part of that text string. Figure 11 shows two multiplicity strings as part  of 
attribute specifications within a class symbol.
If the Multiplicity is associated with an element that appears as a symbol (such as an association end), the multiplicity strin g is 
displayed without square brackets and may be placed near the symbol for the element. Figure 12 shows two multiplicity strings as part of the specification of two association ends.
The specific notation for the ordering and uniqueness specifications may vary depending on the specific subclass of MultiplicityElement. A general notation is to use a property string containing ordered or unordered to define the ordering, and  
unique or nonunique to define the uniqueness.
Presentation Options
If the lower bound is equal to the upper bound, then an alternate notation is to use the string containing just the upper bound . 
For example, “1” is semantically equivalent to “1..1”.
A multiplicity with zero as the lower bound and an unspecified upper bound may use the alternative notation containing a single star “*” instead of “0..*”.
The following BNF defines the syntax for a multiplicity string, including support for the presentation options.
multiplicity ::= <multiplicity_range> [ ‘{‘ <order_designator> ‘}’ ]multiplicity_range ::= [ lower ‘..’ ] upperlower ::= integer | value_specificationupper ::= unlimited_natural | ‘*’ | value_specification<order_designator> ::= ordered | unordered<uniqueness_designator> ::= unique | nonunique
Examples 
7.4.2 Type (from Kernel)
A type constrains the values represented by a typed element.Figure 11 - Multiplicity within a textual specification
Figure 12 - Multiplicity as an adornment to a symbolCustomer
purchase  :  Purchase [*] {ordered, unique}
account: Account [0..5] {unique}
Customer Account Purchasepurchase account
0..5 *{ordered
unique}{unique}
44                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
A type serves as a constraint on the range of values represented by a typed element. Type is an abstract metaclass.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Additional Operations
[1]  The query conformsTo() gives true for a type that conforms to another. By default, two types do not conform to each other.  
This query is intended to be redefined for specific conformance situations.
conformsTo(other: Type): Boolean;
conformsTo = false
Semantics
A type represents a set of values. A typed element that has this type is constrained to represent values within this set.
Notation
No general notation.
7.4.3 TypedElement (from Kernel)
A typed element has a type.
Description
A typed element is an element that has a type that serves as a constraint on the range of values the element can represent. 
Typed element is an abstract metaclass.
Attributes
No additional attributes.
Associations
 type: Type [0..1] The type of the TypedElement.
Constraints
No additional constraints.
Semantics
Values represented by the element are constrained to be instances of the type. A typed element with no associated type may represent values of any type.
UML Superstructure 2.0 Draft Adopted Specification        45Notation
No general notation.
7.5 Kernel – the Expressions Diagram
The Expressions diagram of the Kernel package is shown in Figure 13. 
In order to locate the metaclasses that are referenced from this diagram,
 See “Element (from Kernel)” on page 29.
 See “InstanceSpecification (from Kernel)” on page 57.
 See “MultiplicityElement (from Kernel)” on page 40.
7.5.1 Expression (from Kernel)
An expression is a structured tree of symbols that denotes a (possibly empty) set of values when evaluated in a context.
Description
An expression represents a node in an expression tree, which may be non-terminal or terminal. It defines a symbol, and has a 
possibly empty sequence of operands which are value specifications.
Attributes
 symbol: String [1] The symbol associated with the node in the expression tree.Figure 13 - The Expressions diagram of the Kernel package.OpaqueExpression
body : String
language : String [0..1]LiteralSpecification
Li te ra lB o ole an
value : BooleanLiteralInteger
val ue : IntegerLiteralString
value : StringLiteralUnlimitedNatural
v a lue  : U nl imi te dN atur alLiteralNullInstanceValueInstanceSpecification
1+instance
1Expres s ion
sym b ol  : Stri n gValueSpecifi cati on
*
0..1+operand
* {ordered, subsets ownedElement}
+expre ssi on
0..1
{s ubsets owner}TypedElem ent
46                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 operand: ValueSpecification[*]Specifies a sequence of operands. Subsets Element::ownedElement .
Constraints
No additional constraints.
Semantics
An expression represents a node in an expression tree. If there are no operands it represents a terminal node. If there are 
operands it represents an operator applied to those operands. In either case there is a symbol associated with the node. The interpretation of this symbol depends on the context of the expression.
Notation
By default an expression with no operands is notated simply by its symbol, with no quotes. An expression with operands is notated by its symbol, followed by round parentheses containing its operands in order. In particular contexts special notations  
may be permitted, including infix operators.
Examples
xorelseplus(x,1)x+1
7.5.2 OpaqueExpression (from Kernel)
An opaque expression is an uninterpreted textual statement that denotes a (possibly empty) set of values when evaluated in a context.
Description
An expression contains a language-specific text string used to describe a value or values, and an optional specification of the  
language.
One predefined language for specifying expressions is OCL. Natural language or programming languages may also be used.
Attributes
 body: String [1] The text of the expression.
 language: String [0..1] Specifies the language in which the expression is stated. The interpretation of the expres-
sion body depends on the language. If language is unspecified, it might be implicit from the expression body or the context.
Associations
No additional associations.
Constraints
No additional constraints.
UML Superstructure 2.0 Draft Adopted Specification        47Additional Operations 
These operations are not defined within the specification of UML. They should be defined within an implementation that 
implements constraints so that constraints that use these operations can be evaluated.
[1]  The query value() gives an integer value for an expression intended to produce one.
Expression::value(): Integer;
pre: self.isIntegral()
[2] The query isIntegral() tells whether an expression is intended to produce an integer.
Expression::isIntegral(): Boolean;
[3] The query isPositive() tells whether an integer expression has a positive value.
Expression::isPositive(): Boolean;
pre: self.isIntegral()
[4] The query isNonNegative() tells whether an integer expression has a non-negative value.
Expression::isNonNegative(): Boolean;
pre: self.isIntegral()
Semantics
The interpretation of the expression body depends on the language. If the language is unspecified, it might be implicit from th e 
expression body or the context.
It is assumed that a linguistic analyzer for the specified language will evaluate the body. The time at which the body will be evaluated is not specified.
Notation
An opaque expression is displayed as a text string in a particular language. The syntax of the string is the responsibility of a 
tool and a linguistic analyzer for the language. 
An opaque expression is displayed as a part of the notation for its containing element.
The language of an opaque expression, if specified, is often not shown on a diagram. Some modeling tools may impose a particular language or assume a particular default language. The language is often implicit under the assumption that the form of the expression makes its purpose clear. If the language name is shown, it should be displayed in braces ({}) before the expression string.
Style Guidelines
A language name should be spelled and capitalized exactly as it appears in the document defining the language. For example, use OCL, not ocl.
Examples
a > 0{OCL} i > j and self.size > iaverage hours worked per week
7.5.3 InstanceValue (from Kernel)
An instance value is a value specification that identifies an instance.
48                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
An instance value specifies the value modeled by an instance specification.
Attributes
No additional attributes.
Associations
 instance: InstanceSpecification [1]The instance that is the specified value.
Constraints
No additional constraints.
Semantics
The instance specification is the specified value.
Notation
An instance value can appear using textual or graphical notation. When textual, as can appear for the value of an attribute slo t, 
the name of the instance is shown. When graphical, a reference value is shown by connecting to the instance. See “InstanceSpecification”.
7.5.4 LiteralBoolean (from Kernel)
A literal boolean is a specification of a boolean value.
Description
A literal boolean contains a Boolean-valued attribute.
Attributes
 value: Boolean The specified Boolean value.
Associations
No additional associations.
Constraints
No additional constraints.
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralBoolean::isComputable(): Boolean;
isComputable = true
[2] The query booleanValue() gives the value.
LiteralBoolean::booleanValue() : [Boolean];booleanValue = value
UML Superstructure 2.0 Draft Adopted Specification        49Semantics
A LiteralBoolean specifies a constant Boolean value.
Notation
A LiteralBoolean is shown as either the word ‘true’ or the word ‘false’, corresponding to its value. 
7.5.5 LiteralInteger (from Kernel)
A literal integer is a specification of an integer value.
Description
A literal integer contains an Integer-valued attribute.
Attributes
 value: Integer The specified Integer value.
Associations
No additional associations.
Constraints
No additional constraints.
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralInteger::isComputable(): Boolean;
isComputable = true
[2] The query integerValue() gives the value.
LiteralInteger::integerValue() : [Integer];integerValue = value
Semantics
A LiteralInteger specifies a constant Integer value.
Notation
A LiteralInteger is shown as a sequence of digits.
7.5.6 LiteralNull (from Kernel)
A literal null specifies the lack of a value. 
Description
A literal null is used to represent null, i.e., the absence of a value.
50                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
[1]  The query isComputable() is redefined to be true.
LiteralNull::isComputable(): Boolean;
isComputable = true
[2] The query isNull() returns true.
LiteralNull::isNull() : Boolean;
isNull = true
Semantics
LiteralNull is intended to be used to explicitly model the lack of a value.
Notation
Notation for LiteralNull varies depending on where it is used. It often appears as the word ‘null’. Other notations are describ ed 
for specific uses.
7.5.7 LiteralSpecification (from Kernel)
A literal specification identifies a literal constant being modeled.
Description
A literal specification is an abstract specialization of ValueSpecification that identifies a literal constant being modeled.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
No additional semantics. Subclasses of LiteralSpecification are defined to specify literal values of different types.
Notation
No specific notation.
UML Superstructure 2.0 Draft Adopted Specification        517.5.8 LiteralString (from Kernel)
A literal string is a specification of a string value.
Description
A literal string contains a String-valued attribute.
Attributes
 value: String The specified String value.
Associations
No additional associations.
Constraints
No additional constraints.
Additional Operations
[1]  The query isComputable() is redefined to be true.
LiteralString::isComputable(): Boolean;
isComputable = true
[2] The query stringValue() gives the value.
LiteralString::stringValue() : [String];stringValue = value
Semantics
A LiteralString specifies a constant String value.
Notation
A LiteralString is shown as a sequence of characters within double quotes. 
The character set used is unspecified.
7.5.9 LiteralUnlimitedNatural (from Kernel)
A literal unlimited natural is a specification of an unlimited natural number.
Description
A literal unlimited natural contains a UnlimitedNatural-valued attribute.
Attributes
 value: UnlimitedNatural The specified UnlimitedNatural value.
Associations
No additional associations.
52                 UML Superstructure 2.0 Draft Adopted SpecificationConstraints
No additional constraints.
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralUnlimitedNatural::isComputable(): Boolean;
isComputable = true
[2] The query unlimitedValue() gives the value.
LiteralUnlimitedNatural::unlimitedValue() : [UnlimitedNatural];
unlimitedValue = value
Semantics
A LiteralUnlimitedNatural specifies a constant UnlimitedNatural value.
Notation
A LiteralUnlimitedNatural is shown either as a sequence of digits or as an asterisk (*), where an asterisk denotes unlimited 
(and not infinity).
7.5.10 ValueSpecification (from Kernel)
A value specification is the specification of a (possibly empty) set of instances, including both objects and data values.
Description
ValueSpecification is an abstract metaclass used to identify a value or values in a model. It may reference an instance or it m ay 
be an expression denoting an instance or instances when evaluated.
Attributes
 expression: Expression[0..1] If this value specification is an operand, the owning expression. Subsets Element::owner .
Associations
No additional associations.
Constraints
No additional constraints.
Additional Operations 
These operations are introduced here. They are expected to be redefined in subclasses. Conforming implementations may be 
able to compute values for more expressions that are specified by the constraints that involve these operations.
[1]  The query isComputable() determines whether a value specification can be computed in a model. This operation cannot be 
fully defined in OCL. A conforming implementation is expected to deliver true for this operation for all value specifica-tions that it can compute, and to compute all of those for which the operation is true. A conforming implementation is expected to be able to compute the value of all literals.
ValueSpecification::isComputable(): Boolean;
isComputable = false
UML Superstructure 2.0 Draft Adopted Specification        53[2] The query integerValue() gives a single Integer value when one can be computed.
ValueSpecification::integerValue() : [Integer];
integerValue = Set{}
[3] The query booleanValue() gives a single Boolean value when one can be computed.
ValueSpecification::booleanValue() : [Boolean];
booleanValue = Set{}
[4] The query stringValue() gives a single String value when one can be computed.
ValueSpecification::stringValue() : [String];
stringValue = Set{}
[5] The query unlimitedValue() gives a single UnlimitedNatural value when one can be computed.
ValueSpecification::unlimitedValue() : [UnlimitedNatural];unlimitedValue = Set{}
[6] The query isNull() returns true when it can be computed that the value is null.
ValueSpecification::isNull() : Boolean;
isNull = false
Semantics
A value specification yields zero or more values. It is required that the type and number of values is suitable for the context  
where the value specification is used.
Notation
No specific notation.
7.6 Kernel – the Constraints Diagram
The Constraints diagram of the Kernel package is shown in Figure 14. 
In order to locate the metaclasses that are referenced from this diagram,
 See “Element (from Kernel)” on page 29.
 See “Namespace (from Kernel)” on page 35.
 See “PackageableElement (from Kernel)” on page 37.
 See “ValueSpecification (from Kernel)” on page 52.Figure 14 - The Constraints diagram of the Kernel packagePackageableElem ent
Nam espa ce
ValueSpecificationConstraint
* 0..1 *+/context
0..1 { uni on}
0..1 *+namespace
0..1 {subsets context}+ownedRul e
* { s ub s et s ow n edMem ber } 0..1 1 0..1+sp eci fi ca ti o n
1 { s ub s et s ow n edElement }Elem ent
*+constrainedElement
*{ordered}
54                 UML Superstructure 2.0 Draft Adopted Specification7.6.1 Constraint (from Kernel)
A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the purpose  
of declaring some of the semantics of an element.
Description
Constraint contains a ValueSpecification that specifies additional semantics for one or more elements. Certain kinds of constraints (such as an association “xor” constraint) are predefined in UML, others may be user-defined. A user-defined Constraint is described using a specified language, whose syntax and interpretation is a tool responsibility. One predefined language for writing constraints is OCL. In some situations, a programming language such as Java may be appropriate for 
expressing a constraint. In other situations natural language may be used.
Constraint is a condition (a Boolean expression) that restricts the extension of the associated element beyond what is imposed 
by the other language constructs applied to that element.
Constraint contains an optional name, although they are commonly unnamed.
Attributes
No additional attributes.
Associations
 constrainedElement: Element[*]The ordered set of Elements referenced by this Constraint.
 / context: Namespace [0..1] Specifies the Namesp ace that is the context for evaluating this constraint. This is a 
derived union.
 specification: ValueSpecification[0..1]
A condition that must be true when evaluated in order for the constraint to be satisfied. Subsets Element::ownedElement .
Constraints
[1]  The value specification for a constraint must evaluate to a boolean value.
Cannot be expressed in OCL.
[2] Evaluating the value specification for a constraint must not have side effects.
Cannot be expressed in OCL.
[3] A constraint cannot be applied to itself.
not constrainedElement->includes( self )
Semantics
A Constraint represents additional semantic information attached to the constrained elements. A constraint is an assertion that  
indicates a restriction that must be satisfied by a correct design of the system. The constrained elements are those elements required to evaluate the constraint specification. In addition, the context of the Constraint may be accessed, and may be used as 
the namespace for interpreting names used in the specification. For example, in OCL ‘self’ is used to refer to the context element.
Constraints are often expressed as a text string in some language. If a formal language such as OCL is used, then tools may be able to verify some aspects of the constraints.
In general there are many possible kinds of owners for a Constraint. The only restriction is that the owning element must have 
UML Superstructure 2.0 Draft Adopted Specification        55access to the constrainedElements. 
The owner of the Constraint will determine when the constraint specification is evaluated. For example, this allows an 
Operation to specify if a Constraint represents a precondition or a postcondition.
Notation
A Constraint is shown as a text string in braces ({}) according to the following BNF:
constraint ::= ‘{‘ [ <name> ‘:’ ] <boolean expression>’ }’
For an element whose notation is a text string (such as an attribute, etc.), the constraint string may follow the element text string in braces. Figure 15 shows a constraint string that follows an attribute within a class symbol.
For a Constraint that applies to a single element (such as a class or an association path), the constraint string may be placed  
near the symbol for the element, preferably near the name, if any. A tool must make it possible to determine the constrained element.
For a Constraint that applies to two elements (such as two classes or two associations), the constraint may be shown as a dashed line between the elements labeled by the constraint string (in braces). Figure 16 shows an {xor} constraint between two associations.
Presentation Options
The constraint string may be placed in a note symbol and attached to each of the symbols for the constrained elements by a dashed line. Figure 17 shows an example of a constraint in a note symbol.
If the constraint is shown as a dashed line between two elements, then an arrowhead may be placed on one end. The direction of the arrow is relevant information within the constraint. The element at the tail of the arrow is mapped to the first positio n 
and the element at the head of the arrow is mapped to the second position in the constrainedElements collection.
For three or more paths of the same kind (such as generalization paths or association paths), the constraint may be attached to  
a dashed line crossing all of the paths.
56                 UML Superstructure 2.0 Draft Adopted SpecificationExamples 
Figure 15 - Constraint attached to an attribute
Figure 16 - {xor} constraintStack
size: Integer {size >= 0}
push()
pop()
AccountPerson
Corporation{xor}
UML Superstructure 2.0 Draft Adopted Specification        577.7 Kernel – the Instances Diagram
The Instances diagram of the Kernel package is shown in Figure 18. 
In order to locate the metaclasses that are referenced from this diagram,
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “Element (from Kernel)” on page 29.
 See “PackageableElement (from Kernel)” on page 37.
 See “StructuralFeature (from Kernel)” on page 75.
 See “ValueSpecification (from Kernel)” on page 52.
7.7.1 InstanceSpecification (from Kernel)
An instance specification is a model element that represents an instance in a modeled system.Figure 17 - Constraint in a note symbol
Figure 18 - The Instances diagram of the Kernel package.Person Companyemployee employer
* 0..1boss0..1
{self.boss->isEmpty() or
self.employer = self.boss.employer}
PackageableElem entElem ent
ValueSpecification
ClassifierIns tanceSpecification
0..10..1+owningInstanceSpec
0..1{subsets owner}+specification
0..1 {s ubs ets  ownedElement}
0..*+cl a ssi fi er
0..*ValueSpecificationSlot
1 *+owningIns tance
1{subsets owner}+slot
* {s ubsets ownedElement}0..1
*+owningSlot
0..1{s ubs ets  owner} +value
*{ordered,
subsets ownedElement}
StructuralFeature
1+definingF eature
1
58                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
An instance specification specifies existence of an entity in a modeled system and completely or partially describes the entity . 
The description may include:
 Classification of the entity by one or more classifiers of which the entity is an instance. If the only classifier specified is abstract, then the instance specification only partially describes the entity.
 The kind of instance, based on its classifier or classifiers — for example, an instance specification whose classifier is a class describes an object of that class, while an instance specification whose classifier is an association describes a link of that association.
 Specification of values of structural features of the entity. Not all structural features of all classifiers of the instance specification need be represented by slots, in which case the instance specification is a partial description.
 Specification of how to compute, derive or construct the instance (optional).
InstanceSpecification is a concrete class. 
Attributes
No additional attributes.
Associations
 classifier : Classifier [0..*] The classifier or classifiers of the represented instance. If multiple classifiers are specified , 
the instance is classified by all of them.
 slot : Slot [*] A slot giving the value or values of a structural feature of the instance. An instance speci-
fication can have one slot per structural feature of its classifiers, including inherited fea-tures. It is not necessary to model a slot for each structural feature, in which case the instance specification is a partial description. Subsets Element::ownedElement .
 specification : ValueSpecification [0..1]A specification of how to compute, derive, or construct the instance. Subsets Ele-
ment::ownedElement .
Constraints
[1]  The defining feature of each slot is a structural feature (directly or inherited) of a classifier of the instance specific ation.
slot->forAll(s |
classifier->exists(c | c.allFeatures()->includes(s.definingFeature))
[2] One structural feature (including the same feature inherited from multiple classifiers) is the defining feature of at most
one slot in an instance specification.
classifier->forAll(c |
(c.allFeatures()->forAll(f | slot->select(s | s.definingFeature = f)->size() <= 1)
)
Semantics
An instance specification may specify the existence of an entity in a modeled system. An instance specification may provide 
an illustration or example of a possible entity in a modeled system. An instance specification describes the entity. These deta ils 
can be incomplete. The purpose of an instance specification is to show what is of interest about an entity in the modeled system. The entity conforms to the specification of each classifier of the instance specification, and has features with values  
indicated by each slot of the instance specification. Having no slot in an instance specification for some feature does not mea n 
that the represented entity does not have the feature, but merely that the feature is not of interest in the model.
UML Superstructure 2.0 Draft Adopted Specification        59An instance specification can represent an entity at a point in time (a snapshot). Changes to the entity can be modeled using 
multiple instance specifications, one for each snapshot.
Note – When used to provide an illustration or example of an entity in a modeled system, an InstanceSpecification class does
not depict a precise run-time structure. Instead, it describes information about such structures. No conclusions can be drawnabout the implementation detail of run-time structure. When used to specify the existence of an entity in a modeled system, aninstance specification represents part of that system. Instance specifications can be modeled incompletely — required struc-tural features can be omitted, and classifiers of an instance specification can be abstract, even though an actual entity wouldhave a concrete classification.
Notation
An instance specification is depicted using the same notation as its classifier, but in place of the classifier name appears an  
underlined concatenation of the instance name (if any), a colon (‘:’) and the classifier name or names. If there are multiple classifiers, the names are all shown separated by commas. Classifier names can be omitted from a diagram.
If an instance specification has a value specification as its specification, the value specification is shown either after an e qual 
sign (“=”) following the name, or without an equal sign below the name. If the instance specification is shown using an enclosing shape (such as a rectangle) that contains the name, the value specification is shown within the enclosing shape.
Slots are shown using similar notation to that of the corresponding structural features. Where a feature would be shown textually in a compartment, a slot for that feature can be shown textually as a feature name followed by an equal sign (‘=’) an d 
a value specification. Other properties of the feature, such as its type, can optionally be shown.
An instance specification whose classifier is an association represents a link and is shown using the same notation as for an association, but the solid path or paths connect instance specifications rather than classifiers. It is not necessary to show a n 
underlined name where it is clear from its connection to instance specifications that it represents a link and not an associati on. 
End names can adorn the ends. Navigation arrows can be shown, but if shown, they must agree with the navigation of the Figure 19 - Specification of an instance of String
Figure 20 - Slots with valuesstreetName: String
"S. Crown Ct."
streetName = "S. Crown Ct."
streetNumber : Integer = 381myAddress: Address
60                 UML Superstructure 2.0 Draft Adopted Specificationassociation ends.
Presentation Options
A slot value for an attribute can be shown using a notation similar to that for a link. A solid path runs from the owning 
instance specification to the target instance specification representing the slot value, and the name of the attribute adorns 
the target end of the path. Navigability, if shown, must be only in the direction of the target.
7.7.2 Slot (from Kernel)
A slot specifies that an entity modeled by an instance specification has a value or values for a specific structural feature.
Description
A slot is owned by an instance specification. It specifies the value or values for its defining feature, which must be a struct ural 
feature of a classifier of the instance specification owning the slot.
Attributes
No additional attributes.
Associations
 definingFeature : StructuralFeature [1]
The structural feature that specifies the values that may be held by the slot.
 owningInstance : InstanceSpecification [1]
The instance specification that owns this slot. Subsets Element::owner .
 value : InstanceSpecification [*]
The value or values corresponding to the defining feature for the owning instance specifi-cation. This is an ordered association. Subsets Element::ownedElement .
Constraints
No additional constraints.
Semantics
A slot relates an instance specification, a structural feature, and a value or values. It represents that an entity modeled by the 
instance specification has a structural feature with the specified value or values. The values in a slot must conform to the defining feature of the slot (in type, multiplicity, etc.).
Notation
See “InstanceSpecification (from Kernel)”.Figure 21 - Instance specifications representing two objects connected by a linkDon : Person Josh : Person father son
UML Superstructure 2.0 Draft Adopted Specification        617.8 Kernel – the Classifiers Diagram
The Classifiers diagram of the Kernel package is shown in Figure 22. 
In order to locate the metaclasses that are referenced from this diagram,
 See “DirectedRelationship (from Kernel)” on page 28.
 See “NamedElement (from Kernel, Dependencies)” on page 33.
 See “Namespace (from Kernel)” on page 35.
 See “PackageableElement (from Kernel)” on page 37.
7.8.1 Classifier (from Kernel, Dependencies, PowerTypes)
A classifier is a classification of instances — it describes a set of instances that have features in common. 
Description
A classifier is a namespace whose members can include features. Classifier is an abstract metaclass.
A classifier is a type and can own generalizations, thereby making it possible to define generalization relationships to other 
classifiers. A classifier can specify a generalization hierarchy by referencing its general classifiers.
A classifier is a redefinable element, meaning that it is possible to redefine nested classifiers.
Attributes
 isAbstract: Boolean If true, the Classifier does not provide a complete declaration and can typically not be 
instantiated. An abstract classifier is intended to be used by other classifiers e.g. as the tar-get of general metarelationships or generalization relationships. Default value is false . Figure 22 - The Classifiers diagram of the Kernel packageDirectedRelationship Na me d E l e me n t Namespace
RedefinableElem ent
isLeaf : Boolean = false
*+/redefi nedElement
*{union}Generalization
is Subs titutable : BooleanClassifier
isAbstract : Boolean = false
*+redefinedClassifier
* {s ubs ets redefinedElement}*+ /rede fi ni ti onCo ntext
* {union }
1 *+s pecific
1{s ubs ets s ource, 
subs ets  owner}+ge neralization
* { s ub s et s ow n edElement }1+general
1{s ubs ets  target}
* +/general *Na me d E l e me n t
*+/inher i tedMember
*{s ubs ets member}RedefinableElem ent Type
62                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 attribute: Property [*] Refers to all of the Properties that are direct (i.e. not inherited or imported) attributes of 
the classifier. Subsets Classifier::feature  and is a derived union.
 / feature : Feature [*] Specifies each feature defined in the classifier. Subsets Namespace::member . This is a 
derived union.
 / general : Classifier[*] Specifies the general Classifiers for this Classifier. This is derived. generalization: Generalization[*]Specifies the Generalization relationships for this Classifier. These Generalizations navi-
gate to more general classifiers in the generalization hierarchy. Subsets Ele-
ment::ownedElement .
 / inheritedMember: NamedElement[*]Specifies all elements inherited by this classifier from the general classifiers. Sub-
sets Namespace::member . This is derived.
 package: Package [0..1] Specifies the owning package of this classifier, if any. Subsets NamedEle-
ment::namespace .
 redefinedClassifier: Classifier [*]References the Classifiers that are redefined by this Classifier. Subsets RedefinableEle-
ment::redefinedElement .
Package Dependencies (“Dependencies” on page 105)
 substitution : Substitution References the substitutions that are owned by this Classifier. Subsets Ele-
ment::ownedElement  and NamedElement::clientDependency .)
Package PowerTypes (“PowerTypes” on page 120)
 powertypeExtent : GeneralizationSet
Designates the GeneralizationSet of which the associated Classifier is a power type.
Constraints
[1]  The general classifiers are the classifiers referenced by the generalization relationships.
general = self.parents()
[2] Generalization hierarchies must be directed and acyclical. A classifier can not be both a transitively general and transi-
tively specific classifier of the same classifier.
not self.allParents()->includes(self)
[3] A classifier may only specialize classifiers of a valid type.
self.parents()->forAll(c | self.maySpecializeType(c))
[4] The inheritedMember association is derived by inheriting the inheritable members of the parents.
self.inheritedMember->includesAll(self.inherit(self.parents()->collect(p | p.inheritableMembers(self)))
Package PowerTypes (“PowerTypes” on page 120)
[5] The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generaliza-
tion relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor mayits instances also be its subclasses.
Additional Operations
[1]  The query allFeatures() gives all of the features in the namespace of the classifier. In general, through mechanisms such as 
inheritance, this will be a larger set than feature.
UML Superstructure 2.0 Draft Adopted Specification        63Classifier::allFeatures(): Set(Feature);
allFeatures = member->select(oclIsKindOf(Feature))
[2] The query parents() gives all of the immediate ancestors of a generalized Classifier.
Classifier::parents(): Set(Classifier);
parents = generalization.general
[3] The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.
Classifier::allParents(): Set(Classifier);allParents = self.parents()->union(self.parents()->collect(p | p.allParents())
[4] The query inheritableMembers() gives all of the members of a classifier that may be inherited in one of its descendants,
subject to whatever visibility restrictions apply.
Classifier::inheritableMembers(c: Classifier): Set(NamedElement);
pre: c.allParents()->includes(self)
inheritableMembers = member->select(m | c.hasVisibilityOf(m))
[5] The query hasVisibilityOf() determines whether a named element is visible in the classifier. By default all are visible. It is
only called when the argument is something owned by a parent.
Classifier:: hasVisibilityOf (n: NamedElement) : Boolean;
pre: self.allParents()->collect(c | c.member)->includes(n)
hasVisibilityOf =true
[6] The query conformsTo() gives true for a classifier that defines a type that conforms to another. This is used, for example,
in the specification of signature conformance for operations.
Classifier::conformsTo(other: Classifier): Boolean;
conformsTo = (self=other) or (self.allParents()->includes(other))
[7] The query inherit() defines how to inherit a set of elements. Here the operation is defined to inherit them all. It is inten ded
to be redefined in circumstances where inheritance is affected by redefinition.
Classifier::inherit(inhs: Set(NamedElement)): Set(NamedElement);
inherit = inhs
[8] The query maySpecializeType() determines whether this classifier may have a generalization relationship to classifiers of
the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to beredefined by classifiers that have different specialization constraints.
Classifier::maySpecializeType(c : Classifier) : Boolean;
maySpecializeType = self.oclIsKindOf(c.oclType)
Semantics
A classifier is a classification of instances according to their features.
A Classifier may participate in generalization relationships with other Classifiers. An instance of a specific Classifier is al so an 
(indirect) instance of each of the general Classifiers. Therefore, features specified for instances of the general classifier a re 
implicitly specified for instances of the specific classifier. Any constraint applying to instances of the general classifier a lso 
applies to instances of the specific classifier.
The specific semantics of how generalization affects each concrete subtype of Classifier varies. All instances of a classifier have values corresponding to the classifier’s attributes. 
A Classifier defines a type. Type conformance between generalizable Classifiers is defined so that a Classifier conforms to itself and to all of its ancestors in the generalization hierarchy.
Package PowerTypes (“PowerTypes” on page 120)
The notion of power type was inspired by the notion of power set. A power set is defined as a set whose instances are subsets. In essence, then, a power type is a class whose instances are subclasses. The powertypeExtent association relates a Classifier 
64                 UML Superstructure 2.0 Draft Adopted Specificationwith a set of generalizations which a) have a common specific Classifier, and b) represent a subclass partitioning of that clas s. 
Semantic Variation Points
The precise lifecycle semantics of aggregation is a semantic variation point.
Notation
The default notation for a classifier is a solid-outline rectangle containing the classifier’s name, and optionally with 
compartments separated by horizontal lines containing features or other members of the classifier. The specific type of classifier can be shown in guillemets above the name. Some specializations of Classifier have their own distinct notations.
The name of an abstract Classifier is shown in italics.
An attribute can be shown as a text string that can be parsed into the various properties of an attribute. The basic syntax is (with optional parts shown in braces):
[visibility ] [/] name [: type ] [multiplicity ] [= default ] [{ property-string } ]
In the following bullets, each of these parts is described:
 visibility  is a visibility symbol such as +, -, #, or ~. See VisibilityKind (from Kernel) on page -39.
 / means the attribute is derived.
 name is the name of the attribute.
 type identifies a classifier that is the attribute’s type. 
 multiplicity  shows the attribute’s multiplicity in square brackets. The term may be omitted when a multiplicity of 1 
(exactly one) is to be assumed. See MultiplicityElement (from Kernel) on page -40
 default is an expression for the default value or values of the attribute.
 property-string indicates property values that apply to the attribute. The property string is optional (the braces are 
omitted if no properties are specified).
The following property strings can be applied to an attribute: {readOnly}, {union}, {subsets <property-name>}, {redefines <property-name>}, {ordered}, {bag}, {seq} or {sequence}, and {composite}.
An attribute with the same name as an attribute that would have been inherited is interpreted to be a redefinition, without the  
need for a {redefines <x>} property string. Note that a redefined attribute is not inherited into a namespace where it is redefined, so its name can be reused in the featuring classifier, either for the redefining attribute, or alternately for some other 
attribute.
Presentation Options
Any compartment may be suppressed. A separator line is not drawn for a suppressed compartment. If a compartment is suppressed, no inference can be drawn about the presence or absence of elements in it. Compartment names can be used to remove ambiguity, if necessary. 
An abstract Classifier can be shown using the keyword {abstract} after or below the name of the Classifier.
The type, visibility, default, multiplicity, property string may be suppressed from being displayed, even if there are values i n 
the model. 
The individual properties of an attribute can be shown in columns rather than as a continuous string.
UML Superstructure 2.0 Draft Adopted Specification        65Style Guidelines
Attribute names typically begin with a lowercase letter. Multiword names are often formed by concatenating the words and 
using lowercase for all letter except for upcasing the first letter of each word but the first.
Examples
The attributes in Figure 23  are explained below.
 ClassA::name is an attribute with type String .
 ClassA::shape is an attribute with type Rectangle.
 ClassA::size is a public attribute of type Integer with multiplicity 0..1.
 ClassA::area is a derived attribute with type Integer. It is marked as read-only.
 ClassA::height is an attribute of type Integer with a default initial value of 5.
 ClassA::width is an attribute of type Integer
 ClassB::id is an attribute that redefines ClassA::name.
 ClassB::shape is an attribute that redefines ClassA::shape. It has type Square, a specialization of Rectangle.
 ClassB::height is an attribute that redefines ClassA::height. It has a default of 7 for ClassB instances which overrides 
the ClassA default of 5.
 ClassB::width is a derived attribute that redefines ClassA::width, which is not derived.Figure 23 - Examples of attributesClassB
id {redefines name}
shape: Squareheight = 7/ widthClassA
name: Stringshape: Rectangle+ size: Integer [0..1]
/ area: Integer {readOnly}
height: Integer= 5width: Integer
66                 UML Superstructure 2.0 Draft Adopted SpecificationAn attribute may also be shown using association notation, with no adornments at the tail of the arrow as shown in Figure 24.
Package PowerTypes (“PowerTypes” on page 120)
For example, a Bank Account Type classifier could have a powertype association with a GeneralizationSet. This 
GeneralizationSet could then associate with two Generalizations where the class (i.e., general Classifier) Bank Account has two specific subclasses (i.e., Classifiers): Checking Account and Savings Account. Checking Account and Savings Account, then, are instances of the power type: Bank Account Type. In other words, Checking Account and Savings Account are both:  
instances of Bank Account Type, as well as subclasses of Bank Account. (For more explanation and examples, see Examples in the GeneralizationSet section, below.)
7.8.2 Generalization (from Kernel, PowerTypes)
A generalization is a taxonomic relationship between a more general classifier and a more specific classifier. Each instance of  
the specific classifier is also an indirect instance of the general classifier. Thus, the specific classifier inherits the feat ures of 
the more general classifier.
Description
A generalization relates a specific classifier to a more general classifier, and is owned by the specific classifier. 
Package PowerTypes (“PowerTypes” on page 120)
A generalization can be designated as being a member of a particular generalization set. 
Attributes
 isSubstitutable: Boolean [0..1] Indicates whether the specific classifier can be used whereever the general classifier can 
be used. If true, the execution traces of the specific classifier will be a superset of the exe-
cution traces of the general classifier.
Associations
 general: Classifier [1] References the general classifier in the Generalization relationship. 
Subsets DirectedRelationship::target .
 specific: Classifier [1] References the specializing classifier in the Generalization relationship. 
Subsets DirectedRelationship::source and Element::owner .
Package PowerTypes (“PowerTypes” on page 120)
 generalizationSet Designates a set in which instances of Generalization is considered members. 
Constraints
No additional constraints.Figure 24 - Association-like notation for attributeArea Windowsize
1
UML Superstructure 2.0 Draft Adopted Specification        67Package PowerTypes (“PowerTypes” on page 120)
[1]  Every Generalization associated with a given GeneralizationSet must have the same general Classifier. That is, all Gener-
alizations for a particular GeneralizationSet must have the same superclass.
Semantics
Where a generalization relates a specific classifier to a general classifier, each instance of the specific classifier is also an 
instance of the general classifier. Therefore, features specified for instances of the general classifier are implicitly specif ied for 
instances of the specific classifier. Any constraint applying to instances of the general classifier also applies to instances of the 
specific classifier.
Package PowerTypes (“PowerTypes” on page 120)
Each Generalization is a binary relationship that relates a specific Classifier to a more general Classifier (i.e., a subclass) . Each 
GeneralizationSet contains a particular set of Generalization relationships that collectively  describe the way in which a specific 
Classifier (or class) may be partitioned. The generalizationSet associates those instances of a Generalization with a particula r 
GeneralizationSet. 
For example, one Generalization could relate Person as a general Classifier with a Female Person as the specific Classifier. Another Generalization could also relate Person as a general Classifier, but have Male Person as the specific Classifier. These  
two Generalizations could be associated with the same GeneralizationSet, because they specify one way of partitioning the Person class. 
Notation
A Generalization is shown as a line with an hollow triangle as an arrowhead between the symbols representing the involved classifiers. The arrowhead points to the symbol representing the general classifier. This notation is referred to as the “separ ate 
target style”. See the example section below.
Package PowerTypes (“PowerTypes” on page 120)
A generalization is shown as a line with an hollow triangle as an arrowhead between the symbols representing the involved classifiers. The arrowhead points to the symbol representing the general classifier. When these relationships are named, that name designates the GeneralizationSet to which the Generalization belongs. Each GeneralizationSet has a name (which it inherits since it is a subclass of PackableElement). Therefore, all Generalization relationships with the same GeneralizationSe t 
name are part of the same GeneralizationSet. This notation form is depicted in a), below.
When two or more lines are drawn to the same arrowhead, as illustrated in b) below, the specific Classifiers are part of the same GeneralizationSet. When diagrammed in the way, the lines do not need to be labeled separately; instead the generalization set need only be labeled once. The labels are optional because the GeneralizationSet is clearly designated.
Lastly in c) below, a GeneralizationSet can be designated by drawing a dashed line across those lines with separate arrowheads that are meant to be part of the same set, as illustrated at the bottom of the figure below. Here, as with b), the Generalizati onSet 
may be labeled with a single name, instead of each line labeled separately. However, such labels are optional because the 
68                 UML Superstructure 2.0 Draft Adopted SpecificationGeneralizationSet is clearly designated.  
Presentation Options 
Multiple Generalization relationships that reference the same general classifier can be connected together in the “shared targe t 
style”. See the example section below.Figure 25 - GeneralizationSet designation notationsb) GeneralizationSet designation by subtypes sharing a common generalization arrowhead.
c) GeneralizationSet sharing same general Classifier using the dashed-line notation.one 
another
one Generalization SetGeneralization Setanother
Generalization Set
another
Generalization SetGeneralization 
Seta) GeneralizationSet sharing same general Classifier using the same generalization relationship names.one Generalization Setanother
Generalization Set
generalization
set name-2generalization
set name-1generalization
set name-1
generalization
set name-1 generalization
set name-2generalization
set name-2
generalization
set name-2generalization
set name-1generalization
set name-1
one 
Generalization 
Set
UML Superstructure 2.0 Draft Adopted Specification        69Examples 
Package PowerTypes (“PowerTypes” on page 120)
In the illustration below, the Person class can be specialized as either a Female Person or a Male Person. Furthermore, 
Person’s can be specialized as an Employee. Here, Female Person or a Male Person of Person constitute one GeneralizationSet and Manager another. This illustration employs the notation forms depicted in the diagram above. 
 Figure 26 - Examples of generalizations between classes
Figure 27 - Multiple subtype partitions (GeneralizationSets) exampleShape
Polygon Ellipse Spline
Shape
Polygon Ellipse SplineSeparate target style
Shared target style
Female 
Person
Male
PersonEmployeePerson
gender
Female 
PersonMale
PersonEmployeePersonemployment
statusgender
Female 
PersonMale
PersonEmployeePerson
gendergenderemployment
status
employment
status
Female 
PersonMale
PersonEmployeePerson
70                 UML Superstructure 2.0 Draft Adopted Specification7.8.3 RedefinableElement (from Kernel)
A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or 
differently in the context of another classifier that specializes (directly or indirectly) the context classifier.
Description
A redefinable element is a named element that can be redefined in the context of a generalization. RedefinableElement is an abstract metaclass.
Attributes
 isLeaf: Boolean Indicates whether it is possible to further specialize a RedefinableElement. If the value is 
true, then it is not possible to further specialize the RedefinableElement. Default value is false . 
Associations
 / redefinedElement: RedefinableElement[*]The redefinable element that is being redefined by this element. This is a 
derived union.
 / redefinitionContext: Classifier[*]References the contexts that this element may be redefined from. This is a derived 
union.
Constraints
[1]  At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefi nition 
contexts for each redefined element.
self.redefinedElement->forAll(e | self.isRedefinitionContextValid(e))
[2] A redefining element must be consistent with each redefined element.
self.redefinedElement->forAll(re | re.isConsistentWith(self))
Additional Operations
[1]  The query isConsistentWith() specifies, for any two RedefinableElements in a context in which redefinition is possible, 
whether redefinition would be logically consistent. By default, this is false; this operation must be overridden for sub-classes of RedefinableElement to define the consistency conditions.
RedefinableElement::isConsistentWith(redefinee: RedefinableElement): Boolean;
pre: redefinee.isRedefinitionContextValid(self)
isConsistentWith = false
[2] The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are prop-
erly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the other. Bydefault at least one of the redefinition contexts of this element must be a specialization of at least one of the redefinitioncontexts of the specified element.
RedefinableElement::isRedefinitionContexValid(redefinable: RedefinableElement): Boolean;
isRedefinitionContextValid = self.redefinitionContext->exists(c |
redefinable.redefinitionContext->exists(c | c.allParents()->includes(r))
)
Semantics
A RedefinableElement represents the general ability to be redefined in the context of a generalization relationship. The 
detailed semantics of redefinition varies for each specialization of RedefinableElement.
UML Superstructure 2.0 Draft Adopted Specification        71A redefinable element is a specification concerning instances of a classifier that is one of the element’s redefinition context s. 
For a classifier that specializes that more general classifier (directly or indirectly), another element can redefine the eleme nt 
from the general classifier in order to augment, constrain, or override the specification as it applies more specifically to instances of the specializing classifier.
A redefining element must be consistent with the element it redefines, but it can add specific constraints or other details tha t 
are particular to instances of the specializing redefinition context that do not contradict invariant constraints in the genera l 
context.
A redefinable element may be redefined multiple times. Furthermore, one redefining element may redefine multiple inherited redefinable elements.
Semantic Variation Points
There are various degrees of compatibility between the redefined element and the redefining element, such as name compatibility (the redefining element has the same name as the redefined element), structural compatibility (the client visible  
properties of the redefined element are also properties of the redefining element), or behavioral compatibility (the redefining  
element is substitutable for the redefined element). Any kind of compatibility involves a constraint on redefinitions. The particular constraint chosen is a semantic variation point. 
Notation
No general notation. See the subclasses of RedefinableElement for the specific notation used.
7.9 Kernel – the Features Diagram
The Features diagram of the Kernel package is shown in Figure 28. 
In order to locate the metaclasses that are referenced from this diagram,
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “NamedElement (from Kernel, Dependencies)” on page 33.
 See “Namespace (from Kernel)” on page 35.Figure 28 - The Features diagram of the Kernel packageRedefinableElem ent
StructuralFeature
isReadOnly : Boolean = falseTypedElem entPar amet er Direc tionKind
in
inoutout
return<<enumer ation>>
BehavioralFeatureParameter
d irecti on : Param eterDi re ct ion Kin d =  in
/ de fa ult  : Stri ng0..1 * 0..1+/parameter
*{union,
su bsets  mem b er,
ordered}
0..1 *+ownerReturnParam
0..1{s ubs ets  names pace} +r etur nRes ult
*{or der ed,
s ubs ets  parameter,
s ubs ets  ownedMember }0..1 *+ownerFormalPar am
0..1{su bsets na m e spa ce} +formalParameter
*{ordered,
su bse ts p ara m e te r,
s ubs ets  ownedMember}Feature
is Static : Boolean = fals eClassifier
* 1..*+/feature
* {u n i o n }+ /f ea tur in gCl assifi er
1..* {union}
Namespace
[0..1]ValueSpecif ic ation
0..1 0..1+owningParameter
0..1 { s ubs ets  owner}+defaultValue
0..1 {subsets ownedElement}MultiplicityElem entMultiplicityElem entTy pedEl em ent
Ty pe
*+rais edException*
72                 UML Superstructure 2.0 Draft Adopted Specification See “RedefinableElement (from Kernel)” on page 70.
 See “TypedElement (from Kernel)” on page 44.
 See “ValueSpecification (from Kernel)” on page 52.
7.9.1 BehavioralFeature (from Kernel)
A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.
Description
A behavioral feature specifies that an instance of a classifier will respond to a designated request by invoking a behavior. 
BehavioralFeature is an abstract metaclass specializing Feature and Namespace. Kinds of behavioral aspects are modeled by subclasses of BehavioralFeature. 
Attributes
No additional attributes.
Associations
 formalParameter: Parameter[*] Specifies the ordered set of formal parameters of this BehavioralFeature. Subsets 
BehavioralFeature::parameter and Namespace::ownedMember .
 raisedException: Type[*] References the Types representing exceptions that may be raised during an invocation of 
this operation.
 / parameter: Parameter[*] Specifies the parameters of the BehavioralFeature. Subsets Namespace::member . This is a 
derived union and is ordered.
 returnResult: Parameter[*] Specifies the ordered set of return results of this BehavioralFeature. Subsets Behavioral-
Feature::parameter and Namespace::ownedMember .
Constraints
No additional constraints.
Additional Operations
[1]  The query isDistinguishableFrom() determines whether two BehavioralFeatures may coexist in the same Namespace. It 
specifies that they have to have different signatures.
BehavioralFeature::isDistinguishableFrom(n: NamedElement, ns: Namespace): Boolean;
isDistinguishableFrom =
if n.oclIsKindOf(BehavioralFeature)
then
if ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->notEmpty()
then  Set{}->including(self)->including(n)->isUnique( bf | bf.parameter->collect(type))
else true
endif
else true
endif
Semantics
The list of parameters describes the order and type of arguments that can be given when the BehavioralFeature is invoked.
UML Superstructure 2.0 Draft Adopted Specification        73The formal parameters define the type, and number, of arguments that must be provided when invoking the BehavioralFeature. 
The return results define the type, and number, of arguments that will be returned from a successful invocation. A BehavioralFeature may raise an exception during its invocation.
Notation
No additional notation.
7.9.2 Feature (from Kernel)
A feature declares a behavioral or structural characteristic of instances of classifiers.
Description
A feature declares a behavioral or structural characteristic of instances of classifiers. Feature is an abstract metaclass.
Attributes
 isStatic: Boolean Specifies whether the feature is applied at the classifier-level (true) or the instance-level 
(false). Default value is false .
Associations
 / featuringClassifier: Classifier [1..*]
The Classifiers that have this Feature as a feature. This is a derived union.
Constraints
No additional constraints.
Semantics
A Feature represents some characteristic for its featuring classifiers. A Feature can be a feature of multiple classifiers.
Notation
No general notation. Subclasses define their specific notation.
Static features are underlined.
Presentation Options
Only the names of static features are underlined.
7.9.3 Parameter (from Kernel)
A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature.
Description
A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature. It  
has a type, and may have a multiplicity and an optional default value.
74                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
 / default: String [0..1] Specifies a  String that represents a value to be used when no argument is supplied for the 
Parameter. This is a derived value.
 direction: ParameterDirectionKind [1] Indicates whether a parameter is being sent into or out of a behavioral element. The 
default value is in. 
Associations
 /operation: Operation[0..1] References the Operation for which this is a formal parameter. Subsets NamedEle-
ment::namespace .
 defaultValue: ValueSpecification [0..1]Specifies a ValueSpecification that represents a value to be used when no argument 
is supplied for the Parameter. Subsets Element::ownedElement .
Constraints
No additional constraints.
Semantics
A parameter specifies how arguments are passed into or out of an invocation of a behavioral feature like an operation. The type  
and multiplicity of a parameter restrict what values can be passed, how many, and whether the values are ordered.
If a default is specified for a parameter, then it is evaluated at invocation time and used as the argument for this parameter if 
and only if no argument is supplied at invocation of the behavioral feature.
A parameter may be given a name, which then identifies the parameter uniquely within the parameters of the same behavioral feature. If it is unnamed, it is distinguished only by its position in the ordered list of parameters.
Notation
No general notation. Specific subclasses of BehavioralFeature will define the notation for their parameters. 
Style Guidelines
A parameter name typically starts with a lowercase letter.
7.9.4 ParameterDirectionKind (from Kernel)
Parameter direction kind is an enumeration type that defines literals used to specify direction of parameters.
Description
ParameterDirectionKind is an enumeration of the following literal values:
 in Indicates that parameter values are passed into the behavioral element by the caller. 
 inout Indicates that parameter values are passed into a behavioral element by the caller and then 
back out to the caller from the behavioral element.
 out Indicates that parameter values are passed from a behavioral element out to the caller.  return Indicates that parameter values are passed as return values from a behavioral element back 
to the caller. 
UML Superstructure 2.0 Draft Adopted Specification        757.9.5 StructuralFeature (from Kernel)
A structural feature is a typed feature of a classifier that specify the structure of instances of the classifier.
Description
A structural feature is a typed feature of a classifier that specify the structure of instances of the classifier. Structural f eature is 
an abstract metaclass.
By specializing multiplicity element, it supports a multiplicity that specifies valid cardinalities for the set of values assoc iated 
with an instantiation of the structural feature.
Attributes
 isReadOnly: Boolean States whether the feature’s value may be modified by a client. Default is false.
Associations
No additional associations. 
Constraints
No additional constraints.
Semantics
A structural feature specifies that instances of the featuring classifier have a slot whose value or values are of a specified type. 
Notation
A read only structural feature is shown using {readOnly} as part of the notation for the structural feature. A modifiable 
structural feature is shown using {unrestricted} as part of the notation for the structural feature. This annotation may be suppressed, in which case it is not possible to determine its value from the diagram.
Presentation Option
It is possible to only allow suppression of this annotation when isReadOnly=false. In this case it is possible to assume this value in all cases where {readOnly} is not shown.
76                 UML Superstructure 2.0 Draft Adopted Specification7.10 Kernel – the Operations Diagram
The Operations diagram of the Kernel package is shown in Figure 29. 
In order to locate the metaclasses that are referenced from this diagram,
 See “BehavioralFeature (from Kernel)” on page 72.
 See “Constraint (from Kernel)” on page 54.
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “Parameter (from Kernel)” on page 73.
7.10.1 Operation (from Kernel)
An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an  
associated behavior.
Description
An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an  
associated behavior.Figure 29 - The Operations diagram of the Kernel package.BehavioralFeature
[0..1]
[0..1]Cons traintParameter Operation
isQuery : Boo lea n = fal s e
/ isOrd ered : Boo lea n
/ isUni que : Bool ean
/  l ow er  : Inte ger
/ upper  : UnlimitedNatur al
*+redefinedOperation
* {subsets redefinedElement}0..1 *+preContext
0..1{subsets context,
subsets namespace}+precondition
*{subs ets ownedMember}
0..1 *+postContext
0..1{subsets context,
subsets namespace}+postcondition
* {subs ets ownedMember}
0..1 0..1+bodyCondition
0..1 {subsets ownedMember}+bodyContext
0..1{subs ets context,
subs ets names pace}*0..1+formalParameter
* {redefines formalParameter}+op er ation
0..1{subsets namespace}
Type
0..1+/type
0..1
*+raisedException
*
UML Superstructure 2.0 Draft Adopted Specification        77Attributes
 class : Class [0..1] The class that owns this operation. Subsets RedefinableElement::redefinitionContext, 
NamedElement::namespace and Feature::featuringClassifier .
 /isOrdered : Boolean Specifies whether the return parameter is ordered or not, if present. This is derived. isQuery : Boolean Specifies whether an execution of the BehavioralFeature leaves the state of the system 
unchanged (isQuery=true) or whether side effects may occur (isQuery=false). The default value is false.
 /isUnique : Boolean Specifies whether the return parameter is unique or not, if present. This is derived. /lower : Integer[0..1] Specifies the lower multiplicity of the return parameter, if present. This is derived.
 /upper : UnlimitedNatural[0..1]Specifies the upper multiplicity of the return parameter, if present.This is derived.
Associations
 bodyCondition: Constraint[0..1]An optional Constraint on the result values of an invocation of this Operation. Subsets 
Namespace::ownedMember .
 formalParameter: Parameter[*] Specifies the formal parameters for this Operation. Redefines BehavioralFeature::formal-
Parameter .
 postcondition: Constraint[*] An optional set of Constraints specifying the state of the system when the Operation is 
completed. Subsets Namespace::ownedMember .
 precondition: Constraint[*] An optional set of Constraints on the state of the system when the Operation is invoked. 
Subsets Namespace::ownedMember.
 raisedException: Type[*] References the Types representing exceptions that may be raised during an invocation of 
this operation. Redefines Basic::Operation.raisedException and BehavioralFea-ture.raisedException.
 redefinedOperation: Operation[*]References the Operations that are redefined by this Operation. Subsets RedefinableEle-
ment.redefinedElement.
 /type: Type[0..1] Specifies the return result of the operation, if present. This is a derived value.
Constraints
[1]  If this operation has a single return result, isOrdered equals the value of isOrdered for that parameter. Otherwise isOrde red 
is false.
isOrdered = if returnResult->size() = 1 then  returnResult->any().isOrdered else false endif
[2] If this operation has a single return result, isUnique equals the value of isUnique for that parameter. Otherwise isUnique i s
true.
isUnique  = if returnResult->size() = 1 then  returnResult->any(). isUnique  else true endif
[3] If this operation has a single return result, lower equals the value of lower for that parameter. Otherwise lower is not
defined.
lower  = if returnResult->size() = 1 then  returnResult->any(). lower  else Set{} endif
[4] If this operation has a single return result, upper equals the value of upper for that parameter. Otherwise upper is not
defined.
upper  = if returnResult->size() = 1 then  returnResult->any(). upper  else Set{} endif
[5] If this operation has a single return result, type equals the value of type for that parameter. Otherwise type is not define d.
78                 UML Superstructure 2.0 Draft Adopted Specificationtype = if returnResult->size() = 1 then  returnResult->any(). type else Set{} endif
[6] A bodyCondition can only be specified for a query operation.
bodyCondition->notEmpty() implies  isQuery
Additional Operations
[1]  The query isConsistentWith() specifies, for any two Operations in a context in which redefinition is possible, whether 
redefinition would be logically consistent. A redefining operation is consistent with a redefined operation if it has the same number of formal parameters, the same number of return results, and the type of each formal parameter and return result conforms to the type of the corresponding redefined parameter or return result.
Operation::isConsistentWith(redefinee: RedefinableElement): Boolean;
pre: redefinee.isRedefinitionContextValid(self)
isConsistentWith = (redefinee.oclIsKindOf(Operation) and
let op: Operation = redefinee.oclAsType(Operation) in
self.formalParameter.size() = op.formalParameter.size() and
self.returnResult.size() = op.returnResult.size() and
forAll(i | op.formalParameter[i].type.conformsTo(self.formalParameter[i].type)) and
forAll(i | op.returnResult[i].type.conformsTo(self.returnResult[i].type)))
Semantics
An operation is invoked on an instance of the classifier for which the operation is a feature.
The preconditions for an operation define conditions that must be true when the operation is invoked. These preconditions may 
be assumed by an implementation of this operation.
The postconditions for an operation define conditions that will be true when the invocation of the operation is completes successfully, assuming the preconditions were satisfied. These postconditions must be satisfied by any implementation of the operation.
The bodyCondition for an operation constrains the return result. The bodyCondition differs from postconditions in that the bodyCondition may be overridden when an operation is redefined, whereas postconditions can only be added during redefinition.
An operation may raise an exception during its invocation. When an exception is raised, it should not be assumed that the postconditions or bodyCondition of the operation are satisfied.
An operation may be redefined in a specialization of the featured classifier. This redefinition may specialize the types of the  
formal parameters or return results, add new preconditions or postconditions, add new raised exceptions, or otherwise refine the specification of the operation.
Each operation states whether or not its application will modify the state of the instance or any other element in the model (isQuery). 
An operation may be owned by and in the namespace of a class that provides the context for its possible redefinition.
Semantic Variation Points
The behavior of an invocation of an operation when a precondition is not satisfied is a semantic variation point.
Notation
An operation is shown as a text string of the form:
visibility name ( parameter-list ) : property-string
 Where visibility is the operation’s visibility -- visibility  may be suppressed.
UML Superstructure 2.0 Draft Adopted Specification        79 Where name is the operation’s name.
 Where parameter-list  is a comma-separated list of formal parameters, each specified using the syntax:
direction name : type-expression [multiplicity] = default-value [{ property-string }]
 Where direction is the parameter’s direction, with the default of in if absent.
 Where name is the parameter’s name.
 Where type-expression identifies the type of the parameter.
 Where multiplicity is the parameter’s multiplicity in square brackets -- multiplicity  may be suppressed in which 
case [1] is assumed.
 Where default-value is a value specification for the default value of the parameter. The default value is optional 
(the equal sign is also omitted if the default value is omitted). 
 Where property-string indicates property values that apply to the parameter. The property string is optional (the 
braces are omitted if no properties are specified).
 Where property-string  optionally shows other properties of the operation enclosed in braces.
Presentation Options
The parameter list can be suppressed.
Style Guidelines
An operation name typically begins with a lowercase letter.
Examples
display ()
-hide ()
+createWindow  (location: Coordinates, container: Container [0..1]): Window
+toString (): String
80                 UML Superstructure 2.0 Draft Adopted Specification7.11 Kernel – the Classes Diagram
The Classes diagram of the Kernel package is shown in Figure 30. 
In order to locate the metaclasses that are referenced from this diagram,
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “Operation (from Kernel)” on page 76.
 See “Relationship (from Kernel)” on page 30.
 See “StructuralFeature (from Kernel)” on page 75.
 See “ValueSpecification (from Kernel)” on page 52.
7.11.1 AggregationKind (from Kernel)
AggregationKind is an enumeration type that specifies the literals for defining the kind of aggregation of a property. 
Description
AggregationKind is an enumeration of the following literal values:
 none Indicates that the property has no aggregation.
 shared Indicates that the property has a shared aggregation.  composite Indicates that the property is aggregated compositely, i.e., the composite object has 
responsibility for the existence and storage of the composed objects (parts).
Semantic Variation Points
Precise semantics of shared aggregation varies by application area and modeler. Figure 30 - The Classes diagram of the Kernel package[0..1]StructuralFeature
Classifier
Class if ier
ValueSpecificationAs s ociation
is Der ived : B oolean = fals eProperty
is Derived : Boolean = fals e
is ReadOnly : Boolean = fals e
isDerivedUnion : Boolean = false/ default : Stringaggregation : AggregationKind = none
/ is Compos ite : Boolean
*+redefinedProperty
*{subsets redefinedElement}
0..1+/oppos ite
0..1*+s ub s et ted Pro p er ty
*0..1*+cl assi fi er
0..1 {s ubs ets  redefinitionContext}+/attribute
* {union,
s ubs ets  feature}
0. .1 0..1+owningProperty
0. .1 {su bse ts o wner}+defaul tValue
0..1{ s ub s et s  ow n e dE le me nt }0..1*+owningAs sociation
0..1 {sub sets a sso ci ati on ,
su bsets n am espa ce ,
s ubsets featuringClas sifier}+ownedEnd
* {ordered,
subsets  mem b erEnd,
s ubsets feature,
s ubs ets  ownedMember}0..1 2..*+associa tio n
0..1+memberEnd
2..*{o r d e re d ,
subsets  member}
C l ass ifi erCla ss
0..1 *+class
0..1 {su bsets cl assifi er,
s ubs ets  names pace,
subsets featuringClas sifier}+ownedAttribute
* {ordered,
subsets attribute,
subsets  owne dM em ber}
0..1 *+clas s
0..1 {su b se t s n a m e sp a c e ,
s ubs ets  redefinit ionContext}+nes tedClas s ifier
* {ordered, 
s ubsets ownedMember}*+/sup erCla ss
*{ red efine s gen eral}
AggregationKind
none
s haredcomposite<<enumeration>>Relati on shi p
[0..1]
Operation
0..1 *+class
0..1{subsets redefinitionContext,
subs ets names pace,
s ubs ets  featuringClas s ifier}+ownedOperation
*{ordered,
s ubs ets  feature,
s ubsets 
ownedMember}Type
1..*+/endType
1..*
UML Superstructure 2.0 Draft Adopted Specification        81The order and way in which part instances are created is not defined.
7.11.2 Association (from Kernel)
An association describes a set of tuples whose values refers to typed instances. An instance of an association is called a link .
Description
An association specifies a semantic relationship that can occur between typed instances. It has at least two ends represented b y 
properties, each of which is connected to the type of the end. More than one end of the association may have the same type.
When a property is owned by an association it represents a non-navigable end of the association. In this case the property does  
not appear in the namespace of any of the associated classifiers. When a property at an end of an association is owned by one of the associated classifiers it represents a navigable end of the association. In this case the property is also an attribute of the 
associated classifier. Only binary associations may have navigable ends.
Attributes
 isDerived : Boolean Specifies whether the association is derived from other model elements such as other asso-
ciations or constraints. The default value is false .
Associations
 memberEnd : Property [2..*] Each end represents participation of instances of the classifier connected to the end in 
links of the association. This is an ordered association. Subsets Namespace::member .
 ownedEnd : Property [*] The non-navigable ends that are owned by the association itself. This is an ordered associ-
ation. Subsets Association::memberEnd , Classifier::feature , and Namespace::owned-
Member .
 / endType: Type [1..*] References the classifiers that are used as types of the ends of the association.
Constraints
[1]  An association specializing another association has the same number of ends as the other association.
self.parents()->forAll(p | p.memberEnd.size() = self.memberEnd.size())
[2] When an association specializes another association, every end of the specific association corresponds to an end of the
general association, and the specific end reaches the same type or a subtype of the more general end.
[3] endType is derived from the types of the member ends.
self.endType = self.memberEnd->collect(e | e.type)
Semantics
An association declares that there can be links between instances of the associated types. A link is a tuple with one value for  
each end of the assocaition, where each value is an instance of the type of the end. 
When one or more ends of the association have isUnique=false, it is possible to have several links associating the same set of instances. In such a case, links carry an additional identifier apart from their end values.
When one or more ends of the association are ordered, links carry ordering information in addition to their end values.
For an association with N ends, choose any N-1 ends and associate specific instances with those ends. Then the collection of links of the association that refer to these specific instances will identify a collection of instances at the other end. The multiplicity of the association end constrains the size of this collection. If the end is marked as ordered, this collection wi ll be 
82                 UML Superstructure 2.0 Draft Adopted Specificationordered. If the end is marked as unique, this collection is a set; otherwise it allows duplicate elements.
An end of one association may be marked as a subset  of an end of another in circumstances where (a) both have the same 
number of ends, and (b) each of the set of types connected by the subsetting association conforms to a corresponding type connected by the subsetted association. In this case, given a set of specific instances for the other ends of both associations , the 
collection denoted by the subsetting end is fully included in the collection denoted by the subsetted end.
An end of one association may be marked as redefining  an end of another in circumstances where (a) both have the same 
number of ends, and (b) each of the set of types connected by the redefing association conforms to a corresponding type connected by the redefined association. In this case, given a set of specific instances for the other ends of both associations , the 
collections denoted by the redefining and redefined ends are the same.
Associations may be specialized. The existence of a link of a specializing association implies the existence of a link relating  
the same set of instances in a specialized association.
The semantics of navigable association ends are the same as for attributes.
Note – For n-ary associations, the lower multiplicity of an end is typically 0. If the lower multiplicity for an end of an n-ary
association of 1 (or more) implies that one link (or more) must exist for every possible combination of values for the otherends.
An association may represent a composite aggregation (i.e., a whole/part relationship). Only binary associations can be aggregations. Composite aggregation is a strong form of aggregation that requires a part instance be included in at most one composite at a time. If a composite is deleted, all of its parts are normally deleted with it. Note that a part can (where allo wed) 
be removed from a composite before the composite is deleted, and thus not be deleted as part of the composite. Compositions define transitive asymmetric relationships—their links form a directed, acyclic graph. Composition is represented by the isComposite attribute on the part end of the association being set to true.
Semantic Variation Points
The order and way in which part instances in a composite are created is not defined.
The logical relationship between the derivation of an association and the derivation of its ends is not defined.
The interaction of association specialization with association end redefinition and subsetting is not defined.
Notation
Any association may be drawn as a diamond (larger than a terminator on a line) with a solid line for each association end connecting the diamond to the classifier that is the end’s type. An association with more than two ends can only be drawn this way.
A binary assocation is normally drawn as a solid line connecting two classifiers, or a solid line connecting a single classifie r to 
itself (the two ends are distinct). A line may consist of one or more connected segments. The individual segments of the line itself have no semantic significance, but they may be graphically meaningful to a tool in dragging or resizing an association symbol.
An association symbol may be adorned as follows:
 The association’s name can be shown as a name string near the association symbol, but not near enough to an end to be confused with the end’s name. 
 A slash appearing in front of the name of an association, or in place of the name if no name is shown, marks the asso-ciation as being derived.
 A property string may be placed near the association symbol, but far enough from any end to not be confused with a 
UML Superstructure 2.0 Draft Adopted Specification        83property string on an end.
On a binary association drawn as a solid line, a solid triangular arrowhead next to or in place of the name of the 
association and pointing along the line in the direction of one end indicates that end to be the last in the order of the ends 
of the association. The arrow indicates that the association is to be read as associating the end away from the direction of 
the arrow with the end to which the arrow is pointing (see Figure 31).
 Generalizations between associations can be shown using a generalization arrow between the association symbols.
An association end is the connection between the line depicting an association and the icon (often a box) depicting the 
connected classifier. A name string may be placed near the end of the line to show the name of the association end. The name is optional and suppressible.
Various other notations can be placed near the end of the line as follows:
 A multiplicity.
 A property string enclosed in curly braces. The following property strings can be applied to an association end:
 {subsets <property-name>} to show that the end is a subset of the property called <property-name>.
 {redefined <end-name>} to show that the end redefines the one named <end-name>.
 {union} to show that the end is derived by being the union of its subsets.
 {ordered} to show that the end represents an ordered set.
 {bag} to show that the end represents a collection that permits the same element to appear more than once.
 {sequence} or {seq} to show that the end represents a sequence (an ordered bag).
 if the end is navigable, any property strings that apply to an attribute.
Note that by default an association end represents a set.
A stick arrowhead on the end of an association indicates the end is navigable. A small x on the end of an association indicates  
the end is not navigable. A visibility symbol can be added as an adornment on a navigable end to show the end’s visibility as an attribute of the featuring classifier.
If the association end is derived, this may be shown by putting a slash in front of the name, or in place of the name if no nam e 
is shown.
The notation for an attribute can be applied to a navigable assocation end name.
A composite aggregation is shown using the same notation as a binary association, but with a solid, filled diamond at the aggregate end.
Presentation Options
When two lines cross, the crossing may optionally be shown with a small semicircular jog to indicate that the lines do not intersect (as in electrical circuit diagrams).
Various options may be chosen for showing navigation arrows on a diagram. In practice, it is often convenient to suppress some of the arrows and crosses and just show exceptional situations:
 Show all arrows and xs. Navigation and its absence are made completely explicit. 
 Suppress all arrows and xs. No inference can be drawn about navigation. This is similar to any situation in which infor-mation is suppressed from a view.
 Suppress arrows for associations with navigability in both directions, and show arrows only for associations with one-
84                 UML Superstructure 2.0 Draft Adopted Specificationway navigability. In this case, the two-way navigability cannot be distinguished from situations where there is no nav-
igation at all; however, the latter case occurs rarely in practice.
If there are two or more aggregations to the same aggregate, they may be drawn as a tree by merging the aggregation ends into a single segment. Any adornments on that single segment apply to all of the aggregation ends.
Style Guidelines
Lines may be drawn using various styles, including orthogonal segments, oblique segments, and curved segments. The choice of a particular set of line styles is a user choice.
Generalizations between associations are best drawn using a different color or line width than what is used for the association s.
Examples
Figure 31 shows a binary association from Player  to Year  named PlayedInYear . The solid triangle indicates the order of 
reading: Player PlayedInYear Year . The figure further shows a ternary association between Team , Year , and Player  with ends 
named team , season , and goalie  respectively.
The following example shows association ends with various adornments.
The following adornments are shown on the four association ends in Figure 32.
 Names a, b, and d on three of the ends.Figure 31 - Binary and ternary associations
Figure 32 - Association ends with various adornmentsTeamYear
PlayerPlayedInYear
year*
* season
**
goalie team/triangleleft
B A
C Db
{ordered}*a
0..1
d
{subsets b}0..1 1
UML Superstructure 2.0 Draft Adopted Specification        85 Multiplicities 0..1 on a, * on b, 1 on the unnamed end, and 0..1 on d.
 Specification of ordering on b.
 Subsetting on d. For an instance of class C, the collection d is a subset of the collection b. This is equivalent to the OCL 
constraint:
context C inv: b->includesAll(d)
The following examples show notation for navigable ends.
In Figure 33:
 The top pair AB shows a binary association with two navigable ends.
 The second pair CD shows a binary association with two non-navigable ends. The third pair EF shows a binary association with unspecified navigability. The fourth pair GH shows a binary association with one end navigable and the other non-navigable. The fifth pair IJ shows a binary association with one end navigable and the other having unspecified navigability.
Figure 34 shows a navigable end using attribute notation. A navigable end is an attribute, so it can be shown using attribute 
notation. Normally this notation would be used in conjunction with the line-arrow notation to make it perfectly clear that the Figure 33 - Examples of navigable endsb
A B
2..5 1..4a
E F
2..5f
1..4eC D
2..5d
1..4c
h
G H
2..5 1..4g
I J
2..5j
1..4ib
A B
2..5 1..4a
E F
2..5f
1..4eC D
2..5d
1..4c
h
G H
2..5 1..4g
I J
2..5j
1..4i
86                 UML Superstructure 2.0 Draft Adopted Specificationnavigable ends are also attributes.
Figure 35 shows the notation for a derived union. The attribute A::b is derived by being the strict union of all of the attribu tes 
that subset it. In this case there is just one of these, A1::b1. So for an instance of the class A1, b1 is a subset of b, and b  is 
derived from b1.
Figure 36 shows the black diamond notation for composite aggregation.
7.11.3 Class (from Kernel)
A class describes a set of objects that share the same specifications of features, constraints, and semantics. Figure 34 - Example of navigable end shown with attribute notation
Figure 35 - Derived supersets (union)
Figure 36 - Composite aggregation is depicted as a black diamondA
b: B[*]
A B
0..*/b {union}
0..1a
A1 B1
0..*b1
0..1a
{subsets b}
Window
Slider
Header Panel+scrollbar
+title +body111
21 1
UML Superstructure 2.0 Draft Adopted Specification        87Description
Class is a kind of classifier whose features are attributes and operations. Attributes of a class are represented by instances of 
Property that are owned by the class. Some of these attributes may represent the navigable ends of binary associations.
Attributes
No additional attributes.
Associations
 nestedClassifier: Classifier [*] References all the Classifiers that are defined (nested) within the Class. Subsets Ele-
ment::ownedMember .
 ownedAttribute : Property [*]
The attributes (i.e. the properties) owned by the class. The association is ordered. Subsets Classifier::attribute  and Namespace::ownedMember .
 ownedOperation : Operation [*]
The operations owned by the class. The association is ordered. Subsets Classifier::feature  
and Namespace::ownedMember .
 / superClass : Class [*] This gives the superclasses of a class. It redefines Classifier::general.  This is derived.
Constraints
No additional constraints.
Additional Operations
[1]  The inherit operation is overridden to exclude redefined properties.
Class::inherit(inhs: Set(NamedElement)) : Set(NamedElement);
inherit = inhs->excluding(inh |
ownedMember->select(oclIsKindOf(RedefinableElement))->select(redefinedElement->includes(inh)))
Semantics
The purpose of a class is to specify a classification of objects and to specify the features that characterize the structure an d 
behavior of those objects.
Objects of a class must contain values for each attribute that is a member of that class, in accordance with the characteristic s of 
the attribute, for example its type and multiplicity.
When an object is instantiated in a class, for every attribute of the class that has a specified default, if an initial value o f the 
attribute is not specified explicitly for the instantiation, then the default value specification is evaluated to set the initi al value 
of the attribute for the object.
Operations of a class can be invoked on an object, given a particular set of substitutions for the parameters of the operation.  An 
operation invocation may cause changes to the values of the attributes of that object. It may also return a value as a result, where a result type for the operation has been defined. Operation invocations may also cause changes in value to the attributes  
of other objects that can be navigated to, directly or indirectly, from the object on which the operation is invoked, to its ou tput 
parameters, to objects navigable from its parameters, or to other objects in the scope of the operation’s execution. Operation invocations may also cause the creation and deletion of objects.
Notation
A class is shown using the classifier symbol. As class is the most widely used classifier, the keyword “class” need not be 
88                 UML Superstructure 2.0 Draft Adopted Specificationshown in guillemets above the name. A classifier symbol without a metaclass shown in guillemets indicates a class.
Presentation Options
A class is often shown with three compartments. The middle compartment holds a list of attributes while the bottom 
compartment holds a list of operations.
Attributes or operations may be presented grouped by visibility. A visibility keyword or symbol can then be given once for multiple features with the same visibility.
Additional compartments may be supplied to show other details, such as constraints, or to divide features.
Style Guidelines
 Center class name in boldface.
 Capitalize the first letter of class names (if the character set supports uppercase). Left justify attributes and operations in plain face. Begin attribute and operation names with a lowercase letter. Put the class name in italics if the class is abstract. Show full attributes and operations when needed and suppress them in other contexts or when merely referring to a class.
Examples
Figure 37 - Class notation: details suppressed, analysis-level details, implemen-
tation-level detailsWindow
Window
size: Area
visibility: Boolean
display()
hide()Window
+ size: Area = (100, 100)# visibility: Boolean = true+ defaultSize: Rectangle
- xWin: XWindow
display()
hide()
- attachX(xWin: XWindow)
UML Superstructure 2.0 Draft Adopted Specification        897.11.4 Property (from Kernel, AssociationClasses)
A property is a structural feature. 
When a property is owned by a class it represents an attribute. In this case it relates an instance of the class to a value or set of 
values of the type of the attribute.
When a property is owned by an association it represents a non-navigable end of the association. In this case the type of the property is the type of the end of the association.
Description
Property represents a declared state of one or more instances in terms of a named relationship to a value or values. When a property is an attribute of a classifier, the value or values are related to the instance of the classifier by being held in sl ots of the 
instance. When a property is an association end, the value or values are related to the instance or instances at the other end( s) 
of the association (see semantics of Association).
Property is indirectly a subclass of Constructs::TypedElement. The range of valid values represented by the property can be controlled by setting the property’s type.
Package AssociationClasses (“AssociationClasses” on page 117)
A property may have other properties (attributes) that serve as qualifiers.
Attributes
 aggregation: AggregationKind [1]Specifies the kind of aggregation that applies to the Property. The default value is none .
 / default: String [0..1] A String that is evaluated to give a default value for the Property when an object of the 
owning Classifier is instantiated. This is a derived value.
 / isComposite: Boolean [1] This is a derived value, indicating whether the aggregation of the Property is composite or 
not.
 isDerived: Boolean [1] Specifies whether the Property is derived, i.e., whether its value or values can be com-
puted from other information. The default value is false .Figure 38 - Class notation: attributes and operations grouped according to visi-
bilityWindow
public
  size: Area = (100, 100)  defaultSize: Rectangle
protected
  visibility: Boolean = trueprivate  xWin: XWindow
public  display()  hide()private  attachX(xWin: XWindow)
90                 UML Superstructure 2.0 Draft Adopted Specification isDerivedUnion : Boolean Specifies whether the property is derived as the union of all of the properties that are con-
strained to subset it. The default value is false .
 isReadOnly : Boolean If true, the attribute may only be read, and not written. The default value is false .
Associations
 association: Association [0..1] References the association of which this property is a member, if any.
 owningAssociation: Association [0..1]
References the owning association of this property. Subsets Property::association , 
NamedElement::namespace , Feature::featuringClassifier , and RedefinableEle-
ment::redefinitionContext .
 datatype : DataType [0..1] The DataType that owns this Property. Subsets NamedElement::namespace , Feature::fea-
turingClassifier , and Property::classifier .
 defaultValue: ValueSpecification [0..1]A ValueSpecification that is evaluated to give a default value for the Property 
when an object of the owning Classifier is is instantiated. Subsets Element::ownedEle-
ment .
 redefinedProperty : Property [*]
References the properties that are redefined by this property. Subsets RedefinableEle-
ment::redefinedElement .
 subsettedProperty : Property [*]
References the properties of which this property is constrained to be a subset.
 / opposite : Property [0..1] In the case where the property is one navigable end of a binary association with both ends 
navigable, this gives the other end.
Package AssociationClasses (“AssociationClasses” on page 117)
 associationEnd : Property [ 0..1 ]
Designates the optional association end that owns a qualifier attribute. Subsets Element::owner .
 qualifier : Property [*] An optional list of ordered qualifier attributes for the end. If the list is empty, then the Association is 
not qualified. Subsets Element::ownedElement .
Constraints
[1]  If this property is owned by a class, associated with a binary association, and the other end of the association is also o wned 
by a class, then opposite gives the other end.
opposite = 
if owningAssociation->notEmpty() and association.memberEnd->size() = 2 then  
let otherEnd = (association.memberEnd - self)->any() in 
if otherEnd.owningAssociation->notEmpty() then  otherEnd else Set{} endif
else Set {}
endif
[2] A multiplicity on an aggregate end of a composite aggregation must not have an upper bound greater than 1.
isComposite implies  (upperBound()->isEmpty() or upperBound() <= 1)
[3] Subsetting may only occur when the context of the subsetting property conforms to the context of the subsetted property.
subsettedProperty->notEmpty() implies
(subsettingContext()->notEmpty() and subsettingContext()->forAll (sc |
subsettedProperty->forAll(sp | 
sp.subsettingContext()->exists(c | sc.conformsTo(c)))))
UML Superstructure 2.0 Draft Adopted Specification        91[4] A navigable property (one that is owned by a class) can only be redefined or subsetted by a navigable property.
(subsettedProperty->exists(sp | sp.class->notEmpty())
implies  class->notEmpty())
and
(redefinedProperty->exists(rp | rp.class->notEmpty())
implies  class->notEmpty())
[5] A subsetting property may strengthen the type of the subsetted property, and its upper bound may be less.
subsettedProperty->forAll(sp |
type.conformsTo(sp.type) and
((upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies
upperBound()<=sp.upperBound() ))
[6] Only a navigable property can be marked as readOnly.
isReadOnly implies  class->notEmpty()
[7] A derived union is derived.
isDerivedUnion implies  isDerived
[8] A derived union is read only.
isDerivedUnion implies  isReadOnly
[9] The value of isComposite is true only if aggregation is composite.
isComposite = (self.aggregation = #composite)
Additional Operations
[1]  The query isConsistentWith() specifies, for any two Properties in a context in which redefinition is possible, whether 
redefinition would be logically consistent. A redefining property is consistent with a redefined property if the type of the redefining property conforms to the type of the redefined property, the multiplicity of the redefining property (if.specified) is contained in the multiplicity of the redefined property, and the redefining property is derived if the redefined attribute i s 
property.
Property::isConsistentWith(redefinee : RedefinableElement) : Boolean
pre: redefinee.isRedefinitionContextValid(self)
isConsistentWith = (redefinee.oclIsKindOf(Property) and 
let prop: Property = redefinee.oclAsType(Property) in
type.conformsTo(prop.type) and
(lowerBound()->notEmpty and prop.lowerBound()->notEmpty() implies
lowerBound() >= prop.lowerBound()) and
(upperBound()->notEmpty and prop.upperBound()->notEmpty() implies
upperBound() <= prop.upperBound()) and
(prop.isDerived implies  isDerived)
)
[2] The query subsettingContext() gives the context for subsetting a property. It consists, in the case of an attribute, of the
corresponding classifier, and in the case of an association end, all of the classifiers at the other ends.
Property::subsettingContext() : Set(Type)
subsettingContext = 
if association->notEmpty()
then  association.endType-type 
else if classifier->notEmpty() then  Set{classifier} else Set{} endif
endif
Semantics
When a property is owned by a class or data type via ownedAttribute, then it represents an attribute  of the class or data type. 
When owned by an association via ownedEnd, it represents a non-navigable end  of the association. In either case, when 
instantiated a property represents a value or collection of values associated with an instance of one (or in the case of a tern ary 
92                 UML Superstructure 2.0 Draft Adopted Specificationor higher-order association, more than one) type. This set of classifiers is called the context for the property; in the case o f an 
attribute the context is the owning classifier, and in the case of an association end the context is the set of types at the ot her end 
or ends of the association.
The value or collection of values instantiated for a property in an instance of its context conforms to the property’s type. Property inherits from MultiplicityElement and thus allows multiplicity bounds to be specified. These bounds constrain the size of the collection. Typically and by default the maximum bound is 1.
Property also inherits the isUnique and isOrdered meta-attributes. When isUnique is true (the default) the collection of values  
may not contain duplicates. When isOrdered is true (false being the default) the collection of values is ordered. In combinatio n 
these two allow the type of a property to represent a collection in the following way:
If there is a default specified for a property, this default is evaluated when an instance of the property is created in the ab sence 
of a specific setting for the property or a constraint in the model that requires the property to have a specific value. The evaluated default then becomes the initial value (or values) of the property.
If a property is derived, then its value or values can be computed from other information. Actions involving a derived property  
behave the same as for a nonderived property. Derived properties are often specified to be read-only (i.e. clients cannot directly change values). But where a derived property is changeable, an implementation is expected to appropriately change the source information of the derivation. The derivation for a derived property may be specified by a constraint.
The name and visibility of a property are not required to match those of any property it redefines. 
A derived property can redefine one which is not derived. An implementation must ensure that the constraints implied by the derivation are maintained if the property is updated.
If a property has a specified default, and the property redefines another property with a specified default, then the redefinin g 
property’s default is used in place of the more general default from the redefined property.
If a navigable property (attribute) is marked as readOnly then it cannot be updated, once it has been assigned an initial value .
A property may be marked as the subset of another, as long as every element in the context of subsetting property conforms to 
the corresponding element in the context of the subsetted property. In this case, the collection associated with an instance of  
the subsetting property must be included in (or the same as) the collection associated with the corresponding instance of the subsetted property.
A property may be marked as being a derived union. This means that the collection of values denoted by the property in some context is derived by being the strict union of all of the values denoted, in the same context, by properties defined to subset  it. 
If the property has a multiplicity upper bound of 1, then this means that the values of all the subsets must be null or the sam e.
A property may be owned by and in the namespace of a datatype.Table 2 - Collection types for properties
isOrdered isUnique Collection type
false true Set
true true OrderedSet
false false Bag
true false Sequence
UML Superstructure 2.0 Draft Adopted Specification        93Package AssociationClasses (“AssociationClasses” on page 117)
A qualifier declares a partition of the set of associated instances with respect to an instance at the qualified end (the quali fied 
instance is at the end to which the qualifier is attached). A qualifier instance comprises one value for each qualifier attribu te. 
Given a qualified object and a qualifier instance, the number of objects at the other end of the association is constrained by the 
declared multiplicity. In the common case in which the multiplicity is 0..1, the qualifier value is unique with respect to the qualified object, and designates at most one associated object. In the general case of multiplicity 0..*, the set of associated  
instances is partitioned into subsets, each selected by a given qualifier instance. In the case of multiplicity 1 or 0..1, the qualifier has both semantic and implementation consequences. In the case of multiplicity 0..*, it has no real semantic consequences but suggests an implementation that facilitates easy access of sets of associated instances linked by a given qualifier value.
Note – The multiplicity of a qualifier is given assuming that the qualifier value is supplied. The “raw” multiplicity without the
qualifier is assumed to be 0..*. This is not fully general but it is almost always adequate, as a situation in which the raw mu lti-
plicity is 1 would best be modeled without a qualifier.
Note – A qualified multiplicity whose lower bound is zero indicates that a given qualifier value may be absent, while a lower
bound of 1 indicates that any possible qualifier value must be present. The latter is reasonable only for qualifiers with a fin ite
number of values (such as enumerated values or integer ranges) that represent full tables indexed by some finite range of val-ues.
Notation
Notation for properties is defined separately for their use as attributes and association ends. Examples of subsetting and derived union are shown for associations. See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61. See “Association (from Kernel)” on page 81.
Package AssociationClasses (“AssociationClasses” on page 117)
A qualifier is shown as a small rectangle attached to the end of an association path between the final path segment and the symbol of the classifier that it connects to. The qualifier rectangle is part of the association path, not part of the classifi er. The 
qualifier is attached to the source end of the association.
The multiplicity attached to the target end denotes the possible cardinalities of the set of target instances selected by the pairing of a source instance and a qualifier value.
The qualifier attributes are drawn within the qualifier box. There may be one or more attributes shown one to a line. Qualifier  
attributes have the same notation as classifier attributes, except that initial value expressions are not meaningful. 
It is permissible (although somewhat rare), to have a qualifier on each end of a single association.
A qualifier may not be suppressed.
Style Guidelines
Package AssociationClasses (“AssociationClasses” on page 117)
The qualifier rectangle should be smaller than the attached class rectangle, although this is not always practical.
94                 UML Superstructure 2.0 Draft Adopted SpecificationExamples 
Package AssociationClasses (“AssociationClasses” on page 117)
7.12 Kernel – the DataTypes Diagram
The DataTypes diagram of the Kernel package is shown in Figure 40. 
In order to locate the metaclasses that are referenced from this diagram,
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “InstanceSpecification (from Kernel)” on page 57.Figure 39 - Qualified associations
Figure 40 - The DataTypes diagram of the Kernel packageBank
PersonaccountNo
*
0..1Chessboard
Squarerank : Rank
1
1file : File
PropertyDataType
0..1 *+datatype
0..1{s ubs ets  names pace,
subsets featuringClassifier,
subse ts cl assi fi e r}+ow nedAttribute
* {ordered,
subset s at tri b ut e,
subs ets ownedMember}
Oper ation
0..1 *+datatype
0..1{subsets namespace,
subsets redefinitionContext,
sub set s  feat urin gCla s sif ier}+ow nedOperation
*{ordered,
s ubs ets  feature,
sub set s ow nedM em b er}
PrimitiveType Enumeration EnumerationLiteral
0..1 *+enumer a ti on
0..1 { s ub s et s na me s pa ce}+literal
*{ordered,
s ubs ets  ownedMember}Insta nceSp eci f ic ati onClassifier
UML Superstructure 2.0 Draft Adopted Specification        95 See “Property (from Kernel, AssociationClasses)” on page 89.
 See “Operation (from Kernel)” on page 76.
7.12.1 DataType (from Kernel)
A data type is a type whose values have no identity (i.e., they are pure values). Data types include primitive built-in types 
(such as integer and string) as well as enumeration types.
Description
DataType defines a kind of classifier in which operations are all pure functions (i.e., they can return data values but they 
cannot change data values, because they have no identity). For example, an “add” operation on a number with another number 
as an argument yields a third number as a result; the target and argument are unchanged.
A DataType may also contain attributes to support the modeling of structured data types.
Attributes
No additional attributes.
Associations
 ownedAttribute: Attribute[*] The Attributes owned by the DataType. Subsets Classifier::attribute and Ele-
ment::ownedMember .
 ownedOperation: Operation[*] The Operations owned by the DataType. Subsets Classifier::feature and Ele-
ment::ownedMember .
Constraints
No additional constraints.
Semantics
A data type is a special kind of classifier, similar to a class, whose instances are values (not objects). For example, the int egers 
and strings are usually treated as values. A value does not have an identity, so two occurrences of the same value cannot be differentiated. Usually, a data type is used for specification of the type of an attribute. An enumeration type is a user-defin able 
type comprising a finite number of values.
If a data type has attributes, then instances of that data type will contain attribute values matching the attributes.
Semantic Variation Points
Any restrictions on the capabilities of data types, such as constraining the types of their attributes, is a semantic variation  point.
Notation
A data type is denotated using the rectangle symbol with keyword «dataType» or, when it is referenced by e.g. an attribute, 
denoted by a string containing the name of the data type.
Presentation Options
The attribute compartment is often suppressed, especially when a data type does not contain attributes. The operation compartment may be suppressed. A separator line is not drawn for a missing compartment. If a compartment is suppressed, no inference can be drawn about the presence or absence of elements in it. Compartment names can be used to remove ambiguity, 
96                 UML Superstructure 2.0 Draft Adopted Specificationif necessary. 
Additional compartments may be supplied to show other predefined or user-defined model properties (for example, to show 
business rules, responsibilities, variations, events handled, exceptions raised, and so on). Most compartments are simply lists  
of strings, although more complicated formats are also possible. Appearance of each compartment should preferably be implicit based on its contents. Compartment names may be used, if needed.
A data-type symbol with a stereotype icon may be “collapsed” to show just the stereotype icon, with the name of the data type either inside the rectangle or below the icon. Other contents of the data type are suppressed. 
Style Guidelines
 Center the name of the data type in boldface.
 Center keyword (including stereotype names) in plain face within guillemets above data-type name.
 For those languages that distinguish between uppercase and lowercase characters, capitalize names (i.e, begin them with an uppercase character). 
 Left justify attributes and operations in plain face.
 Begin attribute and operation names with a lowercase letter.
 Show full attributes and operations when needed and suppress them in other contexts or references
Examples
7.12.2 Enumeration (from Kernel)
An enumeration is a data type whose values are enumerated in the model as enumeration literals.
Description
Enumeration is a kind of data type, whose instances may be any of a number of user-defined enumeration literals. 
It is possible to extend the set of applicable enumeration literals in other packages or profiles.
Attributes
No additional attributes.
Associations
 ownedLiteral: EnumerationLiteral[*]The ordered set of literals for this Enumeration. Subsets Element::ownedMember .Figure 41 - Notation of data type: to the left is an icon denoting a data type and 
to the right is a reference to a data type which is used in an attribute.«dataType»
Integersize: Integer
UML Superstructure 2.0 Draft Adopted Specification        97Constraints
No additional constraints.
Semantics
The run-time instances of an Enumeration are data values. Each such value corresponds to exactly one EnumerationLiteral.
Notation
An enumeration may be shown using the classifier notation (a rectangle) with the keyword «enumeration». The name of the 
enumeration is placed in the upper compartment. A compartment listing the attributes for the enumeration is placed below the 
name compartment. A compartment listing the operations for the enumeration is placed below the attribute compartment. A 
list of enumeration literals may be placed, one to a line, in the bottom compartment. The attributes and operations compartments may be suppressed, and typically are suppressed if they would be empty.
Examples
7.12.3 EnumerationLiteral (from Kernel)
An enumeration literal is a user-defined data value for an enumeration.
Description
An enumeration literal is a user-defined data value for an enumeration.
Attributes
No additional attributes.
Associations
 enumeration: Enumeration[0..1]The Enumeration that this EnumerationLiteral is a member of. Subsets NamedEle-
ment::namespace .
Constraints
No additional constraints.
Semantics
An EnumerationLiteral defines an element of the run-time extension of an enumeration data type.
An EnumerationLiteral has a name that can be used to identify it within its enumeration datatype. The enumeration literal Figure 42 - Example of an enumeration«enumeration»
VisibilityKind
publicprivate
98                 UML Superstructure 2.0 Draft Adopted Specificationname is scoped within and must be unique within its enumeration. Enumeration literal names are not global and must be 
qualified for general use.
The run-time values corresponding to enumeration literals can be compared for equality.
Notation
An EnumerationLiteral is typically shown as a name, one to a line, in the a compartment of the enumeration notation.
7.12.4 PrimitiveType (from Kernel)
A primitive type defines a predefined data type, without any relevant substructure (i.e. it has no parts). A primitive datatype  
may have an algebra and operations defined outside of UML, for example, mathematically.
Description
The instances of primitive type used in UML itself include Boolean, Integer, UnlimitedNatural, and String.
Attributes
No addtional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
The run-time instances of a primitive type are data values. The values are in many-to-one correspondence to mathematical elements defined outside of UML (for example, the various integers).
Instances of primitive types do not have identity. If two instances have the same representation, then they are indistinguishable.
Notation
A primitive type has the keyword «primitive» above or before the name of the primitive type.
Instances of the predefined primitive types may be denoted with the same notation as provided for references to such instances (see the subtypes of “ValueSpecification (from Kernel)”).
UML Superstructure 2.0 Draft Adopted Specification        997.13 Kernel – the Packages Diagram
The Packages diagram of the Kernel package is shown in Figure 43. 
In order to locate the metaclasses that are referenced from this diagram,
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “DirectedRelationship (from Kernel)” on page 28.
 See “Namespace (from Kernel)” on page 35.
 See “PackageableElement (from Kernel)” on page 37.
7.13.1 Package (from Kernel)
A package is used to group elements, and provides a namespace for the grouped elements.
Description
A package is a namespace for its members, and may contain other packages. Only packageable elements can be owned 
members of a package. By virtue of being a namespace, a package can import either individual members of other packages, or all the members of other packages.
In addition a package can be merged with other packages.
Attributes
No additional attributes.Figure 43 - The Packages diagram of the Kernel packagePackageableElem ent Namespace
DirectedRelationshipPackageableElem ent
P a cka ge M e rgePackage
0..1 *+ow ni ngPack age
0..1{subsets namespace} +ownedMember
*{redefines ownedMember}
1 *+mer gingPackage
1{ subsets s our ce,
subsets owner}+p acka geExte nsi o n
* {subs ets ownedElement}
1+m er ged Pack age
1 {sub sets targ et}
*0..1
+nestedPackage *
{subsets ownedMember}+nestingPackage
0..1 {subsets nam espace}Type
* 0..1+/ownedClassifier
*{ s ub s et s ow n edMem ber }+package
0..1 {s ubs ets  names pace}
100                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 nestedPackage: Package [*] References the owned members that are Packages. Subsets Package::ownedMember .
 ownedMember: PackageableElement [*]Specifies the members that are owned by this Package. Redefines 
Namespace::ownedMember .
 ownedType: Type [*] References the owned members that are Types. Subsets Package::ownedMember .
 package: Package [0..1] References the owning package of a package. Subsets NamedElement::namespace .
 packageMerge: Package [*] References the PackageMerges that are owned by this Package. Subsets Ele-
ment::ownedElement .
Constraints
[1]  If an element that is owned by a package has visibility, it is public or private.
self.ownedElements->forAll(e | e.visibility->notEmpty() implies  e.visbility = #public or e.visibility = #private)
Additional Operations
[1]  The query mustBeOwned() indicates whether elements of this type must have an owner.
Package::mustBeOwned() : Boolean
mustBeOwned = false
[2] The query visibleMembers() defines which members of a Package can be accessed outside it.
Package::visibleMembers() : Set(PackageableElement);
visibleMembers = member->select( m | self.makesVisible(m))
[3] The query makesVisible() defines whether a Package makes an element visible outside itself. Elements with no visibility
and elements with public visibility are made visible.
Package::makesVisible(el: Namespaces::NamedElement) : Boolean;
pre: self.member->includes(el)
makesVisible = el.visibility->isEmpty() or el.visibility = #public
Semantics
A package is a namespace and is also an packageable element that can be contained in other packages.
The elements that can be referred to using non-qualified names within a package are owned elements, imported elements, and 
elements in enclosing (outer) namespaces. Owned and imported elements may each have a visibility that determines whether they are available outside the package. 
A package owns its owned members, with the implication that if a package is removed from a model, so are the elements owned by the package.
The public contents of a package is always accessible outside the package through the use of qualified names.
Notation
A package is shown as a large rectangle with a small rectangle (a “tab”) attached to the left side of the top of the large rectangle. The members of the package may be shown within the large rectangle. Members may also be shown by branching lines to member elements, drawn outside the package. A plus sign (+) within a circle is drawn at the end attached to the namespace (package).
 If the members of the package are not shown within the large rectangle, then the name of the package should be placed within the large rectangle.
UML Superstructure 2.0 Draft Adopted Specification        101 If the members of the package are shown within the large rectangle, then the name of the package should be placed 
within the tab.
The visibility of a package element may be indicated by preceding the name of the element by a visibility symbol (‘+’ for public and ‘-’ for private). 
Presentation Options
A tool may show visibility by a graphic marker, such as color or font. A tool may also show visibility by selectively displayin g 
those elements that meet a given visibility level, e.g., only public elements. A diagram showing a package with contents must not necessarily show all its contents; it may show a subset of the contained elements according to some criterion.
Elements that become available for use in a importing package through a package import or an element import may have a distinct color or be dimmed to indicate that they cannot be modified.
Examples
There are three representations of the same package Types in Figure 44. The one on the left just shows the package without revealing any of its members. The middle one shows some of the members within the borders of the package, and the one to the right shows some of the members using the alternative membership notation. 
7.13.2 PackageMerge (from Kernel)
A package merge defines how one package extends another package by merging their contents.
Description
A package merge is a relationship between two packages, where the contents of the target package (the one pointed at) is merged with the contents of the source package through specialization and redefinition, where applicable.
This is a mechanism that should be used when elements of the same name are intended to represent the same concept, regardless of the package in which they are defined. A merging package will take elements of the same kind with the same name from one or more packages and merge them together into a single element using generalization and redefinitions. 
It should be noted that a package merge can be viewed as a short-hand way of explicitly defining those generalizations and redefinitions. The merged packages are still available, and the elements in those packages can be separately qualified.
From an XMI point of view, it is either possible to exchange a model with all PackageMerges retained or a model where all PackageMerges have been transformed away (in which case package imports, generalizations, and redefinitions are used instead).Figure 44 - Examples of a package with membersTypesTypes
Integer
Time
Point ShapeTypes
102                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
No additional attributes.
Associations
 mergedPackage: Package [1] References the Package that is to be merged with the source of the PackageMerge. Subsets 
DirectedRelationship;;target .
 mergingPackage: Package [1] References the Package that is being extended with the contents of the target of the Pack-
ageMerge. Subsets Element::owner  and DirectedRelationship::source .
Constraints
No additional constraints.
Semantics
A package merge between two packages implies a set of transformations, where the contents of the merged package is 
expanded in the merging package. Each element has its own specific expansion rules. The package merge is transformed to a package import having the same source and target packages as the package merge.
An element with private visibility in the merged package is not expanded in the merging package. This applies recursively to all owned elements of the merged package.
A classifier from the target (merged) package is transformed into a classifier with the same name in the source (merging) package, unless the source package already contains a classifier of the same kind with the same name. In the former case, the new classifier gets a generalization to the classifier from the target package. In the latter case, the already existing classi fier 
gets a generalization to the classifier from the target package. In either case, every feature of the general classifier is red efined 
in the specific classifier in such a way that all types refer to the transformed classifiers. In addition, the classifier in th e source 
package gets generalizations to each transformed superclassifier of the classifier from the target package. This is because the  
superclassifiers may have merged in additional properties in the source package that need to be propagated properly to the classifier. Classifiers of the same kind with the same name from multiple target packages are transformed into a single classifier in the source package, with generalizations to each target classifier. Nested classifiers are recursively transforme d the 
same way. If features from multiple classifiers are somehow conflicting, the same rules that apply for multiple inheritance are  
used to resolve conflicts. 
Note that having an explicit generalization from a classifier in a source package to a classifier of the same kind with the sam e 
name in a target package is redundant, since it will be created as part of the transformation.
A subpackage from the target (merged) package is transformed into a subpackage with the same name in the source (merging) package, unless the source package already contains a subpackage with the same name. In the former case, the new subpackage gets a package merge to the subpackage from the target package. In the latter case, the already existing package gets a package merge to the subpackage from the target package. Subpackages with the same name from multiple target packages are transformed into a single subpackage in the source package, with package merges to each target subpackage. Nested subpackages are recursively transformed the same way.
A package import owned by the target package is transformed into a corresponding new package import in the source package. Elements from imported packages are not merged (unless there is also a package merge to the imported package). The names of merged elements take precedence over the names of imported elements, meaning that names of imported elements are hidden in case of name conflicts and need to be referred to using qualifiers. An element import owned by the target package is transformed into a corresponding new element import in the source package. Imported elements are not merged (unless there is also a package merge to the package owning the imported element or its alias).
A non-generalizable packageable element owned by the target package is copied down to the source package. Any classifiers 
UML Superstructure 2.0 Draft Adopted Specification        103referenced as part of the packageable element are redirected at transformed classifiers, if any.
Notation
A PackageMerge is shown using a dashed line with a stick arrowhead pointing from the merging package (the source) to the 
merged package (the target). In addition, the keyword «merge» is shown near the dashed line. 
Examples
In Figure 46, packages P and Q are being merged by package R, while package S merges only package Q. 
The transformed packages R and Q are shown in Figure 47. While not shown, the package merges have been transformed into Figure 45 - Notation for package merge
Figure 46 - Simple example of package mergesSourceTarget«merge»
P Q
RSA
BA C
A«merge»«merge»
«merge»
A BD
104                 UML Superstructure 2.0 Draft Adopted Specificationpackage imports. 
In Figure 48, additional package merges are introduced by having the package T merge the packages R and S that were 
previously defined. Aside from the package merges, the package T is completely empty. 
In Figure 49, the transformed version of the package T is depicted. In this package, the partial definitions of A, B, C, and D have all been brought together. Again, the package merges have been transformed to package imports. Note that the types of the ends of the associations that were originally in the packages Q and S have all been updated to refer to the appropriate typ es Figure 47 - Simple example of transformed packages 
Figure 48 - Introducing additional package mergesR
BP::B A CP::A Q::A Q::CS
BACD Q::A Q::C
R
ST
«merge»«merge»
UML Superstructure 2.0 Draft Adopted Specification        105in package T. 
It is possible to elide all but the most specific of each classifier, which gives a clearer picture of the end result of the pa ckage 
merge transformations, as is shown in Figure 50. 
7.14 Dependencies
The contents of the Dependencies package is shown in Figure 51. The Dependencies package is one of the packages of the Classes package.Figure 49 - The result of the additional package merges
Figure 50 - The result of the additional package merges: elided viewT
R::A
A CR::C S::A S::C D
BR::B S::BS::D
T
A CD
B
106                 UML Superstructure 2.0 Draft Adopted SpecificationIn order to locate the metaclasses that are referenced from this package,
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “DirectedRelationship (from Kernel)” on page 28.
 See “OpaqueExpression (from Kernel)” on page 46.
 See “NamedElement (from Kernel, Dependencies)” on page 33.
 See “PackageableElement (from Kernel)” on page 37.Figure 51 - The contents of Dependencies packageUsage Permission
Realization
Substitution
Classifier
1 *+contract
1{subsets supplier, subsets target}
*
*
1 +substitution*
{subsets ownedElement, subsets clientDependency}+substitutingClassifier
1{subsets client, subsets source}Classifier
(from  Kernel)Expression
(from Kernel)Abstraction1 0..1
+mapping1
{subsets ownedElement}0..1Dependency NamedElement
* 1..*+clientDependency
*+client
1..**1..*+supplierDependency
*+supplier
1..*NamedElement
( from  Kernel)DirectedRelationship
(from Kernel)PackageableElement
(from Kernel)
UML Superstructure 2.0 Draft Adopted Specification        1077.14.1 Abstraction (from Dependencies)
Description
An abstraction is a relationship that relates two elements or sets of elements that represent the same concept at different lev els 
of abstraction or from different viewpoints. (See also, the definition of abstration in the Glossary.) In the metamodel, an Abstraction is a Dependency in which there is a mapping between the supplier and the client. 
Attributes
No additional attributes.
Associations
 mapping: Expression  An composition of an Expression that states the abstraction relationship between the sup-
plier and the client. In some cases, such as Derivation, it is usually formal and unidirec-tional; in other cases, such as Trace, it is usually informal and bidirectional. The mapping expression is optional and may be omitted if the precise relationship between the elements is not specified.
Constraints
No additional constraints.
Semantics
Depending on the specific stereotype of Abstraction, the mapping may be formal or informal, and it may be unidirectional or bidirectional. Abstraction has predefined stereotypes (such as «derive», «refine», and «trace») which are defined in the Standard Profiles chapter. If an Abstraction element has more than one client element, the supplier element maps into the set of client elements as a group. For example, an analysis-level class might be split into several design-level classes. The situation is similar if there is more than one supplier element.
Notation
An abstraction relationship is shown as a dependency with an «abstraction» keyword attached to it or the specific predefined stereotype name.
Examples
In the example below, the Employee class indentified in analysis (i.e., the «type») maps to the same concept in the design model called Employee Record.
7.14.2 Classifier (from Dependencies)
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.Figure 52 - An example of a refine abstraction«type»
Employee«implementation 
Employee Recordclass»«refine»
108                 UML Superstructure 2.0 Draft Adopted Specification7.14.3 Dependency (from Dependencies)
Description
A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their 
specification or implementation. This means that the complete semantics of the depending elements is either semantically or structurally dependent on the definition of the supplier element(s).
Attributes
No additional attributes.
Associations
 client: NamedElement [1..*]  The element that is affected by the supplier element. In some cases (such as a Trace 
Abstraction) the direction is unimportant and serves only to distinguish the two elements. 
 supplier: NamedElement [1..*] Designates the element that is unaffected by a change. In a two-way relationship (such as 
some Refinement Abstractions) this would be the more general element. In an undirected situation, such as a Trace Abstraction, the choice of client and supplier is not relevant. 
Constraints
No additional constraints.
Semantics
A dependency signifies a supplier/client relationship between model elements where the modification of the supplier may impact the client model elements. A dependency implies the semantics of the client is not complete without the supplier. The presence of dependency relationships in a model does not have any runtime semantics implications, it is all given in terms of the model-elements that participate in the relationship, not in terms of their instances.
Notation
A dependency is shown as a dashed arrow between two model elements. The model element at the tail of the arrow (the client) depends on the model element at the arrowhead (the supplier). The arrow may be labeled with an optional stereotype and an optional name. It is possible to have a set of elements for the client or supplier. In this case, one or more arrows with their  tails 
on the clients are connected the tails of one or more arrows with their heads on the suppliers. A small dot can be placed on th e 
junction if desired. A note on the dependency should be attached at the junction point. 
Examples
In the example below, the Car class has a dependency on the Vehicle Type class. In this case, the dependency is an instantiate Figure 53 - Notation for a dependency between two elementsNamedElement-1 NamedElement-2«dependecyName»
UML Superstructure 2.0 Draft Adopted Specification        109dependency, where the Car class is an instance of the Vehicle Type class.
7.14.4 NamedElement (from Dependencies)
See “NamedElement (from Kernel, Dependencies)” on page 33.
7.14.5 Permission (from Dependencies)
Description
A Permission signifies granting of access rights from the supplier model element to a client model element. Or to put it anothe r 
way, it signifies that the client requires access to some or all of the constituent elements of the supplier. The supplier elem ent 
gives the client permission to access some or all of its constituents elements.
Attributes
No additional attributes.
Constraints
[1] The supplier must be a namespace
Notation
A permission dependency is shown as a dependency with a «permit» keyword attached to it.
Examples
In the example below, the Employee class grants access rights to Executive objects. This means that executive objects may access the private properties of salary and homePhoneNumber.Figure 54 - An example of a instantiatedependency
Figure 55 - An example of a permit dependencyCarVehicle«instantiate»
Type
EmployeeExecutive«permit»
+ phoneExtension
- salary+employeeID
- homePhoneNumber
110                 UML Superstructure 2.0 Draft Adopted Specification7.14.6 Realization (from Dependencies)
Description
Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the  
supplier) and the other represents an implementation of the latter (the client). Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc. 
Realization is a specialized abstraction relationship between two sets of model elements. Onespecifies the source (the supplier); the other implements the targer (the client). Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc. 
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
A Realization signifies that the client set of elements are an implementation of the supplier set, which serves as the specification. The meaning of ‘implementation’ is not strictly defined, but rather implies a more refined or elaborate form in respect to a certain modeling context. It is possible to specify a mapping between the specification and implementation elements, although it is not necessarily computable. 
Notation
A Realization dependency is shown as a dependency with the keyword «realize» attached to it.
7.14.7 Substitution (from Dependencies)
Description
A substitution is a relationship between two classifiers signifies that the substitutingClassifier complies with the contract specified by the contract classifier. This implies that instances of the substitutingClassifier are runtime substitutable where  
instances of the contract classifier are expected. 
Associations
 contract: Classifier [1] (Specializes Dependency.target .)
 substitutingClassifier: Classifier [1]
(Specializes Dependency.client .)
Attributes
None.
UML Superstructure 2.0 Draft Adopted Specification        111Constraints
No additional constraints.
Semantics
The substitution relationship denotes runtime substitutability which is not based on specialization. Substitution, unlike 
specialization, does not imply inheritance of structure, but only compliance of publicly available contracts. A substitution li ke 
relationship is instrumental to specify runtime substitutability for domains that do not support specilization such as certain component technologies. It requires that (1) interfaces implemented by the contract classifier are also implemented by the sunstituting classifier, or else the substituting classifier implements a more specilized interface type. And, (2) the any port  
owned by the contract classifier has a matching port (see ports) owned by the substituting classifier. 
Notation
A Substitution dependency is shown as a dependency with the keyword «substitute» attached to it.
Examples
In the example below, a generic Window class is substituted in a particular environment by the Resizable Window class.
7.14.8 Usage (from Dependencies)
Description
A usage is a relationship in which one element requires another element (or set of elements) for its full implementation or operation. In the metamodel, a Usage is a Dependency in which the client requires the presence of the supplier. 
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
The usage dependency does not specify how the client uses the supplier other than the fact that the supplier is used by of the definition or implementation of the client. Figure 56 - An example of a substitute dependencyWindowResizable«substitute»
Window
112                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
A usage dependency is shown as a dependency with a «use» keyword attached to it.
Examples
In the example below, a Order class requires the Line Item class for its full implementation.
7.15 Interfaces
The contents of the Interfaces package is shown in Figure 51. The Interfaces package is one of the packages of the Classes 
package.Figure 57 - An example of a use dependency
Figure 58 - The contents of Interfaces packageOrderLine«use»
Item
Realization
(from Dependencies)Property
(from Kernel)
Operation
(from Kernel)Interface
*0..1
+nestedInterface*
{ordered, subsets ownedMember}0..1{subset s namespace, 
subsets redefinitionContext}
*
**
+redefinedInterface*{subset s redefinedElement}*0..1 +ownedAttribute
*{ordered, subsets attribute, subsets ownedMember}
0..1
{subsets classifier, subsets namespace, 
subsets featuringClassifie}
0..1
*0..1
{subsets redefinitionContext}+ownedOperation
*{ordered, subsets feature,  subsets ownedMember}
Implementation1
*+contract 1
{subsets supplier, subsets target}
*
BehavioredClassifier
*1 +implementation
*{subsets ownedElement,
subsets clientDependency}
+implementatingClassifier1
{subsets client , subset s source}Classifier
(from Kernel)
UML Superstructure 2.0 Draft Adopted Specification        113In order to locate the metaclasses that are referenced from this package,
 See “BehavioredClassifier (from Interfaces)” on page 113.
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “Operation (from Kernel)” on page 76.
 See “Property (from Kernel, AssociationClasses)” on page 89.
 See “Realization (from Dependencies)” on page 110.
7.15.1 BehavioredClassifier (from Interfaces)
Description
A BehavioredClassifier may have implementations.
Associations
 implementation: Implementation [*](Specializes Element.ownedElement and Realization.clientDependency .)
7.15.2 Implementation (from Interfaces)
Description
An Implementation is a specialized Realization relationship between a Classifier and an Interface. The implementation 
relationship signifies that the realizing classifier conforms to the contract specified by the interface.
Attributes
No additional attributes.
Associations
 contract: Interface [1]  References the Interface specifying the conformance contract. (Specializes Depen-
dency.supplier and Relationship.target )
 implementingClassifier: Classifier [1]
References the operations owned by the Interface. (Specializes Dependency.client and 
Relationship.source )
Constraints
No additional constraints.
Semantics
A classifier that implements an interface specifies instances that are conforming to the interface and to any of its ancestors.  A 
classifier may implement a number of interfaces. The set of interfaces implemented by the classifier are its provided  interfaces 
and signify the set of services the classifier offers to its clients. A classifier implementing an interface supports the set o f 
features owned by the interface.  In addition to supporting the features, a classifier must comply with the constraints owned by 
the interface.
An implementation relationship between a classifier and an interface implies that the classifier supports the set of features owned by the interface, and any of its parent interfaces. For behavioral features, the implementing classifier will have an 
114                 UML Superstructure 2.0 Draft Adopted Specificationoperations or reception for every operation or reception, respectively, owned by the interface. For properties, the implementin g 
classifier will provide functionality that maintains the state represented by the property. While such may be done by direct mapping to a propertyof the implementing classifier, it may also be supported by the state machine of the classifier or by a pa ir 
of operations that support the retrieval of the state information and an operation that changes the state information.
Notation
See “Interface (from Interfaces)”.
7.15.3 Interface (from Interfaces)
Description
An interface is a kind of classifier that represents a declaration of a set of coherent public features and obligations. In a s ense, 
an interface specifies a kind of contract which must be fulfilled by any instance of a classifier that realizes the interface. The 
obligations that may be associated with an interface are in the form of various kinds of constraints (such as pre- and post-conditions) or protocol specifications, which may impose ordering restrictions on interactions through the interface. 
Since interfaces are declarations, they are not directly instantiable. Instead, an interface specification is realized  by an instance 
of a classifier, such as a class, which means that it presents a public facade that conforms to the interface specification. No te 
that a given classifier may realize more than one interface and that an interface may be realized by a number of different classifiers.
Attributes
No additional attributes.
Associations
 ownedAttribute: Proprety  References the properties owned by the Interface. (Subsets Namespace.ownedMember 
and Classifier.feature .)
 ownedOperation: Operation References the operations owned by the Interface. (Subsets Namespace.ownedMember 
and Classifier.feature .)
 nestedInterface: Interface (Subsets Namespace.ownedMember .)
 redefinedInterface: Interface (Subsets Element.redefinedElement .)
Constraints
[1]  The visibility of all features owned by an interface must be public.
self.feature->forAll(f | f.visibility = #public)
Semantics
An interface declares a set of public features and obligations that constitute a coherent service offered by a classifier. 
Interfaces provide a way to partition and characterize groups of properties that realizing classifier instances must possess. A n 
interface does not specify how it is to be implemented, but merely what needs to be supported by realizing instances. That is, such instances must provide a a public facade (attributes, operations, externally observable behavior) that conforms to the interface. Thus, if an interface declares an attribute, this does not necessarily mean that the realizing instance will necessa rily 
have such an attribute in its implementation, only that it will appear so to external observers. 
Because an interface is merely a declaration it is not an instantiable model element; that is, there are no instances of interf aces 
UML Superstructure 2.0 Draft Adopted Specification        115at run time. 
The set of interfaces realized by a classifier are its provided  interfaces, which represent the obligations that instances of that 
classifier have to their clients. They describe the services that the instances of that classifier offer to their clients. Inte rfaces 
may also be used to specify required  interfaces, which are specified by a usage dependency between the classifier and the 
corresponding interfaces. Required interfaces specify services that a classifier needs in order to perform its function and ful fill 
its own obligations to its clients.
Properties owned by interfaces are abstract and imply that the conforming instance should maintain information corresponding to the type and multiplicity of the property and facilitate retrieval and modification of that information. There will not necessarily be a property implementing the classifier corresponding to the property of the interface. Interfaces may also own constraints which impose constraints on the features of the implementing classifier. 
An association between an interface and any other classifier implies that a conforming association must exist between any implementation of that interface and that other classifier. In particular, an association between interfaces implies that a conforming association must exist between implementations of the interfaces. 
An interface cannot be directly instantiated. Instantiable classifiers, such as classes, must implement an interface (see “Implementation (from Interfaces)”). 
Notation
As a classifier, an interface may be shown using a rectangle symbol with the keyword «interface» preceding the name.
The implementation dependency from a classifier to an interface is shown by representing the interface by a circle or ball, 
labelled with the name of the interface, attached by a solid line to the classifier that implements this interface (see Figure 59).
The usage dependency from a classifer to an interface is shown by representing the interface by a half-circle or socket , labeled 
with the name of the interface, attached by a solid line to the classifier that implements this interface (see Figure 60).
Where two classifiers provide and require the same interface, respectively, these two notations may be combined as shown in Figure 61. The ball-and-socket  notation hints at that the interface in question serves to mediate interactions between the two Figure 59 - Isensor is the provided interface of ProximitySensor
Figure 60 - Isensor is the required interface of TheftAlarmISensorProximitySensor
ISensorTheftAlarm
116                 UML Superstructure 2.0 Draft Adopted Specificationclassifiers.  
Presentation Option
Alternatively, if an interface is shown using the rectangle symbol, their implementation and usage dependencies to provided 
and required interfaces, respectively, may be shown using dependency arrows (see Figure 62). The classifier at the tail of the arrow implements the interface at the head of the arrow or uses that interface, respectively.
A set of interfaces constituting a protocol may be depicted as interfaces with associations between them (see Figure 63). 
Examples
The following example shows a set of associated interfaces that specify an alarm system. (These interfaces may be defined independently or as part of a collaboration.) Figure 64 shows the specification of three interfaces, IAlarm , ISensor , and 
IBuzzer . IAlarm  and Isensor  are shown as engaged in a bidirectional protocol; IBuzzer  describes the required interface for Figure 61 - Isensor is the required interface of TheftAlarm as well as the pro-
vided interface of ProximitySensor
Figure 62 - Alternative notation for the situation depict in Figure 61
Figure 63 - IAlarm is the required interface for any classifier implementing Isen-
sor; conversely, Isensor is the required interface for any classifier implementing 
IAlarm.ISensorTheftAlarm ProximitySensor
TheftAlarm ProximitySensor
activate()
read()ISensor
 
sensor  
+ activate()  
+ read()  IAlarm  
+ notify()  1 1 +theSensor  +theAlarm  Interface»  «Interface»  
UML Superstructure 2.0 Draft Adopted Specification        117instances of classifiers implementing IAlarm , as depicted by their respective associations. 
Three classes: DoorSensor , DoorAlarm , and DoorBell,  implement the above interfaces (see Figure 65 below). These 
classifiers are completely decoupled. Nevertheless, instances of these classifiers are able to interact by virtue of the conforming associations declared by the associations between the interfaces that they realize.
 
7.16 AssociationClasses
The contents of the AssociationClasses package is shown in Figure 66. The AssociationClasses package is one of the packages 
of the Classes package.Figure 64 - A set of collaborating interfaces
Figure 65 - Classifiers implementing the above interfacesIBuzzer  
Volume  
Start() 
Reset()  ISensor  
Activate()  «Interface»  
IAlarm  
Detect()  +theAlarm  
+theSensor  +theBuzzer  «Interface»  «Interface»  
 Alarm    ISensor    IBuzzer   
DoorSensor    DoorAlarm    oorBell    
118                 UML Superstructure 2.0 Draft Adopted SpecificationIn order to locate the metaclasses that are referenced from this package,
 See “Property (from Kernel, AssociationClasses)” on page 89.
 See “Class (from Kernel)” on page 86.
 See “Association (from Kernel)” on page 81.
7.16.1 AssociationClass (from AssociationClasses)
A model element that has both association and class properties. An AssociationClass can be seen as an association that also 
has class properties, or as a class that also has association properties. It not only connects a set of classifiers but also de fines 
a set of features that belong to the relationship itself and not to any of the classifiers.
Description
In the metamodel, an AssociationClass is a declaration of a semantic relationship between Classifiers, which has a set of features of its own. AssociationClass is both an Association and a Class.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
[1]  An AssociationClass cannot be defined between itself and something else.
self.allConnections->forAll ( ar | 
ar.type <> selfFigure 66 - The contents of AssociationClasses packageAssociationClassClass
(from Kernel)Association
(from Kernel)PropertyProperty
0..1 *+associationEnd
0..1+qualifier
*
{ordered, subsets ownedElement} {subsets owner}
UML Superstructure 2.0 Draft Adopted Specification        119and
ar.type.allParents ()-> excludes ( self )
and
ar.type.allChildren () -> excludes ( self ) )
Additional Operations
[1]  The operation allConnections results in the set of all AssociationEnds of the Association.
allConnections : Set ( AssociationEnd );
allConnections = self.end->union ( self.allParents ().end )
Semantics
An association may be refined to have its own set of features; that is, features that do not belong to any of the connected 
classifiers but rather to the association itself. Such an association is called an association class. It will be both an associ ation, 
connecting a set of classifiers and a class, and as such have features and be included in other associations. The semantics of an 
association class is a combination of the semantics of an ordinary association and of a class.
An association class is both a kind of association and kind of a class. Both of these constructs are classifiers and hence have  a 
set of common properties, like being able to have features, having a name etc. As these properties are inherited from the same construct (Classifier), they will not be duplicated. Therefore, an association class has only one name, and has the set of features that are defined for classes and for associations. The constraints defined for class and for association also are applicable for association class, which implies for example that the attributes of the association class, the ends of the association class, and the opposite ends of associations connected to the association class must all have distinct names. Moreover, the specialization and refinement rules defined for class and association are also applicable to association class.
Note –  It should be noted that in an instance of an association class, there is only one instance of the associated classifiers at
each end , i.e. from the instance point of view, the multiplicity of the associations ends are ‘1’.
Notation
An association class is shown as a class symbol attached to the association path by a dashed line. The association path and the  
association class symbol represent the same underlying model element, which has a single name. The name may be placed on the path, in the class symbol, or on both, but they must be the same name.
Logically, the association class and the association are the same semantic entity; however, they are graphically distinct. The association class symbol can be dragged away from the line, but the dashed line must remain attached to both the path and the class symbol.
120                 UML Superstructure 2.0 Draft Adopted Specification7.17 PowerTypes
The contents of the PowerTypes package is shown below. The PowerTypes package is one of the packages of the Classes 
package.Figure 67 - An AssociationClass is depicted by an association symbol (a line) 
and a class symbol (a box) connected with a dashed line. The diagram shows 
the association class Job which is defined between the two classes Person and Company.
Figure 68 - The contents of PowerTypes packageCompany PersonJob * 1..*
Job
salaryperson company
Classifier
GeneralizationSet
isCovering : Boolean
isDisjoint : Boolean0..*0..1
+powertypeExtent0..*+powertype 0..1Generalization
**
+generalizationSet*+generalizati o *Classifier
(from Kernel)Generalization
(from Kernel)* 1 +generalization*
{subsets ownedElement}+specific1
{subsets source, 
subsets owner}
1+general1
{subsets target}
PackageableElement
(from Kernel)
UML Superstructure 2.0 Draft Adopted Specification        121In order to locate the metaclasses that are referenced from this package,
 See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
 See “Generalization (from Kernel, PowerTypes)” on page 66.
 See “PackageableElement (from Kernel)” on page 37.
7.17.1 Classifier (from PowerTypes)
See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
7.17.2 Generalization (from PowerTypes)
See “Generalization (from Kernel, PowerTypes)” on page 66.
7.17.3 GeneralizationSet (from PowerTypes)
A GeneralizationSet is an AutonomousElement (from Foundation :: Kernel :: PackagingNamespaces) whose instances define 
partitioned sets of Generalization relationships.
Description
Each Generalization is a binary relationship that relates a specific Classifier to a more general Classifier (i.e., a subclass) . Each 
GeneralizationSet defines a particular set of Generalization relationships that describe the way in which a specific Classifier  
(or superclass) may be partitioned. For example, a GeneralizationSet could define a partitioning of the class Person into two subclasses: Male Person and Female Person. Here, the GeneralizationSet would associate two instances of Generalization. Both instances would have Person as the specific classifier, however one Generalization would involve Male Person as the general Classifier and the other would involve Female Person as the general classifier. In other words, the class Person can here be said to be partitioned  into two subclasses: Male Person and Female Person. Person could also be partitioned into North 
American Person, Asian Person, European Person, or something else. This partitioning would define a different GeneralizationSet that would associate with three other Generalization relationships. All three would have Person as the specific Classifier; only the general classifiers would differ: i.e., North AmericanPerson, Asian Person, and European Person.
Attributes
 isCovering : Boolean Indicates (via the associated Generalizations) whether or not the set of specific Classifiers 
are covering for a particular general classifier. When isCovering is true, every instance of a particular general Classifier is also an instance of at least one of its specific Classifiers for the GeneralizationSet. When isCovering is false, there are one or more instances of the particular general Classifier that are not instances of at least one of its specific Classifiers defined for the GeneralizationSet. For example, Person could have two Generalization relationships each with a different specific Classifier: Male Person and Female Person. This GeneralizationSet would be covering because every instance of Person would be an instance of Male Person or Female Person. In contrast, Person could have a three General-ization relationships involving three specific Classifiers: North AmericanPerson, Asian Person, and European Person. This GeneralizationSet would not be covering because there are instances of Person for which these three specific Classifiers do not apply. The first example, then, could be read: any Person would be specialized as either being a Male Person or a Female Person—and nothing else ; the second could be read: any Person would 
be specialized as being North American Person, Asian Person, European Person, or some-thing else.
122                 UML Superstructure 2.0 Draft Adopted Specification isDisjoint : Boolean Indicates whether or not the set of specific Classifiers in a Generalization relationship 
have instance in common. If isDisjoint is true, the specific Classifiers for a particular Gen-eralizationSet have no members in common; that is, their intersection is empty. If isDis-joint is false, the specific Classifiers in a particular GeneralizationSet have one or more members in common; that is, their intersection is not empty. For example, Person could 
have two Generalization relationships, each with the different specific Classifier: Manager or Staff. This would be disjoint because every instance of Person must either be a Manager or Staff. In contrast, Person could have two Generalization relationships involving two specific (and non-covering) Classifiers: Sales Person and Manager. This Generalization-Set would not be disjoint because there are instances of Person which can be a Sales Per-son and a Manager.
Associations
 generalization [1] Designates the instances of Generalization which are members of a given Generalization-
Set. 
 powertype [2] Designates the Classifier that is defined as the power type for the associated Generaliza-
tionSet.
Constraints
[1]  Every Generalization associated with a particular GeneralizationSet must have the same general Classifier. 
[2] The Classifier that maps to a GeneralizationSet may neither be a specific nor a general Classifier in any of the Generaliza-
tion relationships defined for that GeneralizationSet. In other words, a power type may not be an instance of itself nor mayits instances be its subclasses.
Semantics
The generalizationSet association designates the partition to which the Generalization link belongs. All of the Generalization links that share a given general Classifier are divided into disjoint sets (that is, partitions) using the generalizationSet association. Each partition represents an orthogonal dimension of specialization of the general Classifier.
As mentioned above, in essence, a power type is a class whose instances are subclasses of another class. Power types, then, are  
metaclasses with an extra twist: the instances are also be subclasses. The powertype association relates a classifier to the instances of that classifier—which are the specific classifiers identified for a GeneralizationSet. For example, the Bank Account Type classifier could associate with a Generalization relationship that has specific classifiers of Checking Account and Savings Account. Here, then, Checking Account and Savings Account are instances of Bank Account Type. Furthermore, if the Generalization relationship has a general classifier of Bank Account, then Checking Account and Savings Account are also subclasses of Bank Account. Therefore, Checking Account and Savings Account are both instances of Bank Account 
Type and subclasses of Bank Account. (For more explanation and examples, see Examples in the Generalization section, below.)
Notation
The notation to express the grouping of Generalizations into GeneralizationSets were presented in the Notation section of Generalization, above. To indicate whether or not a generalization set is covering and disjoint, each set should be labeled wit h 
UML Superstructure 2.0 Draft Adopted Specification        123one of the constraints indicated below.
Graphically, the GeneralizationSet constraints are placed next to the sets, whether the common arrowhead notation is 
employed of the dashed line, as illustrated below.
Power type specification is indicated by placing the name of the powertype Classifier—preceded by a colon—next the GeneralizationSet graphically containing the specific classifiers that are the instances of the power type. The illustration be low Figure 69 - Generalization set constraint notation
Figure 70 - GeneralizationSet constraint notation{complete, disjoint} - Indicates the generalization set is covering and 
its specific Classifiers have no common instances
{incomplete, disjoint} - Indicates the generalization set is not covering and 
its specific Classifiers have no common instances*
{complete, overlapping} - Indicates the generalization set is covering and 
its specific Classifiers do share common instances
{incomplete, overlapping} - Indicates the generalization set is not covering and 
its specific Classifiers do share common instances
*Default is {incomplete, disjoint}
(a) GeneralizationSet constraint when sharing common generalization arrowhead.
(b) GeneralizationSet constraint using dashed-line notation.{Generalization
Set constraint-1}{Generalization
Set constraint-2}
{Generalization
Set constraint-3}{Generalization
Set constraint-4}
124                 UML Superstructure 2.0 Draft Adopted Specificationindicates how this would appear for both the “shared arrowhead” and the “dashed-line” notation. for GeneralizationSets.
Examples
In the illustration below, the Person class can be specialized as either a Female Person or a Male Person. Because this 
partitioning, or GeneralizationSet , is constrained to be complete and disjoint, each instance of Person must either  be a Female 
Person or a Male Person; that is, it must be one or the other and not both. (Therefore, Person is an abstract class because a Person object may not exist without being either a Female Person or a Male Person.) Furthermore, Person’s can be specialized as an Employee. The generalization set here is expressed as {incomplete, disjoint}, which means that instances of Persons can be partitioned as Employees or some other unnamed collection that consists of all non-Employee instances. In other words, Persons can either  be an Employee or in the complement of Employee, and not both. Taken together, the diagram indicates 
that a Person may be 1) either a Male Person or Female Person, and 2) an Employee or not. When expressed in this manner, it Figure 71 - Power type notationGeneral
Specific
Classifier-1PowerType
Classifier-2
: powertype classifier-1
Specific
Classifier-2Specific
Classifier-3ClassifierPowerType
Classifier-1
: powertype classifier-2
General PowerType
Classifier-2
: powertype classifier-1
Specific
Classifier-3ClassifierPowerType
Classifier-1
: powertype classifier-2(a) Power type specification when sharing common generalization arrowhead
(b) Power type specification using dashed-line notationSpecific
Classifier-1Specific
Classifier-2
UML Superstructure 2.0 Draft Adopted Specification        125is possible to partition the instances of a classifier using a disjunctive normal form (DNF).  
Grouping the objects in our world by categories, or classes, is an important technique for organizations. For instance, one of 
the ways botanists organize trees is by species. In this way, each tree we see can be classified as an American elm, sugar maple, apricot, saguaro—or some other species of tree. The class diagram below expresses that each Tree Species classifies zero or more instances of Tree, and each Tree is classified as exactly one Tree Species. For example, one of the instances of Tree could be the tree in your front yard, the tree in your neighbor’s backyard, or trees at your local nursery. Instances of T ree 
Species, such as sugar maple and apricot. Furthermore, this figure indicates the relationships that exist between these two set s 
of objects. For instance, the tree in your front yard might be classified as a sugar maple, your neighbor’s tree as an apricot,  and 
so on. This class diagram expresses that each Tree Species classifies zero or more instances of Tree, and each Tree is classifi ed 
as exactly one Tree Species. It also indicates that each Tree Species is identified with a Leaf Pattern and has a general locat ion 
in any number of Geographic Locations. For example, the saguaro cactus has leaves reduced to large spines and is generally found in southern Arizona and northern Sonora. Additionally, this figure indicates each Tree has an actual location at a particular Geographic Location. In this way, a particular tree could be classified as a saguaro and be located in Phoenix, Arizona. 
Lastly, this diagrams illustrates that Tree is subtyped as American Elm, Sugar Maple, Apricot, or Saguaro—or something else. Each subtype, then, can have its own specialized properties. For instance, each Sugar Maple could have a yearly maple sugar yield of some given quantity, each Saguaro could be inhabited by zero or more instances of a Gila Woodpecker, and so on. At first glance, it would seem that a modeler should only use either the Tree Species class or the subclasses of Tree—since the instances of Tree Species are the same as the subclasses of tree. In other words, it seems  redundant to represent both on the 
same diagram. Furthermore, having both would seem to cause potential diagram maintenance issues. For instance, if botanists got together and decided that the American elm should no longer be a species of tree, the American Elm object would then be removed as an instance of Tree Species. To maintain the integrity of our model in such a situation, the American Elm subtype of Tree must also be removed. Additionally, if a new species were added as a subtype of Tree, that new species would have to be added as an instance of Tree Species. The same kind of situation exists if the name of a tree species were changed—both the subtype of Tree and the instance of Tree Species would have to be modified accordingly.
As it turns out, this seemis redunadancy is not a redundancy semantically (although it may be implemented that way). different modeling approaches depicted above are not really all that different. In reality, the subtypes of Tree and the instances of Tre e 
Species are the same objects. In other words, the subtypes of Tree are instances of Tree Species. Furthermore, the instances of 
Tree Species are the subtypes of Tree. The fact that an instance of Tree Species is called sugar maple and a subtype of Tree is  
called Sugar Maple is no coincidence. The sugar maple instance and Sugar Maple subtype are the same object. The instances of Tree Species are—as the name implies—types of trees. The subtypes of Tree are—by definition—types of trees. While Tree may be partitioned in various ways (based on size or age, for example), in this example it is partitioned on the basis of speci es. 
Therefore, the integrity issue mentioned above is not really an issue here. Deleting the American Elm subtype from the Tree Figure 72 - Multiple subtype partitions (generalization sets) and constraint 
examplesAn incomplete partition  
indicating that a Person  
can also be an Employee  
or not .Female 
Person
Male
PersonEmployeePerson
{complete, 
disjoint}{incomplete, 
disjoint}
A complete partition
indicating that a Person
may be subtyped as 
either a Female Person  
or a Male Person .
126                 UML Superstructure 2.0 Draft Adopted Specificationpartition does not require also deleting the corresponding Tree Species instance, because the American Elm subtype and the 
corresponding Tree Species instance are the same object. Figures 23.4 and 23.5 depict another way of thinking about this. .
As established above, the instances of Classifiers can also be Classifiers. (This is the stuff that metamodels are made of.) Th ese 
same instances, however, can also be specific classifiers (i.e. subclasses) of another classifier. When this occurs, we have wh at 
is called a power type . Formally, a power type is a classifier whose instances are also subclasses of another classifier
In the examples above, Tree Species is a power type on the Tree type. Therefore, the instances of Tree Species are subtypes of 
Tree. This concept applies to many situations within many lines of business. The figure below depicts other examples of power types. The name on the generalization set beginning with a colon indicates the power type. In other words, this name is the name of the type of which the subtypes are instances. 
Diagram (a) in the figure below, then, can be interpreted as: each instance of Account is classified with exactly one instance of 
Account Type. It can also be interpreted as: the subtypes of Account are instances of Account Type. This means that each instance of Checking Account can have its own attributes (based on those defined for Checking Account and those inherited from Account), such as account number and balance. Additionally, it means that Checking Account as an object in its own 
right  can have attributes, such as interest rate and maximum delay for withdrawal. (Such attributes are sometime referred to as 
class variables, rather than instance variables.) The example (b) depicts a vehicle-modeling example. Here, each Vehicle can be subclassed as either a Truck or a Car or something else. Furthermore, Truck and Car are instances of Vehicle Type. In (c), Disease Occurrence classifies each occurrence of disease, e.g. my chicken pox and your measles. Disease Classification is the Figure 73 - Power type example and notationTree
{disjoint, 
incomplete}
American
Elm
SaguaroSugar
Maple
Apricottree species
general
locationsleaf
pattern
Geographic
LocationLeaf 
Patternactual
location*
1tree
* *
*1
1
1Tree 
Species
: Tree Species
UML Superstructure 2.0 Draft Adopted Specification        127power type whose instances are classes such as Chicken Pox and Measles.
Labeling partitions with the power type becomes increasingly important when a type has more than one power type. The figure 
below is one such example. Without knowing which partition contains Policy Coverage Types and which Insurance Lines, clarity is compromised. This figure depicts an even more complex situation. Here, a power type is expressed with multiple partitions. For instance, a Policy can be subtyped as either a Life, Health, Property/Casualty, or some other Insurance Line. Furthermore, a Property/Casualty policy can be further subtyped as Automobile, Equipment, Inland Marine, or some other Property/Casualty line of insurance. In other words, the subtypes in the partitions labeled Insurance Line are all instances of  Figure 74 - Other power type examplesvehicle category
classified vehicleVehicle 
TypeVehicle1
*
{disjoint, incomplete}
Checking 
Account
Savings
Accountaccount classifier
account1
*AccountAccount
Type
{disjoint, incomplete}
Call 
Waitingservice category
installed serviceTelephone 
Service 
CategoryInstalled
Telephone 
Service
{disjoint, incomplete}1
*
Chicken 
Pox
Measlesdisease classifier
classified diseaseDisease 
ClassificationDisease
Occurrence1
*
{disjoint, incomplete}Truck
Car
(a) Bank account/account type example (b) Vehicle/vehicle type example
(c) Disease Occurrence/Disease Classification example (d) Telephone service example:Account Type:Vehicle Type
: Disease Classification : Telephone Service Category
Call 
Transferring
128                 UML Superstructure 2.0 Draft Adopted Specificationthe Insurance Line power type. 
Power types are a conceptual, or analysis, notion. They express a real-world situation. Implementing, however, them may 
not be easy and efficient. To implement power types with a relational database would mean that the instances of a relation could also be relations in their own right. In object-oriented implementations, the instances of a class could also be 
classes. However, if the software implementation can not directly support classes being objects and vice versa, redundant 
structures must be defined. In other words, unless you’re programming in Smalltalk or CLOS, the designer must be aware of the integrity problem of keeping the list of power type instances in sync with the existing subclasses. Without the 
power type designation, implementors would not be aware that they need to consider keeping the subclasses in sync with 
the instances of the power type; with the power type indication, the implementor knows that a) an data integrity situation exists, and b) how to manage the integrity situation. For example, if the Life Policy instance of Insurance Line were 
deleted, the subclass called Life Policy can no longer exist. Or, is a new subclass of Policy were added, a new instance 
must also be added to the appropriate power type. 
7.18 Diagrams
Structure diagram
This section outlines the graphic elements that may be shown in structure diagrams, and provides cross references where 
detailed information about the semantics and concrete notation for each element can be found. It also furnishes examples that illustrate how the graphic elements can be assembled into diagrams.Figure 75 - Other power type examplesGroup
Policy
Individual 
Policyinsurance line
issued policyPolicy
coverage typeissued policy
Life
Policy
Property/
CasualtyPolicy
Type1* 1
*
{disjoint, complete}{disjoint, complete}
:Insurance Line :Policy Coverage Type
Health
PolicyInsurance 
LineCoverage
Policy
UML Superstructure 2.0 Draft Adopted Specification        129Graphical nodes
The graphic nodes that can be included in structure diagrams are shown in Table 3.
Table 3  Graphic nodes included in structure diagrams
NODE TYPE NOTATION REFERENCE
Class See “Class (from Kernel)” on page 86.
Interface See “Interface (from Interfaces)” on page 114.
InstanceSpecification See “InstanceSpecification (from Kernel)” on 
page 57. (Note that instances of any classifier can be shown by prefixing the classifier name by the instance name followed by a colon and underlining the complete name string.)
Package See “Package (from Kernel)” on page 99.ClassName
InterfaceName
<<interface>>
InterfaceName
Instancename :
ClassName
PackageName
130                 UML Superstructure 2.0 Draft Adopted SpecificationGraphical paths
The graphic paths that can be included in structure diagrams are shown in Table 4.
Table 4 - Graphic nodes included in structure diagrams
PATH TYPE NOTATION REFERENCE
Aggregation See “AggregationKind (from Kernel)” on page 80.
Association See “Association (from Kernel)” on page 81.
Composition See “AggregationKind (from Kernel)” on page 80.
Dependency See “Dependency (from Dependencies)” on 
page 108.
Generalization See “Generalization (from Kernel, PowerTypes)” 
on page 66.
Realization See “Realization (from Dependencies)” on 
page 110.
Package Merge See “PackageMerge (from Kernel)” on page 101.
PackageImport 
(private)See “PackageImport (from Kernel)” on page 38.<<merge>>
<<use>>
UML Superstructure 2.0 Draft Adopted Specification        131Variations
Variations of structure diagrams often focus on particular structural aspects, such as relationships between packages, showing 
instance specifications, or relationships between classes. There are no strict boundaries between different variations; it is possible to display any element you normally display in a structure diagram in any variation.
Class diagram
The following nodes and edges are typically drawn in a class diagram:
 Association
 Aggregation
 Class
 Composition
 Dependency
 Generalization
 Interface
 Realization
Package diagram
The following nodes and edges are typically drawn in a package diagram:
 Dependency
 Package
 PackageExtension
 PackageImport
Object diagram
The following nodes and edges are typically drawn in an object diagram:
 InstanceSpecification
 Link (i.e., Association)PackageImport (public)See “PackageImport (from Kernel)” on page 38.Table 4 - Graphic nodes included in structure diagrams
PATH TYPE NOTATION REFERENCE
<<import>>
132                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        1338 Components
8.1 Overview
The Components package specifies a set of constructs that can be used to define software systems of arbitrary size and 
complexity. In particular, the package specifies a component as a modular unit with well-defined interfaces that is replaceable  
within its environment. The component concept addresses the area of component-based development and component-based system structuring, where a component is modeled throughout the development life cycle and successively refined into deployment and run-time.
An important aspect of component-based development is the reuse of previously constructed components. A component can always be considered an autonomous unit within a system or subsystem. It has one or more provided and required interfaces (potentially exposed via ports), and its internals are hidden and inaccessible other than as provided by its interfaces. Althou gh 
it may be dependent on other elements in terms of interfaces that are required, a component is encapsulated and its dependencies are designed such that it can be treated as independently as possible. As a result, components and subsystems can be flexibly reused and replaced by connecting (“wiring”) them together via their provided and required interfaces. The aspects of autonomy and reuse also extend to components at deployment time. The artifacts that implement component are intended to be capable of being deployed and re-deployed independently, for instance to update an existing system.
The Components package supports the specification of both logical components (e.g. business components, process components) and physical components (e.g. EJB components, CORBA components, COM+ and .NET components, WSDL components, etc.), along with the artifacts that implement them and the nodes on which they are deployed and executed. It is anticipated that profiles based around components will be developed for specific component technologies and associated hardware and software environments. 
Basic Components
The BasicComponents package focuses on defining a component as an executable element in a system. It defines the concept of a component as a specialized class that has an external specification in the form of one or more provided and required interfaces, and an internal implementation consisting of one or more classifiers that realize its behavior. In addition, the BasicComponents package defines specialized connectors for ‘wiring’ components together based on interface compatibility.
Packaging Components
The PackagingComponents package focuses on defining a component as a coherent group of elements as part of the development process. It extends the concept of a basic component to formalize the aspects of a component as a ‘building block’ that may own and import a (potentially large) set of model elements.
134                 UML Superstructure 2.0 Draft Adopted Specification8.2 Abstract syntax
Figure 76 shows the dependencies of the Component packages.
Figure 76 - Dependencies between packages described in this chapter
                     (transitive dependencies to Kernel and Interfaces packages are not shown).Bas icComponentsStructuredClass es
(from CompositeStructures )
Pack agingComponents<<merge>>Dependencies
(from Cla s ses)
<<merge>>
UML Superstructure 2.0 Draft Adopted Specification        135Package BasicComponents
Figure 77 - The metaclasses that define the basic Component construct.
Figure 78 - The metaclasses that define the component wiring constructsCla ss
(from StructuredClasses)
Interface
(from  In te rfa ce s)Component
is IndirectlyIns tantiated : Boolean
*
+/required**
+/provided*
Classi fier
(from  Kernel)Realization*
0..1+realization*
{subsets ownedElement,
s ubs ets  clientDependency}+abs traction
0..1{ subsets s our ce,
s ubs ets  owner,
s ubsets client}
1+realizingClas s ifier
1{su bse ts su pp l i er,
s ubs ets  target}
ConnectorKind<<enumeration>>
as sembly
delegationBehavior
(from BasicBehaviors)Connector
kind : Con nectorKi nd**+ c o n t r a c t
**
136                 UML Superstructure 2.0 Draft Adopted SpecificationPackage PackagingComponents
8.3 Class Descriptions
8.3.1 Component
A component represents a modular part of a system that encapsulates its contents and whose manifestation is replaceable 
within its environment. 
A component defines its behavior in terms of provided and required interfaces. As such, a component serves as a type, whose conformance is defined by these provided and required interfaces (encompassing both their static as well as dynamic semantics). One component may therefore be substituted by another only if the two are type conformant. Larger pieces of a system's functionality may be assembled by reusing components as parts in an encompassing component or assembly of components, and wiring together their required and provided interfaces.
A component is modeled throughout the development life cycle and successively refined into deployment and run-time. A component may be manifest by one or more artifacts, and in turn, that artifact may be deployed to its execution environment. A deployment specification may define values that parameterize the component’s execution. (See Deployment chapter).
Description
BasicComponents
A component is a subtype of Class which provides for a Component having attributes and operations, and being able to participate in Associations and Generalizations. A Component may form the abstraction for a set of realizingClassifiers that realize its behavior. In addition, because a itself Class is a subtype of an EncapsulatedClassifier, a Component may optionally  
have an internal structure and own a set of Ports that formalize its interaction points.
A component has a number of provided and required Interfaces, that form the basis for wiring components together, either using Dependencies, or by using Connectors. A provided Interface is one that is either implemented directly by the component or one of its realizingClassifiers, or it is the type of a provided Port of the Component. A required interface is designated b y a 
Usage Dependency from the Component or one of its realizingClassifiers, or it is the type of a required Port.
PackagingComponents
A component is extended to define the grouping aspects of packaging components. This defines the Namespace aspects of a Component through its inherited ownedMember and elementImport associations. In the namespace of a component, all model elements that are involved in or related to its definition are either owned or imported explicitly. This may include e.g. Use Cases and Dependencies (e.g. mappings), Packages, Components, and Artifacts.Figure 79 - The packaging capabilities of ComponentsComponent PackageableElem ent
(from  Kernel)
0..1 * 0..1+ownedMember
* {redefines  ownedMember}
UML Superstructure 2.0 Draft Adopted Specification        137Attributes
BasicComponents
 isIndirectlyInstantiated : Boolean {default = true}
The kind of instantiation that applies to a Component. If false , the component is instanti-
ated as an addressable object. If true, the Component is defined at design-time, but at run-
time (or execution-time) an object specified by the Component does not exist, that is, the component is instantiated indirectly, through the instantiation of its realizing classifiers or parts. Several standard stereotypes use this meta attribute, e.g. 
«specification, «focus», «sub-
system».
Associations
BasicComponents
 provided: Interface The interfaces that the component exposes to its environment. These interfaces may be 
Implemented or Realized by the Component or any of its realizingClassifiers, or they may be the types of its required Ports.The provided interfaces association is a derived association (OCL version of the deriva-tion above to be added).
 required: Interface The interfaces that the component requires from other components in its environment in 
order to be able to offer its full set of provided functionality. These interfaces may be Used by the Component or any of its realizingClassifiers, or they may be the types of its required Ports.The required interfaces association is a derived association (OCL version of the derivation above to be added).
 realization: Realization References the Classifiers of which the Component is an abstraction, i.e. that realize its 
behavior.
PackagingComponents
 ownedMember: PackageableElement
The set of PackageableElements that a Components owns. In the namespace of a compo-nent, all model elements that are involved in or related to its definition may be owned or imported explicitly. These may include e.g. Classes, Interfaces, Components, Packages, Use cases, Dependencies (e.g. mappings), and Artifacts.
Constraints
No further constraints.
Semantics
A component is a self contained unit that encapsulates the state and behavior of a number of classifiers. A component specifies  
a formal contract of the services that it provides to its clients and those that it requires from other components or services in the 
system in terms of its provided and required interfaces. 
A component is a substitutable unit that can be replaced at design time or run-time by a component that offers that offers equivalent functionality based on compatibility of its interfaces. As long as the environment obeys the constraints expressed by the provided and required interfaces of a component, it will be able to interact with this environment. Similarly, a system can be extended by adding new component types that add new functionality.
138                 UML Superstructure 2.0 Draft Adopted SpecificationThe required and provided interfaces of a component allow for the specification of structural features such as attributes and 
association ends, as well as behavioral features such as operations and events. A component may implement a provided interface directly, or, its realizing classifiers may do so. The required and provided interfaces may optionally be organized through ports, these enable the definition of named sets of provided and required interfaces that are typically (but not always ) 
addressed at run-time.
A component has an external view  (or. “black-box” view) by means of its publicly visible properties and operations. 
Optionally, a behavior such as a protocol state machine may be attached to an interface, port and to the component itself, to define the external view more precisely by making dynamic constraints in the sequence of operation calls explicit. Other behaviors may also be associated with interfaces or connectors to define the ‘contract’ between participants in a collaboration  
e.g. in terms of use case, activity or interaction specifications.
The wiring between components in a system or other context can be structurally defined by using dependencies between component interfaces (typically on structure diagrams). Optionally, a more detailed specification of the structural collaboration can be made using parts and connectors in of composite structures, to specify the role or instance level collaboration between components (See Chapter Composite Structures).
A component also has an  internal view  (or “white-box” view) by means of its private properties and realizing classifiers. This 
view shows how the external behavior is realized internally. The mapping between external and internal view is by means of dependencies (on structure diagrams), or delegation connectors to internal parts (on composite structure diagrams). Again, more detailed behavior specifications such as for example interactions and activities may be used to detail the mapping from external to internal behavior.
A number of UML standard stereotypes exist that apply to component, e.g. «subsystem» to model large-scale components, and «specification» and «realization» to model components with distinct specification and realization definitions, where one specification may have multiple realizations - see the UML Standard Elements Appendix.
Notation
A component is shown as a Classifier rectangle with the keyword «component» . Optionally, in the right hand corner a 
component icon can be displayed. This is a classifier rectangle with two smaller rectangles protruding from its left hand side.
Figure 80 - A Component with one provided interface
Figure 81 - A Component with two provided and three required interfaces«component»
QuoteServiceQuoteInf
Order
OrderableItem«component» Person
Invoice
UML Superstructure 2.0 Draft Adopted Specification        139An external view of a Component is by means of Interface symbols sticking out of the Component box (external, or black-box 
view). Alternatively, the interfaces and/or individual operations and attributes can be listed in the compartments of a component box (for scalability, tools may offer way of listing and abbreviating component properties and behavior).
For displaying the full signature of an interface of a component, the interfaces can also be displayed as typical classifier rectangles that can be expanded to show details of operations and events.
An internal, or white box view of a Component is where the realizing classifiers are listed in an additional compartment. Compartments may also be used to display a listing of any parts and connectors, or any implementing artifacts.Figure 82 - Black box notation showing a listing of the properties
                     of a component.
Figure 83 - Explicit representation of the provided and required                     interfaces, allowing interface details such as operation 
                      to be displayed (when desired).
Figure 84 - A white-box representation of a componentOrder«component»
«provided interfaces»
   OrderEntry
   Billing
«required interfaces»
   Invoice      create (...)      registerPayment (...)
Person Order
FindbyName()
Create()GetDetails()«use»«Interface»
OrderEntry
Create()
ValidateDetails()AddOrderline()«Interface»
Order«component»
«provided interfaces»
   OrderEntry   AccountPayable«required interfaces»   Person
«realizations»   OrderHeader   LineItem
«artifacts»   Order.jar
140                 UML Superstructure 2.0 Draft Adopted SpecificationThe internal classifiers that realize the behavior of a component may be displayed by means of general dependencies. 
Alternatively, they may be nested within the component shape.
Alternatively, the internal classifiers that realize the behavior of a component may be displayed nested within the component shape.
If more detail is required of the role or instance level containment of a component, then an internal structure consisting of p arts 
and connectors can be defined for that component. This allows e.g. explicit part names or connector names to be shown in situations where the same Classifier (Association) is the type of more than one Part (Connector). That is, the Classifier is instantiated more than once inside the component, playing different roles in its realization. Optionally, specific instances (InstanceSpecifications) can also be referred to as in this notation.Figure 85 - A representation of the realization of a complex component
Figure 86 - An alternative nested representation of a complex componentCustomer
CustomerImpl CustomerColl CustomerDef
Order
OrderHeader
LineItemPerso
nOrderEntry
*order
item1
UML Superstructure 2.0 Draft Adopted Specification        141Artifacts that implement components can be connected to them by physical containment or by an «implement» relationship, 
which is an instance of the meta association between Component and Artifact.
Examples Figure 87 - An internal or white-box view of the internal structure 
                    of a component that contains other components as parts of                       its internal assembly.
Figure 88 - Example of an overview diagram showing 
                     components and their general dependencies.Store
:Order
:Product:CustomerPerson
Person
OrderableItem
OrderableItemOrderEntryOrderEntry
Account
Account«delegate»
«delegate»
Order«component»
Account«component»
Product«component»
142                 UML Superstructure 2.0 Draft Adopted Specification The wiring of components can be represented on structure diagrams by means of classifiers and dependencies between them 
(Note: the ball-and-socket notation from Figure 90 may used as a notation option for dependency based wiring). On composite 
structure diagrams, detailed wiring can be performed at the role or instance level by defining parts and connectors.Figure 89 - Example of a platform independent model of a component, 
                   its provided and required interfaces, and wiring through 
                     dependencies on a structure diagram.
Figure 90 - Example of a composite structure of components, with 
                    connector wiring between provided and required interfaces 
                      of parts (Note: “Client” interface is a subtype of “Person”).Order«component»
LineItemOrderHeader«focus»
*1
concernsAccount«component»
Product
«component»
OrderableItem/orderedItem/account1
AccountPayable
:BackOrder
:Order
:Product:CustomerPersonPerson
:Organization :ServicePerson
ClientOrderableItem
OrderableItemOrderableItemOrderEntry
:ShoppingCart
OrderEntry
UML Superstructure 2.0 Draft Adopted Specification        143Changes from previous UML
The following changes from UML 1.x have been made:
The component model has made a number of implicit concepts from the UML 1.x model explicit, and made the concept more 
applicable throughout the modeling life cycle (rather than the implementation focus of UML 1.x). In particular, the “resides” relationship from 1.x relied on namespace aspects to define both namespace aspects as well as ‘residence’ aspects. These two aspects have been separately modeled in the UML metamodel in 2.0. The basic residence relationship in 1.x maps to the realizingClassifiers relationship in 2.0. The namespace aspects are defined through the basic namespace aspects of Classifiers in UML 2.0, and extended in the PackagingComponents metamodel for optional namespace relationships to elements other than classifiers.
In addition, the Component construct gains the capabilities from the general improvements in CompositeStructures (around Parts, Ports and Connectors).
In UML 2.0, a Component is notated by a classifier symbol that no longer has two protruding rectangles. These were cumbersome to draw and did not scale well in all circumstances. Also, they interfered with any interface symbols on the edge of the Component. Instead, a «component» keyword notation is used in UML 2.0. Optionally, a component icon that is similar to the UML 1.4 icon can still be used in the upper right-hand corner of the component symbol. For backward compatibility reasons, the UML 1.4 notation with protruding rectangles can still be used.
8.3.2 Connector (from InternalStructures, as specialized)
The connector concept is extended in the Components package to include interface based constraints and notation.
A delegation connector is a connector that links the external contract of a component (as specified by its ports) to the intern al 
realization of that behavior by the component’s parts. It represents the forwarding of signals (operation requests and events) : a 
signal that arrives at a port that has a delegation connector to a part or to another port will be passed on to that target for  
handling.
An assembly connector is a connector between two components that defines that one component provides the services that another component requires. An assembly connector is a connector that is defined from a required interface or port to a provided interface or port.
Description
In the metamodel, a connector kind attribute is added to the Connector metaclass. Its value is an enumeration type with valid values “assembly” or “delegation”.
Attributes
BasicComponents
 kind : ConnectorKind = {assembly, delegation} Indicates the kind of connector.
Associations
No additional associations.
Constraints
[1]  A delegation connector must only be defined between used Interfaces or Ports of the same kind, e.g. between two pro-
vided Ports or between two required Ports.
[2] If a delegation connector is defined between a used Interface or Port and an internal Part Classifier, then that Classifier
must have an “implements” relationship to the Interface type of that Port.
144                 UML Superstructure 2.0 Draft Adopted Specification[3] If a delegation connector is defined between a source Interface or Port and a target Interface or Port, then the target Inte r-
face must support a signature compatible subset of Operations of the source Interface or Port.
[4] In a complete model, if a source Port has delegation connectors to a set of delegated target Ports, then the union of the
Interfaces of these target Ports must be signature compatible with the Interface that types the source Port.
[5] An assembly connector must only be defined from a required Interface or Ports to a provided Interface or Port.
Semantics
A delegation connector is a declaration that behavior that is available on a component instance is not actually realized by tha t 
component itself, but by another instance that has “compatible” capabilities. This may be another Component or a (simple) Class. The latter situation is modeled through a delegation connector from a Component Interface or Port to a contained Class that functions as a Part. In that case, the Class must have an implements relationship to the Interface of the Port. 
Delegation connectors are used to model the hierarchical decomposition of behavior, where services provided by a component may ultimately be realized by one that is nested multiple levels deep within it. The word delegation suggests that concrete message and signal flow will occur between the connected ports, possibly over multiple levels. It should be noted that such signal flow is not always realized in all system environments or implementations (i.e. it may be design time only).
A port may delegate to a set of ports on subordinate components. In that case, these subordinate ports must collectively offer the delegated functionality of the delegating port. At execution time, signals will be delivered to the appropriate port. In th e 
cases where multiple target ports support the handling of the same signal, the signal will be delivered to all these subordinat e 
ports.
The execution time semantics for an assembly connector are that signals travel along an instance of a connector, originating in  
a required port and delivered to a provided port. Multiple connectors directed from a single required interface or port to provided interfaces on different components indicates that the instance that will handle the signal will be determined at execution time. Similarly, multiple required ports that are connected to a single provided port indicates that the request may originate from instances of different component types.
The interface compatibility between provided and required ports that are connected enables an existing component in a system to be replaced by one that (minimally) offers the same set of services. Also, in contexts where components are used to extend a system by offering existing services, but also adding new functionality, assembly connectors can be used to link in the new component definition. That is, by adding the new component type that offers the same set of services as existing types, and defining new assembly connectors to link up its provided and required ports to existing ports in an assembly.
Notation
A delegation connector is notated as a Connector from the delegating source Port to the handling target Part, and vice versa fo r 
UML Superstructure 2.0 Draft Adopted Specification        145required Interfaces or Ports.
An assembly connector is notated by a “ball-and-socket” connection between a provided interface and a required interface. 
This notation allows for succinct graphical wiring of components, a requirement for scaling in complex systems. 
When this notation is used to connect “complex” ports that are typed by multiple provided and/or required interfaces, the various interfaces are listed as an ordered set, designated with {provided} or {required} if needed.
In a system context where there are multiple components that provide or require a particular interface, a notation abstraction can be used that combines by joining the multiple connectors. This abstraction is similar to the one defined for aggregation an d Figure 91 - Delegation connectors connect the externally provided 
                     interfaces of a component to the parts that realize or require them.
Figure 92 - An assembly connector maps a required interface of a 
                   component to a provided interface of another component in a                    certain context (definition of components e.g. in a library on the 
                     left, an assembly of those components on the right).Order
:LineItemPersonOrderEntry
:OrderHeader
Product«component»OrderOrderEntry
OrderableItem«component»
OrderableItem:Order
:ProductOrderableItemOrderableItem«component»
«component»
146                 UML Superstructure 2.0 Draft Adopted Specificationsubtyping relationships.
Changes from previous UML
The following changes from UML 1.x have been made: Connector is not defined in UML 1.4.
8.3.3 Realization (from Dependencies, as specialized)
The Realization concept is specialized in the Components package to (optionally) define the Classifiers that realize the 
contract offered by a component in terms of its provided and required interfaces. The component forms an abstraction from these various Classifiers.
Description
In the metamodel, a Realization is a subtype of Dependencies::Realization.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional associations.
Semantics
A component’s behavior may typically be realized (or implemented) by a number of Classifiers. In effect, it forms an abstraction for a collection of model elements. In that case, a component owns a set of Realization Dependencies to these Figure 93 - As a notation abstraction, multiple wiring relationships 
                    can be visually grouped together in a component assembly.:Order :Customer
OrderEntryPerson
Person«component» «component»
:Organization«component»
Note: Client interface is a subtype of Person interface:BackOrder«component»Person
OrderEntry
UML Superstructure 2.0 Draft Adopted Specification        147Classifiers.
It should be noted that for the purpose of applications that require multiple different sets of realizations for a single compo nent 
specification, a set of standard stereotypes are defined in the UML Standard Profile. In particular, «specification» and «realization» are defined there for this purpose.
Notation
A component realization is notated in the same way as the realization dependency, i.e. as a general dashed line with an open arrow-head.
Changes from previous UML
The following changes from UML 1.x have been made: Realization is defined in UML 1.4 as a ‘free standing’ general dependency - it is not extended to cover component realization specifically. These semantics have been made explicit in UML 2.0.
8.4 Diagrams
Structure diagram
Graphical nodes
The graphic nodes that can be included in structure diagrams are shown in Table 4.
Table 4 - Graphic nodes included in structure diagrams
NODE TYPE NOTATION REFERENCE
Component See “Component”.
Component implements 
InterfaceSee “Interface”.<<component>>
ComponentName
ComponentName
Name«component»
148                 UML Superstructure 2.0 Draft Adopted SpecificationGraphical paths
The graphic paths that can be included in structure diagrams are shown in Table 5.
Variations
Variations of structure diagrams often focus on particular structural aspects, such as relationships between packages, showing 
instance specifications, or relationships between classes. There are no strict boundaries between different variations; it is possible to display any element you normally display in a structure diagram in any variation.Component has provided Port (typed by Interface)See “Port”.
Component uses Inter-
faceSee “Interface”.
Component has required 
Port (typed by Interface)See “Port”.
Component has complex 
Port (typed by provided and required Interfaces)See “Port”.
Table 5 Graphic nodes included in structure diagrams
PATH TYPE NOTATION REFERENCE
Assembly connector See “assembly connector”. Also used as notation 
option for wiring between interfaces using Depen-dencies.Table 4 - Graphic nodes included in structure diagrams
NODE TYPE NOTATION REFERENCE
Name«component»
Name«component»
Name«component»
Name«component»
UML Superstructure 2.0 Draft Adopted Specification        149Component diagram
The following nodes and edges are typically drawn in a component diagram:
 Component
 Interface
 Realization, Implementation, Usage Dependencies
 Class
 Artifact
 Port
150                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        1519 Composite Structures
9.1 Overview
The term “structure” in this chapter refers to a composition of interconnected elements, representing run-time instances 
collaborating over communications links to achieve some common objectives. 
Internal Structures
The InternalStructure subpackage provides mechanisms for specifying structures of interconnected elements that are created 
within an instance of a containing classifier. A structure of this type represents a decomposition of that classifier. and is 
referred to as its “internal structure”.
Ports
The Ports subpackage provides mechanisms for isolating a classifier from its environment. This is achieved by providing a point for conducting interactions between the internals of the classifier and its environment. This interaction point is referr ed 
to as a “port.” Multiple ports can be defined for a classifier, enabling different interactions to be distinguished based on th e 
port through which they occur. By decoupling the internals of the classifier from its environment, ports allow a classifier to be 
defined independently of its environment, making that classifier reusable in any environment that conforms to the interaction constraints imposed by its ports.
Collaborations
Objects in a system typically cooperate with each other to produce the behavior of a system. The behavior is the functionality that the system is required to implement. 
A behavior of a collaboration will eventually be exhibited by a set of cooperating instances (specified by classifiers) that communicate with each other by sending signals or invoking operations. However, to understand the mechanisms used in a design, it may be important to describe only those aspects of these classifiers and their interactions that are involved in accomplishing a task or a related set of tasks, projected from these classifiers. Collaborations  allow us to describe only the 
relevant aspects of the cooperation of a set of instances by identifying the specific roles that the instances will play. Interfaces  
allow the externally observable properties of an instance to be specified without determining the classifier that will eventual ly 
be used to specify this instance. Consequentially, the roles in a collaboration will often be typed by interfaces and will then  
prescribe properties that the participating instances must exhibit, but will not determine what class will specify the participating instances.
StructuredClasses
The StructuredClasses subpackage supports the representation of classes that may have ports as well as internal structure.
Actions
The Actions subpackage adds actions that are specific to the features introduced by composite structures, e.g., the sending of messages via ports.
9.2 Abstract syntax
Figure 94 shows the dependencies of the CompositeStructures packages.
152                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 94 - Dependencies between packages described in this chapterCommunications
(from CommonBehaviors)
InternalStructures
PortsInterfaces
(from  Cl asses)
<<merge>><<merge>><<merge>>
Collaborations<<merge>>
IntermediateActions
(from Actions)InvocationActions<<merge>><<merge>>
<<merge>>St ru ct ur e dC l as s es<<merge>><<merge>>
StructuredActivities
(from Activities)
<<merge>>
StructuredActivities<<merge>><<merge>>
UML Superstructure 2.0 Draft Adopted Specification        153Package InternalStructures
Figure 95 - Structured classifier
Figure 96 - ConnectorsNamedElement
(from Kernel)
PropertyConnectableElement StructuredClassifier
0..1
*0..1
{subsets classifier}+ownedAttribute
*{subsets role, subsets attribute, 
subs ets ownedMember}
*0..1 +/part
*0..1* *+/role
*{union, subsets member}
*
Connector
*0..1+ownedConnector
*{subsets feature, subsets ownedMember}
0..1
{subsets redefinitionContext}**
+redefinedConnector*
{subsets redefinedElement}*Classifier
(from Kernel)
Feature
(from Kernel)MultiplicityElement
(from Kernel)
Association
(from Kernel)Connector
0..1*
+type 0..1*
PropertyConnectorEnd 2..*
1+end2..*
{ordered, subsets ownedElement}1
0..1*
+/definingEnd 0..1*ConnectableElement
* 0..1+end
*+role
0..1
154                 UML Superstructure 2.0 Draft Adopted SpecificationPackage Ports
Package StructuredClassesFigure 97 - The Port metaclass
Figure 98 - Classes with internal structureConnectableElement
(from InternalStructures)StructuredClassifier
(f rom I n ternalStructures)
Property
(from InternalStructures)ConnectorEnd
0..1 +partWithPort 0..1EncapsulatedClassifier
Interface
(from Interfaces)Port
isBehavior : Boolean = false
isServ ice : Boolean = true*0..1 +ownedPor t
*{subsets feature, 
subsets ownedMember}
0..1
{subsets redefinitionContext}
**
+redefinedPort*
{subsets redefinedElement}***+/required
**
* *+/prov ided
* *StructuralFeature
(from Kernel)
Class
(from Communications)
ClassEncapsulatedClassifier
(from Ports)
UML Superstructure 2.0 Draft Adopted Specification        155Package Collaborations
Package ActionsFigure 99 - Collaboration
Figure 100 - Collaboration.occurrence and role binding
Figure 101 - Actions specific to composite structuresConnectableElement
(from InternalStructures)Collaboration* *
+collaborationRole**
ParameterStructuredClassifier
(from InternalStructures)BehavioredClassifier
(fro m Ba sicBehav ior s)
{subsets role}
NamedElement
(f ro m K e rn e l)
Cla ssifier
Dependency
(from  Dependencies)
CollaborationCollaborationOccurrence
0..1 0..1 0..1
+representation0..1
{subsets occurrence}* 0..1
+occurrence*
{subsets ownedElement}0..1
*1 +roleBinding
*{subsets ownedElement}
1
1*
+type 1*
InvocationActionTrigger Port
(from Ports)*0..1*+onPort
0..1* * *
+port*
156                 UML Superstructure 2.0 Draft Adopted SpecificationPackage StructuredActivities
9.3 Class Descriptions
9.3.1 Class (from StructuredClasses, as specialized)
Description
Extends the metaclass Class with the capability to have an internal structure and ports.
Semantics
See “Property” on page 167, “Connector” on page 163, and “Port” on page 167 for the semantics of the features of Class. 
Initialization of the internal structure of a class is discussed in section “StructuredClassifier” on page 171. 
A class acts as the namespace for various kinds of classifiers defined within its scope, including classes. Nesting of classifi ers 
limits the visibility of the classifier to within the scope of the namespace of the containing class and is used for reasons of  
information hiding. Nested classifiers are used like any other classifier in the containing class.
Notation
See “Class (from Kernel)” on page 86, “StructuredClassifier” on page 171, and “Port” on page 167.
Presentation Option
A dashed arrow with a stick arrowhead, optionally labelled with the keyword «create», may be used to relate an instance value to a constructor for a class, describing the single value returned by the constructor which must have the class as its classifi er. 
The arrowhead points at the operation defining the constructor. The constructor may reference parameters declared by the operation. The instance value at the base of the arrow represents the default for the return value of the constructor.Figure 102 - Extension to Variable
Figure 103 - Instance specification describes the return value of an operationVariableConnectableElement
(f ro m In t er n al S t ru c tu re s)
make (...)Window
«create»theW:Window
UML Superstructure 2.0 Draft Adopted Specification        157Changes from UML 1.x
Class has been extended with internal structure and ports.
9.3.2 Classifier (from Collaborations, as specialized)
Description
Classifier is extended with the capability to own collaboration occurrences. These collaboration occurrences link a 
collaboration with the classifier to give a description of the workings of the classifier.
Associations
 occurrence: CollaborationOccurrence
References the collaboration occurrences owned by the classifier. (Subsets Ele-
ment.ownedElement .)
 representation: CollaborationOccurrence [ 0..1 ]
References a collaboration occurrence which indicates the collaboration that represents this classifier. (Subsets Classifier.occurrence .)
Semantics
A classifier can own collaboration occurrences which relate (aspects of) this classifier to a collaboration. The collaboration 
describes those aspects of this classifier.
One of the collaboration occurrences owned by a classifier may be singled out as representing the behavior of the classifier as  
a whole. The collaboration that is related to the classifier by this collaboration occurrence shows how the instances corresponding to the structural features of this classifier (e.g., its attributes and parts) interact to generate the overall b ehavior 
of the classifier. The representing collaboration may be used to provide a description of the behavior of the classifier at a different level of abstraction than is offered by the internal structure of the classifier. The properties of the classifier ar e 
mapped to roles in the collaboration by the role bindings of the collaboration occurrence.
Notation
See “CollaborationOccurrence” on page 160.
Changes from UML 1.x
Replaces and widens the applicability of Collaboration.usedCollaboration . Together with the newly introduced concept of 
internal structure replaces Collaboration.representedClassifier .
9.3.3 Collaboration (from Collaborations)
A collaboration describes a structure of collaborating elements (roles), each performing a specialized function, which 
collectively accomplish some desired functionality. Its primary purpose is to explain how a system works and, therefore, it typically only incorporates those aspects of reality that are deemed relevant to the explanation. Thus, details, such as the identity or precise class of the actual participating instances are suppressed.
Description
A collaboration is represented as a kind of classifier and defines a set of cooperating entities to be played by instances (its  
roles), as well as a set of connectors that define communication paths between the participating instances. The cooperating entities are the properties of the collaboration (see “Property” on page 167). 
158                 UML Superstructure 2.0 Draft Adopted SpecificationA collaboration specifies a view (or projection) of a set of cooperating classifiers. It describes the required links between 
instances that play the roles of the collaboration, as well as the features required of the classifiers that specify the partic ipating 
instances. Several collaborations may describe different projections of the same set of classifiers. 
Attributes
No additional attributes.
Associations
 collaborationRole: ConnectableElement
References connectable elements (possibly owned by other classifiers) which represent 
roles that instances may play in this collaboration. (Subsets StructuredClassifier.role .)
Constraints
No additional constraints.
Semantics
Collaborations are generally used to explain how a collection of cooperating instances achieve a joint task or set of tasks. 
Therefore, a collaboration typically incorporates only those aspects that are necessary for its explanation and suppresses everything else. Thus, a given object may be simultaneously playing roles in multiple different collaborations, but each collaboration would only represent those aspects of that object that are relevant to its purpose.
A collaboration defines a set of cooperating participants that are needed for a given task. The roles of a collaboration will b e 
played by instances when interacting with each other. Their relationships relevant for the given task are shown as connectors between the roles. Roles of collaborations define a usage of instances, while the classifiers typing these roles specify all required properties of these instances. Thus, a collaboration specifies what properties instances must have to be able to participate in the collaboration: A role specifies (through its type) the required set of features a participating instance mus t 
have. The connectors between the roles specify what communication paths must exist between the participating instances. 
Neither all features nor all contents of the participating instances nor all links between these instances are always required in a 
particular collaboration. Therefore, a collaboration is often defined in terms of roles typed by interfaces (see “Interface (fr om 
Interfaces)” on page 114). An interface is a description of a set of properties (externally observable features) required or provided by an instance. An interface can be viewed as a projection of the externally observable features of a classifier realizing the interface. Instances of different classifiers can play a role defined by a given interface, as long as these clas sifiers 
realize the interface, i.e., have all the required properties. Several interfaces may be realized by the same classifier, even in the 
same context, but their features may be different subsets of the features of the realizing classifier. 
Collaborations may be specialized from other collaborations. If a role is extended in the specialization, the type of a role in  the 
specialized collaboration must be conform to the type of the role in the general collaboration. The specialization of the types  of 
the roles does not imply corresponding specialization of the classifiers that realize those roles. It is sufficient that they c onform 
to the constraints defined by those roles.
A collaboration may be attached to an operation or a classifier through a CollaborationOccurrence. A collaboration used in this  
way describes how this operation or this classifier is realized by a set of cooperating instances. The connectors defined withi n 
the collaboration specify links between the instances when they perform the behavior specified in the classifier. The collaboration specifies the context in which behavior is performed. Such a collaboration may constrain the set of valid interactions that may occur between the instances that are connected by a link.
A collaboration is not directly instantiable. Instead, the cooperation defined by the collaboration comes about as a consequenc e 
of the actual cooperation between the instances that play the roles defined in the collaboration (the collaboration is a select ive 
view of that situation).
UML Superstructure 2.0 Draft Adopted Specification        159Notation
A collaboration is shown as a dashed ellipse icon containing the name of the collaboration. The internal structure of a 
collaboration as comprised by roles and connectors may be shown in a compartment within the dashed ellipse icon. Alternatively, a composite structure diagram can be used.
 
Using an alternative notation for properties, a line may be drawn from the collaboration icon to each of the symbols denoting classifiers that are the types of properties of the collaboration. Each line is labeled by the name of the property. In this ma nner, 
a collaboration icon can show the use of a collaboration together with the actual classifiers that occur in that particular use  of 
the collaboration (see Figure 105).
Figure 105 - In the Observer collaboration two roles, a Subject and an 
                     Observer, collaborate to produce the desired behavior. Any 
                     instance playing the Subject role must possess the properties                        specified by CallQueue, and similarly for the Observer role.
Rationale
The primary purpose of collaborations is to explain how a system of communicating entities collectively accomplish a specific 
task or set of tasks without necessarily having to incorporate detail that is irrelevant to the explanation. It is particularly  useful 
as a means for capturing standard design patterns.
Changes from UML 1.x
The contents of a collaboration is specified as its internal structure relying on roles and connectors; the concepts of Figure 104 - The internal structure of the Observer collaboration shown 
                      inside the collaboration icon (a connection is shown between                         the Subject and the Observer role).Observer
Observer : SlidingBarIcon Subject : CallQueue
ObserverSlidingBarIconObserverCallQueue Subject
queue: List of Call
source: Object
waitAlarm: Alarmreading: Real
color: Color
range: Interval
Observer.reading = length (Subject.queue)capacity: Integer
Observer.range = (0 .. Subject.capacity)
160                 UML Superstructure 2.0 Draft Adopted SpecificationClassifierRole, AssociationRole, and AssociationEndRole have been superseded. A collaboration in UML 2.0 is a kind of 
classifier, and can have any kind of behavioral descriptions associated. There is no loss in modeling capabilities.
9.3.4 CollaborationOccurrence (from Collaborations)
A collaboration occurrence represents the application of the pattern described by a collaboration to a specific situation involving specific classes or instances playing the roles of the collaboration.
Description
A collaboration occurrence represents one particular use of a collaboration to explain the relationships between the properties  
of a classifier. A collaboration occurrence indicates a set of roles and connectors that cooperate within the classifier accord ing 
to a given collaboration, indicated by the type of the collaboration occurrence. There may be multiple occurrences of a given collaboration within a classifier, each involving a different set of roles and connectors. A given role or connector may be involved in multiple occurrences of the same or different collaborations.
Associated dependencies map features of the collaboration type to features in the classifier. These dependencies indicate which role in the classifier plays which role in the collaboration.
Attributes
No additional attributes.
Associations
 type: Collaboration [1] The collaboration which is used in this occurrence. The collaboration defines the coopera-
tion between its roles which are mapped to properties of the classifier owning the collabo-ration occurrence.
 roleBinding: Dependency A mapping between features of the collaboration type and features of the classifier or 
operation. This mapping indicates which connectable element of the classifier or operation plays which role(s) in the collaboration. A connectable element may be bound to multiple roles in the same collaboration occurrence (that is, it may play multiple roles).
Constraints
[1]  All the client elements of a roleBinding are in one classifier and all supplier elements of a roleBinding are in one collabo-
ration and they are compatible.
[2] Every role in the collaboration is bound within the collaboration occurrence to a connectable element within the classifier
or operation.
[3] The connectors in the classifier connect according to the connectors in the collaboration
Semantics
A collaboration occurrence relates a feature in its collaboration type to connectable a element in the classifier or operation that 
owns the collaboration occurrence.
Any behavior attached to the collaboration type applies to the set of roles and connectors bound within a given collaboration occurrence. For example, an interaction among parts of a collaboration applies to the classifier parts bound to a single collaboration occurrence. If the same connectable element is used in both the collaboration and the represented element, no role binding is required.
UML Superstructure 2.0 Draft Adopted Specification        161Semantic Variation Points
It is a semantic variation when client and supplier elements in role bindings are compatible.
Notation
A collaboration occurrence is shown by a dashed ellipse containing the name of the occurrence, a colon, and the name of the 
collaboration type. For every role binding, there is a dashed line from the ellipse to the client element; the dashed line is labeled on the client end with the name of the supplier element.
Presentation Option
A dashed arrow with a stick arrowhead may be used to show that a collaboration is used in a classifier, optionally labelled wit h 
the keyword «represents». A dashed arrow with a stick arrowhead may also be used to show that a collaboration represents a classifier, optionally labelled with the keyword «occurrence». The arrowhead points at the owning classifier. When using this presentation option, the role bindings are shown explicitly as dependencies.
Examples
This example shows the definition of two collaborations, Sale (Figure 107) and BrokeredSale (Figure 108). Sale is used twice 
as part of the definition of BrokeredSale . Sale is a collaboration among two roles, a seller  and a buyer . An interaction, or other 
behavior specification, could be attached to Sale to specify the steps involved in making a Sale.
BrokeredSale  is a collaboration among three roles, a producer , a broker , and a consumer . The specification of BrokeredSale  
shows that it consists of two occurrences of the Sale collaboration, indicated be the dashed ellipses. The occurrence wholesale  
indicates a Sale in which the producer  is the seller  and the broker  is the buyer . The occurrence retail  indicates a Sale in which 
the broker  is the seller  and the consumer  is the buyer . The connectors between sellers  and buyers  are not shown in the two 
occurrences; these connectors are implicit in the BrokeredSale  collaboration in virtue of them being comprised of Sales. The 
BrokeredSale  collaboration could itself be used as part of a larger collaboration. Figure 106 - Collaboration occurrence relates a classifier to a collaboration
Figure 107 - The Sale collaborationdisplay (...)Window
:RealizeDisplay
Behavior
«represents»
buyer sellerSale
162                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 109 shows part of the BrokeredSale collaboration in a presentation option.
Rationale
A collaboration occurrence is used to specify the application of a pattern specified by a collaboration to a specific situation . In 
that regard, it acts as the invocation of a macro with specific values used for the parameters (roles).
Changes from UML 1.x
This metaclass has been added.Figure 108 - The BrokeredSale collaboration
Figure 109 - A subset of the BrokeredSale collaborationbroker
producerBrokeredSale
consumerwholesale:
Sale
retail:
Salebuyerseller
seller
buyer
broker
producerBrokeredSaleSale
seller buyer«occurrence»
UML Superstructure 2.0 Draft Adopted Specification        1639.3.5 ConnectableElement (from InternalStructures)
Description
A ConnectableElement is an abstract metaclass representing a set of instances that are owned by a containing classifier 
instance. Connectable elements may be joined by attached connectors and specify configurations of linked instances to be created within an instance of the containing classifier.
Attributes
No additional attributes.
Associations
 end: ConnectorEnd Denotes a connector that attaches to this connectable element. 
Constraints
No additional constraints.
Semantics
The semantics of ConnectableElement is given by its concrete subtypes.
Notation
None.
Examples
None.
Rationale
This metaclass supports factoring out the ability of a model element to be linked by a connector.
Changes from UML 1.x
This metaclass generalizes the concept of classifier role from 1.x
9.3.6 Connector (from InternalStructures)
Specifies a link that enables communication between two or more instances. This link may be an instance of an association, or it may represent the possibility of the instances being able to communicate because their identities are known by virtue of being passed in as parameters, held in variables, created during the execution of a behavior, or because the communicating instances are the same instance. The link may be realized by something as simple as a pointer or by something as complex as a network connection. In contrast to associations, which specify links between any instance of the associated classifiers, connectors specify links between instances playing the connected parts only.
Description
Each connector may be attached to two or more connectable elements, each representing a set of instances. Each connector end is distinct in the sense that it plays a distinct role in the communication realized over a connector. The communications realized over a connector may be constrained by various constraints (including type constraints) that apply to the attached connectable elements.
164                 UML Superstructure 2.0 Draft Adopted SpecificationConstraints
No additional constraints.
Attributes
No additional attributes.
Associations
 end: ConnectorEnd [ 2..* ] A connector consists of at two connector ends, each of which represents the participation 
of instances of the classifiers typing the connectable elements attached to this end. The set of connector ends is ordered. (Subsets Element.ownedElement .)
 type: Association An optional association that specifies the link corresponding to this connector. redefinedConnector: ConnectorA connector may be redefined when its containing classifier is specialized. The redefining 
connector may have a type that specializes the type of the redefined connector. The types of the connector ends of the redefining connector may specialize the types of the connec-tor ends of the redefined connector. The properties of the connector ends of the redefining connector may be replaced. (Subsets Element.redefinedElement .)
Constraints
[1]  The types of the connectable elements that the ends of a connector are attached to must conform to the types of the associ -
ation ends of the association that types the connector, if any.
[2] If a connector is attached to a connectable element which has required interfaces, then the connectable elements attached
to the other ends must realize interfaces that are compatible with these required interfaces.
[3] If a connector is attached to a connectable element which has required interfaces, then either ports attached on the other
ends must provide interfaces that are compatible with these required interfaces, or other connectable elements must realizeinterfaces that are compatible with these required interfaces.
Semantics
If a connector between two roles of a classifier is a feature of an instantiable classifier, it declares that a link may exist within 
an instance of that classifier. If a connector between two roles of a classifier is a feature of an uninstantiable classifier, it 
declares that links may exist within an instance of the classifier that realizes the original classifier. These links will conn ect 
instances corresponding to the parts joined by the connector. 
Links corresponding to connectors may be created upon the creation of the instance of the containing classifier (see “StructuredClassifier” on page 171). The set of links is a subset of the total set of links specified by the association typing the 
connector. All links are destroyed when the containing classifier instance is destroyed. 
If the type of the connector is omitted, the type is inferred based on the connector, as follows: If the type of a role (i.e, t he 
connectable element attached to a connector end) realizes an interface that has a unique association to another interface which  
is realized by the type of another role (or an interface compatible to that interface is realized by the type of another role),  then 
that association is the type of the connector between these parts. If the connector realizes a collaboration (that is, a collaboration occurrence maps the connector to a connector in an associated collaboration through role bindings), then the type  
of the connector is an anonymous association with association ends corresponding to each connector end. The type of each association end is the classifier that realizes the parts connected to the matching connector in the collaboration. Any adornments on the connector ends (either the original connector or the connector in the collaboration) specify adornments of the ends of the inferred association. Otherwise, the type of the connector is an anonymously named association with association ends corresponding to each connector end. The type of each association end is the type of the part that each corresponding connector end is attached to. Any adornments on the connector ends specify adornments of the ends of the 
UML Superstructure 2.0 Draft Adopted Specification        165inferred association. Any inferred associations are always bidirectionally navigable and are owned by the containing classifier .
Semantic Variation Points
What makes interfaces compatible is a semantic variation point. At a minimum, the provided interfaces must support a 
superset of the operations and signals specified in the required interfaces.
Notation
A connector is drawn using the notation for association (see “Association (from Kernel)” on page 81). The optional name string of the connector obeys the following syntax:
{{ [ name ] ‘:’ classname } | name }
where name  is the name of the connector, and classname  is the name of the association that is its type. A stereotype keyword 
within guillemets may be placed above or in front of the connector name. A property string may be placed after or below the connector name.
Examples
Examples are shown in section “StructuredClassifier” on page 171.
Changes from UML 1.x
Connector has been added in UML 2.0. The UML 1.4 concept of association roles is subsumed by connectors.
9.3.7 ConnectorEnd (from InternalStructures, Ports)
Description
A connector end is an endpoint of a connector, which attaches the connector to a connectable element. Each connector end is part of one connector. 
Attributes
No additional attributes.
Associations
InternalStructures
 role: ConnectableElement [1] The connectable element attached at this connector end. When an instance of the contain-
ing classifier is created, a link may (depending on the multiplicities) be created to an instance of the classifier that types this connectable element.
 definingEnd: Property [0..1] A derived association referencing the corresponding association end on the association 
which types the connector owing this connector end. This association is derived by select-ing the association end at the same place in the ordering of association ends as this con-nector end.
Ports
 partWithPort: Property [ 0..1 ] Indicates the role of the internal structure of a classifier with the port to which the connec-
tor end is attached.
Constraints
[1]  If a connector end is attached to a port of the containing classifier, partWithPort will be empty.
166                 UML Superstructure 2.0 Draft Adopted Specification[2] If a connector end references both a role and a partWithPort , then the rolemust be a port that is defined by the type of the
partWithPort .
Semantics
InternalStructures
A connector end describes which connectable element is attached to the connector owning that end. Its multiplicity indicates 
the number of instances that may be linked to each instance of the property connected on the other end.
Notation
InternalStructures
Adornments may be shown on the connector end corresponding to adornments on association ends (see “Association (from Kernel)” on page 81). These adornments specify properties of the association typing the connector. The multiplicity indicates the number of instances that may be connected to each instance of the role on the other end. If no multiplicity is specified, t he 
multiplicity matches the multiplicity of the role the end is attached to.
Ports
If the end is attached to a port on a part of the internal structure and no multiplicity is specified, the multiplicity matches  the 
multiplicity of the port multiplied by the multiplicity of the part (if any).
Changes from UML 1.x
Connector end has been added in UML 2.0. The UML 1.4 concept of association end roles is subsumed by connector ends.
9.3.8 EncapsulatedClassifier (from Ports)
Description
Extends a classifier with the ability to own ports as specific and type checked interaction points.
Attributes
No additional attributes.
Associations
 ownedPort: Port References a set of ports that an encapsulated classifier owns. (Subsets Classifier.feature  
and Namespace.ownedMember .)
Constraints
No additional constraints.
Semantics
See “Port” on page 167.
Notation
See “Port” on page 167.
UML Superstructure 2.0 Draft Adopted Specification        167Changes from UML 1.x
This metaclass has been added to UML.
9.3.9 InvocationAction (from Actions, as specialized)
Description
In addition to targeting an object, invocation actions can also invoke behavioral features on ports from where the invocation 
requests are routed onwards on links deriving from attached connectors. Invocation actions may also be sent to a target via a given port, either on the sending object or on another object.
Associations
 onPort: Port [0..1] A optional port of the receiver object on which the behavioral feature is invoked.
Constraints
[1]  The onPort must be a port on the receiver object.
Semantics
The target value of an invocation action may also be a port. In this case, the invocation request is sent to the object owning this 
port as identified by the port identity, and is, upon arrival, handled as described in “Port” on page 167.
Notation
The optional port is identified by the phrase “via <port>” in the name string of the icon denoting the particular invocation action (for example, see “CallOperationAction” on page 227). 
9.3.10 Parameter (Collaboration, as specialized)
Description
Parameters are allowed to be treated as connectable elements.
Constraints
[1]  A parameter may only be associated with a connector end within the context of a collaboration.
9.3.11 Port (from Ports)
A port is a structural feature of a classifier that specifies a distinct interaction point between that classifier and its envi ronment 
or between the (behavior of the) classifier and its internal parts. Ports are connected to properties of the classifier by connectors through which requests can be made to invoke the behavioral features of a classifier. A Port may specify the services a classifier provides (offers) to its environment as well as the services that a classifier expects (requires) of its environment.
Description
Ports represent interaction points between a classifier and its environment. The interfaces associated with a port specify the nature of the interactions that may occur over a port. The required interfaces of a port characterize the requests which may be  
made from the classifier to its environment through this port. The provided interfaces of a port characterize requests to the classifier that its environment may make through this port.
168                 UML Superstructure 2.0 Draft Adopted SpecificationA port has the ability to specify that any requests arriving at this port are handled by the behavior of the instance of the ow ning 
classifier, rather than being forwarded to any contained instances, if any.
Attributes
 isService: Boolean If true indicates that this port is used to provide the published functionality of a classifier; 
if false , this port is used to implement the classifier but is not part of the essential exter-
nally-visible functionality of the classifier and can, therefore, be altered or deleted along with the internal implementation of the classifier and other properties that are considered part of its implementation. The default value for this attribute is true.
 isBehavior: Boolean Specifies whether requests arriving at this port are sent to the classifier behavior of this 
classifier (see “BehavioredClassifier (from BasicBehaviors)” on page 383). Such ports are 
referred to as behavior port . Any invocation of a behavioral feature targeted at a behavior 
port will be handled by the instance of the owning classifier itself, rather than by any instances that this classifier may contain. The default value is false .
Associations
 required: Interface References the interfaces specifying the set of operations and receptions which the classi-
fier expects its environment to handle. This association is derived as the set of interfaces required by the type of the port or its supertypes.
 provided: Interface References the interfaces specifying the set of operations and receptions which the classi-
fier offers to its environment, and which it will handle either directly or by forwarding it to a part of its internal structure. This association is derived from the interfaces realized by the type of the port or by the type of the port, if the port was typed by an interface.
 redefinedPort: Port A port may be redefined when its containing classifier is specialized. The redefining port 
may have additional interfaces to those that are associated with the redefined port or it may replace an interface by one of its subtypes. (Subsets Element.redefinedElement .)
Constraints
[1]  A port cannot be created or destroyed except as part of the creation or destruction of the owning classifier.
[2] The required interfaces of a port must be provided by elements to which the port is connected. 
Semantics
A port represents an interaction point between a classifier instance and its environment or between a classifier instance and 
instances it may contain. A port by default has public visibility. However, a behavior port may be hidden but does not have to be.
The required interfaces characterize services that the owning classifier expects from its environment and that it may access through this interaction point: Instances of this classifier expects that the features owned by its required interfaces will be  
offered by one or more instances in its environment. The provided interfaces characterize the behavioral features that the owning classifier offers to its environment at this interaction point: The owning classifier must offer the features owned by t he 
provided interfaces.
The provided and required interfaces completely characterize any interaction that may occur between a classifier and its environment at a port. When an instance of a classifier is created, instances corresponding to each of its ports are created an d 
held in the slots specified by the ports, in accordancy with its multiplicity. These instances are referred to as “interaction points” and provide unique references. A link from that instance to the instance of the owning classifier is created through which communication is forwarded to the instance of the owning classifier or through which the owning classifier communicates with its environment. It is, therefore, possible for an instance to differentiate between requests for the 
UML Superstructure 2.0 Draft Adopted Specification        169invocation of a behavioral feature targeted at its different ports. Similarly, it is possible to direct such requests at a port , and the 
requests will be routed as specified by the links corresponding to connectors attached to this port. (In the following, “reques ts 
arriving at a port” shall mean “request occurrences arriving at the interaction point of this instance corresponding to this po rt”.)
The interaction point object must be an instance of a classifier that realizes the provided interfaces of the port. If the port  was 
typed by an interface, the classifier typing the interaction point object realizes that interface. If the port was typed by a c lass, 
the interaction point object will be an instance of that class. The latter case allows elaborate specification of the communication over a port. For example, it may describe that communication is filtered, modified in some way, or routed to other parts depending on its contents as specified by the classifier that types the port.  
If connectors are attached to both the port when used on a property within the internal structure of a classifier and the port on 
the container of an internal structure, the instance of the owning classifier will forward any requests arriving at this port a long 
the link specified by those connectors. If there is a connector attached to only one side of a port, any requests arriving at t his 
port will terminate at this port. 
For a behavior port, the instance of the owning classifier will handle requests arriving at this port (as specified in the beha vior 
of the classifier, see Chapter 13, “Common Behaviors”), if this classifier has any behavior. If there is no behavior defined fo r 
this classifier, any communication arriving at a behavior port is lost.
Semantic Variation Points
If several connectors are attached on one side of a port, then any request arriving at this port on a link derived from a conne ctor 
on the other side of the port will be forwarded on links corresponding to these connectors. It is a semantic variation point whether these request will be forwarded on all links, or on only one of those links. In the latter case, one possibility is tha t the 
link at which this request will be forwarded will be arbitrarily selected among those links leading to an instance that had bee n 
specified as being able to handle this request (i.e., this request is specified in a provided interface of the part correspondi ng to 
this instance).
Notation
A port of a classifier is shown as a small square symbol. The name of the port is placed near the square symbol. If the port symbol is placed overlapping the boundary of the rectangle symbol denoting that classifier this port is exposed (i.e., its visibility is public ). If the port is shown inside the rectangle symbol, then the port is hidden and its visibility is as specified (it 
is protected  by default).
A port of a classifier may also be shown as a small square symbol overlapping the boundary of the rectangle symbol denoting 
a part typed by that classifier (see Figure 110). The name of the port is shown near the port; the multiplicity follows the nam e 
surrounded by brackets. Name and multiplicity may be elided.
The type of a port may be shown following the port name, separated by colon (“:”). A provided interface may be shown using the “lollipop” notation (see “Interface (from Interfaces)” on page 114) attached to the port. A required interface may be shown by the “socket” notation attached to the port. The presentation options shown there are also applicable to interfaces of ports.  
Figure 110 shows the notation for ports: pis a port on the Engine class. The provided interface (also its type) of port p is 
powertrain . The multiplicity of pis “1”. In addition, a required interface, power , is shown also. The figure on the left shows 
170                 UML Superstructure 2.0 Draft Adopted Specificationthe provided interface using the “lollipop” notation, while the figure onj the right shows the interface as the type of the por t. 
A behavior port is indicated by a port being connected through a line to a small state symbol drawn inside the symbol 
representing the containing classifier. (The small state symbol indicates the behavior of the containing classifier.) Figure 11 1 
shows the behavior port p, as indicated by its connection to the state symbol representing the behavior of the Engine  class. Its 
provided interface is powertrain . In addition, a required interface, power , is shown also.
Presentation Option
The name of a port may be suppressed. Every depiction of an unnamed port denotes a different port from any other port.
If there are multiple interfaces associated with a port, these interfaces may be listed with the interface icon, separated by 
commas. Figure 112 below shows a port OnlineServices  on the OrderProcess  class with two provided interfaces, OrderEntry  
and Tracking , as well as a required interface Payment . Figure 110 - Port notation
Figure 111 - Behavior port notation
Figure 112 - Port notation showing multiple provided interfacesEngine
powerpowertrain
p [1]Engine
powerp: powertrain [1]
Engine
powerpowertrain
p
OrderProcessOrderEntry,
Tracking
PaymentOnline
Services
UML Superstructure 2.0 Draft Adopted Specification        171Examples
Figure 113 shows a class Engine with a port p with a provided interface powertrain . This interface specifies the services that 
the engine offers at this port (i.e., the operations and receptions that are accessible by communication arriving at this port) . The 
interface power  is the required interface of the engine. The required interface specifies the services that the engine expects its 
environment to provide. At port p, the Engine class is completely encapsulated; it can be specified without any knowledge of 
the environment the engine will be embedded in. As long as the environment obeys the constraints expressed by the provided and required interfaces of the engine, the engine will function properly. 
Two uses of the Engine  class are depicted: Both a boat and a car contain a part that is an engine. The Carclass connects port 
pof the engine to a set of wheels via the axle. The Boat class connects port p of the engine to a propeller via the shaft . As long 
as the interaction between the Engine  and the part linked to its port p obeys the constraints specified by the provided and 
required interfaces, the engine will function as specified, whether it is an engine of a car or an engine of a boat. (This exam ple 
also shows that connectors need not necessarily attach to parts via ports (as shown in the Car class.)
Rationale
The required and provided interfaces of a port specify everything that is necessary for interactions through that interaction 
point. If all interactions of a classifier with its environment are achieved through ports, then the internals of the classifie r are 
fully isolated from the environment. This allows such a classifier to be used in any context that satisfies the constraints specified by its ports.
Changes from UML 1.x
This metaclass has been added to UML.
9.3.12 Property (from InternalStructures, as specialized)
Description
A property represents a set of instances that are owned by a containing classifier instance.Figure 113 - Port examplesCar
rear : Wheel [2] e : EngineaxleEngine
p
p
Boat
: Propeller e : Engineshaft p<<interface>>
powertrain
<<interface>>
powerpowertrain
power
172                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
When an instance of the containing classifier is created, a set of instances corresponding to its properties may be created eit her 
immediately or at some later time (see “StructuredClassifier” on page 171). These instances are instances of the classifier typing the property. A property specifies that a set of instances may exist; this set of instances is a subset of the total set  of 
instances specified by the classifier typing the property. 
A part (see “StructuredClassifier” on page 171) declares that an instance of this classifier may contain a set of instances by composition. All such instances are destroyed when the containing classifier instance is destroyed. Figure 114 shows two possible views of the Car class. In subfigure (i), Car is shown as having a composition associations with role name rear to a 
class Wheel  and an association with role name e to a class Engine . In subfigure (ii), the same is specified. However, in 
addition, in subfigure (ii) it is specified that rear and ebelong to the internal structure of the class Car. This allows 
specification of detail that holds only for instances of the Wheel and Engine classes within the context of the class Car, but 
which will not hold for wheels and engines in general. For example, subfigure (i) specifies that any instance of class Engine  
can be linked to an arbitrary number of instances of class Wheel . Subfigure (ii), however, specifies that within the context of 
class Car, the instance playing the role of e may only be connected to two instances playing the role of rear. In addition, the 
instances playing the e and rear roles may only be linked if they are roles of the same instance of class Car.
In other words, subfigure (ii) asserts additional constraints on the instances of the classes Wheel and Engine , when they are 
playing the respective roles within an instance of class Car. These constraints are not true for instances of Wheel  and Engine  in 
general. Other wheels and engines may be arbitrarily linked as specified in subfigure (i).
Notation
A part is shown by graphical nesting of a box symbol with a solid outline representing the part within the symbol representing Figure 114 - PropertiesCar
rear : Wheel [2] e : Enginea: AxleCar
Wheel Enginerear 2 e 1
Axle
(i)(ii)* *2 1
UML Superstructure 2.0 Draft Adopted Specification        173the containing classifier in a separate compartment. A property specifying an instance that is not owned by composition by the 
instance of the containing classifier is shown by graphical nesting of a box symbol with a dashed outline.
The contained box symbol has only a name compartment, which contains a string according to the syntax defined in Chapter 1, “Classes”. Detail may be shown within the box symbol indicating specific values for properties of the type classifier when instances corresponding to the property symbol are created.
Presentation Options
The multiplicity for a property may also be shown as a multiplicity mark in the top right corner of the part box.
A property symbol may be shown containing just a single name (without the colon) in its name string. This implies the 
definition of an anonymously named class nested within the namespace of the containing class. The part has this anonymous 
class as its type. Every occurrence of an anonymous class is different from any other occurrence. The anonymously defined class has the properties specified with the part symbol. It is allowed to show compartments defining attributes and operations of the anonymously named class.
Examples
Figure 115 shows examples of properties. On the left, the property denotes that the containing instance will own four instances  
of the Wheel  class by composition. The multiplicity is shown using the presentation option discussed above. The property on 
the right denotes that the containing instance will reference one or two instances of the Engine  class. For additional examples, 
see “StructuredClassifier” on page 171.
Changes from UML 1.x
A connectable element used in a collaboration subsumes the concept of ClassifierRole.
9.3.13 StructuredClassifier (from InternalStructures)
Description
A structured classifier is an abstract metaclass that represents any classifier whose behavior can be fully or partly described  by 
the collaboration of owned or referenced instances. 
Attributes
No additional attributes.
Associations
 role: ConnectableElement References the roles that instances may play in this classifier. (Abstract union; subsets 
Classifier.feature .)
 ownedAttribute: Property References the properties owned by the classifier. (Subsets StructuredClassifier.role, Clas-
sifier.attribute, and Namespace.ownedMember )Figure 115 - Property examplesw: Wheel4
e: Engine [1..2]
174                 UML Superstructure 2.0 Draft Adopted Specification part: Property References the properties specifying instances that the classifier owns by composition. 
This association is derived, selecting those owned properties where isComposite is true.
 ownedConnector: Connector References the connectors owned by the classifier. (Subsets Classifier.feature  and 
Namespace.ownedMember )
Constraints
[1]  The multiplicities on connected elements must be consistent.
Semantics
The multiplicities on the structural features and connector ends indicate the number of instances (objects and links) that may 
be created within an instance of the containing classifier, either when the instance of the containing classifier is created, o r at a 
later time. The lower bound of the multiplicity range indicates the number of instances that are created (unless indicated differently by an associated instance specification or an invoked constructor function); the upper bound of the multiplicity range indicates the maximum number of instances that may be created. The slots corresponding to the structural features are initialized with these instances.
For each instance playing a role in an internal structure, there will initially be as many links as indicated by the multiplici ty of 
the opposite ends of connectors attached to that role (see “ConnectorEnd” on page 165 for the semantics where no multiplicities are given for an end). If the multiplicities of the ends match the multiplicities of the roles they are attached  to 
(see Figure 116 i), the initial configuration that will be created when an instance of the containing classifier is created con sists 
of the set of instances corresponding to the roles (as specified by the multiplicities on the roles) fully connected by links ( see 
the resultant instance, Figure 116 ii).
Multiplicities on connector ends serve to restrict the number of initial links created. Links will be created for each instance  
playing the connected roles according to their ordering until the minimum connector end multiplicity is reached for both ends of the connector (see the resultant instance, Figure 117 ii). In this example, only two links are created, resulting in an arra y Figure 116 - “Star” connector pattern/ a: / b:
/ a: / b:a: b:2 2
2 2(i)
(ii)
UML Superstructure 2.0 Draft Adopted Specification        175pattern.
The manner of creation of the containing classifier may override the default instantiation. When an instance specification is 
used to specify the initial instance to be created for a classifiers (see “Class” on page 156), the multiplicities of its parts determine the number of initial instances that will be created within that classifier. Initially, there will be as many instanc es 
held in slots as indicated by the corresponding multiplicity. Multiplicity ranges on such instance specifications may not contain upper bounds.
All instances corresponding to parts of a structured classifier are destroyed recursively, when an instance of that structured classifier is deleted. The instance is removed from the extent of its classifier, and is itself destroyed.
Notation
The namestring of a role in an instance specification obeys the following syntax:
{{ {[ name [‘/’ rolename]] | ‘/’ rolename} ‘:’ classifiername [{‘,’ classifiername}*]} | { name [‘/’ rolename] | ‘/’ rolename}}
The name of the instance specification may be followed by the name of the part which the instance plays. The name of the part may only be present if the instance plays a role.
Examples
The following example shows two classes, Car and Wheel . The Car class has four parts, all of type Wheel , representing the 
four wheels of the car. The front wheels and the rear wheels are linked via a connector representing the front and rear axle, respectively. An implicit association is defined as the type of each axle with each end typed by the Wheel  class. Figure 118 
specifies that whenever an instance of the Car class is created, four instances of the Wheel  class are created and held by 
composition within the car instance. In addition, one link each is created between the front wheel instances and the rear wheel  Figure 117  - “Array” connector pattern/ a: / b:
/ a: / b:a: b:2 2
11
(ii)(i)
176                 UML Superstructure 2.0 Draft Adopted Specificationinstances.
Figure 119 specifies an equivalent system, but relies on multiplicities to show the replication of the wheel and axle 
arrangement: This diagram specifies that there will be two instances of the left wheel and two instances of the right wheel, with each matching instance connected by a link deriving from the connector representing the axle. As specified by the multiplicities, no additional instances of the Wheel  class can be added as left or right parts for a Car instance.
Figure 120 shows an instance of the Car class (as specified in Figure 118). It describes the internal structure of the Car that it 
creates and how the four contained instances of Wheel  will be initialized. In this case, every instance of Wheel  will have the 
predefined size and use the brand of tire as specified. The left wheel instances are given names, and all wheel instances are Figure 118 - Connectors and parts in a structure diagram
Figure 119 - Connectors and parts in a structure diagram using multiplicitiesCar
leftFront :
WheelrightFront :
Wheelfrontaxletire: Stringsize: StringWheel
leftRear :
WheelrightRear :
Wheelrearaxle
tire: String
size: StringWheel Car
left:   Wheel [2] right: Wheel [2]axle
1
UML Superstructure 2.0 Draft Adopted Specification        177shown as playing the respective roles. The types of the wheel instances have been suppressed.
Finally, Figure 121 shows a constructor for the Car class (see “Class” on page 156). This constructor takes a parameter brand  
of type String . It describes the internal structure of the Car that it creates and how the four contained instances of Wheel  will be 
initialized. In this case, every instance of Wheel  will have the predefined size and use the brand of tire passed as parameter. 
The left wheel instances are given names, and all wheel instances are shown as playing the parts. The types of the wheel instances have been suppressed.
9.3.14 Trigger (from InvocationActions, as specialized)
Description
A trigger specification may be qualified by the port on which the event occurred.
Associations
 port: Port [*] Specifies the ports at which a communication that caused an event may have arrived.Figure 120 - A instance of the Car class
Figure 121 - A constructor for the Car class: Car
tire = "Michelin"
size = "215x95"l1 / leftfrontfrontaxletire: String
size: StringWheel
rearaxletire = "Michelin"
size = "215x95"/ rightfront
tire = "Firestone"
size = "215x95"l2 / leftrear
tire = "Firestone"
size = "215x95"/ rightrearCar
: Car
tire = brand
size = "215x95"l1 / leftfrontfrontaxle
rearaxletire = brandsize = "215x95"/ rightfront
tire = brand
size = "215x95"l2 / leftrear
tire = brandsize = "215x95"/ rightrearCar
make(brand:String)«create»
178                 UML Superstructure 2.0 Draft Adopted SpecificationSemantics
Specifying one or more ports for an event implies that the event triggers the execution of an associated behavior only if the 
event was received via one of the specified ports.
Notation
The ports of a trigger are specified following a trigger signature by a list of port names separated by comma, preceded by the keyword «from»:
«from» { port \ ‘,’}+
9.3.15 Variable (from StructuredActivities, as specialized)
Description
A variable is considered a connectable element.
Semantics
Extends variable to specialize connectable element.
9.4 Diagrams
Composite structure diagram
A composite structure diagram depicts the internal structure of a classifier, , as well as the use of a collaboration in a 
collaboration occurrence.
Graphical nodes
Additional graphical nodes that can be included in composite structure diagrams are shown in Table 6.
Table 6 - Graphic nodes included in composite structure diagrams
NODE TYPE NOTATION REFERENCE
Part See “Property” on page 167.
Port See “Ports” on page 167. A port may appear either 
on a contained part representing a port on that part, or on the boundary of the class diagram, represent-ing a port on the represented classifier itself. The optional ClassifierName  is only used for Complex-
Ports.partName :
ClassName
portName:
ClassifierName
UML Superstructure 2.0 Draft Adopted Specification        179Graphical paths
Additional graphical paths that can be included in composite structure diagrams are shown in Table 7.
Structure diagram
All graphical nodes and paths shown on composite structure diagrams can also be shown on other structure diagrams.Collaboration See “Collaboration” on page 157.
Collaboration 
OccurrenceSee “CollaborationOccurrence” on page 160.
Table 7 - Graphic nodes included in composite structure diagrams
PATH TYPE NOTATION REFERENCE
Connector See “Connector” on page 163.
Role binding See “CollaborationOccurrence” on page 160.Table 6 - Graphic nodes included in composite structure diagrams
NODE TYPE NOTATION REFERENCE
CollaborationName
occurrenceName :
CollaborationName
180                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        18110 Deployments
10.1 Overview
The Deployments package specifies a set of constructs that can be used to define the execution architecture of systems that 
represent the assignment of software artifacts to nodes. Nodes are connected through communication paths to create network systems of arbitrary complexity. Nodes are typically defined in a nested manner, and represent either hardware devices or software execution environments. Artifacts represent concrete elements in the physical world that are the result of a development process.
The Deployment package supports a streamlined model of deployment that is deemed sufficient for the majority of 
modern applications. Where more elaborate deployment models are required, it can be extended through profiles or meta 
models to model specific hardware and software environments.
Artifacts
The Artifacts package defines the basic Artifact construct as a special kind of Classifier.
Nodes
The Nodes package defines the concept of Node, as well as the basic deployment relationship between Artifacts and Nodes.
Component Deployments
The ComponentDeployments package extends the basic deployment model with capabilities to support deployment 
mechanisms found in several common component technologies.
10.2 Abstract syntax
Figure 123 shows the dependencies of the Deployments packages.
182                 UML Superstructure 2.0 Draft Adopted SpecificationPackage ArtifactsFigure 123 - Dependencies between packages described in this chapter
Figure 124 - The elements defined in the Artifacts packageNodesArtifactsDependencies
(f rom Classes)
StructuredClasses
(from CompositeStructures)
ComponentDeploymentsBasicComponents
(from Components)
<<merge>>Kernel
(from Classes)
<<me rge >> <<merge>> <<merge>>
Abstraction
(f ro m  Dependencies)Classifier
(from  Kernel)
PackageableElem ent
(from  Kernel)Manisfes tation
1 *+utilizedElement
1
{ subsets suppli er,
subs ets target}*
Operation
(from Kernel)Property
(from  K erne l)Artifact
fileName : String*+nes tedAr tifact
*{redefines nes tedClass ifi er}
*1+mani fes tation
*{subsets  ownedElement,
subs ets  clientDependency}
1
*0..1
+ow nedOperation*{ordered, subs ets  feature, 
sub set s own edMember}0..1{subs ets redefinitionContext, 
subs ets  names pace, 
subs ets  featuringClas s ifier}
*0..1
+ow nedPr operty *0..1 {s ubs ets namespace,
subsets  featur i ngClass i fier,
sub set s  cl ass i fi er}
UML Superstructure 2.0 Draft Adopted Specification        183Package Nodes
Figure 125 - The definition of the Node concept
Figure 126 - The definition of the Deployment relationship 
    between DeploymentTargets and DeployedArtifacts.Cl ass
(from StructuredClass...
De v ice ExecutionEnv ironmentNode
*+nestedNode
*{redef ines nestedClassif ier}
CommunicationPath
{ All ends of  a C ommunic ationPath
 are ty ped by  Nodes }Association
(from Kernel)
Dependency
(from  Dependencies)Named Ele ment
(from  Dependencies)
No deNa me d E l e me n t
(f rom  D ependenci es)
De plo yed Artifact Deployment
**+deployedArtifact
*{sub sets su pp l i e r,
subsets  target}
*PackageableElem ent Deploym entTarget
*1+deployment
*{s ubs ets  ownedElement,
subset s  cl ientDepen denc y}
+location
1 {su bse ts so urce,
su bse ts cl i e nt} **+/depl oyedElement
**
Property InstanceSpecification Artifact
184                 UML Superstructure 2.0 Draft Adopted SpecificationPackage ComponentDeployments
10.3 Class Descriptions
10.3.1 Artifact
An artifact is the specification of a physical piece of information that is used or produced by a software development process,  
or by deployment and operation of a system. Examples of artifacts include model files, source files, scripts, and binary executable files, a table in a database system, a development deliverable, or a word-processing document, a mail message.
Description
Artifacts
In the metamodel, an Artifact is a Classifier that represents a physical entity. Artifacts may have Properties that represent features of the Artifact, and Operations that can be performed on its instances. Artifacts can be involved in Associations to other Artifacts, e.g. composition associations. Artifacts can be instantiated to represent detailed copy semantics, where different instances of the same Artifact may be deployed to various Node instances (and each may have separate property values, e.g. for a ‘time-stamp’ property.
Node
As part of the Nodes package, an Artifact is extended to become the source of a deployment to a Node. This is achieved by specializing the abstract superclass DeployedArtifact defined in the Nodes package.
Attributes
Artifacts
 filename : String [0..1] A concrete name that is used to refer to the Artifact in a physical context. Example: file 
system name, universal resource locator.Figure 127 - The metaclasses that define component DeploymentArtifact
(from Artifacts)Deployment
(from Nodes)
DeploymentSpecification
deploymentLocation : String
executionLocation : StringDeployment
* 0..1+configuration
*{s ubs ets  ownedMember}0..1
{ the deployment target of a 
DeploymentSpecification is  of type ExecutionEnvironment }
{ the utilized elements  of a 
DeploymentSpecification are of type 
Component }
UML Superstructure 2.0 Draft Adopted Specification        185Associations
Artifacts
 nestedArtifact: Artifact [*] The Artifacts that are defined (nested) within the Artifact.
The association is a specialization of the nestedClassifier association from Class to Classi-
fier.
 ownedProperty : Property [*] The attributes or association ends defined for the Artifact.
The association is a specialization of the ownedMember association.
 ownedOperation : Operation [*]The Operations defined for the Artifact.
The association is a specialization of the ownedMember association.
 manifestation : Manifestation [*] The set of model elements that are manifested in the Artifact. That is, these model ele-
ments are utilized in the construction (or generation) or the artifact.This association is a specialization of the clientDependency association.
Constraints
No additional constraints.
Semantics
An Artifact defined by the user represents a concrete element in the physical world. A particular instance (or ‘copy’) of an artifact is deployed to a node instance. Artifacts may have composition associations to other artifacts that are nested within it. 
For instance, a deployment descriptor artifact for a component may be contained within the artifact that implements that component. In that way, the component and its descriptor are deployed to a node instance as one artifact instance.
Specific profiles are expected to stereotype artifact to model sets of files (e.g. as characterized by a ‘file extension’ on a file 
system). The UML Standard Profile defines several standard stereotypes that apply to Artifacts, e.g. «source», or «executable» (See the Appendix). These stereotypes can be further specialized into implementation and platform specific stereotypes in profiles. For example, an EJB profile might define «jar» as a subclass of «executable» for executable Java archives.
Notation
An artifact is presented using an ordinary class rectangle with the key-word «artifact». Alternatively, it may be depicted by a  
icon. 
Optionally, the underlining of the name of an artifact instance may be omitted, as the context is assumed to be known to users.
Figure 128 - An Artifact instanceOrder.jar«artifact»
186                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from previous UML
The following changes from UML 1.x have been made: Artifacts can now manifest any PackageableElement (not just 
Components, as in UML 1.x). In UML 1.x, 
10.3.2 CommunicationPath
A communication path is an association between two Nodes, through which Nodes are able to exchange signals and messages.
Description
In the metamodel, CommunicationPath is a subclass of Association.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
 The association ends of a CommunicationPath are typed by Nodes.
Semantics
A communication path is an association that can only be defined between nodes, to model the exchange of signals and messages between them.
Notation
No additional notation.Figure 129 - A visual representation of the manifestation relationship 
                       between artifacts and components.Order«component»
Order.jar«artifact»«manifest»
UML Superstructure 2.0 Draft Adopted Specification        187Changes from previous UML
The following changes from UML 1.x have been made: CommunicationPath was implicit in UML 1.x. It has been made 
explicit to formalize the modeling of networks of complex Nodes.
10.3.3 DeployedArtifact
A deployed artifact is an artifact or artifact instance that has been deployed to a deployment target.
Description
In the metamodel, DeployedArtifact is an abstract metaclass that is a specialization of NamedElement. A DeployedArtifact is involved in one or more Deployments to a DeploymentTarget.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
Deployed artifacts are deployed to a deployment target.
Notation
No additional notation.
Changes from previous UML
The following changes from UML 1.x have been made: the capability to deploy artifacts and artifact instances to nodes has been made explicit based on UML 2.0 instance modeling through the addition of this abstract metaclass.
10.3.4 Deployment
Nodes
A deployment is the allocation of an artifact or artifact instance to a deployment target.
ComponentDeployments
A component deployment is the deployment of one or more executable artifacts or artifact instances to a deployment target, optionally parameterized by a deployment specification.
Description
In the metamodel, Deployment is a subtype of Dependency.
188                 UML Superstructure 2.0 Draft Adopted SpecificationAttribute
No additional attributes.
Associations
Nodes
 deployedArtifact : Artifact [*] The Artifacts that are deployed onto a Node.
This association specializes the supplier association.
 location : Node [1] The Node which is the target of a Deployment.
This association specializes the client association.
ComponentDeployments
 configuration : deploymentSpecification [*]
The specification of properties that parameterize the deployment and execution of one or more Artifacts.This association is specialized from the ownedMember association.
Constraints
No additional constraints.
Semantics
The deployment relationship between a DeployedArtifact and a DeploymentTarget can be defined at the “type” level and at the “instance level”. For example, a ‘type level’ deployment relationship can be defined between an “application server” Node and a “order entry request handler” executable Artifact. At the ‘instance level’, 3 specific instances “app-server1” ... “app-server3” may be the deployment target for six “request handler*” instances. Finally, for modeling complex deployment target models consisting of nodes with an composite structure defined through ‘parts’, a Property (that functions as a part) may also be the target of a deployment.
Notation
Deployment diagrams show the allocation of Artifacts to Nodes according to the Deployments defined between them.
Figure 130 - A visual representation of the deployment location 
                       of artifacts (including a dependency between the artifacts).:AppServer1
ShoppinCart.jar«artifact»
Order.jar«artifact»
UML Superstructure 2.0 Draft Adopted Specification        189Changes from previous UML
The following changes from UML 1.x have been made: An association to DeploymentSpecification has been added.
10.3.5 DeploymentTarget
A deployment target is the location for a deployed artifact.
Description
In the metamodel, DeploymentTarget is an abstract metaclass that is a specialization of NamedElement. A DeploymentTarget 
owns a set of Deployments.
Attributes
No additional attributes.
Associations
Nodes
 deployment : Deployment [*] The set of Deployments for a DeploymentTarget.
This association specializes the clientDependency association.
 / deployedElement : PackageableElement [*]
The set of elements that are manifested in an Artifact that is involved in Deployment to a DeploymentTarget.The association is a derived association (OCL for informal derivation above to be pro-vided).
Constraints
No additional constraints.
Semantics
Artifacts are deployed to a deployment target. The deployment target owns the a set of deployments that target it.Figure 131 - A textual list based representation of the deployment location of artifacts.:AppServer1
Order.jar
ShoppingCart.jar
Account.jarProduct.jar
BackOrder.jarService.jar
190                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
No additional notation.
Changes from previous UML
The following changes from UML 1.x have been made: the capability to deploy artifacts and artifact instances to nodes has 
been made explicit based on UML 2.0 instance modeling.
10.3.6 DeploymentSpecification
A deployment specification specifies a set of properties which determine execution parameters of a component artifact that is deployed on a node. A deployment specification can be aimed at a specific type of container. An artifact that reifies or implements deployment specification properties is a deployment descriptor.
Description
In the metamodel, a DeploymentSpecification is a subtype of Artifact. It defines a set of deployment properties that are specific to a certain Container type. An instance of a DeploymentSpecification with specific values for these properties may be  
contained in a complex Artifact.
Attributes
ComponentDeployments
 deploymentLocation : String The location where an Artifact is deployed onto a Node. This is typically a 'directory' or 
'memory address'.
 executionLocation : String The location where a component Artifact executes. This may be a local or remote location.
Associations
ComponentDeployments
 deployment : Deployment [0..1]The deployment with which the DeploymentSpecification is associated.
Constraints
[1]  The DeploymentTarget of a DeploymentSpecification is a kind of ExecutionEnvironment.
[2] The deployedElements of a DeploymentTarget that are involved in a Deployment that has an associated Deployment-
Specification is a kind of Component (i.e. the configured components).
Semantics
A Deployment specification is a general mechanism to parameterize a Deployment relationship, as is common in various hardware and software technologies. The deployment specification element is expected to be extended in specific component profiles. Non-normative examples of standard tagged values that a profile might add to deployment specification are e.g. «concurrencyMode» with tagged values {thread, process, none}, or «transactionMode» with tagged values {transaction, nestedTransaction, none}.
Notation
A DeploymentSpecification is graphically displayed as a classifier rectangle that is attached to a component artifact that is deployed on a container using a regular dependency notation is used. If the deployment relationship is made explicit (as in Figure 132), the Dependency may be attached to that relationship.
UML Superstructure 2.0 Draft Adopted Specification        191Changes from previous UML
The following changes from UML 1.x have been made: DeploymentSpecification does not exist in UML 1.x.
10.3.7 Device
A Device is a physical computational resource with processing capability upon which artifacts may be deployed for execution. Figure 132 - A DeploymentSpecification for an artifact (specification and instance levels)
Figure 133 - DeploymentSpecifications related to the artifacts that they parameterize
Figure 134 - A DeploymentSpecification for an artifactName«deployment spec»
execution: execKind
transaction  :  BooleanName«deployment spec»
execution: thread
transaction  : true
:AppServer1
ShoppinCart.jar«artifact»
Order.jar«artifact»ShoppingApp.ear«artifact»
Orderdesc.xml«deployment spec»
ShoppingAppdesc.xml«deployment spec»
:AppServer
Order.jar«artifact»
192                 UML Superstructure 2.0 Draft Adopted SpecificationDevices may be complex, i.e. they may consist of other devices.
Description
In the metamodel, a Device is a subclass of Node.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
A device may be a nested element, where a physical machine is decomposed into its elements, either through namespace 
ownership or through attributes that are typed by Devices.
Notation
A Device is notated by a Node annotated with the stereotype «device».
Figure 135 - Notation for a Device
Changes from previous UML
The following changes from UML 1.x have been made: Device is not defined in UML 1.x.
10.3.8 ExecutionEnvironment
A ExecutionEnvironment is a node that offers an execution environment for specific types of components that are deployed on «device»
:AppServer
 
:J2EEServer
Order.jar
ShoppingCart.jar
Account.jar
Product.jar
BackOrder.jar
Service.jar:DBServer
OrderSchema.ddl
ItemSchema.ddl«container»«device»
:DBServer
UML Superstructure 2.0 Draft Adopted Specification        193it in the form of executable artifacts.
Description
In the metamodel, a ExecutionEnvironment is a subclass of Node. It is usually part of a general Node, representing the 
physical hardware environment on which the ExecutionEnvironment resides. In that environment, the ExecutionEnvironment implements a standard set of services that Components require at execution time (at the modeling level these services are usually implicit). For each component Deployment, aspects of these services may be determined by properties in a DeploymentSpecification for a particular kind of ExecutionEnvironment.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
ExecutionEnvironment instances are assigned to node instances by using composite associations between nodes and ExecutionEnvironments, where the ExecutionEnvironment plays the role of the part. ExecutionEnvironments can be nested, e.g. a database ExecutionEnvironment may be nested in an operating system ExecutionEnvironment. Components of the appropriate type are then deployed to specific ExecutionEnvironment nodes.
Typical examples of standard ExecutionEnvironments that specific profiles might define stereotypes for are «OS», «workflow 
engine », «database system »and « J2EE container .
An ExecutionEnvironment can optionally have an explicit interface of system level services that can be called by the deployed elements, in those cases where the modeler wants to make the ExecutionEnvironment software execution environment services explicit.
Notation
A ExecutionEnvironment is notated by a Node annotated with the stereotype «ExecutionEnvironment».
Figure 136 - Notation for a ExecutionEnvironment (example of an 
                       instance of a J2EEServer ExecutionEnvironment) 
:J2EEServer
Order.jar
ShoppingCart.jar
Account.jar
Product.jar
BackOrder.jar
Service.jar«container»
194                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from previous UML
The following changes from UML 1.x have been made: ExecutionEnvironment is not defined in UML 1.x.
10.3.9 InstanceSpecification (from Kernel, as specialized)
An instance specification is extended with the capability of being a deployment target in a deployment relationship, in the cas e 
that it is an instance of a node. It is also extended with the capability of being a deployed artifact, if it is an instance of  an 
artifact.
Description
In the metamodel, InstanceSpecification is a specialization of DeploymentTarget and DeployedArtifact.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
[1]  An InstanceSpecification can be a DeploymentTarget if it is the instance specification of a Node and functions as a part i n 
the internal structure of an encompassing Node.
[2] An InstanceSpecification can be a DeployedArtifact if it is the instance specification of an Artifact.
Semantics
No additional semantics.
Notation
An instance can be attached to a node using a deployment dependency, or it may be visually nested inside the node.
Changes from previous UML
The following changes from UML 1.x have been made: the capability to deploy artifact instances to node instances existed in 
UML 1.x, and has been made explicit based on UML 2.0 instance modeling.
10.3.10 Manifestation
A manifestation is the concrete physical of one or more model elements by an artifact.
Description
In the metamodel, a Manifestation is a subtype of Abstraction. A Manifestation is owned by an Artifact.
Attributes
No additional attributes.
UML Superstructure 2.0 Draft Adopted Specification        195Associations
Artifacts
 utilizedElement : PackageableElement [1]
The model element that is utilized in the manifestation in an Artifact.This association specializes the supplier association.
Constraints
No additional associations.
Semantics
An artifact embodies or manifests a number of model elements. The artifact owns the manifestations, each representing the utilization of a packageable element.
Specific profiles are expected to stereotype the manifestation relationship to indicate particular forms of manifestation, e.g.  
<<tool generated>> and <<custom code>> might be two manifestations for different classes embodied in an artifact.
Notation
A manifestation is notated in the same way as an abstraction dependency, i.e. as a general dashed line with an open arrow-head labeled with the keyword <<manifest>>.
Changes from previous UML
The following changes from UML 1.x have been made: Manifestation is defined as a meta association in UML 1.x, prohibiting stereotyping of manifestations. In UML 1.x, the concept of Manifestation was referred to as ‘implementation’ and annotated in the notation as <<implement>>. Since this was one of the many uses of the word ‘implementation’ this has been replaced by <<manifest>>.
10.3.11 Node
A node is computational resource upon which artifacts may be deployed for execution.
Nodes can be interconnected through communication paths to define network structures.
Description
In the metamodel, a Node is a subclass of Class. It is associated with a Deployment of an Artifact. It is also associated with a 
set of Elements that are deployed on it. This is a derived association in that these PackageableElements are involved in a Manifestation of an Artifact that is deployed on the Node. Nodes may have an internal structure defined in terms of parts and connectors associated with them for advanced modeling applications.
Attributes
No additional attributes.
Associations
Nodes
 nestedNode : Node [*] The Nodes that are defined (nested) within the Node.
The association is a specialization of the ownedMember association from Namespace to 
NamedElement.
196                 UML Superstructure 2.0 Draft Adopted SpecificationConstraints
[1]  The internal structure of a Node (if defined) consists solely of parts of type Node.
Semantics
Nodes can be connected to represent a network topology by using communication paths. Communication paths can be defined 
between nodes such as “application server” and “client workstation” to define the possible communication paths between nodes. Specific network topologies can then be defined through links between node instances.
Hierarchical nodes (i.e. nodes within nodes) can be modeled using composition associations, or by defining an internal structure for advanced modeling applications.
Non-normative examples of nodes are «application server», «client workstation», «mobile device», «embedded device».
Notation
A node is shown as a figure that looks like a 3-dimensional view of a cube.
Dashed arrows with the keyword «deploy» show the capability of a node type to support a component type. Alternatively, this may be shown by nesting component symbols inside the node symbol.
Nodes may be connected by associations to other nodes. A link between node instances indicates a communication path between the nodes.Figure 137 - An instance of a Node
Figure 138 - A communication path between two Node types, with deployed Artifacts:AppServer
AppServer DBServer
*1
RequestHandler.jarOrder.jar«deploy»«deploy»
UML Superstructure 2.0 Draft Adopted Specification        197Artifacts may be contained within node instance symbols. This indicates that the items are deployed on the node instances.
Examples
Changes from previous UML
The following changes from UML 1.x have been made: to be written.
10.3.12 Property (from InternalStructures, as specialized)
A Property is extended with the capability of being a DeploymentTarget in a Deployment relationship. This enables modeling 
the deployment to hierarchical Nodes that have Properties functioning as internal parts.
Description
In the metamodel, Property is a specialization of DeploymentTarget.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
[1]  A Property can be a DeploymentTarget if it is a kind of Node and functions as a part in the internal structure of an encom -
passing Node.
Semantics
No additional semantics.
Notation
No additional notation.
Changes from previous UML
The following changes from UML 1.x have been made: the capability to deploy to Nodes with an internal structure has been added to UML 2.0.Figure 139 - A set of deployed component artifacts on a Node:AppServer1
ShoppinCart.jar«artifact»
Order.j ar«artifact»
198                 UML Superstructure 2.0 Draft Adopted Specification10.4 Diagrams
Deployment diagram
Graphical nodes
The graphic nodes that can be included in deployment diagrams are shown in Table 8.
Table 8 - Graphic nodes included in deployment diagrams
NODE TYPE NOTATION REFERENCE
Artifact See “Artifact”
Node See “Node”. Has keyword options «device» and 
«execution environment».
Artifact deployed on Node See “Deployment”
Node with deployed Artifacts See “Deployment”
Node with deployed Artifacts See “Deployment” (alternative, textual notation)
Deployment specification See “Deployment Specification”.ArtifactNam e«artifact»
NodeName
ArtifactName«artifact»
Node
ArtifactName«artifact»
 
NodeName
artifact1
artifact2
artifact3«execution env»
Name«deployment spec»
UML Superstructure 2.0 Draft Adopted Specification        19910.5 Graphical paths
The graphic paths that can be included in deployment diagrams are shown in Table 9.Deployment specification - with 
propertiesSee “Deployment Specification”.
Deployment specification - with 
property valuesSee “Deployment Specification”.
Artifact with annotated deploy-
ment propertiesSee “Artifact”.
Table 9 - Graphic nodes included in deployment diagrams
PATH TYPE NOTATION REFERENCE
Association See “Association” on page 10-50. Used to model communication paths 
between Nodes.
Dependency See “Dependency” on page 26-201. Used to model general dependencies. In 
Deployment diagrams, this notation is used to depict the following metamodel associations: (i) the relationship between an Artifact and the model element(s) that it implements, and (ii) the deployment of an Artifact (instance) on a Node (instance).
Generalization See “Generalization” on page 6-30.
Deployment The Deployment relationshipTable 8 - Graphic nodes included in deployment diagrams
NODE TYPE NOTATION REFERENCE
Name«deployment spec»
execution: execKind
transaction  :  Boolean
Name«deployment spec»
execution: thread
transaction  : true
ArtifactName«artifact»
{execution=thread,
  transaction =true}
«deploy»
200                 UML Superstructure 2.0 Draft Adopted SpecificationManifestation The Manifestation relationshipTable 9 - Graphic nodes included in deployment diagrams
PATH TYPE NOTATION REFERENCE
«manifest»
UML Infrastructure 2.0 Draft Adopted Specification        201Part II - Behavior
This part specifies the dynamic, behavioral constructs (e.g., activities, interactions, state machines) used in various 
behavioral diagrams, such as activity diagrams, sequence diagrams, and state machine diagrams.. The UML packages that 
support behavioral modeling, along with the structure packages they depend upon (CompositeStructures and Classes) are shown in Figure 140.
The function and contents of these packages are described in following chapters, which are organized by major subject 
areas.Figure 140 - UML packages that support behavioral modelingInteractions UseCases Sta teMachi ne sActiv itiesCo mmon Behav iorsClasses
Actions
202                 UML Infrastructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        20311 Actions
11.1 Overview
Basic Concepts
The abstract concept of an action is found in the Activities chapter. This chapter covers its specific actions.
An action is the fundamental unit of behavior specification. An action takes a set of inputs and converts them into a set of 
outputs, though either or both sets may be empty. In addition, some actions modify the state of the system in which the action executes. The values that are the inputs to an action may be obtained from the results of other actions using the activity flow  
model, or they may be described by value specifications. The outputs of the action may be provided as inputs to other actions using the activity flow model.
Actions are contained in activities, which provide their context. Activities provide control and data sequencing constraints among actions as well as nested structuring mechanisms for control and scope. See the Activities chapter for details. The Actions chapter is concerned with the semantics of individual, primitive actions.
Intermediate Concepts
The intermediate level describes the various action primitives that may be executed within UML activity models. These primitive actions are defined in such a way as to enable the maximum range of mappings. Specifically, primitive actions are defined so that they either carry out a computation or access object memory, and never both. This approach enables clean mappings to a physical model, even those with data organizations different from that suggested by the specification. In addition, any re-organization of the data structure will leave the specification of the computation unaffected.
A surface action language would encompass both primitive actions and the control mechanisms provided by activities. In addition, a surface language may map higher-level constructs to the actions. For example, in a composition association where the deletion of an instance implies the deletion of all its components, the specification defines the delete action to remove o nly 
the single instance, and the specification requires further deletions for each of the component instances. A surface language could choose to define a delete-composition operation as a single unit as a shorthand for several deletions that cascade across  
other associations.
A particular surface language could implement each semantic construct one-to-one, or it could define higher-level, composite constructs to offer the modeler both power and convenience. This specification, then, expresses the fundamental semantics in terms of primitive behavioral concepts that are conceptually simple to implement. Modelers can work in terms of higher-level constructs as provided by their chosen surface language or notation.
The semantic primitives are defined to enable the construction of different execution engines, each of which may have different performance characteristics. A model compiler builder can optimize the structure of the software to meet specific performance requirements, so long as the semantic behavior of the specification and the implementation remain the same. For example, one engine might be fully sequential within a single task, while another may separate the classes into different processors based on potential overlapping of processing, and yet others may separate the classes in a client-server, or even a three-tier model
The modeler can provide “hints” to the execution engine when the modeler has special knowledge of the domain solution that could be of value in optimizing the execution engine. For example, instances could—by design—be partitioned to match the distribution selected, so tests based on this partitioning can be optimized on each processor. The execution engines are not required to check or enforce such hints. An execution engine can either assume that the modeler is correct, or just ignore it. An 
execution engine is not required to verify that the modeler’s assertion is true.
When an action violates aspects of static UML modeling that constrain runtime behavior, the semantics is left undefined. For example, attempting to create an instance of an abstract class is undefined: some languages may make this action illegal, 
204                 UML Superstructure 2.0 Draft Adopted Specificationothers may create a partial instance for testing purposes. The semantics are also left undefined in situations that require cla sses 
as values at runtime. However, in the execution of actions the lower multiplicity bound ignored and no error or undefined semantics is implied. (Otherwise it is impossible to use actions to pass through the intermediate configurations necessary to construct object configurations that satisfy multiplicity constraints.) The modeler must determine when minimum multiplicity should be enforced, and these points cannot be everywhere or the configuration cannot change.
Invocation Actions
The actions defined in this package perform operation calls and signal sends (including both transmissions to specific targets and broadcasts to the available “universe”). Operations are specified in the model and can be dynamically selected only through polymorphism. Signals are specified by a signal object, whose type represents the kind of message transmitted between objects, and can be dynamically created. Note that operations may be bound to activities (procedures), state machine transitions, or other behaviors. The receipt of signals may be bound to activities, state machine transitions, or other behavio rs. 
There is also an action to directly invoke behavior.
Read Write Actions
Objects, structural features, links, and variables have values that are available to actions. Objects can be created and destro yed; 
structural features and variables have values; links can be created and destroyed, and can reference values through their ends;  
all of which are available to actions. Read actions get values, while write actions modify values and create and destroy object s 
and links. Read and write actions share the structures for identifying the structural features, links, and variables they acces s. 
The use of qualifiers on associations is supported in CompleteActions. Read actions do not modify the values they access, while write actions have only limited effect. The semantics of actions that read and write associations that have a static end is undefined.
Object actions create and destroy objects. Structural feature actions support the reading and writing of structural features. T he 
abstract metaclass StructuralFeatureAction statically specifies the structural feature being accessed. The object to access is specified dynamically, by referring to an input pin on which the object will be placed at runtime. The semantics for static features is undefined. Association actions operate on associations and links. In the description of these actions, the term “associations” does not include those modeled with association classes, unless specifically indicated. Similarly, a “link” is not a link object unless specifically indicated. The semantics of actions that read and write associations that have a static end is undefined. Variable actions support the reading and writing of variables. The abstract metaclass VariableAction statically specifies the variable being accessed. Variable actions can only access variables within the activity of which the action is a part. 
Computation Actions
Computation actions transform a set of input values to a set of output values by invoking a function. Primitive functions represent functions from a set of input values to a set of output values. The execution of a primitive function depends only on  
the input values and has no other effect than to compute output values. A primitive function does not read or write structural feature or link values, nor otherwise interact with object memory or other objects. Its behavior is completely self-contained. Specific primitive functions are not defined in the UML, but would be defined in domain-specific extensions. Typical primitive functions would include arithmetic, Boolean, and string functions.
Complete Concepts
The major constructs associated with complete actions are outlined below.
Read Write Actions
Additional actions deal with the relation between object and class and link objects. These read the instances of a given classi -
fier, check which classifier an instance is classified by, and change the classifier of an instance. Link object actions operat e on 
instances of association classes. Also the reading and writing actions of associations are extended to support qualifiers. Other 
UML Superstructure 2.0 Draft Adopted Specification        205Actions
Actions are defined for raising exceptions and accepting events, including operation calls. The StartOwnedBehaviorAction 
provides a way to indicate when the behavior of a newly created object should begin to execute.
11.2 Abstract Syntax
The package dependencies of the Actions chapter are shown in Figure 141.
Figure 141 Dependencies of the Action packagesCom pleteActionsIn ter m e di at e Ac ti o ns A sso ci a ti o n Cl a sse s
(fro m  Cl a sse s)
<<merge>>
<<merge>>BehaviorStateMachines
(from StateMachines )
<<merge>>Communications
(from CommonBehaviors )St ruct uredActivities
(from  Activities)
<<me rge >><<merge>>
206                 UML Superstructure 2.0 Draft Adopted SpecificationClass Diagrams (IntermediateActions)
Note that class Action is defined in the Activities chapter.
Figure 142 - Invocation actionsOutputPin
(from BasicActiv ities)
CallAction
is Synchronous  : Boolean = true*+res ult
*{ordered, 
subset s out put}
Behavior
(from  BasicBehav iors)CallBehavi orAc tion
1*
+behavior 1*Action
(from BasicActivities)
InvocationAction
BroadcastSignalAc tion
Signal
(f rom Comm un ic ation s)1*
+s ignal1*
Operation
(from  Ke rn el )SendObjectActi on SendSignalActi on
1*
+signal1*
CallOperationAction
*
1*
+operation 1
InputPin
(from BasicActivities)0..1
10..1
+target
1 {s ubsets input}
1+target
1{s ubs ets input}10..1
+target
1 {subsets input}0..1InputPin
( f ro m Ba si cA cti v itie s)*+argument
*{ order ed,
subsets input}
1+request1{redefines argument}
UML Superstructure 2.0 Draft Adopted Specification        207Figure 143 - Apply actions
Figure 144 - Object actionsPrimitiveFunction
body : String
language : Str i ng
OutputPin
(from  B asicActi v ities)ApplyFunctionAction
1 *+f unc tion
1 *
*+result
*{o r de re d ,
subsets output}Elem ent
(from Kernel)Action
(from  BasicActivities)
[0..1]
InputPin
(from BasicActivities)*+argument
*{subsets input}
DestroyObjectAction
OutputPin
(from  B as icAc tiv itie s)ReadSelfAction
10..1
+resul t
1{subsets output}0..1
OutputPin
(from BasicActivities)TestIdentityAction
10..1
+result
1 {subsets output}0..1
OutputPin
(from  Ba sicA cti v iti e s)Classifier
(from Kernel)CreateObjectAction
10..1
+result
1{subsets output}0..1
1*
+clas s ifier1*Action
(from BasicActivities)
InputPin
(from BasicActi viti es)10..1
+target1{ subsets  input}0..1InputPin
(from BasicActivities)
1
0..1+first1
{subsets input}
0..11
0..1+s eco nd1
{su bse ts i npu t}
0..1
208                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 145 - Structural Feature ActionsRemoveStructuralFeatureValueActionClearStructural FeatureAction
OutputPin
(from BasicActivities)Read Structural Fea tureA cti on
10..1
+result1{subsets output}0..1
Add Str uc tur alFea tur eVa lu eAct ion
isReplaceAll : Boolean = falseWriteStructuralFeatureActionAction
(from  BasicActivities)
StructuralFeatureAction StructuralFeature
(from Kernel)*1*
+s tr uc tur alFea tu re1
InputPin
(from  BasicActiv ities)1 0..1
+obj ect1
{subsets input}0..1
InputPin
(from BasicActivities)0..10..1
+insertAt0..1
{subsets input}0..1
10..1
+value
1{subsets input}0..1
UML Superstructure 2.0 Draft Adopted Specification        209Figure 146 - Link identification
Figure 147 - Read link actionsAction
(f rom Basic Acti vit ies )
Property
(from  Kernel)LinkEndData
1*
+en d 1*LinkAction2..*
1+endData2..*
1Elem ent
(from Kernel)
{ Property must be 
an association end.}InputPin
(from  Ba si cA cti v itie s)0. .1
0..10. .1
+value
0..1
OutputPin
(from BasicActivities)ReadLinkAction1 0..1
+result1
{subse ts o utp ut}0..1LinkAction
210                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 148 - Write link actionsDes troyLink ActionW riteLinkAction
LinkEndDataLinkAction
CreateLinkAction
LinkEndCreationData
isReplaceAll : Boolean = false2..*1
+endData
2..*{redefines endData}1Asso ci ati on
(f rom Kernel)ClearAssociationAction
10..1
+as so ciation 10..1Action
(from BasicActiviti es)
InputPin
(from BasicActivities)0..1
0..1+insertAt0..1
0..1InputPin
(from  BasicActiv ities)10..1
+object
1 {subsets input}0..1
UML Superstructure 2.0 Draft Adopted Specification        211Figure 149 - Variable actionsRemoveVariableValueActi onClearVariableAction
OutputPin
(fr om  Ba sicA cti v ities)ReadVa ri abl eAc ti on
10..1
+resul t
1{subsets output}0..1Variable
(f rom Str ucturedActiviti es)VariableAction 1 *
+variable1 *
WriteVariableAction
Add Var iab le ValueAc tion
isReplaceAll : Boolean = falseAction
(from  BasicActivities)
InputPin
(from BasicActivities)10. .1
+value1{subsets input}0. .1
0..10..1
+insertAt0..1
{subsets input}0..1
212                 UML Superstructure 2.0 Draft Adopted SpecificationClass Diagrams (CompleteActions)
)
Figure 150 - Accept event actionsAction
(from  BasicActivities)
Trigger
(from Com m unications)
OutputPin
(fr om  Ba si cA cti v iti e s)AcceptEventAction1
+trigger1
0..*
+result0..*
{subsets output}
OutputPin
(from  BasicActiv ities)AcceptCallAction
1+r eturnInformation1
{subsets output}InputPin
(from  BasicActiv ities)
CallTrigger
( fr om Communi cations)+trigger
{redefines trigger}ReplyAction
0..*
+replyValue0..*
{s ubs ets  input}1
+returnInformation1
{subsets input}
1 +replyToCall 1
UML Superstructure 2.0 Draft Adopted Specification        213Figure 151 - Object actions (CompleteActions)OutputPin
(from BasicActivities)ReadIsClassifiedObjectAction
isDirect : Boolean = false
10..1
+r es ul t
1{subse ts o ut put }0..1Re cl assifyOb jectA ct ion
isReplaceAll : Boolean = false
Classifier
(from Kernel)1
+clas s ifier1**
+oldClassifier**
**
+newClassifier**
OutputPin
(f rom BasicActivitie s)ReadExtentAction
10..1
+c las s ifie r10..1
10..1
+result
1{ subsets output}0..1Action
(from BasicActivities)
StartOwnedBehaviorAction
InputPin
(from BasicActivities)1+object
1{subsets input}
InputPin
(from BasicActivities)10..1
+ obj ect
1 {subsets input}0..1
InputPin
(from BasicActi vities)10..1
+object
1 {subsets input}0..1
214                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 152 - Link identification (CompleteActions)LinkEndData
(from IntermediateActions)
Property
( fro m  A ss oc ia t io nC la ss es )LinkEndData
QualifierValue *1*
+qual ifier11
*1
+qual ifier *
{Prop erty must 
be a qual ifier 
attribute.}Elem ent
(from Kernel)
InputPin
(from BasicActivities)0..1
10..1
+value 1
UML Superstructure 2.0 Draft Adopted Specification        215Figure 153 - Read link actions (CompleteActions)
Figure 154 - Write link actions (CompleteActions)Action
(fr om Ba si cA cti vit ies)
Property
(from  As so ci at i on Cl as se s)ReadLinkObjectEndQualifierAction
0..1
10..1
+qualifier1
Property
(from  Kernel)OutputPin
(from  BasicActiv ities)10..1
+result1
{subsets output}0..1ReadLinkObjectEndAction
10..1
+end 10..1
10..1
+result1
{subse ts o utp ut }0..1
{ Property must 
be an association end.} {Property must be an qualifier attribute.}InputPin
(from  BasicActiv ities)10..1
+object1
{s ubs ets  input}0..1
10..1
+object1
{subsets input}0..1
Link EndCreationData
(from IntermediateActions)CreateLinkAction
(from  In te rmed iateA ctions)
QualifierValueOutputPin
(from BasicActivities)LinkEndCreationData
1. .* +qualifier 1. .*{ordered}CreateLinkObjectAction
10. .1
+r es ul t1{ s ub s et s  ou tpu t}0. .12..*+endData
2..*
{re defin es en dData}
216                 UML Superstructure 2.0 Draft Adopted Specification11.3 Class Descriptions
11.3.1 AcceptCallAction
(CompleteActions) AcceptCallAction is an accept event action representing the receipt of a synchronous call request. In 
addition to the normal operation parameters, the action produces a output token that is needed later to supply the information to the ReplyAction necessary to return control to the caller.
This action is for synchronous calls. If it is used to handle an asynchronous call, execution of the subsequent reply action wi ll 
complete immediately with no effects.
Attributes
None.
Associations
 trigger: CallTrigger The operation call trigger accepted by the action.
 returnInformation: OutputPin [1..1]
Pin where a token is placed containing sufficient information to perform a subsequent reply and return control to the caller. The value in this token is opaque. It can be passed and copied but it cannot be manipulated by the model.
Constraints
[1]  The result pins must match the in and inout parameters of the call trigger operation in number, type, and order.
Semantics
This action accepts events representing the receipt of calls on the operation specified by the call trigger. If an ongoing acti vity 
has executed an accept call action that has not completed and the owning object has an event representing a call of the specified activity, the accept call action claims the event and removes it from the owning object. If several accept call actio ns 
concurrently request a call on the same operation, it is unspecified which one claims the event, but one and only one action will claim the event. The argument values of the call are placed on the result output pins of the action. Information sufficien t to 
perform a subsequent reply action is placed in a token on the returnInformation output pin. The execution of the accept call action is then complete. This return information token flows like any other data token, but the information in it is opaque and  Figure 155 - Raise exception actionInputPin
(from BasicActivities)Rais eExceptionAction
1+exception
1{s ubs ets  input}Action
(from  BasicActivities)
UML Superstructure 2.0 Draft Adopted Specification        217may not be manipulated by any actions. It only has meaning to ReplyAction.
Note that the target class must not define a method for the operation being received. Otherwise, the operation call will be 
dispatched to that method instead of being put in the event buffer to be handled by AcceptCallAction. In general, classes determine how operation calls are handled, namely by a method, by a behavior owned directly by the class, by a state machine transition, and so on. The class must ensure that the operation call is handled in a way that AcceptCallAction has access to th e 
call event.
11.3.2 AcceptEventAction
(CompleteActions) AcceptEventAction is an action that waits for the occurrence of an event meeting specified conditions.
Attributes
none
Associations
 trigger : Trigger [1] The type of event accepted by the action, as specified by a trigger. If it is a signal trigger, a 
signal of any subtype of the specified signal type is accepted.
 result: OutputPin [1] Pin holding the event object that has been received. Event objects may be copied in trans-
mission, so identity might not be preserved.
Constraints
[1]  Only control edges may target an AcceptEventAction.
[2] If the trigger is a ChangeTrigger, there are no output pins. Same is true for CallTrigger if this class is AcceptCallAction
and not one of its children.
[3] If the trigger is a SignalTrigger or a TimeTrigger, there is exactly one output pin.
Semantics
Accept event actions handle events detected by the object owning the activity. Events are detected by objects independently of 
actions and the events are stored by the object. The arrangement of detected events is not defined, but it is expected that extensions or profiles will specify such arrangements. If the accept event action is executed and the object detected an event matching the specification on the action and the event has not been accepted by another action or otherwise consumed by another behavior, then the accept signal action completes and outputs a token describing the event. If such a matching event is  
not available, the action waits until such an event becomes available, at which point the action may accept it. In a system wit h 
concurrency, several actions or other behaviors might contend for an available event. Unless otherwise specified by an extension or profile, only one action accepts a given event, even if the event would satisfy multiple concurrently executing actions.
If the event is a SignalEvent, the result token contains a signal object whose reception by the owning object caused the event.  
Signal objects may be copied in transmission and storage by the owning object, so identity might not be preserved. An action whose event is a signal event is informally called an accept signal action. If the event is a TimeEvent, the result token conta ins 
the time at which the event occurred. Such an action is informally called a wait time action. If the event is a ChangeEvent ot a 
CallEvent, the result is a control token, there are no output pins. See CommonBehavior for a description of Event specifications.
If an AcceptEventAction has no incoming edges, then the action starts when the containing activity or structured node does. In addition, an AcceptEventAction with no incoming edges is always enabled to accept events, no matter how many it accepts. It does not terminate after accepting an event and outputing a value, but continues to wait for other events. This semantic is an 
218                 UML Superstructure 2.0 Draft Adopted Specificationexception to the normal execution rules in Activities.
This action handles asynchronous messages, including asynchronous calls. If it is used for a synchronous call with no return 
parameters, an immediate reply is sent with no parameters. If it is used for a synchronous call with return parameters, it is a n 
error and the system behavior is unspecified.
Notation
An accept event action is notated with a concave pentagon. A wait time action is notated with an hour glass.  
Examples
Figure 157 is an example of the acceptance of a signal indicating the cancellation of an order. The acceptance of the signal causes an invocation of a cancellation behavior. This action is enabled on entry to the activity containing it, therefore no in put 
arrow is shown. In many cases, the arrow from such a signal will be an interrupting edge (CompleteActions).
In  Figure 158, a request payment signal is sent after an order is processed. The activity then waits to receive a payment confirmed signal. Acceptance of the payment confirmed signal is enabled only after the request for payment is sent; no confirmation is accepted until then. When the confirmation is received, the order is shipped.
In  Figure 159, the end-of-month accept time event action generates an output at the end of the month. Since there are no incoming edges to the time event action, it is enabled as long as its containing activity or structured node is. It will genera te an Figure 156 - Accept event notations.
Figure 157 - Accept signal, top level in scope.
Figure 158 - Accept signal, explicit enableAccept event action Accept time event action 
Cancel
orderCancel
Orderrequest
Payment
confirmedShip
OrderProcess
OrderRequest
Payment
UML Superstructure 2.0 Draft Adopted Specification        219output at the end of every month.
Rationale
Accept event actions are introduced to handle processing of events during the execution of an activity.
Changes from previous UML
AcceptEventAction is new in UML 2.0.
11.3.3 AddStructuralFeatureValueAction
AddStructuralFeatureValueAction is a write structural feature action for adding values to a structural feature.
Description
Structural Features are potentially multi-valued and ordered, so the action supports specification of insertion points for new 
values. It also supports the removal of existing values of the structural feature before the new value is added.
The object to access is specified dynamically, by referring to an input pin on which the object will be placed at runtime. The type of the value of this pin is the classifier that owns the specified structural feature, and the value’s multiplicity is 1.. 1.
Attributes
 isReplaceAll : Boolean [1..1] = falseSpecifies whether existing values of the structural feature of the object should be 
removed before adding the new value.
Associations
 insertAt : InputPin [0..1] (Specialized from Action:input) Gives the position at which to insert a new value or move 
an existing value in ordered structural features. The type of the pin is UnlimitedNatural, but the value cannot be zero. This pin is omitted for unordered structural features.
Constraints
[1]  Actions adding a value to ordered structural features must have a single input pin for the insertion point with type Unlim -
itedNatural and multiplicity of 1..1, otherwise the action has no input pin for the insertion point.
let insertAtPins : Collection = self.insertAt in
if self.structuralFeature.isOrdered = #false
then insertAtPins->size() = 0
else let insertAtPin : InputPin= insertAt->asSequence()->first() in
insertAtPins->size() = 1
and insertAtPin.type = UnlimitedNatural
and insertAtPin.multiplicity.is(1,1))
endifFigure 159 - Repetitive time eventReport
Meter
ReadingEnd of
monthoccurred
220                 UML Superstructure 2.0 Draft Adopted SpecificationSemantics
If isReplaceAll is true, then the existing values of the structural feature are removed before the new one added, except if the  
new value already exists, then it is not removed under this option. If isReplaceAll is false, then adding an existing value has  no 
effect.
Values of a structural feature may be ordered or unordered, even if the multiplicity maximum is 1.Adding values to ordered structural features requires an insertion point for a new value using the insertAt input pin. The insertion point is a positive  
integer giving the position to insert the value, or infinity, to insert at the end.. A positive integer less than or equal to t he 
current number of values means to insert the new value at that position in the sequence of existing values, with the integer on e 
meaning the new value will be first in the sequence. A value of infinity for insertAt means to insert the new value at the end of 
the sequence. The semantics is undefined for a value of zero or an integer greater than the number of existing values. The insertion point is required for ordered structural features and omitted for unordered structural features. Reinserting an exist ing 
value at a new position moves the value to that position (this works because structural feature values are sets).
The semantics is undefined for adding a value that violates the upper multiplicity of the structural feature. Removing a value succeeds even when that violates the minimum multiplicity—the same as if the minimum were zero. The modeler must determine when minimum multiplicity of structural features should be enforced.
The semantics is undefined for adding a new value for a structural feature with settability readOnly or removeOnly after initialization of the owning object.
Notation
None.
Examples
Rationale
AddStructuralFeatureValueAction is introduced to add structural feature values. isReplaceAll is introduced to replace and add 
in a single action, with no intermediate states of the object where only some of the existing values are present.
Changes from previous UML
AddStructuralFeatureValueAction is new in UML 2.0. It generalizes AddAttributeAction in UML 1.5.
11.3.4 AddVariableValueAction
AddVariableValueAction is a write variable action for adding values to a variable.
Description
Variables are potentially multi-valued and ordered, so the action supports specification of insertion points for new values. It  
also supports the removal of existing values of the variable before the new value is added.
Attributes
 isReplaceAll : Boolean [1..1] = falseSpecifies whether existing values of the variable should be removed before adding 
the new value.
UML Superstructure 2.0 Draft Adopted Specification        221Associations
 insertAt : InputPin [0..1] (Specialized from Action:input) Gives the position at which to insert a new value or move 
an existing value in ordered variables. The types is UnlimitedINatural, but the value can-not be zero. This pin is omitted for unordered variables.
Constraints
[1]  Actions adding values to ordered variables must have a single input pin for the insertion point with type UnlimtedNatural 
and multiplicity of 1..1, otherwise the action has no input pin for the insertion point.
let insertAtPins : Collection = self.insertAt in
if self.variable.ordering = #unordered
then insertAtPins->size() = 0
else let insertAtPin : InputPin = insertAt->asSequence()->first() in
insertAtPins->size() = 1
and insertAtPin.type = UnlimitedNatural
and insertAtPin.multiplicity.is(1,1)) 
endif
Semantics
If isReplaceAll is true, then the existing values of the variable are removed before the new one added, except if the new value  
already exists, then it is not removed under this option. If isReplaceAll is false, then adding an existing value has no effect .
Values of an variable may be ordered or unordered, even if the multiplicity maximum is 1.Adding values to ordered variables 
requires an insertion point for a new value using the insertAt input pin. The insertion point is a positive integer giving the position to insert the value, or infinity, to insert at the end.. A positive integer less than or equal to the current number o f values 
means to insert the new value at that position in the sequence of existing values, with the integer one meaning the new value will be first in the sequence. A value of infinity for insertAt means to insert the new value at the end of the sequence. The semantics is undefined for a value of zero or an integer greater than the number of existing values. The insertion point is required for ordered variables and omitted for unordered variables. Reinserting an existing value at a new position moves the value to that position (this works because variable values are sets).
The semantics is undefined for adding a value that violates the upper multiplicity of the variable. Removing a value succeeds even when that violates the minimum multiplicity—the same as if the minimum were zero. The modeler must determine when minimum multiplicity of variables should be enforced.
Notation
None.
Examples
Rationale
AddVariableValueAction is introduced to add variable values. isReplaceAll is introduced to replace and add in a single action, 
with no intermediate states of the variable where only some of the existing values are present.
Changes from previous UML
AddVariableValueAction is unchanged from UML 1.5.
222                 UML Superstructure 2.0 Draft Adopted Specification11.3.5 ApplyFunctionAction
Description
ApplyFunctionAction is an action that invokes a primitive predefined function that computes output values based only on the 
input values and the function. The execution does not have access to object memory or to any objects. The execution of a primitive function has no side effects on any other object.
Attributes
None.
Associations
 argument : InputPin [*] The pins that provide inputs to the function. (Specializes Action.input .)
 function : PrimitiveFunction [1]The primitive function to be invoked. result : OutputPin [*] The pins on which the results of invoking the function are returned. (Specializes 
Action.output .)
Stereotypes
None.
Tagged Values
None.
Constraints
[1]  The number and types of the input arguments and output result pins are derived from the parameters of the function.
self.argument->size( ) = self.function.formalParameter->size( )
and Sequence {1..self.argument->size( )}
-> forAll (i:Integer | 
let argumenti = self.argument->at(i) in
let inparameteri = self.function.formalParameter->at(i) in
argumenti.type = inparameteri.type)
and self.result->size( ) = self.function.returnedResult->size( )
and Sequence {1..self.result->size( )}
-> forAll (i:Integer | 
let resulti = self.result->at(i) in
let outparameteri = self.function.returnedResult>at(i) in
resulti.type = outparameteri.type)
Semantics
The result values are computed from the input values according to the given function. During the execution of the 
computation, no communication or interaction with the rest of the system is possible. The amount of time to compute the results is undefined. 
The result values are placed on the output pins of the action execution and the execution of the apply function action is complete. Primitive functions may raise exceptions for certain input values, in which case the computation is abandoned.
Notation
None.
UML Superstructure 2.0 Draft Adopted Specification        223Presentation Option
None.
Examples
None.
Rationale
ApplyFunctionAction is introduced to invoke behaviors that are external to the modeled system.
Changes from previous UML
Same as UML 1.5.
11.3.6 BroadcastSignalAction
Description
BroadcastSignalAction is an action that transmits a signal instance to all the potential target objects in the system, which ma y 
cause the firing of a state machine transitions or the execution of associated activities of a target object. The argument valu es 
are available to the execution of associated behaviors. The requestor continues execution immediately. Any reply messages are ignored and are not transmitted to the requestor.
Attributes
None
Associations
 signal: Signal [1] The specification of signal object transmitted to the target objects.
Constraints
[1]  The number and order of argument pins must be the same as the number and order of attributes in the signal.
[2] The type, ordering, and multiplicity of an argument pin must be the same as the corresponding attribute of the signal.
Semantics
When all the control and data flow prerequisites of the action execution are satisfied, a signal object is generated from the 
argument values according to signal and this signal object is transmitted concurrently to each of the implicit broadcast target  
objects in the system. The manner of identifying the set of objects that are broadcast targets is a semantic variation point an d 
may be limited to some subset of all the objects that exist. There is no restriction on the location of target objects. The man ner 
of transmitting the signal object, the amount of time required to transmit it, the order in which the transmissions reach the various target objects, and the path for reaching the target objects are undefined.
[1]  When a transmission arrives at a target object, it may invoke a behavior in the target object. The effect of receiving suc h 
transmission is specified in Chapter 13, “Common Behaviors”. Such effects include executing activities and firing state machine transitions.
[2] A broadcast signal action receives no reply from the invoked behavior; any attempted reply is simply ignored, and no
transmission is performed to the requestor.
224                 UML Superstructure 2.0 Draft Adopted SpecificationSemantic Variation Point
The determination of the set of broadcast target objects is a semantic variation point. Notation
None.
Examples
None
Rationale
Sends a signal to a set of system defined target objects.
Changes from previous UML
Same as UML 1.5.
11.3.7 CallAction
CallAction is an abstract class for actions that invoke behavior and receive return values.
Attributes
 isSynchronous: Boolean If true, the call is synchronous and the caller waits for completion of the invoked behavior. 
If false , the call is asynchronous and the caller proceeds immediately and does not expect 
a return values.
Associations
 result: OutputPin [0..*] A list of output pins where the results of performing the invocation are placed.
Constraints
[1]  Only synchronous call actions can have result pins.
Semantics
See children of CallAction.
11.3.8 CallBehaviorAction
Description
CallBehaviorAction is a call action that invokes a behavior directly rather than invoking a behavioral feature that, in turn, results in the invocation of that behavior. The argument values of the action are available to the execution of the invoked behavior. The execution of the call behavior action waits until the execution of the invoked behavior completes and a result is  
returned on its output pin. In particular, the invoked behavior may be an activity.
Attributes
None.
UML Superstructure 2.0 Draft Adopted Specification        225Associations
 behavior : Behavior [1..1] The invoked behavior. It must be capable of accepting and returning control.
Constraints
[1]  The number of argument pins and the number of parameters of the behavior of type in and in-out  must be equal.
[2] The number of result pins and the number of parameters of the behavior of type return , out, and in-out  must be equal.
[3] The type, ordering, and multiplicity of an argument or result pin is derived from the corresponding parameter of the
behavior.
Semantics
[1]  When all the control and data flow prerequisites of the action execution are satisfied, CallBehaviorAction consumes its 
input tokens and invokes its specified behavior. The values in the input tokens are made available to the invoked behavior as argument values. When the behavior is finished, tokens are offered on all outgoing control edges, with a copy made for each control edge. Object and data tokens are offered on the outgoing object flow edges as determined by the output pins. Each parameter of the behavior of the action provides input to a pin or takes output from one. See Pin. The inputs to the action determine the actual arguments of the call.
[2] If the call is asynchronous, a control token is offered to each outgoing control edge of the action and execution of the
action is complete. Execution of the invoked behavior proceeds without any further dependency on the execution of theactivity containing the invoking action. Once the invocation of the behavior has been initiated, execution of the asynchro-nous action is complete.
[3] An asynchronous invocation completes when its behavior is started, or is at least ensured to be started at some point.
When an asynchronous invocation is done, the flow continues regardless of the status of the invoked behavior. For exam-ple, the containing activity may complete even though the invoked behavior is not finished. This is why asynchronousinvocation is not the same as using a fork to invoke the behavior followed by a flow final. A forked behavior still needs tofinish for the containing activity to finish. If it is desired to complete the invocation, but have some outputs provided laterwhen they are needed, then use a fork to give the invocation its own flow line, and rejoin the outputs of the invocation tothe original flow when they are needed.
[4] If the call is synchronous, execution of the calling action is blocked until it receives a reply token from the invoked
behavior. The reply token includes values for any return, out, or inout parameters.
[5] If the call is synchronous, when the execution of the invoked behavior completes, the result values are placed as object
tokens on the result pins of the call behavior action, a control token is offered on each outgoing control edge of the callbehavior action, and the execution of the action is complete. (CompleteActions, ExtraActivities) If the execution of theinvoked behavior yields an exception, the exception is transmitted to the call behavior action where it is presented on adeclared exception pin as an exception token, and the action delivers no normal object or control tokens. If no exceptionpin is declared, the exception is propagated to an enclosing scope.
Notation
The name of the behavior, or other description of it, that is performed by the action is placed inside the rectangle. If the no de 
226                 UML Superstructure 2.0 Draft Adopted Specificationname is different than the behavior name, then it appears in the symbol instead.  
Presentation Option
The call of an activity is indicated by placing a rake-style symbol within the symbol. The rake resembles a miniature 
hierarchy, indicating that this invocation starts another activity that represents a further decomposition. An alternative nota tion 
in the case of an invoked activity is to show the contents of the invoked activity inside a large round-cornered rectangle. Edg es 
flowing into the invocation connect to the parameter object nodes in the invoked activity. The parameter object nodes are shown on the border of the invoked activity. The model is the same regardless of the choice of notation. This assumes the UML 2.0 Diagram Interchange RFP supports the interchange of diagram elements and their mapping to model elements..
Below is an example of invoking an activity called FillOrder.
Examples
Rationale
Invokes a behavior directly without the need for a behavioral feature.
Changes from previous UML
Same as UML 1.5.Figure 160 CallBehaviorAction
Figure 161 - Invoking Activities that have nodes and edges
Figure 162 - Example of invoking an activitybehavior name
Activity name
......
...Activity
name
(Note: the border and name are the notation; the
other symbols are present to provide clarity, only.)Parameter name: type
Fill
Order
UML Superstructure 2.0 Draft Adopted Specification        22711.3.9 CallOperationAction
Description
CallOperationAction is an action that transmits an operation call request to the target object, where it may cause the invocati on 
of associated behavior. The argument values of the action are available to the execution of the invoked behavior. If the action  
is marked synchronous, the execution of the call operation action waits until the execution of the invoked behavior completes and a reply transmission is returned to the caller; otherwise execution of the action is complete when the invocation of the operation is established and the execution of the invoked operation proceeds concurrently with the execution of the calling activity. Any values returned as part of the reply transmission are put on the result output pins of the call operation action.  
Upon receipt of the reply transmission, execution of the call operation action is complete.
Attributes
None.
Associations
 operation: Operation [1] The operation to be invoked by the action execution
 target: InputPin [1] The target object to which the request is sent. The classifier of the target object is used to 
dynamically determine a behavior to invoke. This object constitutes the context of the exe-cution of the operation.
Constraints
[1]  The number of argument pins and the number of formal parameters of the operation of type in and in-out  must be equal.
[2] The number of result pins and the number of formal parameters of the operation of type return , out, and in-out  must be
equal.
[3] The type, ordering, and multiplicity of an argument or result pin is derived from the corresponding formal parameter of
the operation.
[4] The type of the target pin must be the same as the type that owns the operation.
Semantics
The inputs to the action determine the target object and additional actual arguments of the call.
[1]  When all the control and data flow prerequisites of the action execution are satisfied, information comprising the operati on 
and the argument pin values of the action execution is created and transmitted to the target object. The target objects may be local or remote. The manner of transmitting the call, the amount of time required to transmit it, the order in which the transmissions reach the various target objects, and the path for reaching the target objects are undefined.
[2] When a call arrives at a target object, it may invoke a behavior in the target object. The effect of receiving such call is
specified in Chapter 13, “Common Behaviors”. Such effects include executing activities and firing state machine transi-tions.
[3] If the call is synchronous, when the execution of the invoked behavior completes, its return results are transmitted back as
a reply to the calling action execution. The manner of transmitting the reply, the time required for transmission, the repre-sentation of the reply transmission, and the transmission path are unspecified. If the execution of the invoked behavioryields an exception, the exception is transmitted to the caller where it is reraised as an exception in the execution of thecalling action. Possible exception types may be specified by attaching them to the called Operation using the raisedEx-
ception  association.
228                 UML Superstructure 2.0 Draft Adopted Specification[4] If the call is asynchronous, the caller proceeds immediately and the execution of the call operation action is complete. If
the call is synchronous, the caller is blocked from further execution until it receives a reply from the invoked behavior.
[5] When the reply transmission arrives at the invoking action execution, the return result values are placed on the result pins
of the call operation action, and the execution of the action is complete.
Semantic Variation Points
The mechanism for determining the method to be invoked as a result of a call operation is unspecified.
Notation
The name of the operation, or other description of it, is displayed in the symbol.  
Presentation Option
If the node has a different name than the operation, then this is used in the symbol instead. The name of the class may optionally appear below the name of the operation, in parentheses postfixed by a double colon. If the node name is different than the operaiton name, then the behavioral feature name may be shown after the double colon.
 
Examples
None
Rationale
Calls an operation on a specified target object.
Changes from previous UML
Same as UML 1.5.
11.3.10 ClearAssociationAction
ClearAssociationAction is an action that destroys all links of an association in which a particular object participates.
Description
This action destroys all links of an association that have a particular object at one end.Figure 163 - Calling an operation
Figure 164 - Invoking behavioral feature notationsoperation name
name
(ClassName::)name
(ClassName::OperationName)
UML Superstructure 2.0 Draft Adopted Specification        229Attributes
None.
Associations
 association : Association [1..1] Association to be cleared.
 object : InputPin [1..1] (Specialized from Action:input) Gives the input pin from which is obtained the object 
whose participation in the association is to be cleared.
Constraints
[1]  The type of the input pin must be the same as the type of at least one of the association ends of the association.
self.association->exists(end.type = self.object.type)
[2] The multiplicity of the input pin is 1..1.
self.object.multiplicity.is(1,1)
Semantics
This action has a statically-specified association. It has an input pin for a runtime object that must be of the same type as a t 
least one of the association ends of the association. All links of the association in which the object participates are destroy ed 
even when that violates the minimum multiplicity of any of the association ends. If the association is a class, then link objec t 
identities are destroyed.
Notation
None.
Examples
Rationale
ClearAssociationAction is introduced to remove all links from an association in which an object participates in a single action , 
with no intermediate states where only some of the existing links are present.
Changes from previous UML
ClearAssociationAction is unchanged from UML 1.5.
11.3.11 ClearStructuralFeatureAction
ClearStructuralFeatureAction is a structural feature action that removes all values of a structural feature.
Description
This action removes all values of a structural feature.
Attributes
None.
Associations
None.
230                 UML Superstructure 2.0 Draft Adopted SpecificationConstraints
None.
Semantics
All values are removed even when that violates the minimum multiplicity of the structural feature—the same as if the 
minimum were zero. The semantics is undefined if the settability of the structural feature is addOnly, or the settability is readOnly after initialization of the object owning the structural feature, unless the structural feature has no values. The act ion 
has no effect if the structural feature has no values.
Notation
None.
Examples
Rationale
ClearStructuralFeatureAction is introduced to remove all values from a structural feature in a single action, with no 
intermediate states where only some of the existing values are present.
Changes from previous UML
ClearStructuralFeatureAction is new in UML 2.0. It generalizes ClearAttributeAction from UML 1.5.
11.3.12 ClearVariableAction
ClearVariableAction is a variable action that removes all values of an variable.
Description
This action removes all values of an variable.
Attributes
None.
Associations
None.
Constraints
None.
Semantics
All values are removed even when that violates the minimum multiplicity of the variable—the same as if the minimum were zero.
Notation
None.
UML Superstructure 2.0 Draft Adopted Specification        231Examples
Rationale
ClearVariableAction is introduced to remove all values from an variable in a single action, with no intermediate states where 
only some of the existing values are present.
Changes from previous UML
ClearVariableAction is unchanged from UML 1.5.
11.3.13 CreateLinkAction
CreateLinkAction is a write link action for creating links.
Description
This action can be used to create links and link objects. There is no return value in either case. This is so that no change of  the 
action is required if the association is changed to an association class or vice versa. CreateLinkAction uses a specialization of 
LinkEndData called LinkEndCreationData, to support ordered associations. The insertion point is specified at runtime by an additional input pin, which is required for ordered association ends and omitted for unordered ends. The insertion point is a positive integer giving the position to insert the link, or infinity, to insert at the end. Reinserting an existing end at a ne w 
position moves the end to that position.
CreateLinkAction also uses LinkEndCreationData to support the destruction of existing links of the association that connect any of the objects of the new link. When the link is created, this option is available on an end-by-end basis, and causes all l inks 
of the association emanating from the specified ends to be destroyed before the new link is created.
Attributes
None.
Associations
 endData : LinkEndCreationData [2..*] (Redefined from LinkAction:endData) Specifies ends of association and inputs.
Constraints
[1]  The association cannot be an abstract classifier.
self.association().isAbstract = #false
Semantics
CreateLinkAction creates a link or link object for an association or association class. It has no output pin, because links are  not 
necessarily values that can be passed to and from actions. When the action creates a link object, the object could be returned on 
output pin, but it is not for consistency with links. This allows actions to remain unchanged when an association is changed to  
an association class or vice versa. The semantics of CreateLinkObjectAction applies to creating link objects with CreateLinkAction.
This action also supports the destruction of existing links of the association that connect any of the objects of the new link.  
This option is available on an end-by-end basis, and causes all links of the association emanating from the specified ends to b e 
destroyed before the new link is created. If the link already exists, then it is not destroyed under this option. Otherwise, recreating an existing link has no effect.
The semantics is undefined for creating a link for an association class that is abstract. The semantics is undefined for creati ng 
232                 UML Superstructure 2.0 Draft Adopted Specificationa link that violates the upper multiplicity of one of its association ends. A new link violates the upper multiplicity of an en d if 
the cardinality of that end after the link is created would be greater than the upper multiplicity of that end. The cardinality  of an 
end is equal to the number of links with objects participating in the other ends that are the same as those participating in th ose 
other ends in the new link, and with qualifier values on all ends the same as the new link, if any.
The semantics is undefined for creating a link that has an association end with settability readOnly or removeOnly after initialization of the other end objects, unless the link being created already exists. Objects participating in the association  
across from an addable end can have links created as long as the objects across from all readOnly or removeOnly ends are still being initialized. This means that objects participating in links with two or more readOnly or removeOnly ends cannot have links created unless all the linked objects are being initialized.
Creating ordered association ends requires an insertion point for a new link using the insertAt input pin of LinkEndCreationData. The pin is of type UnlimitedNatural with multiplicity of 1..1. A pin value that is a positive integer less  
than or equal to the current number of links means to insert the new link at that position in the sequence of existing links, w ith 
the integer one meaning the new link will be first in the sequence. A value of infinity for insertAt means to insert the new li nk 
at the end of the sequence. The semantics is undefined for value of zero or an integer greater than the number of existing link s. 
The insertAt input pin does not exist for unordered association ends. Reinserting an existing end at a new position moves the end so that it is in the position specified after the action is complete.
Notation
None.
Examples
Rationale
CreateLinkAction is introduced to create links.
Changes from previous UML
CreateLinkAction is unchanged from UML 1.5.
11.3.14 CreateLinkObjectAction
(CompleteActions) CreateLinkObjectAction creates a link object.
Description
This action is exclusively for creating links of association classes. It returns the created link object.
Attributes
None.
Associations
 result [1..1] : OutputPin [1..1] (Specialized from Action:output) Gives the output pin on which the result is put.
Constraints
[1]  The association must be an association class.
self.association().oclIsKindOf(Class)
[2] The type of the result pin must be the same as the association of the action.
UML Superstructure 2.0 Draft Adopted Specification        233self.result.type = self.association()
[3] The multiplicity of the output pin is 1..1.
self.result.multiplicity.is(1,1)
Semantics
CreateLinkObjectAction inherits the semantics of CreateLinkAction, except that it operates on association classes to create a 
link object. The additional semantics over CreateLinkAction is that the new or found link object is put on the output pin. If t he 
link already exists, then the found link object is put on the output pin. The semantics of CreateObjectAction applies to creati ng 
link objects with CreateLinkObjectAction.
Notation
None.
Examples
Rationale
CreateLinkObjectAction is introduced to create link objects in a way that returns the link object. Compare CreateLinkAction.
Changes from previous UML
CreateLinkObjectAction is unchanged from UML 1.5.
11.3.15 CreateObjectAction
CreateObjectAction is an action that creates an object that conforms to a statically specified classifier and puts it on an out put 
pin at runtime.
Description
This action instantiates a classifier. The semantics is undefined for creating objects from abstract classifiers or from association classes.
Attributes
None.
Associations
 classifier : Classifier [1..1] Classifier to be instantiated.
 result : OutputPin [1..1] (Specialized from Action:output) Gives the output pin on which the result is put.
Constraints
[1]  The classifier cannot be abstract.
not (self.classifier.isAbstract = #true)
[2] The classifier cannot be an association class
not self.classifier.oclIsKindOf(AssociationClass)
[3] The type of the result pin must be the same as the classifier of the action.
234                 UML Superstructure 2.0 Draft Adopted Specificationself.result.type = self.classifier
[4] The multiplicity of the output pin is 1..1.
self.result.multiplicity.is(1,1)
Semantics
The new object is created, and the classifier of the object is set to the given classifier. The new object is returned as the v alue 
of the action. The action has no other effect. In particular, no behaviors are executed, no initial expressions are evaluated, and 
no state machines transitions are triggered. The new object has no structural feature values and participates in no links.
Notation
None.
Examples
Rationale
CreateObjectAction is introduced for creating new objects.
Changes from previous UML
Same as UML 1.5.
11.3.16 DestroyLinkAction
DestroyLinkAction is a write link action that destroys links and link objects.
Description
This action destroys a link or a link object. Link objects can also be destroyed with DestroyObjectAction. The link is specifie d 
in the same way as link creation, even for link objects. This allows actions to remain unchanged when their associations are transformed from ordinary ones to association classes and vice versa.
Attributes
None.
Associations
None.
Constraints
None.
Semantics
Destroying a link that does not exist has no effect. The semantics of DestroyObjectAction applies to destroying a link that has  
a link object with DestroyLinkAction.
The semantics is undefined for destroying a link that has an association end with settability addOnly, or readOnly after initialization of the other end objects, unless the link being destroyed does not exist. Objects participating in the associati on 
across from a removable end can have links destroyed as long as the objects across from all readOnly ends are still being 
UML Superstructure 2.0 Draft Adopted Specification        235initialized. This means that objects participating in links with two or more addOnly ends cannot have links destroyed. Same 
for objects participating in two or more readOnly ends, unless all the linked objects are being initialized.
Notation
None.
Examples
Rationale
DestroyLinkAction is introduced for destroying links.
Changes from previous UML
DestroyLinkAction is unchanged from UML 1.5.
11.3.17 DestroyObjectAction
DestroyObjectAction is an action that destroys objects.
Description
This action destroys the object on its input pin at runtime. The object may be a link object, in which case the semantics of 
DestroyLinkAction also applies.
Attributes
None.
Associations
 target : InputPin [1..1] (Specialized from Action:input) The input pin providing the object to be destroyed. 
Constraints
[1]  The multiplicity of the input pin is 1..1.
self.input.multiplicity.is(1,1)
[2] The input pin has no type.
self.input.type->size() = 0
Semantics
The classifiers of the object are removed as its classifiers, and the object is destroyed. The action has no other effect. In particular, no behaviors are executed, no state machines transitions are triggered, and references to the destroyed objects are  
unchanged.
Destroying an object that is already destroyed has no effect.
Notation
None.
236                 UML Superstructure 2.0 Draft Adopted SpecificationExamples
Rationale
DestroyObjectAction is introduced for destroying objects.
Changes from previous UML
Same as UML 1.5.
11.3.18 InvocationAction
Invocation is an abstract class for the various actions that invoke behavior.
Attributes
none
Associations
 argument : InputPin [0..*] Specification of an argument value that appears during execution.
ConstraintsSemantics
See children of InvocationAction.
11.3.19 LinkAction
LinkAction is an abstract class for all link actions that identify their links by the objects at the ends of the links and by t he 
qualifiers at ends of the links.
Description
A link action creates, destroys, or reads links, identifying a link by its end objects and qualifier values, if any.
Attributes
None.
Associations
 endData : LinkEndData [2..*] Data identifying one end of a link by the objects on its ends and qualifiers.
 input : InputPin [1..*] (Specialized from Action:input) Pins taking end objects and qualifier values as input.
Constraints
[1]  The association ends of the link end data must all be from the same association and include all and only the association 
ends of that association.
self.endData->collect(end) = self.association()->collect(connection))
[2] The association ends of the link end data must not be static.
self.endData->forall(end.oclisKindOf(NavigableEnd) implies end.isStatic = #false)
UML Superstructure 2.0 Draft Adopted Specification        237[3] The input pins of the action are the same as the pins of the link end data and insertion pins.
self.input->asSet() = 
let ledpins : Set = self.endData->collect(value) in
if self.oclIsKindOf(LinkEndCreationData)
then ledpins->union(self.endData.oclAsType(LinkEndCreationData).insertAt)else ledpins
Additional operations:
[1]  association operates on LinkAction. It returns the association of the action.
association();association = self.endData->asSequence().first().end.association
Constraints
[1]  The input pins of the action are the same as the pins of the link end data, qualifier values, and insertion pins.
self.input->asSet() = 
let ledpins : Set = if self.endData.oclIsKindOf(CompleteActions::LinkEndData)
then self.endData->collect(value)->union(self.endData.qualifier.value)
else self.endData->collect(value) in
if self.oclIsKindOf(LinkEndCreationData)
then ledpins->union(self.endData.oclAsType(LinkEndCreationData).insertAt)
else ledpins
Semantics
For actions that write links, all association ends must have a corresponding input pin so that all end objects are specified wh en 
creating or deleting a link. An input pin identifies the end object by being given a value at runtime. It has the type of the association end and multiplicity of 1..1, since a link always have exactly one object at its ends.
The behavior is undefined for links of associations that are static on any end.
For the semantics of link actions see the children of LinkAction.
Notation
None.
Examples
Rationale
LinkAction is introduced to abstract aspects of link actions that identify links by the objects on their ends.
In CompleteActions, LinkAction is extended for qualifiers.
Changes from previous UML
LinkAction is unchanged from UML 1.5.
11.3.20 LinkEndCreationData
LinkEndCreationData is not an action. It is an element that identifies links. It identifies one end of a link to be created by 
CreateLinkAction.
238                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
This class is required when using CreateLinkAction, to specify insertion points for ordered ends and for replacing all links at  
end. A link cannot be passed as a runtime value to or from an action. Instead, a link is identified by its end objects and qual ifier 
values, as required. This requires more than one piece of data, namely, the statically-specified end in the user model, the obj ect 
on the end, and the qualifier values for that end. These pieces are brought together around LinkEndData. Each association end is identified separately with an instance of the LinkEndData class.
Qualifier values are used in CompleteActions.
Attributes
 isReplaceAll : Boolean [1..1] = falseSpecifies whether the existing links emanating from the object on this end should be 
destroyed before creating a new link.
Associations
 insertAt : InputPin [0..1] Specifies where the new link should be inserted for ordered association ends, or where an 
existing link should be moved to. The type of the input is UnlimitedNatural, but the input cannot be zero. This pin is omitted for association ends that are not ordered.
Associations (CompleteActions)
 qualifier : QualifierValue [0..*] Specifies qualifier attribute/value pairs of the given end.
Constraints
[1]  LinkEndCreationData can only be end data for CreateLinkAction or one of its specializations.
self.LinkAction.oclIsKindOf(CreateLinkAction)
[2] Link end creation data for ordered association ends must have a single input pin for the insertion point with type Unlimit-
edNatural and multiplicity of 1..1, otherwise the action has no input pin for the insertion point..
let insertAtPins : Collection = self.insertAt in
if self.end.ordering = #unordered then insertAtPins->size() = 0
else let insertAtPin : InputPin = insertAts->asSequence()->first() in
insertAtPins->size() = 1and insertAtPin.type = UnlimitedNatural
and insertAtPin.multiplicity.is(1,1))
endif
Constraints (CompleteActions)
[1]  The qualifiers include all and only the qualifiers of the association end.
self.qualifier->collect(qualifier) = self.end.qualifier
[2] The end object input pin is not also a qualifier value input pin.
self.value->excludesAll(self.qualifier.value)
Semantics
See CreateLinkAction, also see LinkAction and all its children.
Notation
None.
UML Superstructure 2.0 Draft Adopted Specification        239Examples
Rationale
LinkEndCreationData is introduced to indicate which inputs are for which link end objects and qualifiers.
Changes from previous UML
LinkEndCreationData is unchanged from UML 1.5.
11.3.21 LinkEndData
LinkEndData is not an action. It is an element that identifies links. It identifies one end of a link to be read or written by the 
children of LinkAction. A link cannot be passed as a runtime value to or from an action. Instead, a link is identified by its e nd 
objects and qualifier values, if any. This requires more than one piece of data, namely, the statically-specified end in the us er 
model, the object on the end, and the qualifier values for that end, if any. These pieces are brought together around LinkEndData. Each association end is identified separately with an instance of the LinkEndData class.
Attributes
None.
Associations
 end : Property [1..1] Association end for which this link-end data specifies values.
 value : InputPin [0..1] Input pin that provides the specified object for the given end. This pin is omitted if the 
link-end data specifies an “open” end for reading.
Associations (CompleteActions)
 qualifier : QualifierValue [*] List of qualifier values
Constraints
[1]  The property must be an association end.
self.end.association->size = 1
[2] The type of the end object input pin is the same as the type of the association end.
self.value.type = self.end.type
[3] The multiplicity of the end object input pin must be “1..1”.
self.value.multiplicity.is(1,1)
Additional operations:
[1]  association operates on LinkAction. It returns the association of the action.
association();
association = self.endData->asSequence().first().end.association
Semantics
See LinkAction and its children.
240                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
None.
Examples
Rationale
LinkEndData is introduced to indicate which inputs are for which link end objects and qualifiers.
Changes from previous UML
LinkEndData is unchanged from UML 1.5.
11.3.22 MultiplicityElement (as specialized)
Operations
[1]  The operation compatibleWith takes another multiplicity as input. It checks if one multiplicity is compatible with another .
compatibleWith(other : Multiplicity) : Boolean;
compatibleWith(other) = Integer.allInstances()->
forAll(i : Integer | self.includesCardinality(i) implies other.includesCardinality(i))
[2] The operation is determines if the upper and lower bound of the ranges are the ones given.
is(lowerbound : integer, upperbound : integer) : Boolean
is(lowerbound, upperbound) = (lowerbound = self.lowerbound and upperbound = self.upperbound)
11.3.23 PrimitiveFunction
Description
PrimitiveFunction is not an action. It is the signature of a function that produces output values from input values for use wit h 
ApplyFunctionAction. The behavior is described using the body  and language  attributes. The specification of the detailed 
behavior is expressed in an external language and is not further specified within UML.
Attributes
 body: String A textual representation of the function in the named surface language.
 language: String [0..1] Specifies the language in which the body of the primitive function is stated. The interpre-
tation of the body depends on the language. If the language is unspecified, it might be implicit from the body or the context.
Associations
None.
Constraints
None.
Semantics
The interpretation of the function body depends on the specified language. If formal parameters are specified, these provide values to the function during its execution. The result parameters specify the values to be returned by the function.
UML Superstructure 2.0 Draft Adopted Specification        241The execution of a primitive function has no effect on the execution environment other than the production of output values 
that depend only on the supplied input values. 
Notation
None.
Examples
None.
Rationale
PrimitiveFunction models external functions that only take inputs and product outputs and have no effect on the specified system.
Changes from previous UML
Same as UML 1.5.
11.3.24 QualifierValue
(CompleteActions) QualifierValue is not an action. It is an element that identifies links. It gives a single qualifier within a  link 
end data specification. See LinkEndData.
Description
A link cannot be passed as a runtime value to or from an action. Instead, a link is identified by its end objects and qualifier  
values, as required. This requires more than one piece of data, namely, the end in the user model, the object on the end, and t he 
qualifier values for that end. These pieces are brought together around LinkEndData. Each association end is identified separately with an instance of the LinkEndData class.
Attributes
None.
Associations
 qualifier : Property [1..1] Attribute representing the qualifier for which the value is to be specified.
 value : InputPin [1..1] Input pin from which the specified value for the qualifier is taken.
Constraints
[1]  The qualifier attribute must be a qualifier of the association end of the link-end data.
self.LinkEndData.end->collect(qualifier)->includes(self.qualifier)
[2] The type of the qualifier value input pin are the same as the type of the qualifier attribute.
self.value.type = self.qualifier.type
[3] The multiplicity of the qualifier value input pin is “1..1”.
self.value.multiplicity.is(1,1)
Semantics
See LinkAction and its children.
242                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
None.
Examples
Rationale
QualifierValue is introduced to indicate which inputs are for which link end qualifiers.
Changes from previous UML
QualifierValue is unchanged from UML 1.5
11.3.25 RaiseExceptionAction
Description
(CompleteActions) RaiseExceptionAction is an action that causes an exception to occur. The input value becomes the 
exception object.
Attributes
None.
Associations
 exception : InputPin [1..1] An input pin whose value becomes an exception object.
Semantics
When a raise exception action is executed, the value on the input pin is raised as an exception. The value may be copied in thi s 
process, so identity may not be preserved. Raising the exception terminates the immediately containing structured node or activity and begins a search of enclosing nested scopes for an exception handler that matches the type of the exception object.  
See “ExceptionHandler” on page 322 for details of handling exceptions.
Notation
See Action.
Examples
Rationale
Raise exception action allows models to generate exceptions. Otherwise the only exception types would be predefined built-in 
exception types, which would be too restrictive.
Changes from previous UML
RaiseExceptionAction replaces JumpAction from UML 1.5. Their behavior is essentially the same, except that it is no longer needed for performing simple control constructs such as break and continue.
UML Superstructure 2.0 Draft Adopted Specification        24311.3.26 ReadExtentAction
Description
(CompleteActions) ReadExtentAction is an action that retrieves the current instances of a classifier.
Attributes
None.
Associations
 classifier : Classifier [1..1] The classifier whose instances are to be retrieved.
 result : OutputPin [1..1] The runtime instances of the classifier.
Constraints
[1]  The type of the result output pin is the classifier.
[2] The multiplicity of the result output pin is “0..*”.
self.result.multiplicity.is(0,#null)
Semantics
The extent of a classifier is the set of all instances of a classifier that exist at any one time. 
Semantic Variation Point
It is not generally practical to require that reading the extent produce all the instances of the classifier that exist in the entire 
universe. Rather, an execution engine typically manages only a limited subset of the total set of instances of any classifier a nd 
may manage multiple distributed extents for any one classifier. It is not formally specified which managed extent is actually read by a ReadExtentAction.
Notation
None.
Examples
None.
Rationale
ReadExtentAction is introduced to provide access to the runtime instances of a classifier.
Changes from previous UML
ReadExtentAction is unchanged from UML 1.5.
11.3.27 ReadIsClassifiedObjectAction
(CompleteActions) ReadIsClassifiedObjectAction is an action that determines whether a runtime object is classified by a given classifier.
244                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
This action tests the classification of an object against a given class. It can be restricted to testing direct instances.
Attributes
 isDirect : Boolean [1..1] Indicates whether the classifier must directly classify the input object. The default value is 
false .
Associations
 classifier : Classifier [1..1] The classifier against which the classification of the input object is tested.
 object : InputPin [1..1] Holds the object whose classification is to be tested. (Specializes Action.input .)
 result : OutputPin [1..1] After termination of the action, will hold the result of the test. (Specializes Action.output .)
Constraints
[1]  The multiplicity of the input pin is 1..1.
self.argument.multiplicity.is(1,1)
[2] The input pin has no type.
self.argument.type->size() = 0
[3] The multiplicity of the output pin is 1..1.
self.result.multiplicity.is(1,1)
[4] The type of the output pin is Boolean
self.result.type = Boolean
Semantics
The action returns true if the input object is classified by the specified classifier. It returns true if the isDirect  attribute is false  
and the input object is classified by the specified classifier, or by one of its (direct or indirect) descendents. Otherwise, t he 
action returns false .
Notation
None.
Examples
None.
Rationale
ReadisClassifiedObjectAction is introduced for run-time type identification.
Changes from previous UML
ReadisClassifiedObjectAction is unchanged from UML 1.5.
11.3.28 ReadLinkAction
ReadLinkAction is a link action that navigates across associations to retrieve objects on one end.
UML Superstructure 2.0 Draft Adopted Specification        245Description
This action navigates an association towards one end, which is the end that does not have an input pin to take its object (the 
“open” end). The objects put on the result output pin are the ones participating in the association at the open end, conforming  
to the specified qualifiers, in order if the end is ordered. The semantics is undefined for reading a link that violates the navigability or visibility of the open end.
Attributes
None.
Associations
 result : OutputPin [0..*] (Specialized from Action:output) The pin on which are put the objects participating in the 
association at the end not specified by the inputs.
Constraints
[1]  Exactly one link-end data specification (the “open” end) must not have an end object input pin.
self.endData->select(ed | ed.value->size() = 0)->size() = 1
[2] The type and ordering of the result output pin are same as the type and ordering of the open association end.
let openend : AssociationEnd = self.endData->select(ed | ed.value->size() = 0)->asSequence()->first().end in
self.result.type = openend.typeand self.result.ordering = openend.ordering
[3] The multiplicity of the open association end must be compatible with the multiplicity of the result output pin.
let openend : AssociationEnd = self.endData->select(ed | ed.value->size() = 0)->asSequence()->first().end in
openend.multiplicity.compatibleWith(self.result.multiplicity)
[4] The open end must be navigable.
let openend : AssociationEnd = self.endData->select(ed | ed.value->size() = 0)->asSequence()->first().end in
openend.isNavigable = #true
[5] Visibility of the open end must allow access to the object performing the action.
let host : Classifier = self.activity().hostClassifier() inlet openend : AssociationEnd = self.endData->select(ed | ed.value->size() = 0)->asSequence()->first().end in
openend.visibility = #public
or self.endData->exists(oed | not oed.end = openend
and (host = oed.end.participant
 or (openend.visibility = #protected
and host.allSupertypes->includes(oed.end.participant))))
Semantics
Navigation of a binary association requires the specification of the source end of the link.The target end of the link is not 
specified. When qualifiers are present, one navigates to a specific end by giving objects for the source end of the association  
and qualifier values for all the ends. These inputs identify a subset of all the existing links of the association that match t he end 
objects and qualifier values. The result is the collection of objects for the end being navigated towards, one object from each  
identified link.
In a ReadLinkAction, generalized for n-ary associations, one of the link-end data must have an unspecified object (the “open” end). The result of the action is a collection of objects on the open end of links of the association, such that the links have  the 
given objects and qualifier values for the other ends and the given qualifier values for the open end. This result is placed on  the 
output pin of the action, which has a type and ordering given by the open end. The multiplicity of the open end must be compatible with the multiplicity of the output pin. For example, the modeler can set the multiplicity of this pin to support multiple values even when the open end only allows a single value. This way the action model will be unaffected by changes 
246                 UML Superstructure 2.0 Draft Adopted Specificationin the multiplicity of the open end. The semantics are defined only when the open end is navigable, and visible to the host 
object of the action.
Notation
None.
Examples
Rationale
ReadLinkAction is introduced to navigate across links.
Changes from previous UML
ReadLinkAction is unchanged from UML 1.5.
11.3.29 ReadLinkObjectEndAction
(CompleteActions) ReadLinkObjectEndAction is an action that retrieves an end object from a link object.
Description
This action reads the object on an end of a link object. The association end to retrieve the object from is specified staticall y, 
and the link object to read is provided on the input pin at run time.
Attributes
None.
Associations
 end : Property [1..1] Link end to be read.
 object : InputPin [1..1] (Specialized from Action:input) Gives the input pin from which the link object is 
obtained.
 result : OutputPin [1..1] Pin where the result value is placed
Constraints
[1]  The property must be an association end.
self.end.association->size = 1
[2] The association of the association end must be an association class.
self.end.Association.oclIsKindOf(AssociationClass)
[3] The ends of the association must not be static.
self.end.association.end->forall(oclIsKindOf(NavigableEnd) implies isStatic = #false)
[4] The type of the object input pin is the association class that owns the association end.
self.object.type = self.end.association
[5] The multiplicity of the object input pin is “1..1”.
self.object.multiplicity.is(1,1)
[6] The type of the result output pin is the same as the type of the association end.
UML Superstructure 2.0 Draft Adopted Specification        247self.result.type = self.end.type
[7] The multiplicity of the result output pin is 1..1. 
self.result.multiplicity.is(1,1)
Semantics
Notation
None.
ExamplesRationale
ReadLinkObjectEndAction is introduced to navigate from a link object to its end objects.
Changes from previous UML
ReadLinkObjectEndAction is unchanged from UML 1.5.
11.3.30 ReadLinkObjectEndQualifierAction
(CompleteActions) ReadLinkObjectEndAction is an action that retrieves a qualifier end value from a link object.
Description
This action reads a qualifier value or values on an end of a link object. The association end to retrieve the qualifier from is  
specified statically, and the link object to read is provided on the input pin at run time.
Attributes
None.
Associations
 qualifier : Property [1..1] The attribute representing the qualifier to be read.
 object : InputPin [1..1] (Specialized from Action:input) Gives the input pin from which the link object is 
obtained.
 result : OutputPin [1..1] Pin where the result value is placed
Constraints
[1]  The qualifier attribute must be a qualifier attribute of an association end.
self.qualifier.associationEnd->size() = 1
[2] The association of the association end of the qualifier attribute must be an association class.
self.qualifier.associationEnd.association.oclIsKindOf(AssociationClass)
[3] The ends of the association must not be static.
self.qualifier.associationEnd.association.end->forall(oclIsKindOf(NavigableEnd) implies isStatic = #false)
[4] The type of the object input pin is the association class that owns the association end that has the given qualifier attribu te.
self.object.type = self.qualifier.associationEnd.association
248                 UML Superstructure 2.0 Draft Adopted Specification[5] The multiplicity of the qualifier attribute is 1..1.
self.qualifier.multiplicity.is(1,1)
[6] The multiplicity of the object input pin is “1..1”.
self.object.multiplicity.is(1,1)
[7] The type of the result output pin is the same as the type of the qualifier attribute.
self.result.type = self.qualifier.type
[8] The multiplicity of the result output pin is “1..1”.
self.result.multiplicity.is(1,1)
Semantics
Notation
None.
ExamplesRationale
ReadLinkObjectEndQualifierAction is introduced to navigate from a link object to its end objects.
Changes from previous UML
ReadLinkObjectEndQualifierAction is unchanged from UML 1.5, except the name was corrected from 
ReadLinkObjectQualifierAction.
11.3.31 ReadSelfAction
ReadSelfAction is an action that retrieves the host object of an action.
Description
Every action is ultimately a part of some activity, which is in turn is optionally attached in some way to the specification of  a 
classifier—for example as the body of a method or as part of a state machine. When the activity executes, it does so in the context of some specific host instance of that classifier. This action produces this host instance, if any, on its output pin. The 
type of the output pin is the classifier to which the activity is associated in the user model.
Attributes
None.
Associations
 result : OutputPin [1..1] (Specialized from Action:output) Gives the output pin on which the hosting object is 
placed.
Constraints
[1]  The action must be contained in an activity that has a host classifier.
self.activity().hostClassifier()->size() = 1
UML Superstructure 2.0 Draft Adopted Specification        249[2] If the action is contained in an activity that is acting as the body of a method, then the operation of the method must not be
static.
let hostelement : Element = self.activity().hostElement() in
not hostelement.oclIsKindOf(Method)
or hostelement.oclAsType(Method).specification.isStatic = #false
[3] The type of the result output pin is the host classifier.
self.result.type = self.activity().hostClassifier()
[4] The multiplicity of the result output pin is “1..1”.
self.result.multiplicity.is(1,1)
Semantics
The semantics is undefined for activities that have no context object.
Notation
None.
Examples
Rationale
ReadSelfAction is introduced to provide access to the context object when it is not available as a parameter.
Changes from previous UML
ReadSelfAction is unchanged from UML 1.5.
11.3.32 ReadStructuralFeatureAction
ReadStructuralFeatureAction is a structural feature action that retrieves the values of a structural feature.
Description
This action reads the values of a structural feature, in order if the structural feature is ordered.
Attributes
None.
Associations
 result : OutputPin [1..1] (Specialized from Action:output) Gives the output pin on which the result is put.
Constraints
[1]  The type and ordering of the result output pin are the same as the type and ordering of the structural feature.
self.result.type = self.structuralFeature.type
and self.result.ordering = self.structuralFeature.ordering
[2] The multiplicity of the structural feature must be compatible with the multiplicity of the output pin.
self.structuralFeature.multiplicity.compatibleWith(self.result.multiplicity)
250                 UML Superstructure 2.0 Draft Adopted SpecificationSemantics
The values of the structural feature of the input object are placed on the output pin of the action. The type and ordering of t he 
output pin are the same as the specified structural feature. The multiplicity of the structural feature must be compatible with  
the multiplicity of the output pin. For example, the modeler can set the multiplicity of this pin to support multiple values ev en 
when the structural feature only allows a single value. This way the action model will be unaffected by changes in the multiplicity of the structural feature.
Notation
None.
Examples
Rationale
ReadStructuralFeatureAction is introduced to retrieve the values of a structural feature.
Changes from previous UML
ReadStructuralFeatureAction is new in UML 2.0. It generalizes ReadAttributeAction from UML 1.5.
11.3.33 ReadVariableAction
ReadVariableAction is a variable action that retrieves the values of an variable.
Description
This action reads the values of a variables, in order if the variable is ordered.
Attributes
None.
Associations
 result : OutputPin [1..1] (Specialized from Action:output) Gives the output pin on which the result is put.
Constraints
[1]  The type and ordering of the result output pin of a read-variable action are the same as the type and ordering of the vari -
able.
self.result.type =self.variable.type
and self.result.ordering = self.variable.ordering
[2] The multiplicity of the variable must be compatible with the multiplicity of the output pin.
self.variable.multiplicity.compatibleWith(self.result.multiplicity)
Semantics
The values of the variable are placed on the output pin of the action. The type and ordering of the output pin are the same as the 
specified variable. The multiplicity of the variable must be compatible with the multiplicity of the output pin. For example, t he 
modeler can set the multiplicity of this pin to support multiple values even when the variable only allows a single value. This  
way the action model will be unaffected by changes in the multiplicity of the variable.
UML Superstructure 2.0 Draft Adopted Specification        251Notation
None.
Examples
Rationale
ReadVariableAction is introduced to retrieve the values of a variables.
Changes from previous UML
ReadVariableAction is unchanged from UML 1.5.
11.3.34 ReclassifyObjectAction
(CompleteActions) ReclassifyObjectAction is an action that changes which classifiers classify an object.
Description
ReclassifyObjectAction adds given classifier to an object and removes given classifiers from that object. Multiple classifiers 
may be added and removed at a time.
Attributes
 isReplaceAll : Boolean [1..1] Specifies whether existing classifiers should be removed before adding the new classifi-
ers. The default value is false .
Associations
 object : InputPin [1..1] Holds the object to be reclassified. (Specializes Action.input .)
 newClassifier : Classifier [0..*] A set of classifiers to be added to the classifiers of the object. oldClassifier : Classifier [0..*] A set of classifiers to be removed from the classifiers of the object.
Constraints
[1]  None of the new classifiers may be abstract.
not self.newClassifier->exists(isAbstract = true)
[2] The multiplicity of the input pin is 1..1.
self.argument.multiplicity.is(1,1)
[3] The input pin has no type.
self.argument.type->size() = 0
Semantics
After the action completes, the input object is classified by its existing classifiers and the “new” classifiers given to the a ction; 
however, the “old” classifiers given to the actions do not any longer classify the input object. The identity of the object is preserved, no behaviors are executed, and no initial expressions are evaluated. “New” classifiers replace existing classifiers in 
an atomic step, so that structural feature values and links are not lost during the reclassification, when the “old” and “new” classifiers have structural features and associations in common.
Neither adding a classifier that duplicates an already existing classifier, nor removing a classifier that is not classifying t he 
252                 UML Superstructure 2.0 Draft Adopted Specificationinput object, has any effect. Adding and removing the same classifiers has no effect.
If isReplaceAll  is true, then the existing classifiers are removed before the “new” classifiers are added, except if the “new” 
classifier already classifies the input object, in which case this classifier it is not removed. If isReplaceAll  is false , then adding 
an existing value has no effect. 
It is an error, if any of the “new” classifiers is abstract or if all classifiers are removed from the input object.
Notation
None.
Examples
None.
Rationale
ReclassifyObjectAction is introduced to change the classifiers of an object.
Changes from previous UML
ReclassifyObjectAction is unchanged from UML 1.5.
11.3.35 RemoveStructuralFeatureValueAction
RemoveStructuralFeatureValueAction is a write structural feature action that removes values from structural features.
Description
The object to access is specified dynamically, by referring to an input pin on which the object will be placed at runtime. The type of the value of this pin is the classifier that owns the specified structural feature, and the value’s multiplicity is 1.. 1.
Attributes
None.
Associations
None.
Constraints
None.
Semantics
Structural features are potentially multi-valued. Removing a value succeeds even when it violates the minimum multiplicity. 
Removing a value that does not exist has no effect.
The semantics is undefined for removing an existing value for a structural feature with settability addOnly. The semantics is undefined for removing an existing value of a structural feature with settability readOnly after initialization of the owning object.
UML Superstructure 2.0 Draft Adopted Specification        253Notation
None.
Examples
Rationale
RemoveStructuralFeatureValueAction is introduced to remove structural feature values.
Changes from previous UML
RemoveStructuralFeatureValueAction is new in UML 2.0. It generalizes RemoveAttributeValueAction in UML 2.0.
11.3.36 RemoveVariableValueAction
RemoveVaraibleValueAction is a write variable action that removes values from variables.
Description
One value is removed from the set of possible variable values.
Attributes
None.
Associations
None.
Constraints
None.
Semantics
Variables are potentially multi-valued. Removing a value succeeds even when it violates the minimum multiplicity. Removing 
a value that does not exist has no effect.
Notation
None.
Examples
Rationale
RemoveVariableValueAction is introduced to remove variable values.
Changes from previous UML
RemoveVariableValueAction is unchanged from UML 1.5.
254                 UML Superstructure 2.0 Draft Adopted Specification11.3.37 ReplyAction
(CompleteActions) ReplyAction is an action that accepts a set of return values and a token containing return information 
produced by a previous accept call action. The reply action returns the values to the caller of the previous call, completing execution of the call.
Attributes
none
Associations
 replyToCall : CallTrigger [1..1]The operation call trigger being replied to.
 replyValue : OutputPin [0..*] A list of pins containing the reply values of the operation. These values are returned to the 
caller. 
 returnInformation : InputPin [1..1]
A pin containing the return information token produced by an earlier AcceptCallAction.
Constraints
[1]  The reply value pins must match the return, out, and inout parameters of the call trigger operation in number, type, and 
order.
Semantics
The execution of a reply action completes the execution of a call that was initiated by a previous AcceptCallAction. The two are connected by the returnInformation token, which is produced by the AcceptCallAction and consumed by the ReplyAction. The information in this token is used by the execution engine to return the reply values to the caller and to complete executio n 
of the original call. The details of transmitting call requests, encoding return information, and transmitting replies are opaq ue 
and unavailable to models, therefore they need not be and are not specified in this document.
Return information may be copied, stored in objects, and passed around, but it may only be used in a reply action once. If the same return information token is supplied to a second ReplyAction, the execution is in error and the behavior of the system is unspecified. It is not intended that any profile give any other meaning the the return information. The operation specified by the call trigger must be consistent with the information returned at runtime.
If the return information is lost to the execution or if a reply is never made, the caller will never receive a reply and there fore 
will never complete execution. This is not inherently illegal but it represents an unusual situation at the very least.
11.3.38 SendObjectAction
SendObjectAction is an action that transmits an object to the target object, where it may invoke behavior such as the firing of  
state machine transitions or the execution of an activity. The value of the object is available to the execution of invoked behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor.
Attributes
None
UML Superstructure 2.0 Draft Adopted Specification        255Associations
 request: InputPin [1] The signal request object, which is transmitted to the target object as a signal. The signal 
object may be copied in transmission, so identity might not be preserved. (Specialized from InvocationActon.argument )
 target: InputPin [1] The target object to which the signal is sent.
Constraints
None.
Semantics
[1]  When all the control and data flow prerequisites of the action execution are satisfied, the object on the input pin is tra ns-
mitted to the target object. The target object may be local or remote. The object on the input pin may be copied during transmission, so identity might not be preserved. The manner of transmitting the object, the amount of time required to transmit it, the order in which the transmissions reach the various target objects, and the path for reaching the target objects are undefined.
[2] When a transmission arrives at a target object, it may invoke behavior in the target object. The effect of receiving a objec t
is specified in Chapter 13, “Common Behaviors”. Such effects include executing activities and firing state machine tran-sitions.
[3] A send object action receives no reply from the invoked behavior; any attempted reply is simply ignored, and no trans-
mission is performed to the requestor.
Notation
See Action.
Presentation Option
If the activity in which a send object action is used will always send a signal, then the SendSignalAction notation can be used .
Examples
None
Rationale
Sends a signal to a specified target object.
Changes from previous UML
SendObjectAction is new in UML 2.0.
11.3.39 SendSignalAction
SendSignalAction is an action that creates a signal instance from its inputs, and transmits it to the target object, where it 
may cause the firing of a state machine transition or the execution of an activity. The argument values are available to the 
execution of associated behaviors. The requestor continues execution immediately. Any reply message is ignored and is 
not transmitted to the requestor. If the input is already a signal instance, use SendObjectAction.
256                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
None
Associations
 signal: Signal [1] The type of signal transmitted to the target object.
 target: InputPin [1] The target object to which the signal is sent.
Constraints
[1]  The number and order of argument pins must be the same as the number and order of attributes in the signal.
The type, ordering, and multiplicity of an argument pin must be the same as the corresponding attribute of the signal.
Semantics
[1]  When all the control and data flow prerequisites of the action execution are satisfied, a signal instance of the type spec ified 
by signal  is generated from the argument values and his signal instance is transmitted to the identified target object. The 
target object may be local or remote. The signal instance may be copied during transmission, so identity might not be pre-served.The manner of transmitting the signal object, the amount of time required to transmit it, the order in which the transmissions reach the various target objects, and the path for reaching the target objects are undefined.
[2] When a transmission arrives at a target object, it may invoke behavior in the target object. The effect of receiving a signa l
object is specified in Chapter 13, “Common Behaviors”. Such effects include executing activities and firing state machinetransitions.
[3] A send signal action receives no reply from the invoked behavior; any attempted reply is simply ignored, and no trans-
mission is performed to the requestor.
Notation
A send signal action is notated with a convex pentagon. The symbol may optionally have a input pin for the target object but this is often omitted. The symbol has a control output only.
 
Examples
Figure 166 shows part of an order-processing workflow in which two signals are sent. An order is created (in response to some previous request that is not shown in the example). A signal is sent to the warehouse to fill and ship the order. Then an invoi ce Figure 165 - Send signal notationReceive signal actionSignal
Type
UML Superstructure 2.0 Draft Adopted Specification        257is created and sent to the customer. 
Rationale
Sends a signal to a specified target object.
Changes from previous UML
Same as UML 1.5.
11.3.40 StartOwnedBehaviorAction
Description
(CompleteActions) StartOwnedBehaviorAction is an action that starts the owned behavior of the input.
Attributes
None.
Associations
 object : InputPin [1..1] Holds the object on which to start the owned behavior. (Specializes Action.input .)
Constraints
[1]  The input pin has no type.
self.argument.type->size() = 0
Semantics
When a StartOwnedBehaviorAction is invoked, it initiates the owned behavior of the classifier of the input object. If the 
behavior has already been initiated, this action has no effect.
Notation
None.
Examples
None.
Rationale
This action is provided to permit the explicit initiation of owned behaviors, such as state machines and code, in a detailed, l ow-Figure 166 - Signal node notationsCreate
OrderFill order requestCreate
invoiceNotify customer
258                 UML Superstructure 2.0 Draft Adopted Specificationlevel “raw” specification of behavior.
Changes from previous UML
StartOwnedBehaviorAction is unchanged from UML 1.5.
11.3.41 StructuralFeatureAction
StructuralFeatureAction is an abstract class for all structural feature actions.
Description
This abstract action class statically specifies the structural feature being accessed.
The object to access is specified dynamically, by referring to an input pin on which the object will be placed at runtime. The 
type of the value of this pin is the classifier that owns the specified structural feature, and the value’s multiplicity is 1.. 1.
Attributes
None.
Associations
 structuralFeature : StructuralFeature [1..1]Structural feature to be read.
 object : InputPin [1..1] (Specialized from Action:input) Gives the input pin from which the object whose struc-
tural feature is to be read or written is obtained. 
Constraints
[1]  The structural feature must have not be static.
self.structuralFeature.isStatic = #false
[2] The type of the object input pin is the same as the classifier of the object passed on this pin.
[3] The multiplicity of the input pin must be 1..1.
self.object.multiplicity.is(1,1)
[4] Visibility of structural feature must allow access to the object performing the action.
let host : Classifier = self.activity().hostClassifier() in
self.structuralFeature.visibility = #public
or host = self.structuralFeature.featuringClassifier.type
or (self.structuralFeature.visibility = #protected and host.allSupertypes
->includes(self.structuralFeature.featuringClassifier.type)))
Semantics
A structural feature action operates on a statically specified structural feature of some classifier. The action requires an ob ject 
on which to act, provided at runtime through an input pin. The semantics is undefined for accessing a structural feature that violates its visibility. The semantics for static features is undefined.
The structural features of an object may change over time due to dynamic classification. However, the structural feature specified in a structural feature action is inherited from a single classifier, and it is assumed that the object passed to a structural feature action is classified by that classifier directly or indirectly. The structural feature is referred to as a u ser model 
element, so it is uniquely identified, even if there are other structural features of the same name on other classifiers.
UML Superstructure 2.0 Draft Adopted Specification        259Notation
None.
Examples
Rationale
StructuralFeatureAction is introduced for the abstract aspects of structural feature actions.
Changes from previous UML
StructuralFeatureAction is new in UML 2.0. It generalizes AttributeAction in UML 1.5.
11.3.42 TestIdentityAction
TestIdentifyAction is an action that tests if two values are identical objects.t
Description
This action returns true if the two input values are the same identity, false if they are not.
Attributes
None.
Associations
 first: InputPin [1..1]. (Specialized from Action:input) Gives the pin on which an object is placed.
 result: OutputPin [1..1] (Specialized from Action:output) Tells whether the two input objects are identical. second: InputPin [1..1] (Specialized from Action:input) Gives the pin on which an object is placed.
Constraints
[1]  The input pins have no type.
self.first.type->size() = 0
and self.second.type->size() = 0
[2] The multiplicity of the input pins is 1..1.
self.first.multiplicity.is(1,1)and self.second.multiplicity.is(1,1)
Semantics
When all control and data flow prerequisites of the action have been satisfied, the input values are obtained from the input pi ns 
and made available to the computation. If the two input values represent the same object (regardless of any implementation-level encoding), the value true is placed on the output pin of the action execution, otherwise the value false is placed on the  
output pin. The execution of the action is complete and satisfies appropriate control and data flow prerequisites.
Notation
None.
260                 UML Superstructure 2.0 Draft Adopted SpecificationExamples
Rationale
TestIdentityAction is introduced to tell when two values refer to the same object.
Changes from previous UML
TestIdentityAction is unchanged from UML 1.5.
11.3.43 VariableAction
Description
VariableAction is an abstract class for actions that operate on a statically specified variable.
Attributes
None.
Associations
 variable : Variable [1..1] Variable to be read.
Constraints
[1]  The action must be in the scope of the variable.
self.variable.isAccessibleBy(self)
Semantics
Variable action is an abstract metaclass. For semantics see its concrete subtypes.
Notation
None.
ExamplesRationale
VariableAction is introduced for the abstract aspects of variable actions.
Changes from previous UML
VariableAction is unchanged from UML 1.5.
11.3.44 WriteStructuralFeatureAction
WriteStructuralFeatureAction is an abstract class for structural feature actions that change structural feature values.
Description
A write structural feature action operates on a structural feature of an object to modify its values. It has an input pin on wh ich 
the value that will be added or removed is put. Other aspects of write structural feature actions are inherited from 
UML Superstructure 2.0 Draft Adopted Specification        261StructuralFeatureAction.
Attributes
None.
Associations
 value : InputPin [1..1] (Specialized from Action:input) Value to be added or removed from the structural feature.
Constraints
[1]  The type input pin is the same as the classifier of the structural feature.
self.value.type = self.structuralFeature.featuringClassifier
[2] The multiplicity of the input pin is 1..1.
self.value.multiplicity.is(1,1)
Semantics
None. Notation
None.
Examples
Rationale
WriteStructuralFeatureAction is introduced to abstract aspects of structural feature actions that change structural feature 
values.
Changes from previous UML
WriteStructuralFeatureAction is new in UML 2.0. It generalizes WriteAttributeAction in UML 1.5.
11.3.45 WriteLinkAction
WriteLinkAction is an abstract class for link actions that create and destroy links.
Description
A write link action takes a complete identification of a link and creates or destroys it.
Attributes
None.
Associations
None.
Constraints
[1]  All end data must have exactly one input object pin.
self.endData.forall(value->size() = 1)
262                 UML Superstructure 2.0 Draft Adopted SpecificationSemantics
See children of WriteLinkAction.
Notation
None.
Examples
Rationale
WriteLinkAction is introduced to navigate across links.
Changes from previous UML
WriteLinkAction is unchanged from UML 1.5.
11.3.46 WriteVariableAction
WriteVariableAction is an abstract class for variable actions that change variable values.
Description
A write variable action operates on a variable to modify its values. It has an input pin on which the value that will be added or 
removed is put. Other aspects of write variable actions are inherited from VariableAction.
Attributes
None.
Associations
 value : InputPin [1..1] (Specialized from Action:input) Value to be added or removed from the variable.
Constraints
[1]  The type input pin is the same as the type of the variable.
self.value.type = self.variable.type
[2] The multiplicity of the input pin is 1..1.
self.value.multiplicity.is(1,1)
Semantics
See children of WriteVariableAction.
Notation
None.
Examples
Rationale
WriteVariableAction is introduced to abstract aspects of structural feature actions that change variable values.
UML Superstructure 2.0 Draft Adopted Specification        263Changes from previous UML
WriteVariableAction is unchanged from UML 1.5.
11.4 Diagrams
The following sections describe the graphic nodes for actions. The notation for actions is optional. A textual notation may be 
used instead.
Graphic Nodes
The graphic nodes for actions are shown in Table 10.
Table 10 - Graphic nodes included in activity diagrams
NODE TYPE NOTATION REFERENCE
AcceptEventAction See “AcceptEventAction” on page 217
SendSignalAction See “SendSignalAction” on page 255.
264                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        26512 Activities
12.1 Overview
Activity modeling emphasizes the sequence and conditions for coordinating lower-level behaviors, rather than which 
classifiers own those behaviors. These are commonly called control flow and object flow models. The actions coordinated by activity models can be initiated because other actions finish executing, because objects and data become available, or because events occur external to the flow.
Actions and activities
An action execution  corresponds to the execution of a particular action within an activity. Similarly, an activity  execution  is 
the execution of an activity, ultimately including the executions of actions within it. Each action in an activity may execute zero, one, or more times for each activity execution. Execution is not instantaneous, but takes place over a period of time. The UML does not provide for the specification of a time metric, but only describes sequences of executions. Activities and other groupings of actions must be executed in a number of steps, including control of the execution of nested actions.
At the minimum, actions need access to data, they need to transform and test data, and actions may require sequencing. The activities specification (at the higher compliance levels) allows for several (logical) threads of control executing at once an d 
synchronization mechanisms to ensure that activities execute in a specified order. Semantics based on concurrent execution can then be mapped easily into a distributed implementation. However, the fact that the UML allows for concurrently executing objects does not necessarily imply a distributed software structure. Some implementations may group together objects into a single task and execute sequentially—so long as the behavior of the implementation conforms to the sequencing constraints of the specification.
There are potentially many ways of implementing the same specification, and any implementation that preserves the information content and behavior of the specification is acceptable. Because the implementation can have a different structure from that of the specification, there is a mapping between the specification and its implementation. This mapping need not be one-to-one: an implementation need not even use object-orientation, or it might choose a different set of classes from the original specification. 
The mapping may be carried out by hand by overlaying physical models of computers and tasks for implementation purposes, or the mapping could be carried out automatically. This specification neither provides the overlays, nor does it provide for code generation explicitly, but the specification makes both approaches possible. 
See the “Activity” and “Action” metaclasses for more introduction and semantic framework.
BasicActivities
The basic level supports modeling of traditional sequential flow charts. It includes control sequencing, but explicit forks and  
joins of control are not supported at this level. Decisions and merges are supported at this level and need not be well structured.
IntermediateActivities
The intermediate level supports modeling of activity diagrams that include concurrent control and data flow. It supports modeling similar to traditional Petri nets with queuing. It requires the basic level.
The intermediate and structured levels are orthogonal. Either can be used without the other or both can be used to support modeling that includes both concurrency and structured control constructs.
266                 UML Superstructure 2.0 Draft Adopted SpecificationCompleteActivities
The complete level adds constructs that enhance the lower level models, such as edge weights and streaming.
StructuredActivities
The structured level supports modeling of traditional structured programming constructs, such as loops and conditionals, as an 
addition the basic nonstructured activity sequencing. It requires the basic level. It is compatible with the intermediate and complete levels.
CompleteStructuredActivities
This level adds support for data flow output pins of conditionals and loops. It is intended to be used in conjunction with the intermediate layer, which supports explicit concurrency, but there is no actual dependency between the levels.
ExtraStructuredActivities
The extra structure level supports exception handling as found in traditional programming languages and invocation of behaviors on sets of values. It requires the structured level.
UML Superstructure 2.0 Draft Adopted Specification        26712.2 Abstract Syntax
Figure 175 shows the dependencies of the activity packages.
Figure 175 - Dependencies of the Activity packagesCompleteActivities ExtraStruc turedActiv
itiesIntermediateAc tivities
<<me r ge >>
CompleteStructuredActivitiesKernel
(from  Cl asses)
StructuredActivities
<<merge>><<merge>>Bas icActivities
<<merge>><<merge>>Bas icBehaviors
(from CommonBehaviors )
<<merge>>
<<merge>>Behavior StateMachines
(from StateMachines )
<<me rge >>
268                 UML Superstructure 2.0 Draft Adopted SpecificationClass Diagrams (BasicActivities)
Figure 176 - NodesCont ro lNo de ExecutableNode
Pin
Parameter
(from Kernel)ActivityParameterNode
1 +parameter 1Activity
(fr om  Ba si c B eh avi or s)RedefinableElem ent
(from Kernel)
Activity
is ReadOnly : Boolean = false
ObjectNode
Action0..*0..1
+action0..*
{ordered, 
subsets node}0..1
Classifier
(from  Kernel)0..1+/context
0..1TypedElem ent
(f rom Ke r nel)ActivityNode
*0..1+node
*{subsets ownedElement}
+a ctivity0..1
{subsets owner}
*+r ede fi ned Ele me nt
{redefines redefinedElement}*
UML Superstructure 2.0 Draft Adopted Specification        269Figure 177 - FlowsCont ro lFl ow ObjectFlowRedefinableElem ent
(from  Kernel)
{default value is true}ActivityNodeActivity
ValueSpecification
(from  Kernel)ActivityEdge
*1 +outgoing
*+source11
*+target1+ i n c o m i n g
**0..1+edge
*{subsets ownedElement}
+activity0..1
{subsets owner}
1
+guard1
{subsets ownedElement}*
+redefinedElement*
{redefines redefinedElement}
270                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 178 - Actions
Figure 179 - Control nodesPin
Ou tp utPi n InputPin
Action
effect : String1*
1+/output *
{order ed, union,
subsets 
ownedElement}*
1+/input *
{ordered, union,
subsets  
ownedElement}
1ValueSpecification
(from Kernel)ValuePin
10..1
+val ue 10..1
ControlNode
InitialNode FinalNode
ActivityFinalNodeMergeNode
Behavior
(from  BasicBehaviors)DecisionNode
0..1*
+decisionInput0..1*
UML Superstructure 2.0 Draft Adopted Specification        271Class Diagrams (IntermediateActivities)Figure 180 - Groups
Figure 181 - Object nodes (IntermediateActivities)Elem ent
(from Kernel)
ActivityEdge ActivityNodeActivity Grou p*
0..1+/subgroup
*{union, subsets ownedElement}
+/superGroup0..1
{union, subsets owner}
**
+edgeContents*+inGroup*
**
+nodeContents*+inGroup*Activity
*0..1
+group
*{subsets ownedElement}+activity
0..1{subsets owner}
ObjectNode
(from  BasicActivities)
CentralBufferNode
272                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 182 - Controls (IntermediateActivities)Fork Node JoinNodeControlNode
(from  BasicActivities)
FlowFinalNodeFinalNode
(from  Bas icActivities)
UML Superstructure 2.0 Draft Adopted Specification        273Class Diagrams (CompleteActivities)Figure 183 - Partitions
Figure 184 - Elements (CompleteActivities)ActivityEdge ActivityNodeActivit yPart it io n
isDimension : Boolean = fals e
isExternal : Boolean = false0..1 *+represents
0..1 **
0..1+subgroup
*{redefines  s ubgroup}
+superPartition0..1
{subsets s uperGroup}
*
+edgeContents
{redefines  edgeContents}+inPar titi on*
{s ubs ets  inGroup}*
+nodeContents
{redefines nodeContents }+inPartition*
{s ubs ets  inGroup}Nam edElem ent
(from  Kernel)
Elem ent
(f rom Kernel)ActivityGroup
(from  BasicActivities)
Activity
(from BasicActivities)
Activity
is SingleExecution : Boolean
274                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 185 - Constraints (CompleteActivities)
Figure 186 - Flows (CompleteActivities)Constraint
(from Kernel)Action
* 0..1
+loc alP ostco ndition*
{ s ub s et s ow n edEl em en t}0..1*0..1+localPrecondition
*{s ubs ets ownedElement}
0..1Action
(from  Bas icActivitie s)
ActivityEdge
(f rom BasicAct i vitie s)
ObjectFlowEffectKi nd<<enumeration>>
create
read
updatedeleteObjectFlow
(from BasicActivities)
{ default value is  1 }ValueSp ecifica tion
(from  Kernel)ActivityEdge
1 0. .1+wei ght
1{s ubs ets  ownedElement}
0. .1Behavior
(from  B a si c B eh av i or s )ObjectFlow
effect : ObjectFlowEffectKind
isMulticas t : Boolean = false
isMultireceive : Boolean = false0..1*
+trans formation0..1*
0..1 *
+selection0..1 *
UML Superstructure 2.0 Draft Adopted Specification        275Figure 187 - Object nodes (CompleteActivities)
Figure 188 - Data stores
Figure 189 - Parameter setsOb je ctNode
(from BasicActivities)
{ default value is null, 
which means  unlimited }
ObjectNodeOrderingKind
unorderedorderedLIFOFIFO<<enumeration>>
State
(from BehaviorStateMachines)ValueSpecification
(from Kernel)
Behavior
(f rom BasicBehavior s)ObjectNode
ordering : ObjectNodeOrderingKind = FIFO
*
**
+inState *1 0..1
+upperBound1
{s ubs ets  ownedElement}0..1
0..1*
+s election
0..1*
DataStoreNodeCentralBufferNode
(from Activities-int)
Nam edElem ent
(from  Kernel)
ParameterSetParameter
is Exception : Boolean = false
is Stream : Boolean = fals e * 1..*+parameterInSet
*+parameterSet
1..*Parameter
(from Kernel)
276                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 190 - Control nodes (CompleteActivities)
Figure 191 - Interruptible regionsJoinNode
(from IntermediateActiv ities)
{default value is  "and"}ValueSpecification
(from  Kernel)JoinNo de1
+joinSpec1
{s ubs ets  ownedElement}
ActivityGroup
(from  BasicActivities)
ActivityNode
(from  BasicActivities)
ActivityNode ActivityEdgeInterruptibleActivityRegion
+interruptibleRegion
{subsets inGroup}
+nodeContents0+inGroup
+edgeContents0
{redefines edgeContents}*0. .1
+interruptingEdge
*+ interr upt ib leRegi on
0. .1
{subsets 
inGroup}
{redefines nodeContents}
UML Superstructure 2.0 Draft Adopted Specification        277Class Diagrams (StructuredActivities)
Figure 192 - Structured nodesActivityGroup
(from  BasicActivities)TypedElem ent
(from  Kernel)Namespace
(from  Kernel)
ActivityNode
(from  BasicActivities)ConditionalNode
is Determinate : Boolean
is As sured : Boolean
Clause
0..1
*0..1
+bod y **
*+ p re de c e ssor Cl a u se
*
+successorClause
*0..1
*0..1
+tes t *1..*1
+claus e
1..* {s ubs ets  ownedElement}1
OutputPin
(from BasicActivities)10..1
+decider 10..1
ActivityNode
(from  BasicActivities)LoopNode
is Tes tedFirs t : Boolean
10..1
+decid er10..1
0..1
*0..1
+setupPar t
*0..1
*0..1
+bodyPart
*
*0..1
+test*0..1ExecutableNode
( fro m  B a s i cA ct iv i tie s)
Elem ent
(from  Kernel)Variable
ActivityActivityNode
ActivityEdgeStructuredActivityNode1
*+ s c o p e1
{subsets  owner}+variable
*{s ubs ets ownedMember}
0..1*+activity
0..1{redefines activity, 
redefines  activity}
+structuredNode*
{s ubs ets  node, 
s ubs ets  group}0..1 +nodeContents
{redefines  nodeContents }+inStructuredNode
0..1{s ubs ets  inGroup}
0..1+edgeContents
{redefines  edgeContents }+inStructuredNode
0..1{s ubs ets  inGroup}
278                 UML Superstructure 2.0 Draft Adopted SpecificationClass Diagrams (CompleteStructuredActivities)
Figure 193 - Structured nodes (CompleteStructuredActivities)LoopNode
(from  StructuredActiv ities)
Clause
(from  StructuredActiv ities)Condi tio nalNode
(from  StructuredActiv ities)StructuredActivityNode
(from  StructuredActiv ities)
StructuredActivityNode
mustIsolate : BooleanCondi tionalNodeClause
OutputPin
(f rom Ba si c Acti viti es )*0. .1
+result *{ordered,
subsets output}0. .1
OutputPin
(from BasicActivities)**
+bodyOutput**LoopNode
*0..1
+result *{o r de re d ,
subset s  
output}0..1
*0..1
+l oop Var iab le*{ordered,
subset s
ownedElement}0..1
**
+bodyOutput
**Action
(from Bas icActivities)
InputPin
(f r om Ba si c Acti viti es )
*
0..1+l oopVa ri abl eI npu t*
{ordered,
sub set s i np ut} 0..1
UML Superstructure 2.0 Draft Adopted Specification        279Class Diagrams (ExtraStructuredActivities)
Figure 194 - Exceptions
Figure 195 - Expansion regionsExecutableNode
(from BasicActivities)
ObjectNode
(f rom Ba si cA ct ivi tie s)
Classifier
(from Kernel)ExecutableNodeExceptionHandler
1+exceptionInput
1
1..*+exceptionType
1..**1+handler
*{subsets ownedElement}
+protectedNode1
{subsets owner}
1
+handlerBody1Elem ent
(from  Kernel)
StructuredActivityNode
(f rom  Str uc turedActi vit ies )ObjectNode
(from  BasicActiviti...
ExpansionKind<<enumeration>>
parallel
iterative
s treamExpans ionNode Expa ns i onRe gion
mode : Ex pans ionKind1. .*
0..1+inputElement
1. .* +regionAs Input
0..1
0..*0..1
+outputElement0..*
+regionAs Output0..1
280                 UML Superstructure 2.0 Draft Adopted Specification12.3 Class Descriptions
12.3.1 Action
Description
An action is an executable activity node that is the fundamental unit of executable functionality in an activity, as opposed to  
control and data flow among actions. The execution of an action represents some transformation or processing in the modeled system, be it a computer system or otherwise.
An action may have sets of incoming and outgoing activity edges that specify control flow and data flow from and to other 
nodes. An action will not begin execution until all of its input conditions are satisfied. The completion of the execution of a n 
action may enable the execution of a set of successor nodes and actions that take their inputs from the outputs of the action.
In CompleteActivities, action is extended to have pre- and postconditions.
Attributes
 /context : Classifier [1] The classifier that owns the behavior of which this action is a part.
 effect : String [0..1] An optional text specification of the effect of the action. This may be used to indicate the 
behavior of an action without specialization into a subclass, or it may represent a text description of an action that is specialized, either for human understanding or to help code generation.
Associations (BasicActivities)
 /input : InputPin [*] The ordered set of input pins connected to the Action. These are among the total set of 
inputs (other inputs represent constant values).
 /output : OutputPin [*] The ordered set of output pins connected to the Action. The action places its results onto 
pins in this set.
Associations (CompleteActivities)
 localPrecondition : Constraint [0..*] Constraint that must be satisfied when execution is started.
 localPostcondition : Constraint [0..*] Constraint that must be satisfied when executed is completed.
Constraints
none
Operations
[3] activity operates on Action. It returns the activity containing the action.
activity() : Activity;
activity = if self.Activity->size() > 0 then self.Activity else self.group.activity() endif
Semantics
An action execution  represents the run-time behavior of executing an action within a specific activity execution. As Action is 
an abstract class, all action executions will be executions of specific kinds of actions.
The sequencing of actions are controlled by control edges and object flow edges within activities, which carry control and object tokens respectively (see Activity). Except where noted, an action can only begin execution when all incoming control 
UML Superstructure 2.0 Draft Adopted Specification        281edges have tokens, and all input pins have object tokens. The action begins execution by taking tokens from its incoming 
control edges and input pins. When the execution of an action is complete, it offers tokens in its outgoing control edges and output pins, where they are accessible to other actions.
The steps of executing an action are as follows:
[1]  An action execution is created when all its object flow and control flow prerequisites have been satisfied (implicit join) . 
Exceptions to this are listed below. The flow prerequisite is satisfied when all of the input pins are offered tokens and accept them all at once, precluding them from being consumed by any other actions. This ensures that multiple action exe-cutions competing for tokens do not accept only some of the tokens they need to begin, causing deadlock as each execu-tion waits for tokens that are already taken by others.
[2] An action execution consumes the input control and object tokens and removes them from the sources of control edges
and from input pins. The action execution is now enabled and may begin execution.
[3] An action continues executing until it has completed. Most actions operate only on their inputs. Some give access to a
wider context, such as variables in the a containing structured activity node, or the self object, which is the object owningthe activity containing the executing action. The detailed semantic of execution an action and definition of completiondepends on the particular subclass of action.
[4] When completed, an action execution offers object tokens on all its output pins and control tokens on all its outgoing con-
trol edges (implicit fork), and it terminates. Exceptions to this are listed below. The output tokens are now available tosatisfy the control or object flow prerequisites for other action executions.
[5] After an action execution has terminated, its resources may be reclaimed by an implementation, but the details of resource
management are not part of this specification and are properly part of an implementation profile.
See ValuePin for exception to rule for starting action execution.
If a behavior is not reentrant, then no more than one execution of it wil exist at any given time. An invocation of a non-reentrant behavior does not start the behavior when the behavior is already executing. In this case, tokens collect at the inpu t 
pins of the invocation action, if their upper bound is greater than one, or upstream otherwise. An invocation of a reentrant behavior will start a new execution of the behavior with newly arrived tokens, even if the behavior is already executing from tokens arriving at the invocation earlier.
(ExtraStructuredActivities) If an exception occurs during the execution of an action, the execution of the action is abandoned and no regular output is generated by this action. If the action has an exception handler, it receives the exception object as a 
token. If the action has no exception handler, the exception propagates to the enclosing node and so on until it is caught by o ne 
of them. If an exception propagates out of a nested node (action, structured activity node, or activity), all tokens in the nes ted 
node are terminated. The data describing an exception is represented as an object of any class.
(CompleteActivities) Streaming allows an action execution to take inputs and provide outputs while it is executing. During one execution, the action may consume multiple tokens on each streaming input and produce multiple tokens on each streaming output. See Parameter.
(CompleteActivities) Local preconditions and postconditions are constraints that must hold when the execution starts and completes, respectively. They hold only at the point in the flow that they are specified, not globally for other invocations of  the 
behavior at other places in the flow or on other diagrams. Compare to pre- and postconditions on Behavior (in Activities). See semantic variations below for their effect on flow.
Semantic Variation Points
(CompleteActivities) How local pre- and postconditions are enforced is determined by the implementation. For example, violations may detected at compile time or runtime. The effect may be an error that stops the execution or just a warning, and so on. Since local pre and postconditions are modeler-defined constraints, violations do not mean that the semantics of the invocation is undefined as far as UML goes. They only mean the model or execution trace does not conform to the modeler’s 
282                 UML Superstructure 2.0 Draft Adopted Specificationintention (although in most cases this indicates a serious modeling error that calls into question the validity of the model).
See variations in ActivityEdge and ObjectNode.
Notation
Use of action and activity notation is optional. A textual notation may be used instead.
Actions are notated as round-cornered rectangles. The name of the action or other description of it may appear in the symbol. 
See children of action for refinements.  
(CompleteActivities) Local pre- and postconditions are shown as notes attached to the invocation with the keywords «localPrecondition» and «localPostcondition», respectively.
 
Examples
Examples of actions are illustrated below. These perform behaviors called Send Payment and Accept Payment.  Figure 196 - Action
Figure 197 - Local pre- and postconditions
Figure 198 - Examples of actions.name
«localPrecondition»
constraint
name
«localPostcondition»
constraint
Accept
PaymentSend
Payment
UML Superstructure 2.0 Draft Adopted Specification        283Below is an example of an action expressed in an application-dependent action language:
(CompleteActivities) The example below illustrates local pre and postcondition for the action of a drink dispensing machine.
Rationale
An action represents a single step within an activity, that is, one that is not further decomposed within the activity. An acti vity 
represents a behavior which is composed of individual elements that are actions. Note, however, that a call behavior action may reference an activity definition, in which case the execution of the call action involves the execution of the referenced activity and its actions. Similarly for all the invocation actions. An action is therefore simple from the point of view of the  
activity containing it, but may be complex in its effect and not be atomic. As a piece of structure within an activity model, i t is 
a single discrete element; as a specification of behavior to be performed, it may invoke referenced behavior that is arbitraril y 
complex. As a consequence, an activity defines a behavior that can be reused in many places, whereas an instance of an action is only used once at a particular point in an activity.
Changes from previous UML
Explicitly modeled actions as part of activities are new in UML 2.0, and replace ActionState, CallState, and SubactivityState in UML 1.5. They represent a merger of activity graphs from UML 1.5 and actions from UML 1.5.
Local pre and postconditions are new to UML 2.0.
12.3.2 Activity
An activity is the specification of parameterized behavior as the coordinated sequencing of subordinate units whose individual elements are actions. There are actions that invoke activities (directly by “CallBehaviorAction” on page 224 or indirectly as Figure 199 - Example of action with tool-dependent action language..
Figure 200 - Example of an action with local pre/postconditions.FOR every Employee
calculate salary
print check
ENDFOR
«locaPrecondition»
A drink is selected that
Dispense
«localPostcondition»
The vending machine dispensedthe vending machine contains.
the drink that is selected.Drink
284                 UML Superstructure 2.0 Draft Adopted Specificationmethods by “CallOperationAction” on page 227).
Description
An activity specifies the coordination of executions of subordinate behaviors, using a control and data flow model. The 
subordinate behaviors coordinated by these models may be initiated because other behaviors in the model finish executing, because objects and data become available, or because events occur external to the flow. The flow of execution is modeled as activity nodes connected by activity edges. A node can be the execution of a subordinate behavior, such as an arithmetic computation, a call to an operation, or manipulation of object contents. Activity nodes also include flow-of-control constructs , 
such as synchronization, decision, and concurrency control. Activities may form invocation hierarchies invoking other activities, ultimately resolving to individual actions. In an object-oriented model, activities are usually invoked indirectly as 
methods bound to operations that are directly invoked.
Activities may describe procedural computation. In this context, they are the methods corresponding to operations on classes. Activities may be applied to organizational modeling for business process engineering and workflow. In this context, events often originate from inside the system, such as the finishing of a task, but also from outside the system, such as a customer c all. 
Activities can also be used for information system modeling to specify system level processes.
Activities may contain actions of various kinds:
 occurrences of primitive functions, such as arithmetic functions.
 invocations of behavior, such as activities.
 communication actions, such as sending of signals.
 manipulations of objects, such as reading or writing attributes or associations.
Actions have no further decomposition in the activity containing them. However, the execution of a single action may induce the execution of many other actions. For example, a call action invokes an operation which is implemented by an activity containing actions that execute before the call action completes.
Most of the constructs in the activity chapter deal with various mechanisms for sequencing the flow of control and data among the actions:
 object flows for sequencing data produced by one node that is used by other nodes.
 control flows for sequencing the execution of nodes.
 control nodes to structure control and object flow. These include decisions and merges to model contingency. These 
also include initial and final nodes for starting and ending flows. In IntermediateActivities, they include forks and joins for creating and synchronizing concurrent subexecutions.
 activity generalization to replace nodes and edges.
 (StructuredActivities) composite nodes to represent structured flow-of-control constructs, such as loops and condition-
als.
 object nodes to represent objects and data as they flow in and out of invoked behaviors, or to represent collections of 
tokens waiting to move downstream.
 (IntermediateActivities) partitions to organize lower-level activities according to various criteria, such as the real-world 
organization responsible for their performance.
 (CompleteActivities) interruptible regions and exceptions to represent deviations from the normal, mainline flow of 
control.
UML Superstructure 2.0 Draft Adopted Specification        285Attributes (CompleteActivities)
 isReadOnly : Boolean = false If true, this activity must not make any changes to variables outside the activity or to 
objects. (This is an assertion, not an executable property. It may be used by an execution engine to optimize model execution. If the assertion is violated by the action, then the model is ill-formed.) The default is false (an activity may make nonlocal changes).
 isSingleExecution : Boolean = false If true, tokens from separate invocations of the activity may interact.
Associations (BasicActivities)
 edge : ActivityEdge [0..*] Edges expressing flow between nodes of the activity.
 group : ActivityGroup [0..*] Top-level groups in the activity.
 node : ActivityNode [0..*] N odes coordinated by the activity.
Associations (IntermediateActivities)
 partition : ActivityPartition [0..*] Top-level partitions in the activity.
Associations (StructuredActivities)
 structuredNode : StructuredActivityNode [0..*] Top-level structured nodes in the activity.
Stereotypes
None.
Tagged Values
None.
Constraints
[1]  The nodes of the activity must include one ActivityParameterNode for each parameter.
[2] An activity cannot be autonomous and have a classifier or behavioral feature context at the same time.
Operations
[1]  hostElement operates on Activity. It returns the “innermost” element in the user model that is hosting the activity. This will 
be either a Method, State, Transition, Message, or Stimulus.
hostElement() : ModelElement;
hostElement = if self.Method->size() > 0
 then self.Method
 else if self.State->size() > 0
 then self.State else if self.Transition->size() > 0
 then self.Transition
else if self.Message->size()>0
then self.Message
else if self.Stimulus->size>0
then self.Stimulusendif
endif
 endif
 endi
]
286                 UML Superstructure 2.0 Draft Adopted Specification[2] hostClassifier operates on Activity. It returns the classifier hosting the activity. This is the classifier on which the act ivity
is defined as a method, action in a state machine, sender of a message in a collaboration, or sender of a stimulus in a Col-laborationInstance.
hostClassifier() : Classifier;
hostClassifier = if self.Method->size() > 0
then self.Method.owner
else if self.State->size() > 0
then self.oclAsType(StateVertex).hostClassifier()
else if self.Transition->size() > 0
then self.Transition.source.hostClassifier()else if self.Message->size()>0
then self.Message.sender.base
else if self.Stimulus->size>0
then self.Stimulus.sender.classifier
endif
endif
endif
endif
Semantics
The semantics of activities is based on token flow. By flow, we mean that the execution of one node affects and is affected by 
the execution of other nodes, and such dependencies are represented by edges  in the activity diagram. A token  contains an 
object, datum, or locus of control, and is present in the activity diagram at a particular node. Each token is distinct from an y 
other, even if it contains the same value as another. A node may begin execution when specified conditions on its input tokens are satisfied; the conditions depend on the kind of node. When a node begins execution, tokens are accepted from some or all of its input edges and a token is placed on the node. When a node completes execution, a token is removed from the node and tokens are offered to some or all of its output edges. See later in this section for more about how tokens are managed.
All restrictions on the relative execution order of two or more actions are explicitly constrained by flow relationships. If tw o 
actions are not directly or indirectly ordered by flow relationships, they may execute concurrently. This does not require parallel execution; a specific execution engine may choose to perform the executions sequentially or in parallel, as long as an y 
explicit ordering constraints are satisfied. In most cases, there are some flow relationships that constrain execution order. Concurrency is supported IntermediateActivities, but not in BasicActivities.
Activities can be parameterized, which is a capability inherited from Behavior. See “ActivityParameterNode”. Functionality inherited from Behavior also supports the use of activities on classifiers and as methods for behavioral features. The classifi er, 
if any, is referred to as the context  of the activity. At runtime, the activity has access to the attributes and operations of its 
context object and any objects linked to the context object, transitively. An activity that is also a method of a behavioral feature has access to the parameters of the behavioral feature. In workflow terminology, the scope of information an activity uses is called the process-relevant data. Implementations that have access to metadata can define parameters that accept entire  
activities or other parts of the user model.
An activity with a a classifier context, but that is not a method of a behavioral feature, is invoked when the classifier is instantiated. An activity that is a method of a behavioral feature is invoked when the behavioral feature is invoked. The Behavior metaclass also provides parameters, which must be compatible with the behavioral feature it is a method of, if any. Behavior also supports overriding of activities used as inherited methods. See the Behavior metaclass for more information.
Activities can also be invoked directly by other activities rather than through the call of a behavioral feature that has an ac tivity 
as a method. This functional or monomorphic style of invocation is useful at the stage of development where focus is on the activities to be completed and goals to be achieved. Classifiers responsible for each activity can be assigned at a later stage  by 
declaring behavioral features on classifiers and assigning activities as methods for these features. For example, in business reengineering, an activity flow can be optimized independently of which departments or positions are later assigned to handle each step. This is why activities are autonomous when they are not assigned to a classifier.
Regardless of whether an activity is invoked through a behavioral feature or directly, inputs to the invoked activity are 
UML Superstructure 2.0 Draft Adopted Specification        287supplied by an invocation action in the calling activity, which gets its inputs from incoming edges. Likewise an activity 
invoked from another activity produces outputs that are delivered to an invocation action, which passes them onto its outgoing edges. 
An activity execution represents an execution of the activity. An activity execution, as a reflective object, can support operations for managing execution, such as starting, stopping, aborting, and so on; attributes, such as how long the process ha s 
been executing or how much it costs; and links to objects, such as the performer of the execution, who to report completion to,  
or resources being used, and states of execution such as started, suspended, and so on. Used this way activity is the modeling basis for the WfProcess interface in the OMG Workflow Management Facility, www.omg.org/cgi-bin/doc?formal/00-05-02. It is expected that profiles will include class libraries with standard classes that are used as root classes for activities in th e user 
model. Vendors may define their own libraries, or support user-defined features on activity classes.
Nodes and edges have token flow rules. Nodes control when tokens enter or leave them. Edges have rules about when a token may be taken from the source node and moved to the target node. A token traverses an edge when it satisfies the rules for target node, edge, and source node all at once. This means a source node can only offer tokens to the outgoing edges, rather than force them along the edge, because the tokens may be rejected by the edge or the target node on the other side. Since multiple edges can leave the same node, token flow semantics is highly distributed and subject to timing issues and race conditions, as is any distributed system. There is no specification of the order in which rules are applied on the various node s 
and edges in an activity. It is the responsibility of the modeler to ensure that timing issues do not affect system goals, or t hat 
they are eliminated from the model. Execution profiles may tighten the rules to enforce various kinds of execution semantics. Start at ActivityEdge and ActivityNode to see the token management rules.
Tokens cannot “rest” at control nodes , such as decisions and merges, waiting to moving downstream. Control nodes act as 
traffic switches managing tokens as they make their way between object nodes and actions, which are the nodes where tokens can rest for a period of time. Initial nodes are excepted from this rule.
A data token with no value in is called the null token. It can be passed along and used like any other token. For example, an 
action can output a null token and a downstream decision point can test for it and branch accordingly. Null tokens satisfy the type of all object nodes.
The semantics of activities is specified in terms of these token rules, but only for the purpose of describing the expected runtime behavior. Token semantics is not intended to dictate the way activities are implemented, despite the use of the term “execution”. They only define the sequence and conditions for behaviors to start and stop. Token rules may be optimized in particular cases as long as the effect is the same.
(IntermediateActivities) Activities can have multiple tokens flowing in them at any one time, if required. Special nodes called  
object nodes  provide and accept objects and data as they flow in and out of invoked behaviors, and may act as buffers, 
collecting tokens as they wait to move downstream.
(CompleteActivities) Each time an activity is invoked, the isSingleExecution attribute indicates whether the same execution of the activity handles tokens for all invocations, or a separate execution of the activity is created for each invocation. For example, an activity that models a manufacturing plant might have a parameter for an order to fill. Each time the activity is invoked, a new order enters the flow. Since there is only one plant, one execution of the activity handles all orders. If a sin gle 
execution of the activity is used for all invocations, the modeler must consider the interactions between the multiple streams of 
tokens moving through the nodes and edges. Tokens may reach bottlenecks waiting for other tokens ahead of them to move downstream, they may overtake each other due to variations in the execution time of invoked behaviors, and most importantly, may abort each other with constructs such as activity final.
If a separate execution of the activity is used for each invocation, tokens from the various invocations do not interact. For example, an activity with a context classifier, but that is not a method, is invoked when the classifier is instantiated, and t he 
modeler will usually want a separate execution of the activity for each instance of the classifier. A new activity execution fo r 
each invocation reduces token interaction, but might not eliminate it. For example, an activity may have a loop creating tokens  
to be handled by the rest of the activity, or an unsynchronized flow that is aborted by an activity final. In these cases, mode lers 
must consider the same token interaction issues as using a single activity execution for all invocations. Also see the effect o f 
288                 UML Superstructure 2.0 Draft Adopted Specificationnon-reentrant behaviors described at “Action”. Except in CompleteActivities, each invocation of an activity is executed 
separately; tokens from different invocations do not interact.
Nodes and edges inherited from more general activities can be replaced. See RedefinableElement for more information on overriding inherited elements.
(IntermediateActivities) If a single execution of the activity is used for all invocations, the modeler must consider additiona l 
interactions between tokens. Tokens may reach bottlenecks waiting for tokens ahead of them to move downstream, they may overtake each other due to the ordering algorithm used in object node buffers, or due to variations in the execution time of invoked behaviors, and most importantly, may abort each other with constructs such as activity final, exception outputs, and interruptible regions.
(CompleteActivities) Complete activities add functionality that also increases interaction. For example, streaming outputs create tokens to be handled by the rest of the activity. In these cases, modelers must consider the same token interaction issu es 
even when using a separate execution of activity execution for all invocations.
(CompleteActivities) Interruptible activity regions are groups of nodes within which all execution can be terminated if an interruptible activity edge is traversed leaving the region.
See “ActivityNode” and “ActivityEdge” for more information on the way activities function. An activity with no nodes and edges is well-formed, but unspecified. It may be used as an alternative to a generic behavior in activity modeling. See “ActivityPartition” for more information on grouping mechanisms in activities.
Semantic Variation Points
No specific variations in token management are defined, but extensions may add new types of tokens that have their own flow rules. For example, a BPEL extension might define a failure token that flows along edges that reject other tokens. Or an extension for systems engineering might define a new control token that terminates executing actions.
Notation
Use of action and activity notation is optional. A textual notation may be used instead.
The notation for an activity is a combination of the notations of the nodes and edges it contains, plus a border and name displayed in the upper left corner. Activity parameter nodes are displayed on the border. Actions and flows that are contained in the activity are also depicted. 
Pre- and postcondition constraints, inherited from Behavior, are shown as with the keywords «precondition» and «postcondition», respectively. These apply globally to all uses of the activity. See Figure 201 and Behavior in Common Behavior. Compare to local pre- and postconditions on Action.
(CompleteActivities) The keyword «singleExecution» is used for activities that execute as a single shared execution. Otherwise, each invocation executes in its space. See the notation sections of the various kinds of nodes and edges for more information.
UML Superstructure 2.0 Draft Adopted Specification        289The notation for classes can be used for diagramming the features of a reflective activity as shown below, with the keyword 
“activity” to indicate it is an activity class. Association and state machine notation can also be used as necessary.
Presentation OptionExamples
The definition of Process Order below uses the border notation to indicate that it is an activity. It has pre and post conditio ns Figure 201 - Activity notation
Figure 202 - Activity class notationactivity name
.........parameter name: Type«precondition» constraint
«postcondition» constraint
«activity» 
Activity Name
attribute : type
attribute : type
operation (parameters)
operation (parameters)
290                 UML Superstructure 2.0 Draft Adopted Specificationon the order (see Behavior).  All invocations of it use the same execution.  
The diagram below is based on a standard part selection workflow within an airline design process in section 6.1.1.2 of the 
Workflow Process Definition RFP, bom/2000-12-11. Notice that the Standards Engineer insures that the substeps in Provide Required Part are performed in the order specified and under the conditions specified, but doesn't necessarily perform the steps. Some of them are performed by the Design Engineer even though the Standards Engineer is managing the process. The Expert Part Search behavior can result in a part found or not. When a part is not found, it is assigned to the Assign Standards  
Engineer activity. Lastly, Specify Part Mod Workflow invocation produces entire activities and they are passed to subsequent invocations for scheduling and execution (i.e. Schedule Pat Mod Workflow, Execute Part Mod Workflow, and Research Production Possibility). In other words, behaviors can produce tokens that are activities that can in turn be executed; in shor t, Figure 203 - Example of an activity with input parameterReceive Fill
OrderShip
Order OrderClose
Order
Send
InvoiceMake
PaymentAccept
Payment[orderaccepted][order
rejected]
InvoiceProcess Order
Requested Order: Order
Requested
Order«precondition» Order complete
«postcondition» Order closed «singleCopy»
UML Superstructure 2.0 Draft Adopted Specification        291runtime activity generation and execution.
The diagram below is based on a trouble-ticket activity defined in section 6.1.1.3 of the Workflow Process Definition RFP, Figure 204 - Workflow based on example from the Workflow Process Definition RFPID Part Standard
Part SearchUse
Part Requirement
Provide
Required
Part[part 
Review
RequirementsReview
ScheduleClarify
Requirements
[accept][stream]found]
[part not
found]
Provide Required PartDesign Part
Design
Engineer
Standards
Engineer
Provide
addt’l part
 mod info
Execute
Part Mod
 Workflow
Research
Production
 PossibilitySpecify
Part Mod
 WorkflowSchedule
Part Mod
 Workflow
[reject]Expert
Part
 Search[part 
found]
[part not
found]Assign
Standards
 Engineer[stream]
[stream][stream]Design
EngineerStandards
Engineer[part provided]
[else]
[cancel] [reschedule]
[OK]
292                 UML Superstructure 2.0 Draft Adopted Specificationbom/2000-12-11.
Below is an example of using class notation to show the class features of an activity. Associations and state machines can also  
be shown.
Rationale
Activities are introduced to flow models that coordinate other behaviors, including other flow models. It supports class features to model control and monitoring of executing processes, and relating them to other objects, for example in an organization model.
Changes from previous UML
Activity replaces ActivityGraph in UML 1.5. Activities are redesigned to use a Petri-like semantics instead of state machines. Among other benefits, this widens the number of flows that can be modeled, especially those that have parallel flows. Activity also replaces procedures in UML 1.5, as well as the other control and sequencing aspects, including composite and collection actions.Figure 205 - Workflow based on example from the Workflow Process Definition RFP.
Figure 206 - Activity class with attributes and operationsRecord Reproduce
ProblemCorrect
Problem Problem
Audit and
RecordVe ri f y
ResolutionCommunicate
Results
[else][recorded]Trouble Ticket
ID Problem
and Resolution[cannot reproduce problem]
[problem not solved][else]
[canreproduce problem][duplicationof anotherproblem][knownproblemand solution][not recorded][problem statement rectified]
«activity» 
Fill Order
costSoFar : USD
timeToComplete : Integer
suspend ()
resume ()
UML Superstructure 2.0 Draft Adopted Specification        29312.3.3 ActivityEdge
An activity edge is an abstract class for directed connections between two activity nodes.
Description
ActivityEdge is an abstract class for the connections along which tokens flow between activity nodes. It covers control and 
data flow edges.
Description (CompleteActivities)
Edges support controlling token flow and be contained in interruptible regions.
Associations (BasicActivities)
 activity : Activity[0..1] Activity containing the edge.
 inGroup : ActivityGroup[0..*] Groups containing the edge. Multiplicity specialized to [0..1] for StructuredActivity-
Group.
 guard : ValueSpecification [1..1] = trueSpecification evaluated at runtime to determine if the edge can be traversed. redefinedElement: ActivityEdge [0..*]Inherited 
edges replaced by this edge in a specialization of the activity.
 source ActivityNode [1..1] Node from which tokens are taken when they traverse the edge. target : ActivityNode [1..1]
Node to which tokens are put when they traverse the edge.
Associations (IntermediateActivities)
 inPartition : Partition [0..*] Partitions containing the edge.
Associations (StructuredActivities)
 inStructuredNode : StructuredActivityNode [0..1]Structured activity node containing the edge.
Associations (CompleteActivities)
 interruptibleRegion  : InterruptibleActivityRegion [0..1]Region that the edge can interrupt. weight : ValueSpecification [1..1] = 1Number of objects consumed from the source node on each traversal.
Constraints
[1]  The source and target of an edge must be in the same activity as the edge.
[2] Activity edges may be owned only by activities or groups.
Semantics
Activity edges are directed connections, that is, they have a source and a target, along which tokens may flow.
Other rules for when tokens may be passed along the edge depend the kind of edge and characteristics of its source and target. 
See the children of ActivityEdge and ActivityNode. The rules may be optimized to a different algorithm as long as the effect is  
the same.
Semantics (IntermediateActivities)
The guard must evaluate to true for every token that is offered to pass along the edge. Tokens in the intermediate level of 
294                 UML Superstructure 2.0 Draft Adopted Specificationactivities can only pass along the edge individually at different times. See application of guards at DecisionNode.
Semantics (CompleteActivities)
Any number of tokens can pass along the edge, in groups at one time, or individually at different times. The weight attribute 
dictates the minimum number of tokens that must traverse the edge at the same time. It is a value specification evaluated every  
time a new token becomes available at the source. It must evaluate to a positive integer or null, and may be a constant, that i s, 
a LiteralInteger or a LiteralNull. When the minimum number of tokens are offered, all the tokens at the source are offered to the target all at once. The guard must evaluate to true for each token. If the guard fails for any of the tokens, and this redu ces 
the number of tokens that can be offered to the target to less than the weight, then all the tokens fail to be offered. A null weight means that all the tokens at the source are offerred to the target. This can be combined with a join to take all of the tokens at the source when certain conditions hold. See examples in Figure 210. A weaker but simpler alternative to weight is grouping information into larger objects so that a single token carries all necessary data. See additional functionality for gu ards 
at DecisionNode.
Other rules for when tokens may be passed along the edge depend the kind of edge and characteristics of its source and target. See the children of ActivityEdge and ActivityNode. The rules may be optimized to a different algorithm as long as the effect is  
the same. For example, if the target is an object node that has reached its upper bound, no token can be passed. The implementation can omit unnecessary weight evaluations until the downstream object node can accept tokens.
Edges can be named, by inheritance from RedefinableElement, which is a NamedElement. However, edges are not required to have unique names within an activity. The fact that Activity is a Namespace, inherited through Behavior, does not affect this, because the containment of edges is through ownedElement, the general ownership metaassociation for Element that does not imply unique names, rather than ownedMember.
Edges inherited from more general activities can be replaced. See RedefinableElement for more information on overriding inherited elements.
Semantic Variation Points
See variations at children of ActivityEdge and ActivityNode.
Notation
An activity edge is notated by a stick-arrowhead line connecting two activity nodes. If the edge has a name it is notated near the arrow. 
An activity edge can also be notated using a connector, which is a small circle with the name of the edge in it. The circles an d 
lines involved map to a single activity edge in the model. Every connector with a given label must be paired with exactly one other with the same label on the same activity diagram. One connector must have exactly one incoming edge and the other exactly one outgoing edge, each with the same type of flow, object or control. This assumes the UML 2.0 Diagram Figure 207 - Activity edge notationRegular activity edgeActivity edge with namename
UML Superstructure 2.0 Draft Adopted Specification        295Interchange RFP supports the interchange of diagram elements and their mapping to model elements. 
Notation (CompleteActivities)
The weight of the edge many be shown in curly braces that contain the weight. The weight is a value specification that is a 
positive integer, which may be a constant. When regions have interruptions, a lightning-bolt style activity edge expresses this  
interruption, see InterruptibleActivityRegion. See Pin for filled arrowhead notation. 
Examples (BasicActivities)
In the example illustrated below, the arrowed line connecting Fill Order to Ship Order is a control flow edge. This means that when the Fill Order behavior is completed, control is passed to the Ship Order. Below it, the same control flow is shown with an edge name. The one at the bottom left employs connectors, instead of a continuous line. On the upper right, the arrowed lines starting from Send Invoice and ending at Make Payment (via the Invoice object node) are object flow edges. This indicates that the flow of Invoice objects goes from Send Invoice to Make Payment.Figure 208 - Activity edge connector notation
Figure 209 - Activity edge notation(where, n is connector name) n n
Activity edge for interruptible regions
With edge weight{weight= n}
{weight=null}
(where n is a value specification)
296                 UML Superstructure 2.0 Draft Adopted SpecificationIn the example below, a connector is used to avoid drawing a long edge around one tine of the fork. If a problem is not priorit y 
one, the token going to the connector is sent to the merge instead of the one that would arrive from Revise Plan for priority o ne 
problems. This is equivalent to the activity shown in  Figure 212, which is how Figure 211 is stored in the model.Figure 210 - Activity edge examples
Figure 211 - Connector exampleFill
OrderShip
Order
Send
InvoiceMake
Payment
Invoice
A AFill
OrderShip
OrderFill
OrderShip
OrderFilled
Fill
OrderShip
Orderis equivalent to
Register
Problem[priority=1]Evaluate
Impact
Fix
ProblemRevise
Plan
Test
FixRelease
Fix[else]A
A
UML Superstructure 2.0 Draft Adopted Specification        297Examples (CompleteActivities)
The figure below illustrates three examples of using the weight attribute. The Cricket example uses a constant weight to 
indicate that a cricket team cannot be formed until eleven players are present. The Task example uses a non-constant weight to indicate that an invoice for a particular job can only be sent when all of its tasks have been completed. The proposal example depicts an activity for placing bids for a proposal, where many such bids can be placed. Then, when the bidding period is over,  
the Award Proposal Bid activity reads all the bids as a single set and determines which vendor to award the bid.
Rationale
Activity edges are introduced to provide a general class for connections between activity nodes.Figure 212 - Equivalent model to Figure 211
Figure 213 - Activity edge examplesRegister
Problem[priority=1]Evaluate
Impact
Fix
ProblemRevise
Plan
Test
FixRelease
Fix[else]
Form
CricketCricket{weight=11}
PlayerTeamSend
JobTask{weight=no_of_job_tasks}
[completed]Invoice
{weight=all}Bids for
ProposalAward
BidReady
to award 
bid
Bid
arrives
298                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from previous UML
ActivityEdge replaces the use of (state) Transition in UML 1.5 activity modeling. It also replaces data flow and control flow 
links in UML 1.5 action model.
12.3.4 ActivityFinalNode
An activity final node is a final node that stops all flows in an activity.
Description
An activity may have more than one activity final node. The first one reached stops all flows in the activity.
Attributes
None.
Associations
None.
Stereotypes
None.
Tagged Values
None.
Constraints
None.
Semantics
A token reaching an activity final node aborts all flows in the containing activity, that is the activity is terminated, and th e 
token is destroyed. All tokens offered on the incoming edges are accepted. Any object nodes declared as outputs are passed out of the containing activity. If there is more than one final node in an activity, the first one reached terminates the activ ity, 
including the flow going towards the other activity final.
If it is not desired to abort all flows in the activity, use flow final instead. For example, if the same execution of an activ ity is 
being used for all its invocations, then multiple streams of tokens will be flowing through the same activity. In this case, it  is 
probably not desired to abort all tokens just because one reaches an activity final. Using a flow final will simply consume the  
tokens reaching it without aborting other flows. Or arrange for separate invocations of the activity to use separate executions  
of the activity, so tokens from separate invocations will not affect each other.
Semantic Variation Points
None.
Notation
Activity final nodes are notated as a solid circle with a hollow circle, as indicated in the figure below. It can be thought of  as a 
UML Superstructure 2.0 Draft Adopted Specification        299goal notated as “bull’s eye,” or target.
Presentation Option
Style GuidelinesExamples
The first example below depicts that when the Close Order behavior is completed, all tokens in the activity are terminated. 
This is indicated by passing control to an activity final node. 
The next figure is based on an example for an employee expense reimbursement process in section 6.1.1.1 of the Workflow Process Definition RFP, bom/2000-12-11. It uses an activity diagram that illustrates two parallel flows racing to complete. The  
first one to reach the activity final aborts the others. The two flows appear in the same activity so they can share data, for Figure 214 - Activity final notation
Figure 215 - Activity final exampleClose
Order
300                 UML Superstructure 2.0 Draft Adopted Specificationexample who to notify in the case of no action.  
The last figure is based on the second example in section 6.1.1.4 of the Workflow Process Definition RFP, bom/2000-12-11. 
Here, two ways to reach an activity final exist; but it is result of exclusive “or” branching, not a “race” situation like the previous example. This example uses two activity final nodes, which has the same semantics as using one with two edges targeting it. The Notify of Modification behavior must not take long or the activity finals might kill it.
Rationale
Activity final nodes are introduced to model non-local termination of all flows in an activity.Figure 216 - Activity final example based on example from the 
                       Workflow Process Definition RFP.
Figure 217 - Activity final example based on an example from the 
                       Workflow Process Definition RFP.No actionSubmit for
Approval
timer[amount >= 200]
Auto
Approve[amount < 200]Reject
[decision = accept]Service
Approval[decision = reject]Notify
Reject
Notify
No ActionCancel
ServiceCancel
Transaction
Modify
ProposalReview
Proposal
[decision = accept]Publish
Proposal
[decision = reject]Notify of
Modification
Notify of
Rejection[decision = modify]
UML Superstructure 2.0 Draft Adopted Specification        301Changes from previous UML
ActivityFinal is new in UML 2.0.
12.3.5 ActivityGroup
(IntermediateActivities) An activity group is an abstract class that for defining sets of nodes and edges in an activity.
Description
Activity groups are a generic grouping construct for nodes and edges. Nodes and edges can belong to more than group. They 
have no inherent semantics and can be used for various purposes. Subclasses of ActivityGroup may add semantics.
Attributes
None.
Associations
 activity : Activity [0..1] Activity containing the group.
 edgeContents : ActivityEdge [0..*] Edges immediately contained in the group. nodeContents : ActivityNode [0..*] Nodes immediately contained in the group. /superGroup : ActivityGroup [0..1] Group immediately containing the group. /subgroup : ActivityGroup [0..*] Groups immediately contained in the group.
Constraints
[1]  All nodes and edges of the group must be in the same activity as the group.
[2] No node or edge in a group may be contained by its subgroups or its containing groups, transitively.
[3] Groups may only be owned by activities or groups.
Semantics
None.
Notation
None.
Examples
None.
Rationale 
Activity groups provide a generic grouping mechanism that can be used for various purposes, as defined in the subclasses of 
ActivityGroup, and in extensions and profiles.
Changes from previous UML
ActivityGroups are new in UML 2.0.
302                 UML Superstructure 2.0 Draft Adopted Specification12.3.6 ActivityNode
An activity node is an abstract class for points in the flow of an activity connected by edges.
Description
An activity node is an abstract class for the steps of an activity. It covers invocation nodes, control nodes, and object nodes .
Nodes can be replaced in generalization and (CompleteActivities) be contained in interruptible regions.
Attributes (CompleteStructuredActivities)
 mustIsolate : Boolean If true, then the actions in the node execute in isolation from actions outside the node.
Associations (BasicActivities)
 activity : Activity[0..1] Activity containing the node.
 inGroup : Group [0..*] Groups containing the node. Multiplicity specialized to [0..1] for StructuredActivity-
Group.
 incoming : ActivityEdge [0..*] Edges that have the node as target. outgoing ActivityEdge [0..*] Edges that have the node as source. redefinedElement : ActivityNode [0..*]Inherited nodes replaced by this node in a specialization of the activity.
Associations (IntermediateActivities)
 inPartition : Partition [0..*] Partitions containing the node.
Associations (StructuredActivities)
 inStructuredNode : StructuredActivityNode [0..1]Structured activity node containing the node.
Associations 
 interruptibleRegion : InterruptibleActivityRegion [0..*] Interruptible regions containing the node.
Constraints
[1]  Activity nodes can only be owned by activities or groups.
Semantics
Nodes can be named, however, nodes are not required to have unique names within an activity to support multiple invocations 
of the same behavior or multiple uses of the same action. See Action, which is a kind of node. The fact that Activity is a Namespace, inherited through Behavior, does not affect this, because the containment of nodes is through ownedElement, the general ownership metaassociation for Element that does not imply unique names, rather than ownedMember. Other than naming, and functionality added by the complete version of activities, an activity node is only a point in an activity at this level 
of abstraction. See the children of ActivityNode for additional semantics.
Nodes inherited from more general activities can be replaced. See RedefinableElement for more information on overriding inherited elements, and Activity for more information on activity generalization. See children of ActivityNode for additional semantics.
(CompleteStructuredActivities) If the mustIsolate flag is true for an activity node, then any access to an object by an action within the node must not conflict with access to the object by an action outside the node. A conflict is defined as an attempt to 
UML Superstructure 2.0 Draft Adopted Specification        303write to the object by one or both of the actions. If such a conflict potentially exists, then no such access by an action outs ide 
the node may be interleaved with the execution of any action inside the node. This specification does not constrain the ways in  
which this rule may be enforced. If it is impossible to execute a model in accordance with these rules, then it is ill formed.
Notation
The notations for activity nodes are illustrated below. There are a three kinds of nodes: action node, object node, and control  
node. See these classes for more information.
Examples
This figure illustrates the following kinds of activity node: action nodes (e.g., Receive Order, Fill Order), object nodes 
(Invoice), and control nodes (the initial node before Receive Order, the decision node after Receive Order, and the fork node and Join node around Ship Order, merge node before Close Order, and activity final after Close Order). 
Rationale
Activity nodes are introduced to provide a general class for nodes connected by activity edges.Figure 218 - Activity node notation
Figure 219 - Activity node example (where the arrowed lines are only the non-activity node 
symbols)Action node Object node Control nodes 
Receive Fill
OrderShip
Order OrderClose
Order
Send
InvoiceMake
PaymentAccept
Payment[order
accepted][order
rejected]
Invoice
304                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from previous UML
ActivityNode replaces the use of StateVertex and its children for activity modeling in UML 1.5.
12.3.7 ActivityParameterNode
An activity parameter node is an object node for inputs and outputs to activities.
Description
Activity parameters are object nodes at the beginning and end of flows, to accept inputs to an activity and provide outputs fro m 
it.
(CompleteActivities) Activity parameters inherit support for streaming and exceptions from Parameter.
Attributes
None.
Associations
 parameter : Parameter The parameter the object node will be accepting and providing values for.
Constraints
[1]  Activity parameter nodes must have parameters from the containing activity.
[2] The type of an activity parameter node is the same as the type of its parameter.
[3] Activity parameter nodes must have either no incoming edges or no outgoing edges.
[4] Activity parameter object nodes with no incoming edges and one or more outgoing edges must have a parameter with in
or inout direction.
[5] Activity parameter object nodes with no outgoing edges and one or more incoming edges must have a parameter with in,
inout, or return direction.
See Activity.
Semantics
When an activity in invoked, the inputs values are placed as tokens on the input activity parameter nodes, those with no incoming edges. Outputs of the activity must flow to output activity parameter nodes, those with no outgoing edges. See semantics at ObjectNode, Action, and ActivityParameterNode.
UML Superstructure 2.0 Draft Adopted Specification        305Notation
Also see notation at Activity.
(CompleteActivities) The figure below shows annotations for streaming and exception activity parameters, which are same as 
for pins. See Parameter for semantics of stream and exception parameters.
Presentation Option
(CompleteActivities) See presentation option for Pin when parameter is streaming. This can be used for activity parameters also.
Examples
In the example below, production materials are fed into printed circuit board. At the end of the activity, computers are qualit y Figure 220 - Activity notation
Figure 221 - Activity notationActivity name
.........Parameter name: type
Activity name
.........Parameter name: type {stream}
306                 UML Superstructure 2.0 Draft Adopted Specificationchecked.
(CompleteActivities) In the example below, production materials are streaming in to feed the ongoing printed circuit board 
fabrication. At the end of the activity, computers are quality checked. Computers that do not pass the test are exceptions. See  
Parameter for semantics of streaming and exception parameters.
Rationale
Activity parameter nodes are introduced to model parameters of activities in way that integrates easily with the rest of the fl ow 
model.
Changes from previous UML
ActivityParameterNode is new in UML 2.0.Figure 222 - Example of activity parameters.nodes
Figure 223 - Example of activity parameter nodes for streaming and exceptionsProduce
Printed-Circuit
Boards
Printed-
Circuit
BoardsProduction
MaterialsAssemble
Computers
Assembled
ComputersTest
Computers
Accepted
ComputersRejected
Computers
{stream}
Produce
Printed-Circuit
Boards
Printed-
Circuit
BoardsProduction
MaterialsAssemble
Computers
Assembled
ComputersTest
Computers
Accepted
ComputersRejected
Computers
UML Superstructure 2.0 Draft Adopted Specification        30712.3.8 ActivityPartition
(IntermediateActivities) An activity partition is a kind of activity group for identifying actions that have some characteristi c in 
common.
Description
Partitions divide the nodes and edges to constrain and show a view of the contained nodes. Partitions can share contents. They often correspond to organizational units in a business model. They may be used to allocate characteristics or resources among the nodes of an activity.
Attributes
 isDimension : Boolean [1..1] = falseTells whether the partition groups other partitions along a dimension.
 isExternal : Boolean [1..1] = falseTells whether the partition represents an entity to which the partitioning structure does 
not apply.
Associations
 partition : ActivityPartition [0..1] Partition immediately containing the partition. Specialized from Activity-
Group::group.
 represents : Element [0..1] An element constraining behaviors invoked by nodes in the partition. superPartition : ActivityPartition [0..1] Partitions immediately containing the partition. Specialized from Activity-
Group::subgroup.
 activity : Activity [0..1] The activity containing the partition. Specialized from ActivityGroup.
Constraints
[1]  A partition with isDimension = true may not be contained by another partition.
[2] No node or edge of a partition may be in another partition in the same dimension.
[3] If a partition represents a part, then all the non-external partitions in the same dimension and at the same level of nestin g
in that dimension must represent parts directly contained in the internal structure of the same classifier.
[4] If a non-external partition represents a classifier and is contained in another partition, then the containing partition mus t
represent a classifier, and the classifier of the subpartition must be nested in the classifier represented by the containingpartition, or be at the contained end of a strong composition association with the classifier represented by the containingpartition.
[5] If a partition represents a part and is contained by another partition, then the part must be of a classifier represented by  the
containing partition, or of a classifier that is the type of a part representing the containing partition.
Semantics
Partitions do not affect the token flow of the model. They constrain and provide a view on the behaviors invoked in activities.  
Constraints vary according to the type of element that the partition represents. The following constraints are normative:
1) Classifier
Behaviors of invocations contained by the partition are the responsibility of instances of the classifier represented by the partition. This means the context of invoked behaviors is the classifier. Invoked procedures containing a call to an operation or 
sending a signal must target objects at runtime that are instances of the classifier.
308                 UML Superstructure 2.0 Draft Adopted Specification2) Instance
This imposes the same constraints as classifier, but restricted to a particular instance of the classifier.
3) Part
Behaviors of invocations contained by the partition are the responsibility of instances playing the part represented by the 
partition. This imposes the constraints for classifiers above according to the type of the part. In addition, invoked procedure s 
containing a call to an operation or sending a signal must target objects at runtime that play the part at the time the message  is 
sent. Just as partitions in the same dimension and nesting must be represented by parts of the same classifier’s internal structure, all the runtime target objects of operation and signal passing invoked by the same execution of the activity must pl ay 
parts of the same instance of the structured classifier. In particular, if an activity is executed in the context of a particul ar object 
at runtime, the parts of that object will be used as targets. If a part has more than one object playing it at runtime, the 
invocations are treated as if they were multiple, that is, the calls are sent in parallel, and the invocation does not complete  until 
all the operations return.
4) Attribute and Value
A partition may be represented by an attribute and its subpartitions by values of that attribute. Behaviors of invocations contained by the subpartition have this attribute and the value represented by the subpartition. For example, a partition may represent the location at which a behavior is carried out, and the subpartitions would represent specific values for that attri bute, 
such as Chicago. The location attribute could be on the process class associated with an activity, or added in a profile to ext end 
behaviors with these attributes.
A partition may be marked as being a dimension for its subpartitions. For example, an activity may be have one dimension of partitions for location at which the contained behaviors are carried out, and another for the cost of performing them. Dimension partitions cannot be contained in any other partition.
Partitions may be used in a way that provides enough information for review by high-level modelers, though not enough for execution. For example, if a partition represents a classifier, then behaviors in that partition are the responsibility of inst ances 
of the classifier, but the model may or may not say which instance in particular. In particular, a behavior in the partition ca lling 
an operation would be limited to an operation on that classifier, but an input object flow to the invocation might not be specified to tell which instance should be the target at runtime. The object flow could be specified in a later stage of development to support execution. Another option would be to use partitions that represent parts. Then when the activity executes in the context of a particular object, the parts of that object at runtime will be used as targets for the operation c alls, as 
described above.
External partitions are intentional exceptions to the rules for partition structure. For example, a dimension may have partitio ns 
showing parts of a structured classifier. It can have an external partition that does not represent one of the parts, but a completely separate classifier. In business modeling, external partitions can be used to model entities outside a business.
Notation
Activity partition may be indicated with two, usually parallel lines, either horizontal or vertical, and a name labeling the partition in a box at one end. Any activity nodes and edges placed between these lines are considered to be contained within the partition. Swimlanes can express hierarchical partitioning by representing the children in the hierarchy as further partitioning of the parent partition, as illustrated in b), below. Diagrams can also be partitioned multidimensionally, as depicted in c), below, where, each swim cell is an intersection of multiple partitions. The specification for each dimension 
UML Superstructure 2.0 Draft Adopted Specification        309(e.g., part, attribute) is expressed in next to the appropriate partition set.
In some diagramming situations, using parallel lines to delineate partitions is not practical. An alternate is to place the par tition 
name in parenthesis above the activity name, as illustrated for actions in a), below. A comma-delimited list of partition names  
means that the node is contained in more than one partition. A double colon within a partition name indicates that the partitio n 
is nested, with the larger partitions coming earlier in the name. When activities are considered to occur outside the domain of  a 
particular model, the partition can be label with the keyword «external», as illustrated in b) below. Whenever an activity in a  
swimlane is marked «external», this overrides the swimlane and dimension designation.
Presentation Option
When partitions are combined with the frame notation for Activity, the outside edges of the top level partition can be merged with the activity frame.
Examples
The figures below illustrate an example of partitioning the order processing activity diagram into “swim lanes.” The top Figure 224 - Activity partition notations
Figure 225 - Activity partition notationsPartition Name
b) Partition using a hierarchical swimlane notation Partition Namea) Partition using a swimlane notation
Sub-partition
 NameSub-partition
 Name
Partition Name-1Partition
 Name-2Partition Name-3Partition
 Name-4
c) Partition using a multidimensional
hierarchical swimlane notationDimension nameDimension nameDimension name
a) Partition notated on a specific activityaction(Partition Name) «external»
b) Partition notated to occur outside«external»
the primary concern of the model.Partition Name
action(PartitionName)
action(Name1, Name2)
action(Name::Subname)
310                 UML Superstructure 2.0 Draft Adopted Specificationpartition contains the portion of an activity for which the Order Department is responsible; the middle partition, the 
Accounting Department, and the bottom the Customer. These are attributes of the behavior invoked in the partitions, except for Customer, which is external to the domain. The flow of the invoice is not a behavior, so it does not need to appear in a partition.
Figure 226 - Activity partition using swimlane example
Figure 227 - Activity partition using annotation exampleOrder Department Acctg DepartmentReceive Fill
OrderShip
Order Order
Send
InvoiceAccept
Payment
InvoiceClose
Order
Make Payment[order
accepted]Customer«attribute» performingDept: Department«external»
(Accounting  
Department)(Accounting  
Department)(Order
Department)(Order
Department)(Order
Department) (Order
Department)
[order
accepted]
Invoice«external»Receive
OrderFill Order Ship Order
Close Order
Send Invoice Make
PaymentAccept
Payment(Customer)
UML Superstructure 2.0 Draft Adopted Specification        311The example below depicts multidimensional swim lanes. The Receive Order and Fill Order behaviors are performed by an 
instance of the Order Processor class, situated in Seattle, but not necessarily the same instance for both behaviors. Even thou gh 
the Make Payment is contain with in the Seattle/Accounting Clerk swim cell, it’s performer and location are not specified by the containing partition, because it has an overriding partition.
Rationale 
Activity partitions are introduced to support the assignment of domain-specific information to nodes and edges.
Changes from previous UML
Edges can be contained in partitions in UML 2.0. Additional notation is provided for cases when swimlanes are too cumbersome. Partitions can be hierarchical and multidimensional. The relation to classifier, parts, and attributes is formalize d, 
including external partitions as exceptions to these rules.
12.3.9 CentralBufferNode
A central buffer node is a object node for managing flows from multiple sources and destinations.
Description
A central buffer node accepts tokens from upstream objects nodes and passes them along to downstream object nodes. They act as a buffer for multiple in flows and out flows from other object nodes. They do not connect directly to actions.
Attributes
None.Figure 228 - Activity partition using multidimensional swimlane exampleOrder Processor Accounting ClerkReceive Fill
OrderShip
Order Order
Send
InvoiceAccept
Payment
InvoiceClose
Order
Make Payment[order
accepted]Seattle Reno«attribute» performingLocation:Location «external»
(Customer)«class» «class»
312                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
None.
Semantics
See semantics at ObjectNode. All object nodes have buffer functionality, but central buffers differ in that they are not tied t o 
an action as pins are, or to an activity as activity parameter nodes are. See example below.
Notation
See notation at ObjectNode. A central buffer may also have the keyword «centralBuffer» as shown below. This is useful when it needs to be distinguished from the standalone notation for pins shown on the left of Figure 280 and the top left of Figure 2 86.
Examples
In the example below, the behaviors for making parts at two factories produce finished parts. The central buffer node collects 
the parts, and behaviors after it in the flow use them as needed. All the parts that are not used will be packed as spares, bec ause 
each token can only be drawn from the object node by one outgoing edge.  
Rationale
Central buffer nodes give additional support for queuing and competition between flowing objects.
Changes from previous UML
CentralBufferNode is new in UML 2.0.Figure 229 - Optional central buffer notation
Figure 230 - Central buffer node example«centralBuffer»
Pack
PartsMake Parts
at Factory 1
Part
[Finished]
Use
PartsPart
[Finished]Part
[Finished]
Part
[Finished]Make Parts
at Factory2 Part
[Finished]«centralBuffer»
UML Superstructure 2.0 Draft Adopted Specification        31312.3.10 Clause
A clause is an element that represents a single branch of a conditional construct, including a test and a body section. The bod y 
section is executed only if (but not necessarily if) the test section evaluates true.
Attributes
none
Associations (StructuredActivities)
 test : ActivityNode [0..*] A nested activity fragment with a designated output pin that specifies the result of the test.
 body : ActivityNode [0..*] A nested activity fragment that is executed if the test evaluates to true and the clause is 
chosen over any concurrent clauses that also evaluate to true.
 predecessorClause : Clause [*] A set of clauses whose tests must all evaluate false before the current clause can be tested. successorClause : Clause [*] A set of clauses which may not be tested unless the current clause tests false. decider : OutputPin [1] An output pin within the test fragment the value of which is examined after execution of 
the test to determine whether the body shoud be executed.
Associations ((CompleteStructuredActivities))
 bodyOutput : OutputPin [0..*] A list of output pins within the body fragment whose values are copied to the result pins of 
the containing conditional node or conditional node after execution of the clause body.
Semantics
The semantics are explained under “ConditionalNode”.
12.3.11 ConditionalNode
A conditional node is a structured activity node that represents an exclusive choice among some number of alternatives.
Description
A conditional node consists of one or more clauses. Each clause consists of a test section and a body section. When the conditional node begins execution, the test sections of the clauses are executed. If one or more test sections yield a true val ue, 
one of the corresponding body sections will be executed. If more than one test section yields a true value, only one body section will be executed. The choice is nondeterministic unless the test sequence of clauses is specified. If no test section yields a true value, then no body section is executed; this may be a semantic error if output values are expected from the conditional node.
In general, test section may be executed in any order, including simultaneously (if the underlying execution architecture supports it). The result may therefore be nondeterministic if more than one test section can be true concurrently. To enforce ordering of evaluation, sequencing constraints may be specified among clauses. One frequent case is a total ordering of clauses, in which case the result is determinate. If it is impossible for more than one test section to evaluate true simultaneously, the result is deterministic and it is unnecessary to order the clauses, as ordering may impose undesirable and unnecessary restrictions on implementation.Note that, although evaluation of test sections may be specified as concurrent, this  
does not require that the implementation evaluate them in parallel; it merely means that the model does not impose any order on evaluation.
An “else” clause is a clause that is a successor to all other clauses in the conditional and whose test part always returns tru e. A 
314                 UML Superstructure 2.0 Draft Adopted Specificationnotational gloss is provided for this frequent situation.
Output values created in the test or body section of a clause are potentially available for use outside the conditional. Howeve r, 
any value used outside the conditional must be created in every clause, otherwise an undefined value would be accessed if a clause not defining the value were executed.
Attributes (StructuredActivities)
 isAssured : Boolean If true, the modeler asserts that at least one test will succeed.
 isDeterminate: Boolean If true, the modeler asserts that at most one test will succeed concurrently and therefore 
the choice of clause is deterministic.
Associations (StructuredActivities)
 clause : Clause[1..*] Set of clauses composing the conditional.
Associations (CompleteStructuredActivities)
 result : OutputPin [0..*] A list of output pins that constitute the data flow outputs of the conditional. 
Constraints
None.
Semantics
No part of a conditional node is executed until all control-flow or data-flow predecessors of the conditional node have completed execution. When all such predecessors have completed execution and made tokens available to inputs of the conditional node, the conditional node captures the input tokens and begins execution. 
The test section of any clause without a predecessorClause is eligible for execution immediately. If a test section yields a fa lse 
value, a control token is delivered to all of its successorClauses. Any test section with a predecessorClause is eligible for execution when it receives control tokens from each of its predecessor clauses.
If a test section yields a true value, then the corresponding body section is executed provided another test section does not a lso 
yield a true value. If more than one test section yields a true value, exactly one body section will be executed, but it is indeterminate which one will be executed. When a body section is chosen for execution, the evaluation of all other test parts i s 
terminated (just like an interrupting edge). If some of the test parts have external effects, terminating them may be another source of indeterminacy. Although test parts are permitted to produce side effects, avoiding side effects in tests will greatly  
reduce the chance of logical errors and race conditions in a model and in any code generated from it.
If no test section yields a true value, the execution of the conditional node terminates with no outputs. This may be a semanti c 
error if a subsequent node requires an output from the conditional. It is safe if none of the clauses create outputs. If the isAssured  attribute of the conditional node has a true value, the modeler asserts that at least one true section will yield a true 
value. If the isDeterminate  attribute has a true value, the modeler asserts that at most one true section will concurrently yield a 
true value (the predecessor relationship may be used to enforce this assertion). Note that it is, in general, impossible for a computer system to verify these assertions, so they may provide useful information to a code generator, but if the assertions are incorrect then incorrect code may be generated.
When a body section is chosen for execution, all of its nodes without predecessor flows within the conditional receive control tokens and are enabled for execution. When execution of all nodes within the body section has completed, execution of the conditional node is complete and its successors are enabled.
Within the body section, variables defined in the loop node or in some higher-level enclosing node may be accessed and updated with new values. Values that are used in a data flow manner must be created or updated in all clauses of the 
UML Superstructure 2.0 Draft Adopted Specification        315conditional, otherwise undefined values would be accessed.
Notation
Presentation Option
Style Guidelines
Mixing sequential and concurrent tests in one conditional may be confusing, although it is permitted.
Examples
Rationale
Conditional nodes are introduced to provide a structured way to represent decisions.
Changes from previous UML
Conditional nodes replace ConditionalAction from the UML 1.5 action model.
12.3.12 ControlFlow
A control flow is an edge starts an activity node after the previous one is finished.
Description
Objects and data cannot pass along a control flow edge. 
Attributes
None.
Associations
None.
Constraints
[1]  Control flows may not have object nodes at either end.
Semantics
See semantics inherited from ActivityEdge. A control flow is an activity edge that only passes control tokens. Tokens offered 
by the source node are all offered to the target node.
316                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
A control flow is notated by an arrowed line connecting two actions. 
Examples
The figure below depicts an example of the Fill Order action passing control to the Ship Order action. The activity edge 
between the two is a control flow which indicates that when Fill Order is completed, Ship Order is invoked. 
Rationale
Control flow is introduced to model the sequencing of behaviors that does not involve the flow of objects.
Changes from previous UML
Explicitly modeled control flows are new to activity modeling in UML 2.0. They replace the use of (state) Transition in UML 1.5 activity modeling. They replace control flows in UML 1.5 action model.
12.3.13 ControlNode
A control node is an abstract activity node that coordinates flows in an activity.
Description
A control node is an activity node used to coordinate the flows between other nodes. It covers initial node, final node and its  
children, fork node, join node, decision node, and merge node.
Attributes
None.
Associations
None.Figure 231 - Control flow notation
Figure 232 - Control flow exampleControl flow
(without actions)Control flow edge linking 
two actions
Fill
OrderShip
Order
UML Superstructure 2.0 Draft Adopted Specification        317Stereotypes
None.
Tagged Values
None.
Constraints
[1]  The edges coming into and out of a control node must be either all object flows or all control flows.
Semantics
See semantics at Activity. See subclasses for the semantics of each kind of control node. 
Semantic Variation Points
None.
Notation
The notations for control nodes are illustrated below: decision node, initial node, activity final, and flow final.
(IntermediateActivities) Fork node and join node are the same symbol, they have different semantics and are distinguished 
notationally by the way edges are used with them. For more information, see ForkNode and JoinNode below.
Examples
The figure below contains examples of various kinds of control nodes. An initial node is depicted in the upper left as triggeri ng 
the Receive Order action. A decision node after Received Order illustrates branching based on order rejected or order accepted conditions. Fill Order is followed by a fork node which passes control both to Send Invoice and Ship Order. The join node indicates that control will be passed to the merge when both Ship Order and Accept Payment are completed. Since a merge will just pass the token along, Close Order activity will be invoked. (Control is also passed to Close Order whenever an order Figure 233 - Control node notationsDecision node Fork node, join node Initial node Activity final Flow final
 Final nodesor Merge node
318                 UML Superstructure 2.0 Draft Adopted Specificationis rejected.) When Close Order is completed, control passes to an activity final. 
Rationale
Control nodes are introduced to provide a general class for nodes that coordinate flows in an activity.
Changes from previous UML
ControlNode replaces the use of PseudoState in UML 1.5 activity modeling.
12.3.14 DataStoreNode
A data store node is a central buffer node for non-transient information.
Description
A data store keeps all tokens that enter it, copying them when they are chosen to move downstream. Incoming tokens 
containing a particular object replace any tokens in the object node containing that object.
Attributes
None.
Associations
None
Constraints
None.
Semantics
Tokens chosen to move downstream are copied so that tokens appear to never leave the data store. If a token containing an Figure 234 - Control node examples (with accompanying actions and control flows)Receive Fill
OrderShip
Order Order
Send
InvoiceMake
PaymentAccept
Payment[orderaccepted][order
rejected]
InvoiceClose
Order
UML Superstructure 2.0 Draft Adopted Specification        319object is chosen to move into a data store, and there is a token containing that object already in the data store, then the cho sen 
token replaces existing one. Selection and transformation behavior on outgoing edges can be designed to get information out of the data store, as if a query were being performed. For example, the selection behavior can identify an object to retrieve a nd 
the transformation behavior can get the value of an attribute on that object. Selection can also be designed to only succeed when a downstream action has control passed to it, thereby implementing the pull semantics of earlier forms of data flow.
Notation
The data store notation is a special case of the object node notation, using the label «datastore» .
Presentation Option
Style GuidelinesExamples
The figure below is an example of using a data store node.
Rationale
Data stores are introduced to support earlier forms of data flow modeling in which data is persistent and used as needed, rathe r 
than transient and used when available.
Changes from previous UML
Data stores are new in UML 2.0.
12.3.15 DecisionNode
A decision node is a control node that chooses between outgoing flows.Figure 235 - Data store node notation.
Figure 236 - Data store node examplename
[state]«datastore»
Personnel
database«datastore»Hire
Employee
Assign
EmployeeReview
Employee{weight=all}
Once a year«selection»
employee.
assignment = null
320                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
A decision node has one incoming edge and multiple outgoing activity edges.
Attributes
None.
Associations
 decisionInput : Behavior [0..1] Provides input to guard specifications on edges outgoing from the decision node.
Stereotypes
None.
Tagged Values
None.
Constraints
[1]  A decision node has one incoming edge.
[2] A decision input behavior has one input parameter and one output parameter. The input parameter must be the same as or
a supertype the type of object token coming along the incoming edge. The behavior cannot have side effects.
Semantics
Each token arriving at a decision node can traverse only one outgoing edge. Tokens are not duplicated. Each token offered by the incoming edge is offered to the outgoing edges.
Most commonly, guards of the outgoing edges are evaluated to determine which edge should be traversed. The order in which guards are evaluated is not defined, because edges in general are not required to determine which tokens they accept in any particular order. The modeler should arrange that each token only be chosen to traverse one outgoing edge, otherwise there will be race conditions among the outgoing edges. For decision points, a predefined guard “else” may be defined for at most one outgoing edge. This guard succeeds for a token only if the token is not acepted by all the other edges outgoing from the decision point.
Notice that the semantics only requires that the token traverse one edge, rather than be offered to only one edge. Multiple edges may be offered the token, but if only one of them has a target that accepts the token, then that edge is traversed. If multiple edges accept the token and have approval from their targets for traversal at the same time, then the semantics is not defined.
If a decision input behavior is specified, then each token is passed to the behavior before guards are evaluated on the outgoin g 
edges. The output of the behavior is available to the guard. Because the behavior is used during the process of offering tokens  
to outgoing edges, it may be run many times on the same token before the token is accepted by those edges. This means the behavior cannot have side effects. It may not modify objects, but it may for example, navigate from one object to another or get an attribute value from an object.
Semantic Variation Points
None.
UML Superstructure 2.0 Draft Adopted Specification        321Notation
The notation for a decision node is a diamond-shaped symbol, as illustrated on the left side of the figure below. Decision inpu t 
behavior is specified by the keyword «decisionInput» placed in a note symbol, and attached to the appropriate decision node symbol as illustrated in the figure below.
A decision node must have a single activity edge entering it, and one or more edges leaving it. The functionality of decision node and merge node can be combined by using the same node symbol, as illustrated at the right side of the figure below. This case maps to a model containing a a merge node with all the incoming edges shown in the diagram and one outgoing edge to a decision node that has all the outgoing edges shown in the diagram. It assumes the UML 2.0 Diagram Interchange RFP supports the interchange of diagram elements and their mapping to model elements.
 
Presentation Option
Style GuidelinesExamples
The figure below contains a decision node that follows the Received Order behavior. The branching is based on whether order 
was rejected or accepted. An order accepted condition results in passing control to Fill Order and rejected orders to Close Order. 
The example in the figure below illustrates an order process example. Here, an order item is pulled from stock and prepared for delivery. Since the item has been remove from inventory, the reorder level should also be checked; and if the actual level Figure 237 - Decision node notation
Figure 238 - Decision node example.Decision nodeDecision node
(with control flows)
...
Decision node and merge node used
together, sharing the same symbol
...
...
Decision node«decisionInput»
decision condition
with behavior
Receive Fill
Order OrderClose
Order
[order
accepted][order
rejected]
322                 UML Superstructure 2.0 Draft Adopted Specificationfalls below a prespecified reorder point, more of the same type of item should be reordered.
Rationale
Decision nodes are introduced to support conditionals in activities. Decision input behaviors are introduced to avoid redudant 
recalculations in guards.
Changes from previous UML
Decision nodes replace the use of PseudoState with junction kind in UML 1.5 activity modeling.
12.3.16 ExceptionHandler
(ExtraStructuredActivities) An exception handler is an element that specifies a body to execute in case the specified exception  
occurs during the execution of the protected node.
Associations
 protectedNode : ExecutableNode [1..1]
The node protected by the handler. The handler is examined if an exception propagates to the outside of the node.
 handlerBody : ExecutableNode [1..1]A node that is executed if the handler satisfies an uncaught exception. exceptionType : Classsifier [1..*]The kind of instances that the handler catches. If an exception occurs whose type is any 
of the classifiers in the set, the handler catches the exception and executes its body.
 exceptionInput : ObjectNode An object node within the handler body. When the handler catches an exception, the 
exception token is placed in this node, causing the body to execute.
Constraints
The exception body may not have any explicit input or output edges.
(str-adv) The result pins of the exception handler body must correspond in number and types to the result pins of the protected  
node.
Semantics
If an exception occurs during the execution of an action, the set of execution handlers on the action is examined for a handler  
that matches the exception. A handler matches if the type of the exception is the same as or a descendant of one of the Figure 239 - Decision node examplePull
Order ItemPrepare Item
for Delivery
«decisionInput»
inventoryLevel Reorder
Goods[true]
< reorderPointShip
Order
from Stock
[false]
UML Superstructure 2.0 Draft Adopted Specification        323exception classifiers specified in the handler. If there is a match, the handler “catches” the exception. The exception object is 
placed in the exceptionInput node as a token to start execution of the handler body. 
If the exception is not caught by any of the handlers on the node, all the tokens in the node are terminated and the exception propagates to the enclosing executable node or activity. If the exception propagates to the topmost level of the system and is not caught, the behavior of the system is unspecified. Profiles may specify what happens in such cases.
The exception body has no explicit input or output edges. It has the same access to its surrounding context as the protected node. The result tokens of the exception body become the result tokens of the protected node. Any control edges leaving the protected node receive control tokens on completion of execution of the exception body. When the execution body completes execution, it is as if the protected node had completed execution.
Semantic Variation Points
None.
Notation
The notation for exception handlers is illustrated in Figure 240. An exception handler for a protected node is shown by drawing a “lightning bolt” symbol from the boundary of the protected node to a small square on the boundary of the exception handler. The name of the exception type is placed next to the lightning bolt. The small square is the exception input node, and  
it must be owned by the handler body. Its type is the given exception type. Both the protected node and the exception handler must be at the same nesting level. (Otherwise the notation could be misinterpreted as an interrupting edge, which crosses a boundary.) Multiple exception handlers may may attached to the same protected node, each by its own lightning bolt. 
Presentation Option
Style GuidelinesExamples
Figure 241 shows a matrix calculation. First a matrix is inverted, then it is multiplied by a vector to produce a vector. If th e 
matrix is singular, the inversion will fail and a SingularMatrix exception occurs. This exception is handled by the exception handler labeled SingularMatrix, which executes the region containing the SubstituteVector1 action. If an overflow exception occurs during either the matirx inversion or the vector multiplication, the region containing the SubstituteVector2 action is executed.
The successors to an exception handler body are the same as the successors to the protected node. It is unnecessary to show control flow from the hander body. Regardless of whether the matrix operations complete without exception or whether one of Figure 240 - Exception Handler NotationProtected
NodeHandlerBody
NodeExceptionType
324                 UML Superstructure 2.0 Draft Adopted Specificationthe exception handlers is triggered, the action PrintResults is executed next.
Rationale
Changes from previous UML
ExceptionHandler replaces JumpHandler in UML 1.5.
Modeling of traditional break and continue statements can be accomplished using direct control flow from the statement to the 
control target.UML 1.5 combined the modeling of breaks and continues with exceptions, but that is no longer necessary and it is not recommended in this specification.
12.3.17 ExecutableNode
An executable node is an abstract class for activity nodes that may be executed. It is used as an attachment point for exceptio n 
handlers.
Associations (StructuredActivities)
 handler : ExceptionHandler [0..*]
A set of exception handlers that are examined if an uncaught exception propagates to the outer level of the executable node.
12.3.18 ExpansionKind
(ExtraStructuredActivities) ExpansionKind is an enumeration type used to specify how multiple executions of an expansion region interact. See “ExpansionRegion”.Figure 241 - Exception Handler exampleSingularMatrix
Invert
Matrix
Multiply
VectorSubstituteVector1
SubstituteVector2Overflow
PrintResults
UML Superstructure 2.0 Draft Adopted Specification        325Enumeration Literals
 parallel The executions are independent. They may be executed concurrently.
 iterative The executions are dependent and must be executed one at a time, in order of the collec-
tion elements.
 stream A stream of collection elements flows into a single execution, in oprder of the collection 
elements.
12.3.19 ExpansionNode
(ExtraStructuredActivities) An expansion node is an object node used to indicate a flow across the boundary of an expansion region. A flow into a region contains a collection that is broken into its individual elements inside the region, which is executed once per element. A flow out of a region combines individual elements into a collection for use outside the region.
Associations
 regionAsInput : ExpansionRegion[0..1]The expansion region for which the node is an input.
 regionAsOutput : ExpansionRegion[0..1]The expansion region for which the node is an output.
Semantics
See “ExpansionRegion”.
Notation
See “ExpansionRegion”.
12.3.20 ExpansionRegion
(ExtraStructuredActivities) An expansion region is a structured activity region that executes multiple times corresponding to 
elements of an input collection.
Description
An expansion region is a strictly nested region of an activity with explicit input and outputs (modeled as ExpansionNodes). Each input is a collection of values. If there are multiple input pins, each of them must hold the same kind of collection, although the types of the elements in the different collections may vary. The expansion region is executed once for each element (or position) in the input collection.
If an expansion region has outputs, they must be collections of the same kind and must contain elements of the same type as the corresponding inputs. The number of output collections at runtime can differ from the number of input collections. On each execution of the region, an output value from the region is inserted into an output collection at the same position as the  
input elements. If the region execution ends with no output, then nothing is added to the output collection. When this happens the output collection will not have the same number of elements as the input collections, the region acts as a . 
[Reviewer:  text is missing]
If all the executions provide an output to the collection, then the output collections will have the same number of elements as  
the input collections.
The inputs and outputs to an expansion region are modeled as ExpansionNodes. From “outside” of the region, the values on these nodes appear as collections. From “inside” the region the values appear as elements of the collections. Object flow edges  
connect pins outside the region to input and output expansion nodes as collections. Object flow edges connect pins inside the 
326                 UML Superstructure 2.0 Draft Adopted Specificationregion to input and output expansion nodes as individual elements. From the inside of the region, these nodes are visible as 
individual values. If an expansion node has a name, it is the name of the individual element within the region.
Any object flow edges that cross the boundary of the region, without passing through expansion nodes, provide values that are fixed within the different executions of the region.
Attributes
 mode : ExpansionKind The way in which the executions interact:
parallel — all interactions are independentiterative — the interactions occur in order of the elementsstream — a stream of values flows into a single execution
Associations
 inputElement : ExpansionNode[1..*]
An object node that holds a separate element of the input collection during each of the multiple executions of the region.
 outputElement : ExpansionNode[0..*]
An object node that accepts a separate element of the output collection during each of the multiple executions of the region. The values are formed into a collection that is available when the execution of the region is complete.
Constraints
[1]  An ExpansionRegion must have one or more argument ExpansionNodes and zero or more result ExpansionNodes. 
Semantics
When an execution of an activity makes a token available to the input of an expansion region, the expansion region 
consumes the token and begins execution. The expansion region is executed once for each element in the collection (or 
once per element position, if there are multiple collections). The concurrency attribute controls how the multiple executions proceed:
If the value is parallel , the execution may happen in parallel, or overlapping in time, but they are not required to. 
If the value is iterative , the executions of the region must happen in sequence, with one finishing before another can 
begin. The first iteration begins immediately. Subsequent iterations start when the previous iteration is completed. During 
each of these cases, one element of the collection is made available to the execution of the region as a token during each execution of the region. If the collection is ordered, the elements will be presented to the region in order; if the collection  
in unordered, the order of presenting elements is undefined and not necessarily repeatable. On each execution of the 
region, an output value from the region is inserted into an output collection at the same position as the input elements.
If the value is stream , there is a single execution of the region, but its input place receives a stream of elements from the 
collection. The values in the input collection are extracted and placed into the execution of the expansion region as a 
stream, in order if the collection is ordered. Such a region must handle streams properly or it is ill defined. When the 
execution of the entire stream is complete, any output streams are assembled into collections of the same kinds as the inputs.
Notation
An expansion region is shown as a dashed rounded box with one of the keywords concurrent , iterative , or streaming  in 
the upper left corner.
UML Superstructure 2.0 Draft Adopted Specification        327Input and output expansion nodes are drawn as small rectangles divided by vertical bars into small compartments. (The 
symbol in meant to suggest a list of elements.) The expansion node symbols are placed on the boundary of the dashed 
box. Usually arrows inside and outside the expansion region will distinguish input and output expansion nodes. If not, then a small arrow can be used as with Pins (see Figure 284 on page 358).
As a shorthand notation, the “list box pin” notation may be placed directly on an action symbol, replacing the pins of the 
action (Figure 243). This indicates an expansion region containing a single action. The equivalent full form is shown in 
Figure 244.Figure 242 - Expansion region
Figure 243 - Shorthand notation for expansion region containing single nodekeyword
keyword
identifier: behaviorDescription
328                 UML Superstructure 2.0 Draft Adopted SpecificationPresentation Option
The UML 1.5 notation for unlimited dynamicMultiplicity maps to an expansion region in parallel mode, with one behavior 
invoked in the region, as shown below.
Examples
Figure 246 shows an expansion region with two inputs and one output that is executed concurrently. Execution of the 
region does not begin until both input collections are available. Both collections must have the same number of elements. 
The interior activity fragment is executed once for each position in the input collections. During each execution of the 
region, a pair of values, one from each collection, is available to the region on the expansion nodes. Each execution of the Figure 244 - Full form of previous shorthand notation
Figure 245 - UML 1.5 notation for expansion region with one behavior invocationkeyword
identifier: behaviorDescription
*
name
UML Superstructure 2.0 Draft Adopted Specification        329region produces a result value on the output expansion node. All of the result values are formed into a collection of the 
same size as the input collections. This output collection is available outside the region on the result node after all the 
concurrent executions of the region have completed.
Figure 246 shows a fragment of an FFT (Fast Fourier Transform) computation containing an expansion region. Outside the 
region, there are operations on arrays of complex numbers. S, Slower, Supper, and V are arrays. Cut and shuffle are operations on arrays. Inside the region, two arithmetic operations are performed on elements of the 3 input arrays, yielding 2 output Figure 246 - Expansion region with 2 inputs and 1 outputparallel
330                 UML Superstructure 2.0 Draft Adopted Specificationarrays. Different positions in the arrays do not interact, therefore the region can be executed concurrently on all positions.
The following example shows a use of the shorthand notation for an expansion region with a single action. In this example, the 
trip route outputs sets of flights and sets of hotels to book. The hotels may be booked independently and concurrently with Figure 247 - Expansion regionnxteven = lower+upper nxtodd = (lower-upper)*rootlower:Complexupper:Complex
nxteven:Complex nxtodd:Complexroot:ComplexSlower, Supper = cut(S)
concurrent
S = shuffle(Sneven,Snodd)Sneven: Array<Complex> Snodd: Array<Complex>
S’: Array<Complex>S: Array<Complex>
Slower: Array<Complex>Supper: Array<Complex>V: Array<Complex>
UML Superstructure 2.0 Draft Adopted Specification        331each other and with booking the flight.
Using the UML 1.5 notation, specify Trip Route below can result in multiple flight segments, each of which must be booked 
separately. The Book Flight action will invoke the Book Flight behavior multiple times, once for each flight segment in the set  
passed to BookFlight.  
Rationale
Expansion regions are introduced to support applying behaviors to elements of a set without constraining the order of application.
Changes from previous UML
ExpansionRegion replaces MapAction, FilterAction, and dynamicConcurrency and dynamicMultiplicity attributes on ActionState. Dynamic multiplicities less than unlimited are not supported in UML 2.0.
12.3.21 FinalNode
A final node is an abstract control node at which a flow in an activity stops.
Description
See descriptions at children of final node.
Attributes
None.Figure 248 -Examples of expansion region shorthand
Figure 249 - Shortand notation for expansion regionBook
Flight
Specify
Trip
Route
Book
HotelPrint
Itinerary
*Book
FlightSpecify
Trip
Route
332                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
None.
Constraints
[1]  A final node has no outgoing edges.
Semantics
All tokens offered on incoming edges are accepted. See children of final node for other semantics.
Notation
The notations for final node are illustrated below. There are a two kinds of final node: activity final and 
(IntermediateActivities) flow final. For more detail on each of these specializations, see ActivityFinal and FlowFinal.
Examples
The figure below illustrates two kinds of final node: flow final and activity final. In this example, it is assumed that many components can be built and installed before finally delivering the resulting application. Here, the Build Component behavior occurs iteratively for each component. When the last component is built, the end of the building iteration is indicated with a flow final. However, even though all component building has come to an end, other behaviors are still executing. When the last component has been installed, the application is delivered. When Deliver Application has completed, control is passed to an activity final node—indicating that all processing in the activity is terminated. 
Rationale
Final nodes are introduced to model where flows end in an activity.
Changes from previous UML
FinalNode replaces the use of FinalState in UML 1.5 activity modeling, but its concrete classes have different semantics than FinalState.Figure 250 - Final node notation
Figure 251 - Final node example.Activity final Flow final
Build
Component
[more components
to be built][no more componentsInstall
Component
[more components
to be installed][no more components
Deliver
Application
to be built]to be installed]
UML Superstructure 2.0 Draft Adopted Specification        33312.3.22 FlowFinalNode
A flow final node is a final node that terminates a flow.
Description
A flow final destroys all tokens that arrive at it. It has no effect on other flows in the activity.
Attributes
None.
Associations
None.
Constraints
None.
Semantics
Flow final destroys tokens flowing into it.
Notation
The notation for flow final is illustrated below.  
Examples
In the example below, it is assumed that many components can be built and installed. Here, the Build Component behavior 
occurs iteratively for each component. When the last component is built, the end of the building iteration is indicated with a flow final. However, even though all component building has come to an end, other behaviors are still executing (such as Install Component). Figure 252 - Flow final notation
Figure 253 - Flow final example without merge edgeBuild
Component
[more components
to be built][no more componentsInstall
Component
to be built]
334                 UML Superstructure 2.0 Draft Adopted SpecificationRationale
Flow final nodes are introduced to model termination or merging of a flow in an activity.
Changes from previous UML
Flow final is new in UML 2.0.
12.3.23 ForkNode
A fork node is a control node that splits a flow into multiple concurrent flows.
Description
A fork node has one incoming edge and multiple outgoing edges.
Attributes
None.
Associations
None.
Constraints
[1]  A fork node has one incoming edge.
Semantics
Tokens arriving at a fork are duplicated across the outgoing edges. Tokens offered by the incoming edge are all offered to the 
outgoing edges. When an offered token is accepted on all the outgoing edges, duplicates of the token are made and one copy traverses each edges. No duplication is necessary if there is only one outgoing edge, but it is not a useful case.
If guards are used on edges outgoing from forks, the modelers should ensure that no downstream joins depend on the arrival of tokens passing through the guarded edge. If that cannot be avoided, then a decision node should be introduced to have the guard, and shunt the token to the downstream join if the guard fails. See example in Figure 212 on page 297.
Notation
The notation for a fork node is simply a line segment, as illustrated on the left side of the figure below. In usage, however, the 
fork node must have a single activity edge entering it, and two or more edges leaving it. The functionality of join node and fo rk 
node can be combined by using the same node symbol, as illustrated at the right side of the figure below. This case maps to a model containing a a join node with all the incoming edges shown the diagram and one outgoing edge to a fork node that has all the outgoing edges shown in the diagram. It assumes the UML 2.0 Diagram Interchange RFP supports the interchange of diagram elements and their mapping to model elements.
 
Figure 254 - Fork node notation
...
Fork node
(without flows)Fork node
(with flows)
...
...
Join node and fork node used
together, sharing the same symbol
UML Superstructure 2.0 Draft Adopted Specification        335Examples
In the example below, the fork node passes control to both the Ship Order and Send Invoice behaviors when Fill Order is 
completed. 
Rationale
Fork nodes are introduced to support parallelism in activities.
Changes from previous UML
Fork nodes replace the use of PseudoState with fork kind in UML 1.5 activity modeling. State machine forks in UML 1.5 required synchronization between parallel flows through the state machine RTC step. UML 2.0 activity forks model unrestricted parallelism.
12.3.24 InitialNode
An initial node is a control node at which flow starts when the activity is invoked.
Description
An activity may have more than one initial node.
Attributes
None.
Associations
None.
Constraints
[1]  An initial node has no incoming edges.
Semantics
An initial node is a starting point for invoking an activity. A control token is placed at the initial node when the activity s tarts. 
Tokens in an initial node are offered to all outgoing edges. If an activity has more than one initial node, then invoking the activity starts multiple flows, one at each initial node. For convenience, initial nodes are an exception to the rule that cont rol 
nodes cannot hold tokens if they are blocked from moving downstream (see Activity). This is equivalent interposing a CentralBufferNode between the initial node and its outgoing edges.
Note that flows can also start at other nodes, see ActivityParameterNode and AcceptEventAction, so initial nodes are not Figure 255 - Fork node example.Fill
Order
Send
InvoiceFill
Order
336                 UML Superstructure 2.0 Draft Adopted Specificationrequired for an activity to start execution.
Notation
Initial nodes are notated as a solid circle, as indicated in the figure below.
Examples
In the example below, the initial node passes control to the Receive Order behavior at the start of an activity. 
Rationale
Initial nodes are introduced to model where flows start in an activity.
Changes from previous UML
InitialNode replaces the use of PseudoState with kind initial in UML 1.5 activity modeling.
12.3.25 InputPin
An input pin is a pin that holds input values to be consumed by an action. They are object nodes and receive values from other 
actions through object edges. See Pin, Action, and ObjectNode for more details.
Attributes
None.
Associations
None.
Constraints
[1]  Input pins have incoming edges only.
12.3.26 InterruptibleActivityRegion
An interruptible activity region is an activity group that supports termination of tokens flowing in the portions of an activit y.Figure 256 - Initial node notation
Figure 257 - Initial node exampleReceive
Order
UML Superstructure 2.0 Draft Adopted Specification        337Description
An interruptible region contains activity nodes. When a token leaves an interruptible region via edges designated by the region  
as interrupting edges, all tokens and behaviors in the region are terminated.
Attributes
None.
Associations (CompleteActivities)
 interruptingEdge : ActivityEdge [0..*].The edges leaving the region that will abort other tokens flowing in the region.
Constraints
[1]  Interrupting edges of a region must have their source node in the region and their target node outside the region in the 
same activity containing the region.
Semantics
The region is interrupted when a token traverses an interrupting edge. At this point the interrupting token has left the region  
and is not terminated. 
Token transfer is still atomic, even when using interrupting regions. If a non-interrupting edge is passing a token from a sour ce 
node in the region to target node outside the region, then the transfer is completed and the token arrives at the target even i f in 
interruption occurs during the traversal. In other words, a token transition is never partial; it is either complete or it does  not 
happen at all.
Do not use an interrupting region if it is not desired to abort all flows in the region in some cases. For example, if the same  
execution of an activity is being used for all its invocations, then multiple streams of tokens will be flowing through the sam e 
activity. In this case, it is probably not desired to abort all tokens just because one leaves the region. Arrange for separate  
invocations of the activity to use separate executions of the activity when employing interruptible regions, so tokens from eac h 
invocation will not affect each other.
Notation
An interruptible activity region is notated by a dashed, round-cornered rectangle drawn around the nodes contained by the region. An interrupting edge is notation with a lightning-bolt activity edge.
Figure 258 - InterruptibleActivityRegion notation with interrupting edge
338                 UML Superstructure 2.0 Draft Adopted SpecificationPresentation Option
An option for notating an interrupting edge is an zig zag adornment on a straight line.
Examples
The first figure below illustrates that when an order cancellation request is made—only while receiving, filling, or shipping) 
orders—the Cancel Order behavior is invoked.
Rationale
Interruptible regions are introduced to support more flexible non-local termination of flow.
Changes from previous UML
Interruptible regions in activity modeling are new to UML 2.0.
12.3.27 JoinNode
A join node is a control node that synchronizes multiple flows.Figure 259 - InterruptibleActivityRegion notation with interrupting edge
Figure 260 - InterruptibleActivityRegion exampleReceive Fill
OrderShip
Order OrderClose
Order
Send
InvoiceMake
PaymentAccept
Payment[orderaccepted][order
rejected]
InvoiceCancel
OrderOrder
cancel
request
UML Superstructure 2.0 Draft Adopted Specification        339Description
A join node has multiple incoming edges and one outgoing edge.
(CompleteActivities) Join nodes have a boolean value specification using the names of the incoming edges to specify the 
conditions under which the join will emit a token.
Attributes
None.
Associations
None.
Associations (CompleteActivities)
 joinSpec : ValueSpecification [1..1] A specification giving the conditions under which the join will emit a token. Default 
is “and”.
Constraints
[1]  A join node has one outgoing edge.
Semantics
If there is a token offered on all incoming edges, then tokens are offered on the outgoing edge according to the following join  
rules:
1. If all the tokens offered on the incoming edges are control tokens, then one control token is offered on the outgoing 
edge.
2. If some of the tokens offered on the incoming edges are control tokens and other are data tokens, then only the data 
tokens are offered on the outgoing edge.
No joining of tokens is necessary if there is only one incoming edge, but it is not a useful case.
(CompleteActivities) The reserved string “and” used as a join specification is equivalent to a specification that requires at l east 
one token offered on each incoming edge. It is the default. The join specification is evaluated whenever a new token is offered  
on any incoming edge. The evaluation is not interrupted by any new tokens offered during the evaluation, nor are concurrent evaluations started when new tokens are offered during an evaluation.
If any tokens are offered to the outgoing edge, they must be accepted or rejected for traversal before any more tokens are offered to the outgoing edge. If tokens are rejected for traversal, they are no longer offered to the outgoing edge. The join specification may contain the names of the incoming edges to refer to whether a token was offered on that edge at the time the evaluation started.
Other rules for when tokens may be passed along the outgoing edge depend the characteristics of the edge and its target. For example, if the outgoing edge targets an object node that has reached its upper bound, no token can be passed. The rules may be optimized to a different algorithm as long as the effect is the same. In the full object node example, the implementation ca n 
omit the unnecessary join evaluations until the down stream object node can accept tokens.
Notation
The notation for a join node is a line segment, as illustrated on the left side of the figure below. The join node must have on e or 
more activity edges entering it, and only one edge leaving it. The functionality of join node and fork node can be combined by 
340                 UML Superstructure 2.0 Draft Adopted Specificationusing the same node symbol, as illustrated at the right side of the figure below. This case maps to a model containing a a join  
node with all the incoming edges shown in the diagram and one outgoing edge to a fork node that has all the outgoing edges shown in the diagram. It assumes the UML 2.0 Diagram Interchange RFP supports the interchange of diagram elements and their mapping to model elements.
(CompleteActivities) Join specifications are shown near the join node, as shown below.
Examples
The example at the left of the figure indicates that a Join is used to synchronize the processing of the Ship Order and Accept Order behaviors. Here, when both have been completed, control is passed to Close Order.
(CompleteActivities) The example below illustrates how a join specification can be used to ensure that both a drink is selected  
and the correct amount of money has been inserted before the drink is dispensed. Names of the incoming edges are used in the Figure 261 - Join node notations
Figure 262 - Join node notations
Figure 263 - Join node example
...
Join node
(without flows)Join node
(with flows)
...
Join node and fork node used
together, sharing the same symbol
......Join node (with flows  {joinSpec = ...}
and a join specification)
Ship
Order
Close
OrderAccept
Order
UML Superstructure 2.0 Draft Adopted Specification        341join specification to refer to whether tokens are available on the edges.
Rationale
Join nodes are introduced to support parallelism in activities.
Changes from previous UML
Join nodes replace the use of PseudoState with join kind in UML 1.5 activity modeling.
12.3.28 LoopNode
(StructuredActivities) A loop node is a costructured activity node that represents a loop with setup, test, and body sections. 
Description
Each section is a well-nested subregion of the activity whose nodes follow any predecessors of the loop and precede any 
successors of the loop. The test section may precede or follow the body section. The setup section is executed once on entry to  
the loop, and the test and body sections are executed repeatedly until the test produces a false value. The results of the fina l 
execution of the test or body are available after completion of execution of the loop.
Attributes
 isTestedFirst : Boolean [1] If true, the test is performed before the first execution of the body.
If false, the body is executed once before the test is performed.
Associations (StructuredActivities)
 setupPart : ActivityNode[0..*] The set of nodes and edges that initialize values or perform other setup computations for 
the loop.
 bodyPart : ActivityNode[0..*] The set of nodes and edges that perform the repetitive computations of the loop. The body 
section is executed as long as the test section produces a true value.
 test : ActivityNode[0..*] The set of nodes, edges, and designated value that compute a Boolean value to determine 
if another execution of the body will be performed.
 decider : OutputPin [1] An output pin within the test fragment the value of which is examined after execution of 
the test to determine whether to execute the loop body.Figure 264 - Join node exampleSelect
Drink
Dispense
DrinkInsert
CoinA and B
and the total coin value
inserted is >= drink price}{joinSpec =
A
B
342                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations ((CompleteStructuredActivities)
 result : OutputPin [0..*] A list of output pins that constitute the data flow output of the entire loop.
 loopVariable : OutputPin [0..*] A list of output pins owned by the loop that hold the values of the loop variables during an 
execution of the loop. When the test fails, the values are copied to the result pins of the loop.
 bodyOutput : OutputPin [0..*] A list of output pins within the body fragment the values of which are copied to the loop 
variable pins after completion of execution of the body, before the next iteration of the loop begins or before the loop exits.
 loopVariableInput : InputPin[0..*]
A list of values that are copied into the loop variable pins before the first iteration of the 
loop.
Constraints
None.
Semantics
No part of a loop node is executed until all control-flow or data-flow predecessors of the loop node have completed execution. When all such predecessors have completed execution and made tokens available to inputs of the loop node, the loop node captures the input tokens and begins execution. 
First the setup section of the loop node is executed. A front end node  is a node within a nested section (such as the setup 
section, test section, or body section) that has no predecessor dependencies within the same section. A control token is offere d 
to each front end node within the setup section. Nodes in the setup section may also have individual dependencies (typically data flow dependencies) on nodes external to the loop node. To begin execution, such nodes must receive their individual tokens in addition to the control token from the overall loop. 
A back end node  is a node within a nested section that has no successor dependencies within the same section. When all the 
back end nodes have completed execution, the overall section is considered to have completed execution. (It may be thought of as delivering a control token to the next section within the loop.)
When the setup section has completed execution, the iterative execution of the loop begins. The test section may precede or follow the body section (test-first loop or test-last loop). The following description assumes that the test section comes firs t. If 
the body section comes first, it is always executed at least once, after which this description applies to subsequent iteration s.
When the setup section has completed execution (if the test comes first) or when the body sections has completed execution of 
an iteration, the test section is executed. A control token is offered to each front end node within the test section. When all  back 
end nodes in the test section have completed execution, execution of the test section is complete. Typically there will only be  
one back end node and it will have a Boolean value, but for generality it is permitted to perform arbitrary computation in the test section. 
When the test section has completed execution, the Boolean value on the designated decider  pin within the test section is 
examined. If the value is true, the body section is executed again. If the value is false, execution of the loop node is comple te.
When the setup section has completed execution (if the body comes first) or when the iteration section has completed 
execution and produced a true value, execution of the body section begins. Each front end node in the body section is offered a  
control token. When all back end nodes in the body section have completed execution, execution of the body section is complete. 
Within the body section, variables defined in the loop node or in some higher-level enclosing node are updated with any new values produced during the iteration and any temporary values are discarded.
UML Superstructure 2.0 Draft Adopted Specification        343Notation
Examples
Rationale
Loop nodes are introduced to provide a structured way to represent iteration.
Changes from previous UML
Loop nodes are new in UML 2.0.
12.3.29 MergeNode
A merge node is a control node that brings together multiple alternate flows. It is not used to synchronize concurrent flows bu t 
to accept one among several alternate flows.
Description
A merge node has multiple incoming edges and a single outgoing edge.
Attributes
None.
Associations
Constraints
[1]  A merge node has one outgoing edge.
Semantics
All tokens offered on incoming edges are offered to the outgoing edge. There is no synchronization of flows or joining of 
tokens. 
Notation
The notation for a merge node is a diamond-shaped symbol, as illustrated on the left side of the figure below. In usage, however, the merge node must have two or more edges entering it and a single activity edge leaving it. The functionality of merge node and decision node can be combined by using the same node symbol, as illustrated at the right side of the figure below. This case maps to a model containing a a merge node with all the incoming edges shown the diagram and one outgoing edge to a decision node that has all the outgoing edges shown in the diagram. It assumes the UML 2.0 Diagram Interchange 
344                 UML Superstructure 2.0 Draft Adopted SpecificationRFP supports the interchange of diagram elements and their mapping to model elements.
Examples
In the example below, either one or both of the behaviors, Buy Item or Make Item could have been invoked. As each  
completes, control is passed to Ship Item. That is, if only one of Buy Item or Make Item complete, then Ship Item is invoked only once; if both complete, Ship Item is invoked twice. 
Rationale
Merge nodes are introduced to support bringing multiple flows together in activities. For example, if a decision is used after a 
fork, the two flows coming out of the decision need to be merged into one before going to a join. Otherwise the join will wait for both flows, only one of which will arrive.
Changes from previous UML
Merge nodes replace the use of PseudoState with junction kind in UML 1.5 activity modeling. 
12.3.30 ObjectFlow
An object flow is an activity edge that can have objects or data passing along it.
Description
An object flow models the flow of values to or from object nodes.
(CompleteActivities) Object flows add support for modeling the effects of behaviors, multicast/receive, and token selection from object nodes and transformation of tokens.Figure 265 - Merge node notation
Figure 266 - Merge node exampleMerge node Merge node
(with flows)...
Merge node and decision node used
together, sharing the same symbol
...
...
Buy
Ship
ItemItem
Make
Item
UML Superstructure 2.0 Draft Adopted Specification        345Attributes (CompleteActivities)
 effect : ObjectFlowEffectKind [0..*]Specifies the effect that the immediately upstream or downstream action has on the 
objects flowing along the edge.
 isMulticast : Boolean [1..1] = falseTells whether the objects in the flow are passed by multicasting. isMultireceive : Boolean [1..1] = falseTells whether the objects in the flow are gathered from respondents to multicasting.
Associations (CompleteActivities)
 selection : Behavior [0..1] Selects tokens from a source object node. transformation : Behavior [0..1]Changes or replaces data tokens flowing along edge.
Constraints (BasicActivities)
[1]  Object flows may have an action on at most one end.
[2] Object nodes connected by an object flow, with optionally intervening control nodes, must have compatible types. In par-
ticular, the downstream object node type must be the same or a supertype of the upstream object node type.
[3] Object nodes connected by an object flow, with optionally intervening control nodes, must have the same upper bounds.
Constraints (CompleteActivities)
[1]  An edge with constant weight may not target an object node, or lead to an object node downstream with no intervening 
actions, that has an upper bound less than the weight.
[2] A transformation behavior has one input parameter and one output parameter. The input parameter must be the same as or
a supertype the type of object token coming from the source end. The output parameter must be the same or a subtype ofthe type of object token expected downstream. The behavior cannot have side effects.
[3] An object flow may have a selection behavior only if has an object node as a source.
[4] A selection behavior has one input parameter and one output parameter. The input parameter must be a bag of elements of
the same as or a supertype the type of source object node. The output parameter must be the same or a subtype of the typeof source object node. The behavior cannot have side effects.
[5] isMulticast and isMultireceive cannot both be true.
[6] Only object flows with actions at one end or the other may have effects. Only object flows with actions on the target end
may have a delete effect. Only object flows with actions on the source end may have create effect.
Semantics (BasicActivities)
See semantics inherited from ActivityEdge. An object flow is an activity edge that only passes object and data tokens. Tokens offered by the source node are all offered to the target node, subject to the restrictions inherited from ActivityEdge.
Two object flows may have the same object node as source. In this case the edges will compete for objects. Once an edge takes an object from an object node, the other edges do not have access to it. Use a fork to duplicate tokens for multiple uses.
Semantics (CompleteActivities)
If a transformation behavior is specified, then each token offered to the edge is passed to the behavior, and the output of the  
behavior is given to the target node for consideration. Because the behavior is used while offering tokens to the target node, it 
may be run many times on the same token before the token is accepted by the target node. This means the behavior cannot have side effects. It may not modify objects, but it may for example, navigate from one object to another, get an attribute val ue 
from an object, or replace a data value with another.
346                 UML Superstructure 2.0 Draft Adopted SpecificationIf a selection behavior is specified, then it is used to offer a token from the source object node to the edge, rather than usi ng 
object node’s ordering. It has the same semantics as selection behavior on object nodes. See ObjectNode. See application at DataStoreNode.
Multicasting and receiving is used in conjunction with partitions to model flows between behaviors that are the responsibility of objects determined by a publish and subscribe facility. To support execution the model must be refined to specify the particular publish/subscribe facility employed. This is illustrated in the Figure 274.
Notation
An object flow is notated by an arrowed line.
(CompleteActivities) Selection behavior is specified with the keyword «selection» placed in a note symbol, and attached to the appropriate objectFlow symbol as illustrated in the figure below.
(CompleteActivities) Specifying the effect that the behavior of the actions have on the objects flowing on the edge can be represented by placing the effect in braces near the edge leading to the affected object node. Since flows from actions to pins  
are elided, the effect is shown next to the pin.Figure 267 - Object flow notations
Figure 268 - Specifying selection behavior on an Object flow
Figure 269 - Specifying effect that actions have on objectsObject flow
(without activity nodes)Two object flow edges linking 
object nodes and actions
An object flow edge linking 
two object node pins.
«selection»
selection specification«selection»
selection specification
{input 
effect}{output 
effect}{input effect}{output 
effect}
UML Superstructure 2.0 Draft Adopted Specification        347Presentation Option
To reduce clutter in complex diagrams, object nodes may be elided. The names of the invoked behaviors can suggest their 
parameters. Tools may support hyperlinking from the edge lines to show the data flowing along them, and show a small square above the line to indicate that pins are elided, as illustrated in the figure below. Any adornments that would normally be near  
the pin, like effect, can be displayed at the ends of the flow lines.
Examples
In the example on the left below, the two arrowed lines are both object flow edges. This indicates that order objects flow from  
Fill Order to Ship Order. In the example on the right, the one arrowed line starts from the Fill Order object node pin and ends  
at Ship Order object node pin. This also indicates that order objects flow from Fill Order to Ship Order.
On the left, the example below shows the Pick Materials activity provide an order along with its associated materials for assembly. On the right, the object flow has been simplified through eliding the object flow details.
(CompleteActivities) In the figure below, two examples of selection behavior are illustrated. The example on the left indicates  
that the orders are to be shipped based or order priority—and those with the same priority should be filled on a first-in/first -out 
(FIFO) basis. The example on the right indicates that the result of a Close Order activity produces closed order objects, but t he 
Send Customer Notice activity requires a customer object. The selection, then, specifies that a query operation that takes an Order evaluates the customer object via the Order.customer:Party association. At the bottom of the figure, an example depicts a Place Order activity which creates orders and Fill Order activity which reads these placed orders for the purpose of filling them.Figure 270 - Eliding objects flowing on the edge
Figure 271 - Object flow example
Figure 272 - Eliding objects flowing on the edgeWith explicit pins With pins elided
Fill
OrderShip
OrderOrder Ship
OrderFill
OrderOrder Order
With explicit pins With elided pinsPick 
Materials
for OrderAssemble
OrderPick 
Materials
for OrderAssemble
OrderOrder Order
Materials Materials
348                 UML Superstructure 2.0 Draft Adopted Specification(CompleteActivities) In the example below, the Requests for Quote (RFQs) are sent to multiple specific sellers (i.e. is 
multicast) for a quote response by each of the sellers. Some number of sellers then respond by returning their quote response. Since multiple responses can be received, the edge is labeled for the multiple-receipt option. Publish/subscribe and other brokered mechanisms can be handled using the multicast and multireceive mechanisms. Note that the swimlanes are an important feature for indicating the subject and source of this.
Rationale
Object flow is introduced to model the flow of data and objects in an activity.
Changes from previous UML
Explicitly modeled object flows are new in UML 2.0. They replace the use of (state) Transition in UML 1.5 activity modeling. They also replace data flow dependencies from UML 1.5 action model.Figure 273 - Specifying selection behavior on an Object flow
Figure 274 - Specifying multicast and multireceive on the edgeShip
OrderFill
OrderOrder
[Filled]Order
[Filled]«selection»
FIFO within
Order Priority
Send
Customer«transformation»Order.customer
NoticeClose
OrderOrder
[Closed]Customer
{create} {read}Fill
OrderPlace
OrderOrder
[Placed]Order
[Placed]
«multicast»
Request
for QuotePlace
QuoteRFQs
Quote
Responses«multireceive» Award
QuoteBuyer Seller
UML Superstructure 2.0 Draft Adopted Specification        34912.3.31 ObjectFlowEffectKind
The datatype ObjectFlowEffectKind is an enumeration that indicates the data base effect of an action.
Enumeration Values
 create
 read
 update
 delete
12.3.32 ObjectNode
An object node is an abstract activity node that is part of defining object flow in an activity.
Description
An object node is an activity node that indicates an instance of a particular classifier, possibly in a particular state, may b e 
available at a particular point in the activity. Object nodes can be used in a variety of ways, depending on where objects are flowing from and to, as described in the semantics section.
(CompleteActivities) Complete object nodes add support for token selection, limitation on the number of tokens, and specifying the state required for tokens.
Attributes (CompleteActivities)
 ordering : ObjectNodeOrderingKind [1..1] = FIFO
Tells whether and how the tokens in the object node are ordered for selection to traverse edges outgoing from the object node.
Associations (BasicActivities)
None.
Associations (CompleteActivities)
 inState : State [0..*] The required states of the object available at this point in the activity.
 selection : Behavior [0..1] Selects tokens for outgoing edges. upperBound : ValueSpecification [1..1] = Null
The maximum number of tokens allowed in the node. Objects cannot flow into the node if the upper bound is reached.
Constraints (BasicActivities)
[1]  All edges coming into or going out of object nodes must be object flow edges.
Constraints (CompleteActivities)
[1]  The upper bound must be equal to the upper bound of nearest upstream and downstream object nodes that do not have 
intervening action nodes.
350                 UML Superstructure 2.0 Draft Adopted Specification[2] If an object node has a selection behavior, then the ordering of the object node is ordered, and vice versa.
[3] A selection behavior has one input parameter and one output parameter. The input parameter must be a bag of elements of
the same type as the object node or a supertype of the type of object node. The output parameter must be the same or asubtype of the type of object node. The behavior cannot have side effects.
Semantics
Object nodes may only contain values at runtime that conform to the type of the object node, in the state or states specified, if 
any. If no type is specified, then the values may be of any type. Multiple tokens containing the same value may reside in the object node at the same time. This includes data values.
Semantics (CompleteActivities)
An object node may not contain more tokens than its upper bound. The upper bound must be a positive LiteralInteger or a LiteralNull. An upper bound that is a LiteralNull means the upper bound is unlimited. See ObjectFlow for additional rules regarding when objects may traverse the edges incoming and outgoing from an object node.
The ordering of an object node specifies the order in which tokens in the node are offered to the outgoing edges. This can be set to require that tokens do not overtake each other as they pass through the node (FIFO), or that they do (LIFO or modeler-defined ordering). Modeler-defined ordering is indicated by an ordering value of ordered, and a selection behavior that determines what token to offer to the edges. The selection behavior takes all the tokens in the object node as input and choose s 
a single token from those. It is executed whenever a token is to be offered to an edge. Because the behavior is used while offering tokens to outgoing edges, it may be run many times on the same token before the token is accepted by those edges. This means the behavior cannot have side effects. The selection behavior of an object node is overridden by any selection behaviors on its outgoing edges. See ObjectFlow. Overtaking due to ordering is distinguished from the case where the each invocation of the activity is handled by a separate execution of the activity. In this case, the tokens have no interaction wit h 
each other, because they flow through separate executions of the activity. See Activity.
Notation
Object nodes are notated as rectangles. A name labeling the node is placed inside the symbol, where the name indicates the type of the object node. Object nodes whose instances are sets of the “name” type are labeled as such. Object nodes with a signal as type are shown with the symbol on the right.
(CompleteActivities) A name labeling the node indicates the type of the object node. The name can also be qualified by a state or states, which is to be written within brackets below the name of the type. Upper bounds and ordering other than the defaults  Figure 275 - Object node notationsSet of name name
Object node
for tokenscontaining setsObject nodename
Object node
for tokens withsignal as type
UML Superstructure 2.0 Draft Adopted Specification        351are notated in braces underneath the object node.
(CompleteActivities) Selection behavior is specified with the keyword «selection» placed in a note symbol, and attached to an 
ObjectNode symbol as illustrated in the figure below.
Presentation Option
It is expected that the UML 2.0 Diagram Interchange RFP will define a metaassociation between model elements and view elements, like diagrams. It can be used to link an object node to an object diagram showing the classifier that is the type of the 
object and its relations to other elements. Tools can use this information in various ways to integrate the activity and class diagrams, such as a hyperlink from the object node to the diagram, or insertion of the class diagram in the activity diagram as  
desired. See example in Figure 287.
Style Guidelines
Examples
See examples at ObjectFlow and children of ObjectNode.
Rationale
Object nodes are introduced to model the flow of objects in an activity.
Changes from previous UML
ObjectNode replaces and extends ObjectFlowState in UML 1.5. In particular, it and its children support collection of tokens at 
runtime, single sending and receipt, and the new “pin” style of activity model.Figure 276 - Object node notations
Figure 277 - Specifying selection behavior on an Object nodename
[state, state...]
Object node for
tokens containing
objects in specific
statesObject node
with a limited
upper bound{ordering = LIFO} name
{upperBound = 2} name
Object node
with orderingother than FIFO
name«selection»
selection specification
352                 UML Superstructure 2.0 Draft Adopted Specification12.3.33 ObjectNodeOrderingKind
ObjectNodeOrderingKind is an enumeration indicating queuing order within a node.
Enumeration Values
 unordered
o r d e r e dL I F OF I F O
12.3.34 OutputPin
An output pin is a pin that holds output values produced by an action. Output pins are object nodes and deliver values to other  
actions through object edges. See Pin, Action, and ObjectNode for more details.
Attributes
None.
Associations
None.
Constraints
[1]  Output pins have outgoing edges only.
12.3.35 Parameter (as specialized)
(CompleteActivities) Parameter is specialized when used with complete activities.
Description
Parameters are extended in complete activities to add support for streaming, exceptions, and parameter sets.
Attributes
 isException : Boolean [1..1] =falseTells whether an output parameter may emit a value to the exclusion of the other out-
puts.
 isStream : Boolean [1..1] = falseTells whether an input parameter may accept values while its behavior is executing, or 
whether an output parameter post values while the behavior is executing.
 parameterSet : ParameterSet [0..*] The parameter sets containing the parameter. See ParameterSet.
Associations
None.
Constraints
[1]  A parameter cannot be a stream and exception at the same time.
UML Superstructure 2.0 Draft Adopted Specification        353[2] An input parameter cannot be an exception.
[3] Reentrant behaviors cannot have stream parameters.
Semantics
isException applies to output parameters. An output posted to an exception excludes outputs from being posted to other data 
and control outputs of the behavior. A token arriving at an exception output parameter of an activity aborts all flows in the activity. Any objects previously posted to non-stream outputs never leave the activity. Streaming outputs posted before any exception are not affected. Use exception parameters on activities only if it is desired to abort all flows in the activity. Fo r 
example, if the same execution of an activity is being used for all its invocations, then multiple streams of tokens will be flowing through the same activity. In this case, it is probably not desired to abort all tokens just because one reaches an 
exception. Arrange for separate executions of the activity to use separate executions of the activity when employing 
exceptions, so tokens from separate executions will not affect each other.
Streaming parameters give an action access to tokens passed from its invoker while the action is executing. Values for streaming parameters may arrive anytime during the execution of the action, not just at the beginning. Multiple value may arrive on a streaming parameter during a single action execution and be consumed by the action. In effect, streaming parameters give an action access to token flows outside of the action while it is executing. In addition to the execution rules  
given at Action, these rules also apply to invoking a behavior with streaming parameters:
 All non-stream inputs must arrive for the behavior to be invoked. If there are only stream inputs, then at least one must 
arrive for the behavior to be invoked.
 All inputs must arrive for the behavior to finish, that is, for all inputs must arrive for non-stream outputs to be posted 
and control edges traversed out of the invocation of the behavior.
 Either all non-stream outputs must be posted when an activity is finished, or one of the exception outputs must be.
The execution rules above provide for the arrival of inputs after a behavior is started and the posting of outputs before a behavior is finished. These are stream inputs and outputs. Multiple stream input and output tokens may be consumed and posted while a behavior is running. Since an activity is a kind of behavior, the above rules apply to invoking an activity, eve n 
if the invocation is not from another activity. A reentrant behavior cannot have streaming parameters because there are potentially multiple executions of the behavior going at the same time, and it is ambiguous which execution should receive streaming tokens.
See semantics of Action and ActivityParameterNode.
Notation
See notation at Pin and ActivityParameterNode. The notation in class diagrams for exceptions and streaming parameters 
on operations has the keywords “exception” or “stream” in the property string. See notation for Operation.
Examples
See examples at Pin and ActivityParameterNode.
Rationale
Parameter (in Activities) is extended to support invocation of behaviors by activities.
Changes from previous UML
Parameter (in Activities) is new in UML 2.0.
354                 UML Superstructure 2.0 Draft Adopted Specification12.3.36 ParameterSet
A parameter set is an element that provides alternative sets of inputs and outputs that a behavior may use.
Description
An parameter set acts as a complete set of inputs and outputs to a behavior, exclusive of other parameter sets on the behavior.
Attributes
None.
Associations (CompleteActivities)
 parameterInSet : ParameterPin [1..*] Parameters in the parameter set .
Constraints
[1]  The parameters in a parameter set must all be inputs or all be outputs of the same parameterized entity, and the parameter  
set is owned by that entity.
[2] If a behavior has input parameters that are in a parameter set, then any inputs that are not in a parameter set must be
streaming. Same for output parameters.
Semantics
A behavior with input parameter sets can only accept inputs from parameters in one of the sets per execution. A behavior with output parameter sets can only post outputs to the parameters in one of the sets per execution. The semantics described at Action and ActivityParameter apply to each set separately.
Notation
Multiple object flows entering or leaving a behavior invocation are typically treated as “and” conditions. However, sometimes one group of flows are permitted to the exclusion of another. This is modeled as parameter set and notated with rectangles surrounding one or more pins. The notation in the figure below expresses a disjunctive normal form where one group of “and” flows are separated by “or” groupings. For input, when one group or another has a complete set of input flows, the activity may begin. For output, based on the internal processing of the behavior, one group or other of output flows may occur.
Figure 278 - Alternative input/outputs using parameter sets notation
UML Superstructure 2.0 Draft Adopted Specification        355Examples
In the figure below, the Ship Item activity begins whenever it receives a bought item or a made item. The diagram on the left 
uses a decision diamond; the one on the left uses parameter sets to express the same notion. The example at the bottom of the figure is a similar simplification of the Trouble Ticket example earlier.
Rationale
Parameter sets provide a way for behaviors to direct token flow in the activity which invokes those behaviors.
Changes from previous UML
ParameterSet is new in UML 2.0.
12.3.37 Pin
A pin is an object node for inputs and outputs to actions.
Description
Pins are connected as inputs and outputs to actions. They provide values to actions and accept result values from them.Figure 279 - Example of alternative input/outputs using parameter setsBuy
Item
Make
Item
Using parameter sets to express “or” invocation
Record Reproduce
ProblemCorrect
Problem Problem
Audit and
RecordCommunicate
Results
[else][recorded][cannot reproduce problem]
[problem not solved][else]
[canreproduce problem][duplicationof anotherproblem][knownproblemand solution][not recorded][problem statement rectified]
Trouble Ticket example using parameter sets.Ship
Item
ID Problem
and ResolutionVerify
Resolution
356                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
None.
Associations
None.
Constraints
[1]  If the action is an invocation action, the number and types of pins must be the same as the number of parameters and
 types of the invoked behavior or behavioral feature. Pins are matched to parameters by order.
See constraints on ObjectFlow.
Semantics
A pin represents an input to an action or an output from an action. The definition on an action assumes that pins are ordered (although names are usually sufficient in the notation to disambiguate pins, so the ordering is rarely shown in the notation). 
Notation
Pin rectangles may be notated as small rectangles that are attached to action rectangles. See figure below and examples. The name of the pin can be displayed near the pin. The name is not restricted, but it is often just shows the type of object or dat a 
that flows through the pin. It can also be a full specification of the corresponding behavior parameter for invocation actions,  
using the same notation as parameters for behavioral features on classes. The pins may be elided in the notation even though they are present in the model.
The situation in which the output pin of one action is connected to the input pin of the same name in another action may be shown by the optional notations of Figure 281. The standalone pin in the notation maps to an output pin and an input pin in the  
underlying model. This form should be avoided if the pins are not of the same type. These variations in notation assume the UML 2.0 Diagram Interchange RFP supports the interchange of diagram elements and their mapping to model elements, so that the chosen variation is preserved on interchange.Figure 280 - Pin notationsname
Input pinname
Output pin
UML Superstructure 2.0 Draft Adopted Specification        357 
See ObjectNode for other notations applying to pins, with examples for pins below.
(CompleteActivities) To show streaming, a text annotation is placed near the pin symbol: {stream} or {nonstream}. See figure 
below. The notation is the same for a standalone object node. Nonstream is the default where the notation is omitted.  
(CompleteActivities) Pins for exception parameters are indicated with a small triangle annotating the source end of the edge that comes out of the exception pin. The notation is the same even if the notation uses a standalone notation. See figure below .Figure 281 - Standalone pin notations
Figure 282 - Stream pin notationsname
name
Output pin,
streamingname
[state]
{stream}name{stream} {stream}
Standalone object node,,
streaming on both endname
[state]
Input pin,
streaming {stream}
358                 UML Superstructure 2.0 Draft Adopted SpecificationSee ObjectNode for other notations applying to pins, with examples for pins below.
Presentation Option
When edges are not present to distinguish input and output pins, an optional arrow may be placed inside the pin rectangle, as 
shown below. Input pins have the arrow pointing toward the action and output pins have the arrow pointing away from the action.
(CompleteActivities) Additional emphasis may be added to streaming parameters by using a graphical notation instead of the textual adornment. Object nodes can be connected with solid arrows contained filled arrowheads to indicate streaming. Pins can be shown as filled rectangles. When combined with the option above, the arrows are shown as normal arrowheads.Figure 283 - Exception pin notations
Figure 284 - Pin notations, with arrowsOutput pin, pin style, exception
Input and output pin, standalone style, exception 
Input pin,
pin-style, with arrowOutput pin,
pin-style, with arrow
UML Superstructure 2.0 Draft Adopted Specification        359Examples
In the example below, the pin named “Order” represents Order objects. In this example at the upper left, the Fill Order 
behavior produces filled orders and Ship Order consumes them and an invocation of Fill Order must complete for Ship Order to begin. The pin symbols have been elided from the actions symbols; both pins are represented by the single box on the arrow. The example on the upper right shows the same thing with explicit pin symbols on actions. The example at the bottom of the figure illustrates the use of multiple pins.
 
In the figure below, the object node rectangle Order is linked to a class diagram that further defines the node. The class 
diagram shows that filling an order requires order, line item, and the customer’s trim-and-finish requirements. An Order token 
is the object flowing between the Accept and Fill activities, but linked to other objects. The activity without the class diagr am Figure 285 - Stream pin notations, with filled arrows and rectangles
Figure 286 - Pin examplesOutput pin,
pin-style, streamingname
[state]
name
[state]
Input and output pin,
stand-alone style, streaming on both endsname
[state]
Input pin,
pin-style, streaming 
Fill
OrderShip
Order
OrderOrder Order
Ship
OrderFill
Order
Order
Order
[accepted]Accept
Order
Materials
[picked]Pick
Materials
for OrderPC designs
Produce
Designs{stream}
Materials
[picked]PC designs
Order
[assembled]Assemble
Order
360                 UML Superstructure 2.0 Draft Adopted Specificationprovides a simplified view of the process. The link to an associated class diagram is used to show more detail.
(CompleteActivities) In the example below Order Filling is a continuous behavior that periodically emits (streams out) filled-
order objects, without necessarily concluding as an activity. The Order Shipping behavior is also a continuous behavior that periodically receives filled-order objects as they are produced. Order Shipping is invoked when the first order arrives and doe s 
not terminate, processing orders as they arrive.
 
(CompleteActivities) Examples of exception notation is shown at the top of the figure below. Accept Payment normally completes with a payment as being accepted and the account is then credited. However, when something goes wrong in the acceptance process, an exception can be raised that the payment is not valid, and the payment is rejected.Figure 287 - Linking a class diagram to an object node
Figure 288 - Pin examplesAccept
OrderOrderFill
Order
Order
LineItem Trim &
FinishObject node 
rectangle linked
with a class diagram
Order
[Filled]Order
[Filled]
Order
ShippingOrder
Filling
{stream} {stream}Order
[Filled]Order
FillingOrder
Shipping
{stream}{stream}
UML Superstructure 2.0 Draft Adopted Specification        361(CompleteActivities) The figure below shows two examples of selection behavior. Both examples indicate that orders are to be 
shipped based or order priority—and those with the same priority should be filled on a first-in/first-out (FIFO) basis.
Rationale
Pins are introduced to model inputs and outputs of actions.
Changes from previous UML
Pin is new to activity modeling in UML 2.0. It replaces pins from UML 1.5 action model.
12.3.38 StructuredActivityNode
(StructuredActivities) A structured activity node is an executable activity node that may have an expansion into subordinate nodes as an ActivityGroup. The subordinate nodes must belong to only one structured activity node, although they may be nested.
Description
A structured activity node represents a structured portion of the activity that is not shared with any other structured node, except for nesting. It may have control edges connected to it, and pins in CompleteStructuredActivities. The execution of any embedded actions may not begin until the structured activity node has received its object and control tokens. The availability of output tokens from the structured activity node does not occur until all embedded actions have completed execution.
(CompleteStructuredActivities) Because of the concurrent nature of the execution of actions within and across activities, it ca n Figure 289 - Exception pin examples
Figure 290 - Specifying selection behavior on an Object flowAccept
PaymentAccept
PaymentSend
Rejection
Credit
AccountSend
Rejection
Credit
AccountRejected
Payment
Accepted
Payment
Ship
OrderFill
OrderOrder
[Filled]
«selection»
FIFO within
Order PriorityFill
OrderShip
Order
Order
[Filled]
«selection»
FIFO within
Order PriorityOrder
[Filled]
362                 UML Superstructure 2.0 Draft Adopted Specificationbe difficult to guarantee the consistent access and modification of object memory. In order to avoid race conditions or other 
concurrency-related problems, it is sometimes necessary to isolate the effects of a group of actions from the effects of action s 
outside the group. This may be indicated by setting the mustIsolate attribute to true on a structured activity node. If a 
structured activity node is “isolated,” then any object used by an action within the node cannot be accessed by any action outside the node until the structured activity node as a whole completes. Any concurrent actions that would result in accessing  
such objects are required to have their execution deferred until the completion of the node.
Note – Any required isolation may be achieved using a locking mechanisms, or it may simply sequentialize execution to
avoid concurrency conflicts. Isolation is different from the property of “atomicity”, which is the guarantee that a group ofactions either all complete successfully or have no effect at all. Atomicity generally requires a rollback mechanism to preventcommitting partial results. 
Attributes
None.
Associations
 variable: Variable [0..*] A variable defined in the scope of the structured activity node. It has no value and may not 
be accessed outside the node.
Constraints
[1]  The edges owned by a structured node must have source and target nodes in the structured node.
Semantics
Nodes and edges contained by a structured node cannot be contained by any other structured node. This constraint is modeled as a specialized multiplicity from ActivityNode and ActivityEdge to StructuredActivityNode. See children of StructuredActivityNode.
No subnode in the structured node may begin execution until the node itself has consumed a control token. A control flow from a structured activity node implies that a token is produced on the flow only after no tokens are left in the node or its contained nodes recursively.
(CompleteStructuredActivities) An object node attached to a structured activity node is accessible within the node. The same rules apply as for control flow. An input pin on a structured activity node implies that no action in the node may begin execution until all input pins have received tokens. An output pin on a structured activity node will make tokens available outside the node only after no tokens left in the node or its contained nodes recursively.
Notation
A structured activity node is notated with a dashed round cornered rectangle enclosed its nodes and edges, with the keyword «structured» at the top. Also see children of StructuredActivityNode.
Examples
See children of StructuredActivityNode.
Rationale
StructuredActivityNode is for applications that require well-nested nodes. It provides well-nested nodes that were enforced by strict nesting rules in UML 1.5.
UML Superstructure 2.0 Draft Adopted Specification        363Changes from previous UML
StructuredActivityNode is new in UML 2.0.
12.3.39 ValuePin
A value pin is an input pin that provides a value to an action that does not come from an incoming object flow edge.
Attributes
None.
Associations
 value : ValueSpecification [1..1]Value that the pin will provide.
Constraints
[1]  Value pins have no incoming edges.
[2] The type of value specification must be compatible with the type of the value pin.
Semantics
ValuePins provide values to their actions, but only when the actions are otherwise enabled. If an action has no incoming edges 
or other way to start execution, a value pin will not start the execution by itself or collect tokens waiting for execution to start. 
When the action is enabled by these other means, the value specification of the value pin is evaluated and the result provided as input to the action, which begins execution. This is an exception to the normal token flow semantics of activities.
Notation
A value pin is notated as an input pin with the value specification written beside it.
Examples
Rationale
ValuePin is introduced to reduce the size of activity models that use constant values.
Changes from UML 1.5
ValuePin replaces LiteralValueAction from UML 1.5.
12.3.40 Variable
(StructuredActivities) Variables are elements for passing data between actions indirectly. A local variable stores values share d 
by the actions within a structured activity group but not accessible outside it. The output of an action may be written to a variable and read for the input to a subsequent action, which is effectively an indirect data flow path. Because there is no predefined relationship between actions that read and write variables, these actions must be sequenced by control flows to prevent race conditions that may occur between actions that read or write the same variable.
Description
A variable specifies data storage shared by the actions within a group. There are actions to write and read variables. These actions are treated as side effecting actions, similar to the actions to write and read object attributes and associations. The re are 
364                 UML Superstructure 2.0 Draft Adopted Specificationno sequencing constraints among actions that access the same variable. Such actions must be explicitly coordinated by control 
flows or other constraints.
Any values contained by a variable must conform to the type of the variable and have cardinalities allowed by the multiplicity of the variable.
Associations
None.
Attributes
 scope : StructuredActivityGroup [1]The structured activity group that owns the variable.
Constraints
None.
Semantics
A variable specifies a slot able to hold a value or a sequence of values, consistent with the multiplicity of the variable. The  
values held in this slot may be accessed from any action contained directly or indirectly within the group action that is the scope of the variable.
Notation
None.
Examples
None.
Rationale
Variables are introduced to simplify translation of common programming languages into activity models for those applications that do not require object flow information to be readily accessible. However, source programs that set variables only once can  
be easily translated to use object flows from the action that determines the values to the actions that use them. Source progra ms 
that set variables more than once can be translated to object flows by introducing a local object containing attributes for the  
variables, or one object per variable combined with data store nodes.
Changes from UML 1.5
Variable is unchanged from UML 1.5, except that it is used on StructuredActivityNode instead of GroupNode.
12.4 Diagrams
The focus of activity modeling is the sequence and conditions for coordinating lower-level behaviors, rather than which classifiers own those behaviors. These are commonly called control flow and object flow models. The behaviors coordinated by these models can be initiated because other behaviors finish executing, because objects and data become available, or because events occur external to the flow. See the Activity on page -283 metaclass for more introduction and semantic framework.
The notation for activities is optional. A textual notation may be used instead.
The following sections describe the graphic nodes and paths that may be shown in activity diagrams.
UML Superstructure 2.0 Draft Adopted Specification        365Graphic Nodes
The graphic nodes that can be included in structural diagrams are shown in Table 11.
Table 11 - Graphic nodes included in activity diagrams
NODE TYPE NOTATION REFERENCE
Action See Action on page -280.
ActivityFinal See ActivityFinalNode on page -298.
ActivityNode See ExecutableNode, ControlN-
ode, and ObjectNode.See ActivityNode on page -302.
ControlNode See DecisionNode, FinalNode, 
ForkNode, InitialNode, Join-Node, and MergeNode.See ControlNode on page -316.
DataStore See DataStoreNode on page -318 .
DecisionNode See DecisionNode on page -319.
FinalNode See ActivityFinal and FlowFinal. See FinalNode on page -331.
FlowFinal See FlowFinalNode on page -333.
ForkNode See ForkNode on page -334.
InitialNode See InitialNode on page -335.<<datastore>>
......
366                 UML Superstructure 2.0 Draft Adopted SpecificationGraphic Paths
The graphic paths that can be included in structural diagrams are shown in Table 12 .JoinNode See “JoinNode” on page 338.
MergeNode See “MergeNode” on page 343.
ObjectNode See “ObjectNode” on page 349 and its children.
Table 12 - Graphic nodes included in activity diagrams
PATH TYPE REFERENCE
ActivityEdge See ControlFlow and Object-
Flow.See “ActivityEdge” on page 293.
ControlFlow See “ControlFlow” on page 315.
ObjectFlow See “ObjectFlow” on page 344 and its children.Table 11 - Graphic nodes included in activity diagrams
NODE TYPE NOTATION REFERENCE......
UML Superstructure 2.0 Draft Adopted Specification        367Other Graphical Elements
Activity diagrams have graphical elements for containment. These are included in Table 13 .
Table 13 - Graphic nodes included in activity diagrams
TYPE NOTATION REFERENCE
Activity See “Activity” on page 283.
ActivityPartition See “ActivityPartition” on 
page 307.
InterruptibleActivityRegion See “InterruptibleActivityRegion” 
on page 336.
ExceptionHandler See “ExceptionHandler” on 
page 322.
ExpansionRegion “ExpansionRegion” on page 325Activity name
.........Para meter  name : type
Partition Name
invocation(Partition Name)
368                 UML Superstructure 2.0 Draft Adopted SpecificationLocal pre- and postconditions. See “Action” on page 280.
ParameterSet See “ParameterSet” on page 354.Table 13 - Graphic nodes included in activity diagrams
TYPE NOTATION REFERENCE
«localPrecondition»
constraint
name
«localPostcondition»
constraint
UML Superstructure 2.0 Draft Adopted Specification        36913 Common Behaviors
13.1 Overview
The Common Behaviors packages specify the core concepts required for dynamic elements and provides the 
infrastructure to support more detailed definitions of behavior. Figure 306 shows a domain model explaining the relationship between occurrences of behaviors.
Note – The models shown in Figure 306 through Figure 310 are not metamodels but show objects in the semantic domain and
relationships between these objects. These models are used to give an informal explication of the dynamic semantics of theclasses of the UML metamodel.
 
Any behavior is the direct consequence of the action of at least one object. A behavior describes how the states of these 
objects, as reflected by their structural features, change over time. Behaviors, as such, do not exist on their own, and they 
do not communicate. If a behavior operates on data, that data is obtained from the host object. (Note that an executing behavior may itself be an object, however.)
There are two kinds of behaviors, emergent behavior and executing behavior. An executing behavior  is performed by an 
object (its host) and is the description of the behavior of this object. An executing behavior is directly caused by the 
invocation of a behavioral feature of that object or by its creation. In either case, it is a consequence of the execution of an action by some related object. A behavior has access to the structural features of its host object. Objects that may host 
behaviors are specified by the concrete subtypes of the BehavioredClassifier  metaclass.
Emergent behavior results from the interaction of one or more participant objects. If the participating objects are parts of 
a larger composite object, an emerging behavior can be seen as indirectly describing the behavior of the container object also. Nevertheless, an emergent behavior is simply the sum of the executing behaviors of the participant objects.
Occurring behaviors are specified by the concrete subtypes of the abstract Behavior  metaclass. Behavior specifications 
can be used to define the behavior of an object, or they can be used to describe or illustrate the behavior of an object. The 
latter may only focus on a relevant subset of the behavior an object may exhibit (allowed behavior), or it may focus on behavior an object must not exhibit (forbidden behavior).
Albeit behavior is ultimately related to an object, emergent behavior may also be specified for non-instantiable classifiers, 
such as interfaces or collaborations. Such behaviors describe the interaction of the objects that realize the interfaces or the  
parts of the collaboration (see  “Collaboration (from Collaborations)” on page 157).Figure 306 - Common Behaviors Domain ModelBehaviorOccurrence
BehaviorExecution BehaviorEmergence Object
*1
*+invoker1*1+execution
*+host1
* 1..* * +participant 1..*
370                 UML Superstructure 2.0 Draft Adopted SpecificationBasicBehaviors
The BasicBehaviors subpackage of the Common Behavior package introduces the framework that will be used to specify 
behaviors. The concrete subtypes of Behavior will provide different mechanisms to specify behaviors. A variety of 
specification mechanisms are supported by the UML, such as automata (“StateMachine (from BehaviorStatemachines)” 
on page 489), Petri-net like graphs (“Activity (from BasicBehaviors)” on page 378), informal descriptions (“UseCase (from UseCases)” on page 519), or partially-ordered sequences of events (“Interaction (from BasicInteraction, 
Fragments)” on page 419). Profiles may introduce additional styles of behavioral specification. The styles of behavioral 
specification differ in their expressive power and domain of applicability. Further, they may specify behaviors either explicitly, by describing the observable events resulting from the occurrence of the behavior, or implicitly, by describing 
a machine that would induce these events. The relationship between a specified behavior and its hosting or participating 
instances is independent of the specification mechanism chosen and described in the common behavior package. The 
choice of specification mechanism is one of convenience and purpose; typically, the same kind of behavior could be 
described by any of the different mechanisms. Note that not all behaviors can be described by each of the different specification mechanisms, as these do not all have the same expressive power. However, for many behaviors, the choice 
of specification mechanism is one of convenience.
As shown in the domain model of Figure 307, the execution of a behavior may be caused by a call behavior event 
(representing the direct invocation of a behavior through an action) or a trigger event (representing an indirect invocation of a behavior, such as through an operation call). A start event marks the beginning of a behavior execution, while its 
completion is accompanied by a termination event.
Communications
The Communications subpackage of the Common Behavior package adds the infrastructure to communicate between 
objects in the system and to invoke behaviors. The domain model shown in Figure 308 explains how communication 
takes place. Note that this domain model specifies the semantics of communication between objects in a system. Not all 
aspects of the domain model are explicitly represented in the specification of the system but may be implied by the dynamic semantics of the constructs used in a specification.
An action representing the invocation of a behavioral feature is executed by a sender object resulting in an invocation 
event occurring. The invocation event may represent the sending of a signal or the call to an operation. As a result of the 
invocation event, a request is generated. A request is an object capturing the data that was passed to the action causing the invocation event (the arguments which must match the parameters of the invoked behavioral feature), information about Figure 307 - Invocation Domain ModelTrigger EventTermination EventObject
Start EventEventBehav iorExecution1 1
+finish1 1*1
+execution *+host 1
1 1 1
+start11 0..1+cause
1+ef fect
0..1
CallBehaviorEvent
UML Superstructure 2.0 Draft Adopted Specification        371the nature of the request (i.e., the behavioral feature that was invoked), the identities of the sender and receiver objects, a s 
well as sufficient information about the behavior execution to enable the return of a reply from the invoked behavior, 
where appropriate. (In profiles, the request object may include additional information, for example, a time stamp.) 
While each request is targeted at exactly one receiver object and caused by exactly one sending object, an invocation 
event may result in a number of requests being generated (as in a signal broadcast). The receiver may be the same object 
that is the sender, it may be local (i.e., an object held in a slot of the currently executing object, or the currently executi ng 
object itself, or the object owning the currently executing object), or it may be remote. The manner of transmitting the request object, the amount of time required to transmit it, the order in which the transmissions reach their receiver objects, 
and the path for reaching the receiver objects are undefined. Once the generated request arrives at the receiver object, a 
receiving event will occur. 
Several kinds of requests exist between instances, for example, sending a signal or invoking an operation. The kind of 
request is determined by the kind of invocation event that caused it, as shown in Figure 309. The former is used to trigger 
a reaction in the receiver in an asynchronous way and without a reply, while the latter applies an operation to an instance, 
which may be either synchronously or asynchronously and may require a reply from the receiver to the sender. A send 
invocation event creates a send request and causes a signal event in the receiver. A call invocation event creates a call request and causes a call event in the receiver.Figure 308 - Communication Domain ModelObject
Receiving EventRequest
1 1+receiveEvent
1+message
1
Object*
1*
+sender 1 1*
+receiver1*
1*
+receiver
1*
BehaviorExecution
1 * +host 1 +execution*Invocation Event
1..* 1+message
1..*+sendEvent
1
1*
+sender
1*
1*
+execution 1+ev ent*
372                 UML Superstructure 2.0 Draft Adopted SpecificationInvocation events are specified by various kinds of actions (see Chapter 5, “Actions”). A send request is specified by a 
Signal (see “Signal” on page 395). A call request is derived from the operation associated with the specification of the call invocation event. Signal events and call events are specified by the corresponding metaclasses (see “SignalTrigger” 
on page 396 and “CallTrigger” on page 385).
As shown in Figure 308, the invocation event that eventually will lead to a behavior invocation which itself occurs within 
the context of a behavior execution, is in turn hosted by an object. In case of an operation invocation, the invoked behavior will be able to reply to the action in virtue of having knowledge of this behavior execution.
Receiving events may cause a behavioral response. For example, a statemachine may transition to a new state upon 
detection of a trigger event or an activity may be enabled upon detection of a receiving event. The specific mechanism by 
which the data passed with the request (the attributes of the request object) are made available as arguments to the invoked behavior (e.g., whether the data or copies are passed with the request) is a semantic variation point. The behavior 
will be executed in the context of the receiving object (i.e., the receiving object will host the behavior execution). The 
details of identifying the behavior to be invoked in response to the occurrence of an event is a semantic variation point. 
The occurrence of spontaneous events may also trigger behaviors: The occurrence of a change event (see 
“ChangeTrigger” on page 385) is based on some expression becoming true.  A time event occurs when a predetermined 
deadline expires (see “TimeTrigger” on page 399). No data is passed by the occurrence of a spontaneous event. Figure 
310 shows the hierarchy of such trigger events. The occurrence of trigger events, may also cause the invocation of a 
behavior in the context of the containing object. When a trigger event is recognized by an object, it may have an 
immediate effect or the event may be saved in an event pool and have a later effect when it is matched by a trigger specified for a behavior.Figure 309 - Domain Model Showing Request KindsSendInvocation 
EventSignal Event SendRequest
CallInvocat ion Ev ent Call Event CallRequestInvocation EventReceiving Event Request 1..*
1+message1..* +sendEvent
11
1 +receiveEvent1 +message
1
UML Superstructure 2.0 Draft Adopted Specification        373SimpleTime
The SimpleTime subpackage of the Common Behavior package adds metaclasses to represent time and durations, as well 
as actions to observe the passing of time.
The simple model of time described here is intended as an approximation for situations where the more complex aspects 
of time and time measurement can safely be ignored. For example, this model does not account for the relativistic effects that occur in many distributed systems, or the effects resulting from imperfect clocks with finite resolution, overflows, 
drift, skew, etc. It is assumed that applications for which such characteristics are relevant will use a more sophisticated 
model of time provided by an appropriate profile.Figure 310 - Domain Model Showing Event KindsSpontaneous EventTrigger Event
Change Event Time EventReceiving Event
374                 UML Superstructure 2.0 Draft Adopted Specification13.2 Abstract syntax
Figure 311 shows the dependencies of the CommonBehaviors packages.
Figure 311 - Dependencies of the CommonBehaviors packagesCommunicationsBas i cBehaviorsKernel
(from Classes)
IntermediateActions
(from Actions) <<merge>>
TimeInterfaces
(from Classes)
<<merge>><<merge>><<merge>>
<<merge>>
UML Superstructure 2.0 Draft Adopted Specification        375BasicBehaviors
Figure 312 - Common Behavior
Figure 313 - Expression
Figure 314 - Precondition and postcondition constraints for behaviorClassifier
(from Kernel)Class
(from Kernel)
BehavioralFeature
isAbstract : BooleanBehavioredClassifierParameter
(from Kernel)Behavior
isReentrant : Boolean
**
+redefinedBehavior*
{subsets redefinedElement}** 0..1+method
*+specification
0..10..1
*+context0..1+ownedBehavior
*{subsets ownedMember}
0..10..1+classifierBehavior
0..1{subsets ownedBehavior} 0..1*0..1 +parameter
*{ordered, subsets ownedMember}
0..1
* 0..1+/formalParameter
* {ordered} 0..1
* 0..1+/returnResult
*{ordered}0..1
Activ ity
body : String
language : String
Parameter
(from Kernel)
BehaviorOpaqueExpression0..1*+/result
0..1*
0..1 *+behavior
0..1 *
Constraint
(from Kernel)Behavior
* 0..1+precondition
* {subsets ownedRule} 0..1{subsets namespace, subsets context}
* 0..1+postcondition
* {subsets ownedRule} 0..1
{subsets namespace, subsets context}
376                 UML Superstructure 2.0 Draft Adopted SpecificationCommunications
Figure 315 - Reception
Figure 316 - Extensions to behavioral features and signalBehavioralFeature
concurrency : CallConcurrencyKindBehavioredClassifier
(from BasicBeha vi ors)
Class
isActive : Boolean
InterfaceReception* 0..1
+ownedReception*{subsets feature,
subsets ownedMember}
0..1
*0..1
+ownedReception*
{subsets feature,
subsets ownedMember}0..1Signal
*0..1
*+signal0..1
CallConcurrencyKind
sequential
guarded
concurrent<<enumeration>>BehavioralFeature
concurrency : CallConcurrencyKind
Property
(from Kernel)Signal*
* +raisedException*
{redefines raisedException}*
*0..1
+ownedAttribute
*{ordered, subsets attribute, subsets ownedMember}+owningSignal 0..1
{subsets namespace, subsets classifier, subsets featuringClassifier}Classifier
(from Kernel)
UML Superstructure 2.0 Draft Adopted Specification        377Figure 317 - TriggersSignalTrigger
Signal**
+signal 1Element
(from  Kernel)
Operation
(f rom Kernel)CallTrigger
1*
+operation 1*ValueSpecification
(from  Kernel)ChangeTrigger
1 +changeEx pression 1
{sub set s o wne dElement }TriggerTrigger
MessageTrigger
AnyTrigger
ValueSpecification
(from  Ke rn el)TimeTrigger
isRelative : Boolean
1 +when 1
{subsets o wned Element }
378                 UML Superstructure 2.0 Draft Adopted SpecificationSimpleTime
13.3 Class Descriptions
13.3.1 Activity (from BasicBehaviors)
An activity specifies behavior by its body string.
Description
An activity contains a language-specific text string used to describe a computation, and an optional specification of the 
language. OCL, natural language, or programming languages may be used to specify an activity.
Attributes
 body: String [0..1] A textual representation of the computation in the surface language determined by the lan-
guage attribute. 
 language: String [0..1] Specifies the language in which the body of the activity is stated. The interpretation of the 
expression body depends on the language.
Associations
No additional associations.Figure 318 - SimpleTimeConstraint
(from Kernel)
IntervalConstraint
WriteStructuralFeatureAction
(from  Interm ediateActions)TimeConstraint
DurationObservationActionDurationConstraintDuration
firstTime : Boolean = True
+duration {redefines  value}DurationInterval +sp eci fi ca ti on
{redefines specification}+min{redefines mi n}
+max
{ redefi nes max}ValueSpecification
(from Kernel)
Interval+specification
{redefines specification}1
+max1
1
+min1
TimeObservationActionTimeInterval+specification
{ red ef ine s s p ecifica tion}Na me d E l e me n t
(f rom Kern el )
0..2 +event 0..2TimeExpression
firstTime : Boolean = True
+now
{re defin es va lu e}+min{redefines  min}
+max
{redefines max}0..1+ev ent
0..1Tim eTrigger
1+when1{ r ed efine s  w hen }
UML Superstructure 2.0 Draft Adopted Specification        379Constraints
No additional constraints.
Semantics
The interpretation of the activity body depends on the specified language. 
Notation
See “OpaqueExpression (from Kernel)” on page 46.
Changes from UML 1.x
In UML 1.4, the function of the Activity metaclass, as defined in this package, was subsumed by Expression.
13.3.2 AnyTrigger (from Communications)
Description
An AnyTrigger for a given state specifies that the transition is triggered for all applicable message triggers except for 
those specified explicitly on other transitions for this state.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
An AnyTrigger for a given state specifies that the transition is triggered for all applicable message triggers except for those specified explicitly on other transitions for this state.
Notation
Any AnyTrigger is denoted by the string “all” used as the trigger.
Changes from UML 1.x
This construct has been added.
13.3.3 Behavior (from BasicBehaviors)
Description
Behavior is a specification of how its context classifier changes state over time. This specification may be either a definition of possible behavior execution or emergent behavior, or a selective illustration of an interesting subset of possible executions. The latter form is typically used for capturing examples, such as a trace of a particular execution. 
380                 UML Superstructure 2.0 Draft Adopted SpecificationA classifier behavior is always a definition of behavior and not an illustration. It describes the sequence of state changes an  
instance of a classifier may undergo in the course of its lifetime. Its precise semantics depends on the kind of classifier. Fo r 
example, the classifier behavior of a collaboration represents emergent behavior of all the parts, whereas the classifier behavior of a class is just the behavior of instances of the class separated from the behaviors of any of its parts.
When a behavior is associated as the method of a behavioral feature, it defines the implementation of that feature; i.e., the 
computation that generates the effects of the behavioral feature.
As a classifier, a behavior can be specialized. Instantiating a behavior is referred to as “invocating” the behavior, an 
instantiated behavior is also called a behavior “execution.” A behavior may be invoked directly or its invocation may be 
the result of invoking the behavioral feature that specifies this behavior. A behavior can also be instantiated as an object in virtue of it being a class.
The specification of a behavior can take a number of forms, as described in the subclasses of Behavior. Behavior is an 
abstract metaclass factoring out the commonalities of these different specification mechanisms.
When a behavior is invoked, its execution receives a set of input values that are used to affect the course of execution and 
as a result of its execution it produces a set of output values which are returned, as specified by its parameters. The 
observable effects of a behavior execution may include changes of values of various objects involved in the execution, the 
creation and destruction of objects, generation of communications between objects, as well as an explicit set of output values.
Attributes
 isReentrant: Boolean [1] Tells whether the behavior can be invoked while it is still executing from a previous invo-
cation.
Associations
 specification: BehavioralFeature [ 0..1 ]
Designates a behavioral feature that the behavior implements. The behavioral feature must be owned by the classifier that owns the behavior or be inherited by it. The param-eters of the behavioral feature and the implementing behavior must match. If a behavior does not have a specification, it is directly associated with a classifier (i.e., it is the behavior of the classifier as a whole).
 context: BehavioredClassifier [ 0..1 ]
The classifier owning the behavior. The features of the context classifier as well as the ele-ments visible to the context classifier are visible to the behavior.
 parameter: Parameter References a list of parameters to the behavior which describes the order and type of 
arguments that can be given when the behavior is invoked and of the values which will be returned when the behavior completes its execution. (Specializes Namespace.owned-
Member .)
 /formalParameter: Parameter References a list of parameters to the behavior which describes the order and type of 
arguments that can be given when the behavior is invoked. Derived from Behav-
ior.parameter  by omitting those parameters who have direction=return .
 /returnedResult: ReturnResult References a sequence of parameters to the behavior which describes the order and type 
of values that will be returned when the behavior terminates. Derived from Behav-
ior.parameter  by selecting those parameters who have direction=return .
 redefinedBehavior: Behavior References a behavior that this behavior redefines. A subtype of Behavior may redefine 
any other subtype of Behavior. If the behavior implements a behavioral feature, it replaces 
UML Superstructure 2.0 Draft Adopted Specification        381the redefined behavior. If the behavior is a classifier behavior, it extends the redefined 
behavior.
 precondition: Constraint An optional set of Constraints specifying what must be fulfilled when the behavior is 
invoked. (Specializes Namespace.constraint  and Constraint.context .)
 postcondition: Constraint An optional set of Constraints specifying what is fulfilled after the execution of the behav-
ior is completed, if its precondition was fulfilled before its invocation. (Specializes Namespace.constraint  and Constraint.context .)
Constraints
[1]  The parameters of the behavior must match the parameters of the implemented behavioral feature.
[2] The implemented behavioral feature must be a feature (possibly inherited) of the context classifier of the behavior.[3] If the implemented behavioral feature has been redefined in the ancestors of the owner of the behavior, then the behavior
must realize the latest redefining behavioral feature.
[4] There may be at most one behavior for a given pairing of classifier (as owner of the behavior) and behavioral feature (as
specification of the behavior).
Semantics
The detailed semantics of behavior is determined by its subtypes. The features of the context classifier and elements that 
are visible to the context classifier are also visible to the behavior, provided that is allowed by the visibility rules.
When a behavior is invoked, its attributes and parameters (if any) are created and appropriately initialized. Upon 
invocation, the arguments of the original invocation action are made available to the new behavior execution 
corresponding to its formal parameters, if any. When a behavior completes its execution, a value or set of values is 
returned corresponding to each return  result  parameter, if any. If such a parameter has a default value associated and the 
behavior does not explicitly generate a value for this parameter, the default value describes the value that will be returned 
corresponding to this parameter. If the invocation was synchronous, any return values from the behavior execution are 
returned to the original caller, which is unblocked and allowed to continue execution
The behavior executes within its context object, independently of and concurrently with any existing behavior executions. 
The object which is the context of the behavior manages the input pool holding the events to which a behavior may 
respond (see BehavioredClassifier on page 383). As an object may have a number of behaviors associated, all these 
behaviors may access the same input pool. The object ensures that each event on the input pool is consumed by only one behavior. 
When a behavior is instantiated as an object, it is its own context.
Semantic Variation Points
The means by which requests are transported to their target depend on the type of requesting action, the target, the 
properties of the communication medium, and numerous other factors. In some cases, this is instantaneous and completely 
reliable while in others it may involve transmission delays of variable duration, loss of requests, reordering, or duplication. (See also the discussion on page 371.)
How the parameters of behavioral features or a behavior match the parameters of a behavioral feature is a semantic 
variation point (see BehavioralFeature on page 382).
Notation
None.
382                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from UML 1.x
This metaclass has been added. It abstracts the commonalities between the various ways that behavior can be 
implemented in the UML. It allows the various ways of implementing behavior (as expressed by the subtypes of 
Behavior) to be used interchangeably.
13.3.4 BehavioralFeature (from BasicBehaviors, Communications, specialized)
Description
A behavioral feature is implemented (realized) by a behavior. A behavioral feature specifies that a classifier will respond 
to a designated request by invoking its implementing method.
Attributes
BasicBehaviors
 isAbstract: Boolean If true, then the behavioral feature does not have an implementation, and one must be 
supplied by a more specific element. If false , the behavioral feature must have an imple-
mentation in the classifier or one must be inherited from a more general element.
Communications
 concurrency: CallConcurrencyKind
Specifies the semantics of concurrent calls to the same passive instance (i.e., an instance originating from a class with isActive  being false ). Active instances control access to 
their own behavioral features.
Associations
BasicBehaviors
 method: Behavior A behavioral description that implements the behavioral feature. There may be at most 
one behavior for a particular pairing of a classifier (as owner of the behavior) and a behav-ioral feature (as specification of the behavior).
Communications
 raisedException: Signal The signals that the behavioral feature raises as exceptions. (Specializes BehavioralFea-
ture.raisedException .)
Constraints
No additional constraints.
Semantics
The invocation of a method is caused by receiving a request invoking the behavioral feature specifying that behavior. The 
details of invoking the behavioral feature are defined by the subclasses of BehavioralFeature.
UML Superstructure 2.0 Draft Adopted Specification        383Semantic Variation Points
How the parameters of behavioral features or a behavior match the parameters of a behavioral feature is a semantic 
variation point. Different languages and methods rely on exact match (i.e., the type of the parameters must be the same), 
co-variant match (the type of a parameter of the behavior may be a subtype of the type of the parameter of the behavioral 
feature), contra-variant match (the type of a parameter of the behavior may be a supertype of the type of the parameter of the behavioral feature), or a combination thereof.
Changes from UML 1.x
The metaattributes isLeaf  and isRoot  have been replaced by properties inherited from RedefinableElement.
13.3.5 BehavioredClassifier (from BasicBehaviors)
Description
A classifier can have behavior specifications defined in its namespace. One of these may specify the behavior of the 
classifier itself.
Attributes
No additional attributes.
Associations
 ownedBehavior: Behavior References behavior specifications owned by a classifier. (Specializes Namespace.owned-
Member .) 
 classifierBehavior: Behavior [ 0..1 ]
A behavior specification that specifies the behavior of the classifier itself. (Specializes BehavioredClassifier.ownedBehavior .)
Constraints
If a behavior is classifier behavior, it does not have a specification.
Semantics
The behavior specifications owned by a classifier are defined in the context of the classifier. Consequently, the behavior 
specifications may reference features of the classifier. Any invoked behavior may, in turn, invoke other behaviors visible to its context classifier. When an instance of a behaviored classifier is created, its classifier behavior is invoked.
When an event is recognized by an object that is an instance of a behaviored classifier, it may have an immediate effect 
or the event may be saved for later triggered  effect. An immediate effect is manifested by the invocation of a behavior as 
determined by the event. A triggered effect is manifested by the storage of the event in the input event pool of the object and the later consumption of the event by the execution of an ongoing behavior that reaches a point in its execution at 
which a trigger matches the event in the pool. At this point, a behavior may be invoked as determined by the event.
When an executing behavior owned by an object comes to a point where it needs a trigger to continue its execution, the 
input pool is examined for an event that satisfies the outstanding trigger or triggers. If an event satisfies one of the triggers, the event is removed from the input pool and the behavior continues its execution, as specified. Any data 
associated with the event are made available to the triggered behavior. 
384                 UML Superstructure 2.0 Draft Adopted SpecificationSemantic Variation Points
It is a semantic variation whether one or more behaviors are triggered when an event satisfies multiple outstanding triggers.
If an event in the pool satisfies no triggers at a wait point, it is a semantic variation point what to do with it.
The ordering of the events in the input pool is a semantic variation. 
Notation
See “Classifier (from Kernel, Dependencies, PowerTypes)” on page 61.
Changes from UML 1.x
In UML 1.4, there was no separate metaclass for classifiers with behavior.
13.3.6 CallConcurrencyKind (from Communications)
Description
CallConcurrencyKind is an enumeration with the following literals:
 sequential No concurrency management mechanism is associated with the operation and, therefore, 
concurrency conflicts may occur. Instances that invoke a behavioral feature need to coor-dinate so that only one invocation to a target on any behavioral feature occurs at once.
 guarded Multiple invocations of a behavioral feature may occur simultaneously to one instance, 
but only one is allowed to commence. The others are blocked until the performance of the first behavioral feature is complete. It is the responsibility of the system designer to ensure that deadlocks do not occur due to simultaneous blocks.
 concurrent Multiple invocations of a behavioral feature may occur simultaneously to one instance 
and all of them may proceed concurrently.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
Not applicable.
Notation
None.
Changes from UML 1.x
None.
UML Superstructure 2.0 Draft Adopted Specification        38513.3.7 CallTrigger (from Communications)
A call trigger specifies that a given behavior execution may be triggered by a call event.
Description
A call trigger represents the reception  of a request to invoke a specific operation and specifies a call event. A call event 
is distinct from the call action that caused it. A call event may cause the invocation of a behavior that is the method of the operation referenced by the call request, if that operation is owned or inherited by the classifier that specified the receiver  
object.
Attributes
No additional attributes.
Associations
 operation: Operation [1] Designates the operation whose invocation raised the call event that is specified by the 
call trigger.
Constraints
No additional constraints.
Semantics
A call trigger specifies that a behavior will be triggered by a call event as caused by the object receiving a call request 
from some other object or from itself. The call event may result in the execution of the behavior that implements the called operation. A call event may, in addition, cause other responses, such as a state machine transition, as specified in 
the classifier behavior of the classifier that specified the receiver object. In that case, the additional behavior is invoked 
after the completion of the operation referenced by the call trigger.
A call event makes available any argument values carried by the received call request to all behaviors caused by this 
event (such as transition actions or entry actions).
Notation
None.
Changes from UML 1.x
This metaclass replaces CallEvent.
13.3.8 ChangeTrigger (from Communications)
A change trigger specifies that a behavior execution may trigger as the result of a change event.
Description
A change trigger specifies an event that occurs when a Boolean-valued expression becomes true as a result of a change in value of one or more attributes or associations. A change event is raised implicitly and is not the result of an explicit 
action. 
386                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
No additional attributes.
Associations
 changeExpression: Expression [1]
A Boolean-valued expression that will result in a change event whenever its value changes from false  to true.
Constraints
No additional constraints.
Semantics
Each time the value of the change expression changes from false to true, a change event is generated.
Semantic Variation Points
It is a semantic variation when the change expression is evaluated. For example, the change expression may be 
continuously evaluated until it becomes true. It is further a semantic variation whether a change event remains until it is 
consumed, even if the change expression changes to false  after a change event.
Notation
A change trigger is denoted by a Boolean expression.
Changes from UML 1.x
This metaclass replaces change event.
13.3.9 Class (from Communications, specialized)
Description
A class may be designated as active, i.e., each of its instance having its own thread of control, or passive, i.e., each of its  
instance executing within the context of some other object. 
A class may also specify which signals the instances of this class handle.
Attributes
 isActive: Boolean Determines whether an object specified by this class is active or not. If true, then the 
owning class is referred to as an active class . If false , then such a class is referred to as a 
passive class .
Associations
 ownedReception: Reception Receptions that objects of this class are willing to accept. (Specializes Namespace.owned-
Member  and Classifier.feature .)
UML Superstructure 2.0 Draft Adopted Specification        387Semantics
An active object is an object that, as a direct consequence of its creation, commences to execute its classifier behavior, 
and does not cease until either the complete behavior is executed or the object is terminated by some external object. 
(This is sometimes referred to as “the object having its own thread of control”.) The points at which an active object 
responds to communications from other objects is determined solely by the behavior of the active object and not by the invoking object. If the classifier behavior of an active object completes, the object is terminated.
Notation
Presentation options
A class with the property isActive  = true can be shown by a class box with an additional vertical bar on either side, as 
depicted in Figure 319.
13.3.10 Duration (from Time)
Description
A duration defines a value specification that specifies the temporal distance between two time expressions that specify 
time instants.
Attributes
 firstTime:Boolean [0..2] If the duration is between times of two NamedElements, there are two Boolean attributes, 
one for the start of the duration and one for the end of the duration. For each of these it holds that firstTime  is true if the time information is associated with the first point in time 
of the NamedElement referenced by event , and false  if it represents the last point in time 
of the NamedElement. If there is only one NamedElement referenced by event, then this 
attribute is irrelevant. The default value is true.
Associations
 event: NamedElement [0..2] Refers to the specification(s) that describes the starting TimeExpression and the ending 
TimeExpression of the Duration. If only one NamedElement is referenced, the duration is from the first point in time of that NamedElement until the last point in time of that NamedElement.
Constraints
No additional constraints.
Semantics
A Duration defines a ValueSpecification that denotes some duration in time. The duration is given by the difference in 
time between a starting point in time and an ending point in time.Figure 319 - Active classEngineControl
388                 UML Superstructure 2.0 Draft Adopted SpecificationIf the ending point in time precedes the starting point in time the duration will still be positive assuming the starting point  
and ending points to swap.
Notation
A Duration is a value of relative time given in an implementaion specific textual format. Often a Duration is a non-negative integer expression representing the number of "time ticks" which may elapse during this duration.
Changes from UML 1.x
This metaclass has been added.
13.3.11 DurationConstraint (from Time)
Description
A DurationConstraint defines a Constraint that refers to a DurationInterval.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
The semantics of a DurationConstraint is inherited from Constraints. 
Notation
A DurationConstraint is shown as some graphical association between a DurationInterval and the constructs that it constrains. The notation is specific to the diagram type.
Examples
See example in Figure 320 where the TimeConstraint is associated with the duration of a Message and the duration between two EventOccurrences.
UML Superstructure 2.0 Draft Adopted Specification        389Changes from UML 1.x
This metaclass has been added.
13.3.12 DurationInterval (from Time)
Description
A DurationInterval defines the range between two Durations.
Attributes
No additional attributes.
Associations
 min: Duration [1] Refers to the Duration denoting the minimum value of the range.
 max: Duration [1] Refers to the Duration denoting the maximum value of the range.
Constraints
No additional constraints.
Semantics
None.Figure 320 - DurationConstraint. and other time-related conceptssd UserAccepted
:User :ACSystem
Code d= duration
CardOut {0..13}
OK
Unlock{d..3*d}
t=now
{t..t+3}DurationConstraint
DurationConstraint
390                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
A DurationInterval is shown using the notation of Interval where each value specification element is a 
DurationExpression.
13.3.13 DurationObservationAction (from Time)
Description
A DurationObservationAction defines an action that observes duration in time.
Attributes
No additional attributes.
Associations
 duration: Duration[1] represent the measured Duration
Constraints
No additional constraints.
Semantics
A DurationObservationAction measures a duration during a trace at runtime.
Notation
A Duration is depicted by text in the expression language used to denote a time value. It may be possible that a duration 
contains arithmetic operators.
A duration observation is when a duration is assigned to a write-once variable. The duration observation is associated 
with two NamedElements with lines.
durationobservation ::= write-once-attribute= duration
Examples
See example in Figure 321 where the duration observation records the duration of a message, i.e., the time between the 
sending and the reception of that message.
Changes from UML 1.x
This metaclass has been added.Figure 321 - Duration observationCode d= durationDuration
in a duration observation
of a Message
UML Superstructure 2.0 Draft Adopted Specification        39113.3.14 Interface (from Communications, specialized)
Description
Adds the capability for interfaces to include receptions (in addition to operations).
Associations
 ownedReception: Reception Receptions that objects providing this interface are willing to accept. (Subsets 
Namespace.ownedMember  and Classifier.feature .)
13.3.15 Interval (from Time)
Description
An Interval defines the range between two value specifications.
Attributes
No additional attributes.
Associations
 min: ValueSpecification[1] Refers to the ValueSpecification denoting the minimum value of the range.
 max: ValueSpecification[1] Refers to the ValueSpecification denoting the maximum value of the range.
Constraints
No additional constraints.
Semantics
The semantics of an Interval is always related to Constraints in which it takes part.
Notation
An Interval is denoted textually by two ValueSpecifications separated by “..”:
interval ::= valuespecification-min .. valuespecification-max
Changes from UML 1.x
This metaclass has been added.
13.3.16 IntervalConstraint (from Time)
Description
A IntervalConstraint defines a Constraint that refers to an Interval.
Attributes
No additional attributes.
392                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
No additional associations.
Constraints
No additional constraints.
Semantics
The semantics of an IntervalConstraint is inherited from Constraint. All traces where the constraints are violated are 
negative traces, i.e., if they occur in practice the system has failed.
Notation
An IntervalConstraint is shown as a graphical association between an Interval and the constructs that this Interval 
constrains. The concrete form is given in its subclasses.
Changes from UML 1.x
This metaclass has been added.
13.3.17 MessageTrigger (from Communications)
Description
A message trigger specifies the an observable event caused by a either a call or a signal. MessageTrigger is an abstract metaclass.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
No additional semantics.
Notation
None.
Changes from UML 1.x
The metaclass has been added.
UML Superstructure 2.0 Draft Adopted Specification        39313.3.18 OpaqueExpression (from BasicBehaviors, specialized)
Description
Provides a mechanism for precisely defining the behavior of an opaque expression. An opaque expression is defined by a 
behavior restricted to return one result.
Attributes
No additional attributes.
Associations
 behavior: Behavior [ 0..1 ] Specifies the behavior of the opaque expression.
 result: Parameter [ 0..1 ] Restricts an opaque expression to return exactly one return result. When the invocation of 
the opaque expression completes, a single set of values is returned to its owner. This asso-ciation is derived from the single return result parameter of the associated behavior.
Constraints
[1]  The behavior  must not have formal parameters.
[2] The behavior  must have exactly one return result parameter.
Semantics
An opaque expression is invoked by the execution of its owning element. Anopaque expression does not have formal 
parameters and thus cannot be passed data upon invocation. It accesses its input data through elements of its behavioral 
description. Upon completion of its execution, a single value or a single set of values is returned to its owner.
13.3.19 Operation (from Communications, as specialized)
Description
On operation may invoke both the execution of method behaviors as well as other behavioral responses.
Semantics
If an operation is not mentioned in a trigger of a behavior owned or inherited by the behaviored classifier owning the 
operation, then upon occurrence of a call event (representing the receipt of a request for the invocation of this operation) a resolution process is performed which determines the method behavior to be invoked, based on the operation and the 
data values corresponding to the parameters of the operation transmitted by the request. Otherwise, the call event is 
placed into the input pool of the object (see BehavioredClassifier on page 383). If a behavior is triggered by this event, it begins with performing the resolution process and invoking the so determined method. Then the behavior continues its 
execution as specified.
Operations specify immediate or triggered effects (see “BehavioredClassifier” on page 383).
Semantic Variation Points
Resolution specifies how a particular behavior is identified to be executed in response to the invocation of an operation, 
using mechanisms such as inheritance. The mechanism by which the behavior to be invoked is determined from an operation and the transmitted argument data is a semantic variation point. In general, this mechanism may be complicated 
394                 UML Superstructure 2.0 Draft Adopted Specificationto include languages with features such as before-after methods, delegation, etc. In some of these variations, multiple 
behaviors may be executed as a result of a single call. The following defines a simple object-oriented process for this 
semantic variation point.
 Object-oriented resolution When a call request is received, the class of the target object is examined for an owned 
operation with matching parameters (see “BehavioralFeature” on page 382). If such oper-ation is found, the behavior associated as method  is the result of the resolution. Otherwise 
the parent classifier is examined for a matching operation, and so on up the generalization hierarchy until a method is found or the root of the hierarchy is reached. If a class has mul-tiple parents, all of them are examined for a method. If a method is found in exactly one ancestor class, then that method is the result of the resolution. If a method is found in more than one ancestor class along different paths, then the model is ill-formed under this 
semantic variation. 
If no method by the resolution process, then it is a semantic variation point what is to happen.
13.3.20 Reception (from Communications)
Description
A reception is a declaration stating that a classifier is prepared to react to the receipt of a signal. A reception designates a 
signal and specifies the expected behavioral response. The details of handling a signal are specified by the behavior associated with the reception or the classifier itself.
Attributes
No additional attributes.
Associations
 signal: Signal [0..1] The signal that this reception handles.
Constraints
[1]  A Reception can not be a query.
not self.isQuery
[2] A passive class cannot have receptions.
Semantics
The receipt of a signal instance by the instance of the classifier owning a matching reception will cause the asynchronous invocation of the behavior specified as the method of the reception. A reception matches a signal if the received signal is 
a subtype of the signal referenced by the reception. The details of how the behavior responds to the received signal 
depends on the kind of behavior associated with the reception. (For example, if the reception is implemented by a state machine, the signal event will trigger a transition and subsequent effects as specified by that state machine.)
Receptions specify triggered effects (see “BehavioredClassifier” on page 383).
UML Superstructure 2.0 Draft Adopted Specification        395Notation
Receptions are shown using the same notation as for operations with the keyword «signal», as shown in Figure 322. 
Changes from UML 1.x
None.
13.3.21 Signal (from Communications)
Description
A signal is a specification of type of send request instances communicated between objects. The receiving object handles 
the signal instance as specified by its receptions. The data carried by a send request and passed to it by the occurrence of 
the send invocation event that caused the request is represented as attributes of the signal instance. A signal is defined 
independently of the classifiers handling the signal.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
A signal triggers a reaction in the receiver in an asynchronous way and without a reply. The sender of a signal will not block waiting for a reply but continue execution immediately. By declaring a reception associated to a given signal, a classifier specifies that its instances will be able to receive that signal, or a subtype thereof, and will respond to it with the 
designated behavior. An exception is also represented as signal and is typically used to indicate fault situations.
Notation
A signal is depicted by a classifier symbol with the keyword «signal».
Changes from UML 1.x
None.Figure 322 - Showing signal receptions in classifiers«signal» Notify
«signal» Activate«interface»
IAlarm
396                 UML Superstructure 2.0 Draft Adopted Specification13.3.22 SignalTrigger (from Communications)
A signal trigger represents the fact that a behavior may trigger based upon the receipt  of an asynchronous signal instance. 
A signal event may e.g. cause a state machine to trigger a transition.
Description
A signal event represents the receipt  of an asynchronous signal. A signal event may cause a response, such as a state 
machine transition as specified in the classifier behavior of the classifier that specified the receiver object, if the signal 
referenced by the send request is mentioned in a reception owned or inherited by the classifier that specified the receiver 
object.
Attributes
 signal: Signal [1] The specific signal that is associated with this event.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
A signal trigger specifies a signal event as caused by an object receiving a send request from some other object or from itself. A signal event may result in the execution of the behavior that implements the reception matching the received 
signal.
A signal event makes available any argument values carried by the received send request to all behaviors caused by this 
event (such as transition actions or entry actions).
Semantic Variation Points
The means by which requests are transported to their target depend on the type of requesting action, the target, the 
properties of the communication medium, and numerous other factors. In some cases, this is instantaneous and completely 
reliable while in others it may involve transmission delays of variable duration, loss of requests, reordering, or 
duplication. (See also the discussion on page 371.)
Notation
See Trigger on page 400.
Changes from UML 1.x
This metaclass replaces SignalEvent.
13.3.23 TimeConstraint (from Time)
Description
A TimeConstraint defines a Constraint that refers to a TimeInterval.
UML Superstructure 2.0 Draft Adopted Specification        397Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
The semantics of a TimeConstraint is inherited from Constraints. All traces where the constraints are violated are negative 
traces i.e. if they occur in practice the system has failed.
Notation
A TimeConstraint is shown as graphical association between a TimeInterval and the construct that it constrains. Typically this graphical association is a small line, e.g., between an EventOccurrence and a TimeInterval.
Examples
See example in Figure 323 where the TimeConstraint is associated with the reception of a Message.
Changes from UML 1.x
This metaclass has been added.
13.3.24 TimeExpression (from Time)
Description
A Time Expression defines a value specification that represent a time value.
Attributes
 firstTime:Boolean True if the TimeExpression describes the first point in time of the NamedElement refer-
enced by event , in cases where the NamedElement describes something which extends in Figure 323 - TimeConstraintTimeConstraint:User
CardOut {0..13}
{t..t+3}
398                 UML Superstructure 2.0 Draft Adopted Specificationtime. False  if the TimeExpression describes the last point in time for the referenced 
NamedElement.
Associations
 event: NamedElement [0..1] Refers to the specification of the event occurrence that the TimeExpression describes
Constraints
No additional constraints.
Semantics
A TimeExpression denotes a time value.
Notation
A TimeExpression is a value of absolute time given in an implementation specific textual format. Often a TimeExpression 
is a non-negative integer expression representing the number of "time ticks" after some given starting point.
Changes from UML 1.x
This metaclass has been added.
13.3.25 TimeInterval (from Time)
Description
A TimeInterval defines the range between two TimeExpressions.
Attributes
No additional attributes.
Associations
 min: TimeExpression [1] Refers to the TimeExpression denoting the minimum value of the range
 max: TimeExpression [1] Refers to the TimeExpression denoting the maximum value of the range
Constraints
No additional constraints.
Semantics
None.
Notation
A TimeInterval is shown with the notation of Interval where each value specification element is a TimeExpression.
Changes from UML 1.x
This metaclass has been added.
UML Superstructure 2.0 Draft Adopted Specification        39913.3.26 TimeObservationAction (from Time)
Description
A TimeObservationAction defines an action that observes the current point in time.
Attributes
No additional attributes.
Associations
 now: TimeExpression [1] Represents the current point in time.
Constraints
No additional constraints.
Semantics
A TimeObservationAction is an action that, when executed, returns the current value of time in the context in which it is 
executing.
Notation
A TimeExpression is depicted by text in the expression language used to denote a time value. It may be possible that a time value contains arithmetic operators. The time expression is associated with a NamedElement with a line. A time 
observation action assigns a time expression to a write-once attribute.
timeobservation ::= write-once-attribute= now
Changes from UML 1.x
This metaclass has been added.
13.3.27 TimeTrigger (from Communications)
A TimeTrigger is a trigger that specifies when a time event will be generated. The time event occurs at the instant when 
a specified point in time has transpired.Figure 324 - Time observation:ACSystem
OKt=nowTimeObservationAction
400                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
A time trigger specifies a time event, which models the expiration of a specific deadline. 
Attributes
 isRelative: Boolean Specifies whether it is relative or absolute time.
Associations
 when: TimeExpression [1] Specifies the corresponding time deadline.
Constraints
No additional constraints.
Semantics
The expression specifying the deadline may be relative or absolute. If the time trigger is relative, a starting time must be 
defined. 
Semantic Variation Points
There may be a variable delay between the time of reception and the time of dispatching of the TimeEvent (e.g., due to 
queueing delays). 
Notation
A relative time trigger is specified with the keyword ‘after’ followed by an expression that evaluates to a time value, such as “after (5 seconds)”. An absolute time trigger is specified as an expression that evaluates to a time value, such as “Jan. 
1, 2000, Noon”.
Changes from UML 1.x
This metaclass replaces TimeEvent. The attribute isRelative  has been added for clarity.
13.3.28 Trigger (from Communications)
A trigger specifies the an event that may cause the execution of an associated behavior.
Description
A trigger specifies the an event that may cause the execution of an associated behavior. An event is often ultimately 
caused by the execution of an action, but need not be. Trigger is an abstract metaclass.
Attributes
No additional attributes.
Associations
 port: Port [*] Optionally specifies the ports at which a communication that caused an event may have 
arrived.
UML Superstructure 2.0 Draft Adopted Specification        401Constraints
No additional constraints.
Semantics
Events may cause execution of behavior, e.g the execution of the effect activity of a transition in a state machine. A 
triggers specifies the event that may trigger a behavior execution as well as any constraints on the event to filter out events not of interest. Based upon the different kinds of events that may trigger behavior execution, triggers are classified 
into signal trigger, call trigger, change trigger and time trigger, specifying that a behavior might be triggered by a signal 
event, call event, change event, or time event, respectively.
Events are often generated as a result of some action either within the system or in the environment surrounding the 
system. Upon their occurrence, events are placed into the input pool of the object where they occurred (see 
BehavioredClassifier on page 383). An event is dispatched when it is taken from the input pool and either directly cause the occurrence of a behavior or are delivered to the classifier behavior of the receiving object for processing. At this 
point, the event is considered consumed and referred to as the current event. A consumed event is no longer available for 
processing.
Semantic Variation Points
No assumptions are made about the time intervals between event occurrence, event dispatching, and consumption. This 
leaves open the possibility of different semantic variations such as zero-time semantics.
It is a semantic variation whether an event is discarded if there is no appropriate trigger defined for them.
Notation
A trigger is denoted by a list of names of the triggering events, followed by an assignment specification:
event-name-list [ ‘(’ assignment-specification ‘)’ ]
where the assignment-specification  is a comma separated list of items, where each item may be of the form
  attr-name : this implies an implicit assignment of the corresponding parameter of the event to an attribute (with this 
name) of the of the context object owning the triggered behavior.
Changes from UML 1.x
The corresponding metaclass in 1.x was Event. In 1.x, events were specified with Parameters. Instead, the data that may 
be communicated by an event is accessed via the properties of the specification element defining the event. In UML 2.0, 
the term “event” means an occurrence of an event of a particular type, whereas in UML 1.x, that same term indicated the event type.
402                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        40314 Interactions
14.1 Overview
Interactions are used in a number of different situations. They are used to get a better grip of an interaction situation for 
an individual designer or for a group that need to achieve a common understanding of the situation. Interactions are also used during the more detailed design phase where the precise inter-process communication must be set up according to 
formal protocols. When testing is performed, the traces of the system can be described as interactions and compared with 
those of the earlier phases.
The Interaction package describes the concepts needed to express Interactions.Depending on their purpose, an interaction 
can be displayed in several different types of diagrams: Sequence Diagrams, Interaction Overview Diagrams and 
Communication Diagrams. Optional diagram types such as Timing Diagrams and Interaction Tables come in addition. Each type of diagram provides slightly different capabilities that makes it more appropriate for certain situations.
Interactions are a common mechanism for describing systems that can be understood and produced, at varying levels of 
detail, by both professionals of computer systems design, as well as potential end users and stakeholders of (future) 
systems.
Typically when interactions are produced by designers or by running systems, the case is that the interactions do not tell 
the complete story. There are normally other legal and possible traces that are not contained within the described 
interactions. Some projects do, however, request that all possible traces of a system shall be documented through 
interactions in the form of e.g. sequence diagrams or similar notations.
The most visible aspects of an Interaction are the messages between the lifelines. The sequence of the messages is 
considered important for the understanding of the situation. The data that the messages convey and the lifelines store may 
also be very important, but the Interactions do not focus on the manipulation of data even though data can be used to 
decorate the diagrams.
In this chapter we use the term trace  to mean “sequence of eventoccurrences” which corresponds well with common use 
in the area of trace-semantics which is a preferred way to describe the semantics of Interactions. We may denote this by 
<eventoccurrence1, eventoccurrence2, ...,eventoccurrence-n>. We are aware that other parts of the UML languatge 
definition the term “trace” is used also for other purposes.
By interleaving  we mean the merging of two or more traces such that the events from different traces may come in any 
order in the resulting trace, while events within the same trace retain their order. Interleaving semantics is different from 
a semantics where it is perceived that two events may occur at exactly the same time. To explain Interactions we apply an 
Interleaving Semantics.
404                 UML Superstructure 2.0 Draft Adopted Specification14.2 Abstract syntax
Package structure
 
Figure 325 - Dependencies of the Interactions packagesBasicInteractions
FragmentsBas i cBehaviors
(from CommonBehaviors)
<<merge>>Kernel
(from Classes)
<<merge>>
InternalStructures
(from Compos iteStructures )
<<merge>>
<<merge>>Bas icActivities
(from Activities)
<<me rge >>
UML Superstructure 2.0 Draft Adopted Specification        405BasicInteractions
Figure 326  - Interaction. (from BasicInteractions)ExecutionOccurrenceEventOccurrenceBehavior
(f rom BasicBehav iors)NamedElement
(from  Kernel)
Constraint
(f rom Kernel)StateInvariant
1+invariant1InteractionFragment
Interaction*
0. . 1+fragment
*
+enclosingInteraction
0. . 1
Stop{ordered
subsets ownedM ember}
{s ubsets ownedM ember}
406                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 327 - Lifeline (from BasicInteractions)NamedElement
(from Kernel)InteractionFragment
ConnectableElement
(from InternalStructures)Expression
(from Kernel)EventOccurrence
StateInvariant
Lifeline**
+cov ered*+coveredBy *
*
1*
+represent s
10..10..1
+discriminator
0..10..1*
1*
+covered
1*
1*
+covered1Interact ion
*1
+lifeline
*+interaction1
{redefines covered}
{redefines covered} {subsets ownedMember}
{subsets ownedElement}{subsets namespace}
UML Superstructure 2.0 Draft Adopted Specification        407Figure 328 - Messages (from BasicInteractions)++++
MessageKind
complete
lostfoundunknown<<enumeration>>NamedEl em ent
(from Kernel)
NamedElem ent
(from Kernel)
MessageSort
synchCall
synchSignalasynchCallasynchSignal<<enum eration>>Connector
(from InternalStructures)MessageEndInteraction
NamedElem ent
(from Dependencies)ValueSpecification
(from Kernel)Message
/ messageKind : MessageKind
messageSort : MessageSort
0..1*
+connector 0..1*0..1 0..1+sendMessage
0..1+sendEvent
0..1
0..1 0..1+receiveMessage
0..1+receiveEvent
0..1*1
+m essage
*+i nteraction1
0..1 +signature 0..1* 0..1+argument
* 0..1InteractionFragm ent
GeneralOrderi ng* +generalOrderi ng *
EventOccurrence
1*+before
1+toAfter
*
* 1
+toBefore*
+after1
Behavior
(from BasicBehaviors)E x ec ut i on O cc ur ren ce*1
+startExec*+start1
*1
+finishEx ec*+finish1
+behavior{subsets ownedElement}{subsets ownedMember}{subsets namespace}
{subsets ownedElement}
408                 UML Superstructure 2.0 Draft Adopted SpecificationFragments
Figure 329 - CombinedFragments (from Fragments)
Figure 330 - Gates (from Fragments)Constraint
(from Kernel)ValueSpecification
(from Kernel)InteractionFragment
(from BasicInteractions)
InteractionConstraint
0..1 +minint 0..10..1 +maxint 0..1InteractionOperand*
0..1+fragment
*
+enclosingOperand
0..1{ordered}
0..11
+guar d0..11CombinedFragment
interactionOperator : InteractionOperat ... 1..* 0..1+operand
1..* 0..1
InteractionOperator
seq
altoptbreakparstrictloopregionnegassertignoreconsider<<enumeration>>
Continuation
setting : Boolean = True{subsets namespace}
{subsets ownedMember}
{subsets ownedElement}
{subsets ownedElement}
{subsets ownedElement}
MessageEnd
(f ro m B a si cI nt e ra ct io n s)
CombinedFragmentInteractionOccurrenceGate
*0..1+cfragmentGate
*0..10..1*0..1+actualGate
*
Int era c ti on
*0..1+formalGate
*0..1{subsets ownedMember}
{subsets ownedMember}
{subsets ownedMember}
UML Superstructure 2.0 Draft Adopted Specification        40914.3 Class Descriptions
14.3.1 CombinedFragment (from Fragments)
A combined fragment defines an expression of interaction fragments. A combined fragment is defined by an interaction 
operator and corresponding interaction operands. Through the use of CombinedFragments the user will be able to describe 
a number of traces in a compact and concise manner.
CombinedFragment is a specialization of InteractionFragment.
Attributes
 interactionOperator : InteractionOperator Specifies the operation which defines the semantics of this combination of 
InteractionFragments.
Associations
 cfragmentGate : Gate[*] Specifies the gates that form the interface between this CombinedFragment and its sur-
roundings
 operand: InteractionOperand[1..*]The set of operands of the combined fragment.
Constraints
[1]  If the interactionOperator is opt, loop or neg there must be exactly one operand
[2] The InteractionConstraint with minint and maxint only apply when attached to an InteractionOperand where the interac-
tionOperator is loop.Figure 331 - InteractionOccurrence (from Fragments)InputPin
(from Bas icActivities )InteractionInteractionOccurrence
*0..1+argument
*0..11* +refersTo
1*InteractionFragment
(from BasicInteractions)
PartDecompos it ion Lifeline 1
+decomposedAs1
410                 UML Superstructure 2.0 Draft Adopted SpecificationSemantics
The semantics of a CombinedFragment is dependent upon the interactionOperator as explained below.
Alternatives
The interactionOperator alt designates that the CombinedFragment represents a choice of behavior. At most one of the 
operands will execute. The operand that executes must have an explicit or implicit guard expression that evaluates to true 
at this point in the interaction. An implicit true guard is implied if the operand has no guard.
The set of traces that defines a choice is the union of the (guarded) traces of the operands.An operand guarded by else designates a guard that is the negation of the disjunction of all other guards in the enclosing 
CombinedFragment.
Option
The interactionOperator opt designates that the CombinedFragment represents a choice of behavior where either the (sole) 
operand happens or nothing happens. An option is semantically equivalent to an alternative CombinedFragment where 
there is one operand with non-empty content and the second operand is empty.
Break
The interactionOperator break  designates that the CombinedFragment represents a breaking scenario in the sense that the 
operand is a scenario that is performed instead of the remainder of the enclosing InteractionFragment. Thus the break  
operator is a shorthand for an Alternative operator where one operand is given and the other assumed to be the rest of the 
enclosing InteractionFragment.
Break CombinedFragments must be global relative to the enclosing InteractionFragment.
Parallel
The interactionOperator par designates that the CombinedFragment represents a parallel merge between the behaviors of 
the operands. The eventoccurrences of the different operands can be interleaved in any way as long as the ordering 
imposed by each operand as such is preserved.
A parallel merge defines a set of traces that describes all the ways that eventoccurrences of the operands may be 
interleaved without obstructing the order of the eventoccurrences within the operand.
Weak Sequencing
The interactionOperator seq designates that the CombinedFragment represents a weak sequencing between the behaviors 
of the operands.
Weak sequencing is defined by the set of traces with these properties:
1. The ordering of eventoccurrences within each of the operands are maintained in the result
2. Eventoccurrences on different lifelines from different operands may come in any order.
3. Eventoccurrences on the same lifeline from different operands are ordered such that an eventoccurrence of the first 
operand comes before that of the second operand.
Thus weak sequencing reduces to a parallel merge when the operands are on disjunct sets of participants. Weak 
sequencing reduces to strict sequencing when the operands work on only one participant.
UML Superstructure 2.0 Draft Adopted Specification        411Strict Sequencing
The interactionOperator strict  designates that the CombinedFragment represents a strict sequencing between the behaviors 
of the operands. The semantics of the strict operation defines a strict ordering of the operands on the first level within the 
CombinedInteraction with operator strict . Therefore eventoccurrences within contained CombinedInteractions will not 
directly be compared with other eventoccurrences of the enclosing CombinedInteraction.
Negative
The interactionOperator neg designates that the CombinedFragment represents traces that are defined to be invalid.
The set of traces that defined a negative CombinedFragment is equal to the set of traces given by its (sole) operand, only 
that this set is a set of invalid rather than valid traces. All InteractionFragments that are different from Negative are 
considered positive meaning that they describe traces that are valid and should be possible.
Critical Region
The interactionOperator critical  designates that the CombinedFragment represents a critical region. A critical region 
means that the traces of the region cannot be interleaved by other Eventoccurrences (on those Lifelines covered by the 
region). This means that the region is treated atomically by the enclosing fragment when determining the set of valid 
traces. Even though enclosing CombinedFragments may imply that some Eventoccurrences may interleave into the region, such as e.g. with par-operator, this is prevented by defining a region.
Thus the set of traces of enclosing constructs are restricted by critical regions.
Figure 332 - Critical Regionsd CriticalRegion
:Operator :Caller :Emergency :Callee
call(100)
call(100)par
call(101)
call(101)
criticalcall(911)
call(911)
412                 UML Superstructure 2.0 Draft Adopted SpecificationThe example in Figure 332 shows that the handling of a 911-call must be contiguously handled. For the operator he must 
make sure to forward the 911-call before doing anything else. The normal calls, however, can be freely interleaved.
Ignore / Consider
The interactionOperator ignore  designates that there are some message types that are not shown within this combined 
fragment. These message types can be considered insignificant and are intuitively ignored if they appear in a corresponding execution. Alternatively one can understand ignore  to mean that the messages that are ignored can appear 
anywhere in the traces.
Conversely the interactionOperator consider  designates which messages should be considered within this 
CombinedFragment. This is equivalent to defining every other message to be ignored .
Assertion
The interactionOperator assert  designates that the CombinedFragment represents an assertion. The sequences of the 
operand of the assertion are the only valid continuations. All other continuations result in an invalid trace.
Assertions are often combined with Ignore or Consider as shown in Figure 345.
Loop
The interactionOperator loop designates that the CombinedFragment represents a loop. The loop operand will be repeated 
a number of times.
The Guard may include a lower and an upper number of iterations of the loop as well as a Boolean expression. The 
semantics is such that a loop will iterate minimum the ‘minint’ number of times (given by the iteration expression in the 
guard) and at most the ‘maxint’ number of times. After the minimum number of iterations have executed, and the boolean 
expression is false the loop will terminate. The loop construct represent a recursive application of the seq operator where 
the loop operand is sequenced after the result of earlier iterations.
The Semantics of Gates (see also “Gate (from Fragments)” on page 418)
The gates of a CombinedFragment represent the syntactic interface between the CombinedFragment and its surroundings, 
which means the interface towards other InteractionFragments.
The only purpose of gates is to define the source and the target of Messages or General Order relations.
Notation
The notation for a CombinedFragment in a Sequence Diagram is a solid-outline rectangle. The operator is shown in a 
pentagon in the upper left corner of the rectangle.
More than one operator may be shown in the pentagon descriptor. This is a shorthand for nesting CombinedFragments. 
This means that sd strict  in the pentagon descriptor is the same as two CombinedFragments nested, the outermost with sd 
and the inner with strict .
The operands of a CombinedFragment are shown by tiling the graph region of the CombinedFragment using dashed 
horizontal lines to divide it into regions corresponding to the operands.
UML Superstructure 2.0 Draft Adopted Specification        413Strict
Notationally this means that the vertical coordinate of the contained fragments is significant throughout the whole scope 
of the CombinedFragment and not only on one Lifeline. The vertical position of an EventOccurrence is given by the 
vertical position of the corresponding point. The vertical position of other InteractionFragments is given by the topmost 
vertical position of its bounding rectangle.
Ignore / Consider
Textual syntax: ( ignore | consider ){ <message name>{,<message name>}* }
Examples: consider  {m, s}: showing that only m and s messages are considered significant
ignore  {q,r}: showing that q and r messages are considered insignificant
Ignore and consider operations are typically combined with other operations such as “ assert consider  {m, s}”
See example in Figure 345.
Loop
Textual syntax of the loop operand: loop [ ‘(‘ <minint> [, <maxint> ] ‘)’ ]
<minint> ::= non-negative natural<maxint> ::= non-negative natural (greater than or equal to <minint> | ‘ *’
‘*’ means infinity.If only <minint> is present, this means that minint=maxint=integer.If only loop  then this means a loop with infinity upper bound and with 0 as lower bound.
Presentation Option for “coregion area”
A notational shorthand for parallel combined fragments are available for the common situation where the order of event 
occurrences (or other nested fragments) on one Lifeline is insignificant. This means that in a given “coregion” area of a 
Lifeline all the directly contained fragments are considered separate operands of a parallel combined fragment. See 
example in Figure 333.
414                 UML Superstructure 2.0 Draft Adopted SpecificationExamples
Rationale
Not applicable.
Changes from UML 1.x
This concept was not included in UML 1.x.
14.3.2 Continuation (from Fragments)
A Continuation is a syntactic way to define continuations of different branches of an Alternative CombinedFragment. 
Continuations is intuitively similar to labels representing intermediate points in a flow of control.
Attributes
 setting : Boolean True: when the Continuation is at the end of the enclosing InteractionFragment and False 
when it is in the beginning.Figure 333 - CombinedFragmentsd example
ob1:C1 ob3:C3 ob4:C4
opti
alt[x>0]
ob2:C2create
foo(foo_par=x)
foo(_)doit(z)
doit(_)
[else]
doit(z)
doit(_)bar(x)
x=bar(_):15InteractionConstraintCombinedFragment
(Alternative)InteractionOperator
InteractionOperand separator
UML Superstructure 2.0 Draft Adopted Specification        415Constraints
[1]  Continuations with the same name may only cover the same set of Lifelines (within one Classifier).
[2] Continuations are always global in the enclosing InteractionFragment e.g. it always covers all Lifelines covered by the
enclosing InteractionFragment.
[3] Continuations always occur as the very first InteractionFragment or the very last InteractionFragment of the enclosing
InteractionFragment.
Semantics
Continuations have semantics only in connection with Alternative CombinedFragments and (weak) sequencing.
If an InteractionOperand of an Alternative CombinedFragment ends in a Continuation with name (say) X, only 
InteractionFragments starting with the Continuation X (or no continuation at all) can be appended.
Notation
Continuations are shown with the same symbol as States, but they may cover more than one Lifeline.
Continuations may also appear on flowlines of Interaction Overview Diagrams.Continuations that are alone in an InteractionFragment is considered to be at the end of the enclosing 
InteractionFragment.
Figure 334 - Continuationsd Continue
:A :B :C
refQuestion
alt
ok
notOKyes
nosd Question
:A :B
alt
ok
notOKask
DoSth
nonono
Continuation (setting==False) Continuation (setting==True)
416                 UML Superstructure 2.0 Draft Adopted SpecificationThe two diagrams in Figure 334 are together equivalent to the diagram in Figure 335.
14.3.3 EventOccurrence (from BasicInteractions)
EventOccurrences represents moments in time to which Actions are associated. An EventOccurrence is the basic semantic 
unit of Interactions. The sequences of Eventoccurrences are the meanings of Interactions. Messages are sent through either asynchronous signal sending or operation calls. Likewise they are recieved by Receptions or actions of 
consumption.
EventOccurrence is a specialization of InteractionFragment and of MessageEnd.EventOccurrences are ordered along a Lifeline.The namespace of an EventOccurrence is the Interaction in which it is contained.
Associations
 startExec: ExecutionOccurrence[0..1]References the ExecutionOccurrence of start (of action)
 finishExec:ExecutionOccurrence[0..1]References the ExecutionOccurrence of finish (of action) covered: Lifeline[1] References the Lifeline on which the Eventoccurrence appears. Redefines Interaction-
Fragment.covered.
 toBefore:GeneralOrdering[*] References the GeneralOrderings that specify EventOcurrences that must occur before this 
EventOccurrence
 toAfter: GeneralOrdering[*] References the GeneralOrderings that specify EventOcurrences that must occur after this 
EventOccurrenceFigure 335 - Continuation interpretationsd Continue
:A :B :C
alt
noask
DoSth
yes
nonono
UML Superstructure 2.0 Draft Adopted Specification        417Semantics
The semantics of an EventOccurrence is just the trace of that single EventOccurrence.
The understanding and deeper meaning of the Eventoccurrence is dependent upon the associated Message and the 
information that it conveys.
Notation
Eventoccurrences are merely syntactic points at the ends of Messages or at the beginning/end of an ExecutionOccurrence.
Examples
14.3.4 ExecutionOccurrence (from BasicInteractions)
An ExecutionOccurrence is an instantiation of a unit of behavior within the Lifeline. Since the ExecutionOccurrence will 
have some duration, it is represented by two Eventoccurrences, the start EventOccurrence and the finish 
EventOccurrence.
An ExecutionOccurrence is an InteractionFragment.
Associations
 start : Eventoccurrence[1] References the Eventoccurrence that designates the start of the Action
 finish: Eventoccurrence[1] References the Eventoccurrence that designates the finish of the Action. behavior:Behavior[0..1] References the associated behavior
Constraints
[1]  The startEvent and the finishEvent must be on the same Lifeline
start.lifeline = finish.lifeline
Semantics
The trace semantics of Interactions merely see an ExecutionOccurrence as the trace <start, finish>. There may be 
Eventoccurrences between these. Typically the start Eventoccurrence and the finish Eventoccurrence will refer to 
Eventoccurrences such as a receive Eventoccurrence (of a Message) and the send Eventoccurrence (of a return Message).Figure 336 - EventOccurrencesd EventOccurrence
:Lifeline
msgEventOccurrence
Message(formal)
Gate
(msg.sendEvent)
418                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
ExecutionOccurences are represented as thin rectangles (grey or white) on the lifeline (see “Lifeline (from 
BasicInteractions, Fragments)” on page 427).
We may also represent an ExecutionOccurrence as Actions are represented in Activity diagrams.ExecutionOccurrences that refer to atomic actions such as reading attributes of a Signal (conveyed by the Message), the 
Action symbol may be associated with the reception EventOccurrence with a line in order to emphasize that the whole 
Action is associated with only one EventOccurrence (and start and finish associations refer the very same EventOccurrence)
14.3.5 Gate (from Fragments)
A Gate is a connection point for relating a Message outside an InteractionFragment with a Message inside the InteractionFragment.
Gate is a specialization of MessageEnd.Gates are connected through Messages. A Gate is actually a representative of an EventOccurrence that is not in the same 
scope as the Gate.
Gates play different roles: we have formal gates on Interactions, actual gates on InteractionOccurrences, expression gates 
on CombinedFragments.
Constraints
[1]  The message leading to/from an actualGate of an InteractionOccurrence must correspond to the message leading from/to 
the formalGate with the same name of the Interaction referenced by the InteractionOccurrence.
[2] The message leading to/from an (expression) Gate within a CombinedFragment must correspond to the message leading
from/to the CombinedFragment on its outside.
Semantics
The gates are named either explicitly or implicitly. Gates may be identified either by name (if specified), or by a 
constructed identifier formed by concatenating the direction of the message and the message name (e.g. out_CardOut ). 
The gates and the messages between gates have one purpose, namely to establish the concrete sender and receiver for 
every message.
Notation
Gates are just points on the frame, the ends of the messages. They may have an explicit name. See Figure 336.
The same gate may appear several times in the same or different diagrams.
14.3.6 GeneralOrdering (from BasicInteractions)
A GeneralOrdering represents a binary relation between two Eventoccurrences, to describe that one Eventoccurrence must 
occur before the other in a valid trace. This mechanism provides the ability to define partial orders of EventOccurrences 
that may otherwise not have a specified order.
A GeneralOrdering is a specialization of NamedElement.A GeneralOrdering may appear anywhere in an Interaction, but only between Eventoccurrences.
UML Superstructure 2.0 Draft Adopted Specification        419Associations
 before: EventOccurrence[1] The Eventoccurrence referred comes before the Eventoccurrence referred by after
 after:EventOccurrence[1] The Eventoccurrence referred comes after the Eventoccurrence referred by before
Semantics
A GeneralOrdering is introduced to restrict the set of possible sequences. A partial order of Eventoccurrences is defined 
by a set of GeneralOrdering.
Notation
A GeneralOrdering is shown by a dotted line connected the two Eventoccurrences. The direction of the relation from the before  to the after  is given by an arrowhead placed somewhere in the middle of the dotted line (i.e. not at the endpoint).
14.3.7 Interaction (from BasicInteraction, Fragments)
An interaction is a unit of behavior that focuses on the observable exchange of information between 
ConnectableElements. 
An Interaction is a specialization of InteractionFragment and of Behavior.
Associations
 formalGate: Gate[*] Specifies the gates that form the message interface between this Interaction and any Inter-
actionOccurrences which reference it.
 lifeline: LifeLine[0..*] Specifies the participants in this Interaction event:MessageEnd[*] MessageEnds (e.g. EventOccurrences or Gates) owned by this Interaction message:Message[*] The Messages contained in this Interaction. fragment:InteractionFragment[*]The ordered set of fragments in the Interaction
Semantics
Interactions are units of behavior of an enclosing Classifier. Interactions focus on the passing of information with 
Messages between the ConnectableElements of the Classifier.
The semantics of an Interaction is given as a pair of sets of traces. The two trace sets represent valid traces and invalid 
traces. The union of these two sets need not necessarily cover the whole universe of traces. The traces that are not included are not described by this Interaction at all, and we cannot know whether they are valid or invalid.
A trace is a sequence of Eventoccurrences. The semantics of Interactions are compositional in the sense that the semantics 
of an Interaction is mechanically built from the semantics of its constituent InteractionFragments. The constituent 
InteractionFragments are ordered and combined by the seq operation (weak sequencing) as explained in “Weak Sequencing” on page 410.
The invalid set of traces are associated only with the use of a Negative CombinedInteraction. For simplicity we describe 
only valid traces for all other constructs.
As Behavior an Interaction is generalizable and redefineable. Specializing an Interaction is simply to add more traces to 
those of the original. The traces defined by the specialization is combined with those of the inherited Interaction with a union.
420                 UML Superstructure 2.0 Draft Adopted SpecificationThe classifier owning an Interaction may be specialized, and in the specialization the Interaction may be redefined. 
Redefining an Interaction simply means to exchange the redefining Interaction for the redefined one, and this exchange 
takes effect also for InteractionOccurrences within the supertype of the owner. This is similar to redefinition of other kinds of Behavior.
Basic trace model:  The semantics of an Interaction is given by a pair [P, I] where P is the set of valid traces and I is the 
set of invalid traces.  needs not be the whole universe of traces.
A trace is a sequence of event occurrences denoted <e1, e2, ... , en>.An event occurrence will also include information about the values of all relevant objects at this point in time.Each construct of Interactions (such as CombinedFragments of different kinds) are expressed in terms of how it relates to 
a pair of sets of traces. For simplicity we normally refer only to the set of valid traces as these traces are those mostly 
modeled.
Two Interactions are equivalent if their pair of trace-sets are equal.Relation of trace model to execution model : In Chapter 13, “Common Behaviors” we find an Execution model, and this 
is how the Interactions Trace Model relates to the Execution model.
An Interaction is an Emergent Behavior.An Invocation Event in the Execution model corresponds with an EventOccurrence in Interactions. Normally in 
Interaction the action leading to the invocation as such is not described (such as the sending action). However, if it is 
desirable to go into details, a Behavior (such as an Activity) may be associated with an Eventoccurrence. An 
Eventoccurrence in Interactions are normally interpreted to take zero time. Duration is always between Eventoccurrences.
Likewise a Receiving Event in the Execution model corresponds with an Eventoccurrence in Interactions. Similarly the 
detailed actions following immediately from this reception is often omitted in Interactions, but may also be described 
explicitly with a Behavior associated with that Eventoccurrence.
A Request in the Execution model corresponds to the Message in Interactions.A BehaviorExecution in the Execution model corresponds directly to an Execution Occurrence in Interactions. An 
ExecutionOccurrence is defined in the trace by two EventOccurrences, one at the start and one at the end. This corresponds to the Start Event and the Termination Event of the Execution model
Notation
The notation for an Interaction in a Sequence Diagram is a solid-outline rectangle. The keyword sd followed by the 
Interaction name and parameters is in a pentagon in the upper left corner of the rectangle. The notation within this 
rectangular frame comes in several forms: Sequence Diagrams, Communication Diagrams, Interaction Overview 
Diagrams and Timing Diagrams.
The notation within the pentagon descriptor follows the general notation for the name of Behaviors. In addition the 
Interaction Overview Diagrams may include a list of Lifelines through a lifeline-clause as shown in Figure 349. The list 
of lifelines is simply a listing of the Lifelines involved in the Interaction. An Interaction Overview Diagram does not in 
itself show the involved lifelines even though the lifelines may occur explicitly within inline Interactions in the graph nodes.
An Interaction diagram may also include definitions of local attributes with the same syntax as attributes in general are 
shown within class symbol compartments. These attribute definitions may appear near the top of the diagram frame or 
within note symbols other places in the diagram.PI∪
UML Superstructure 2.0 Draft Adopted Specification        421Please refer to  Section 14.4 to see examples of notation for Interactions.
Examples
The example in Figure 337 shows three messages communicated between two (anonymous) lifelines of types User  and 
ACSystem . The message CardOut  overtakes the message OK in the way that the receiving event occurrences are in the 
opposite order of the sending eventoccurrences. Such communication may occur when the messages are asynchronous. 
Finally a fourth message is sent from the ACSystem  to the environment through a gate with implicit name out_Unlock . 
The local attriburte PIN of UserAccepted  is declared near the diagram top. It could have been declared in a Note 
somewhere else in the diagram.
Rationale
Not applicable.
Changes from UML 1.x
Interactions are now contained within Classifiers and not only within Collaborations. Their participants are modeled by Lifelines instead of ClassifierRoles.
14.3.8 InteractionConstraint (from Fragments)
An InteractionConstraint is a boolean expression that guards an operand in a CombinedFragment.
InteractionConstraint is a specialization of Constraint.Furthermore the InteractionConstraint contains two expressions designating the minimum and maximum number of times 
a loop CombinedFragment should execute.Figure 337 - An example of an Interaction in the form of a Sequence Diagramsd UserAccepted
:User :ACSystem
Code(PIN)
CardOut
OK
Unlock+PIN:Integer {readonly 0<=PIN <=9999}Name of Interaction
Lifeline
MessageLocal Attribute
422                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 minint: ValueSpecification[0..1]The minimum number of iterations of a loop
 maxint: ValueSpecification[0..1]The maximum number of iterations of a loop
Constraints
[1]  The dynamic variables that take part in the constraint must be owned by the ConnectableElement corresponding to the 
covered Lifeline.
[2] The constraint may contain references to global data or write-once data.
[3] Minint/maxint can only be present if the InteractionConstraint is associated with the operand of a loop CombinedFrag-
ment.
[4] If minint is specified, then the expression must evaluate to a non-negative integer.
[5] If maxint is specified, then the expression must evaluate to a positive integer.
[6] If maxint is specified, then minint must be specified and the evaluation of maxint must be >= the evaluation of minint
Semantics
InteractionConstraints are always used in connection with CombinedFragments, see “CombinedFragment (from 
Fragments)” on page 409.
Notation
An InteractionConstraint is shown in square brackets covering the lifeline where the first event occurrence will occur, positioned above that event, in the containing Interaction or InteractionOperand.
interactionconstraint ::= [‘[‘ Boolean Expression | else‘]’]
When the InteractionConstraint is omitted, true is assumed.
Please refer to an example of InteractionConstraints in Figure 333.
14.3.9 InteractionFragment (from Fragments)
InteractionFragment is an abstract notion of the most general interaction unit. An interaction fragment is a piece of an 
interaction. Each interaction fragment is conceptually like an interaction by itself. 
InteractionFragment is an abstract class and a specialization of NamedElement.
Associations
 enclosingOperand: InteractionOperand[0..1]The operand enclosing this InteractionFragment (they may nest recursively)
 covered : Lifeline[*] References the Lifelines that the InteractionFragment involves generalOrdering:GeneralOrdering[*]The general ordering relationships contained in this fragment enclosingInteraction: Interaction[0..1]The Interaction enclosing this InteractionFragment.
Semantics
The semantics of an InteractionFragment is a pair of set of traces. See “Interaction (from BasicInteraction, Fragments)” 
for explanation of how to calculate the traces.
UML Superstructure 2.0 Draft Adopted Specification        423Notation
There is no general notation for an InteractionFragment. The specific subclasses of InteractionFragment will define their 
own notation.
Rationale
Not applicable.
Changes from UML 1.x
This concept did not appear in UML 1.x.
14.3.10 InteractionOccurrence (from Fragments)
An InteractionOccurrence refers to an Interaction. The InteractionOccurrence is a shorthand for copying the contents of 
the referred Interaction where the InteractionOccurrence is. To be accurate the copying must take into account substituting 
parameters with arguments and connect the formal gates with the actual ones.
It is common to want to share portions of an interaction between several other interactions. An InteractionOccurrence 
allows multiple interactions to reference an interaction that represents a common portion of their specification.
Description
InteractionOccurrence is a specialization of InteractionFragment.
An InteractionOccurrence has a set of actual gates that must match the formal gates of the referenced Interaction.
Associations
 refersTo: Interaction[1] Refers to the Interaction that defines its meaning
 argument:InputPin[*] The actual arguments of the Interaction actualGate:Gate[*] The actual gates of the InteractionOccurrence
Constraints
[1]  Actual Gates of the InteractionOccurrence must match Formal Gates of the referred Interaction. Gates match when their 
names are equal.
TBD
[2] The InteractionOccurrence must cover all Lifelines of the enclosing Interaction which appear within the referred Interac-
tion.
[3] The arguments of the InteractionOccurrence must correspond to parameters of the referred Interaction
[4] The arguments must only be constants, parameters of the enclosing Interaction or attributes of the classifier owning the
enclosing Interaction.
Semantics
The semantics of the InteractionOccurrence is the set of traces of the semantics of the referred Interaction where the gates 
have been resolved as well as all generic parts having been bound such as the arguments substituting the parameters.
424                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
The InteractionOccurrence is shown as a CombinedFragment symbol where the operator is called ref. The complete 
syntax of the name (situated in the InteractionOccurrence area) is:
name ::=[ attribute-name = ][collaborationoccurrence.] interactionname[‘(‘arguments’)’] [: return-value]
argument ::= in-argument [ out out-argument]
The attribute-name refers to an attribute of one of the lifelines in the Interaction.
The collaborationoccurence is an identification of a collaboration occurrence that binds lifelines of a collaboration. The 
interaction name is in that case within that collaboration. See example of the usage of collaboration occurrences in Figure 
346.
The arguments are most often arguments of IN-parameters. If there are OUT- or INOUT-parameters and the output value 
is to be described, this can be done following an out keyword.
For general syntax of arguments we use the same syntax as for Messages (“Message (from BasicInteractions)” on 
page 428).
If the InteractionOccurrence returns a value, this may be described following a colon at the end of the clause.
Examples
In Figure 338 we show an InteractionOccurrence  referring the Interaction EstablishAccess  with (input) argument “Illegal 
PIN”. Within the optional CombinedFragment there is another InteractionOccurrence without arguments referring 
OpenDoor .Figure 338 - InteractionOccurrence:Usersd UserAccess
:ACSystem
refEstablishAccess("Illegal PIN")
CardOut
opt Msg("Please Enter")
refOpenDoorInteractionOccurrence
UML Superstructure 2.0 Draft Adopted Specification        425In Figure 339 we have a more advanced Interaction that models a behavior returning a Verdict  value. The return value 
from the Interaction is shown as a separate Lifeline a_op_b . Inside the Interaction there is an InteractionOccurrence 
referring a_util_b  with value return to the attribute xc of :xx with the value 9, and with inout parameter where the 
argument is w with returning out-value 12. 
Rationale
Not applicable.
Changes from UML 1.x
InteractionOccurrence was not a concept in UML 1.x
14.3.11 InteractionOperand (from Fragments)
An InteractionOperand is contained in a CombinedFragment. An InteractionOperand represent one operand of the expression given by the enclosing CombinedFragment.
An InteractionOperand is an InteractionFragment with an optional guard expression. An InteractionOperand may be 
guarded by a InteractionConstraint. Only InteractionOperands with a guard that evaluates to true at this point in the 
interaction will be considered for the production of the traces for the enclosing CombinedFragment.
InteractionOperand contains an ordered set of InteractionFragments.Figure 339 - InteractionOccurrence with value returnsd a_op_b(int x, inout int w):Verdict
:xx :yy
s1(x)
put(fail)alt
put(pass)w a_op_b
put(xc) [xc>8]
[xc<8]ref
:xx.xc=a_util_b(31,w:12):9
InteractionOccurrence
with valuereturnreturn parameter as
Lifeline
inout parameter as
Lifeline
argument with output
426                 UML Superstructure 2.0 Draft Adopted SpecificationIn Sequence Diagrams these InteractionFragments are ordered according to their geometrical position vertically. The 
geometrical position of the InteractionFragment is given by the topmost vertical coordinate of its contained 
eventoccurrences or symbols.
Associations
 fragment: InteractionFragment[*]The fragments of the operand.
 guard: InteractionConstraint[0..1]Constraint of the operand
Constraints
[1]  The guard must be placed directly prior to (above) the eventoccurrence that will become the first eventoccurrence 
within this InteractionOperand
[2] The guard must contain only references to values local to the Lifeline on which it resides, or values global to the whole
Interaction (See “InteractionConstraint (from Fragments)” on page 421).
Semantics
Only InteractionOperands with true guards are included in the calculation of the semantics. If no guard is present, this is 
taken to mean a true guard.
The semantics of an InteractionOperand is given by its constituent InteractionFragments combined by the implicit seq 
operation. The seq operator is described in “CombinedFragment (from Fragments)” on page 409
Notation
InteractionOperands are separated by a dashed horizontal line. The InteractionOperands together make up the framed CombinedFragment.
Within an InteractionOperand of a Sequence Diagram the order of the InteractionFragments are given simply by the 
topmost vertical position.
See Figure 333 for examples of InteractionOperand.
14.3.12 InteractionOperator (from Fragments)
Interaction Operator is an enumeration designating the different kinds of operators of CombinedFragments.The InteractionOperand defines the type of operator of a CombinedFragment.
Literals
 alt, opt, par, loop, critical, neg, assert, strict, seq, ignore, consider
Semantics
The value of the InteractionOperator is significant for the semantics of “CombinedFragment (from Fragments)” on 
page 409.
Notation
The value of the InteractionOperand is given as text in a small compartment in the upper left corner of the CombinedFragment frame.
UML Superstructure 2.0 Draft Adopted Specification        427See Figure 333 for examples of InteractionOperator.
14.3.13 Lifeline (from BasicInteractions, Fragments)
A lifeline represents an individual participant in the Interaction. While Parts and StructuralFeatures may have multiplicity 
greater than 1, Lifelines represent only one interacting entity.
Lifeline is a specialization of NamedElement.If the referenced ConnectableElement is multivalued (i.e. has a multiplicity > 1), then the Lifeline may have an 
expression (the ‘selector’) that specifies which particular part is represented by this Lifeline. If the selector is omitted th is 
means that an arbitrary representative of the multivalued ConnectableElement is chosen.
Associations
 selector : Expression[0..1] If the referenced ConnectableElement is multivalued, then this specifies the specific indi-
vidual part within that set.
 interaction: Interaction[1] References the Interaction enclosing this Lifeline. represents: ConnectableElement[1]References the ConnectableElement within the classifier that contains the enclosing 
interaction.
 decomposedAs : PartDecomposition[1]References the Interaction that represents the decomposition.
Constraints
[1]  If two (or more) InteractionOccurrences within one Interaction, refer to Interactions with common Lifelines, those Life-
lines must also appear in the Interaction with the InteractionOccurrences. By ‘common Lifelines’ we mean Lifelines with the same selector and represents associations.
TBD
[2] The selector for a Lifeline must only be specified if the referenced Part is multivalued.
(self.selector->isEmpty implies not self.represents.isMultivalued()) or
(not self.selector->isEmpty implies self.represents.isMultivalued())
[3] The classifier containing the referenced ConnectableElement must be the same classifier, or an ancestor, of the classifier
that contains the interaction enclosing this lifeline.
Semantics
The order of Eventoccurrences along a Lifeline is significant denoting the order in which these Eventoccurrence will 
occur. The absolute distances between the Eventoccurrences on the Lifeline are, however, irrelevant for the semantics.
The semantics of the Lifeline (within an Interaction) is the semantics of the Interaction selecting only Eventoccurrences 
of this Lifeline.
Notation
A Lifeline is shown using a symbol that consists of a rectangle forming its “head” followed by a vertical line (which may be dashed) that represents the lifetime of the participant. Information identifying the lifeline is displayed inside the rectangle in the following format:
lifelineident ::= [connectable_element_name [‘[‘ selector ‘]’]] [: class_name] [decomposition] | self
selector ::= expressiondecomposition ::= ref interactionident
428                 UML Superstructure 2.0 Draft Adopted Specificationclass_name is the type referenced by the represented ConnectableElement.
Even though the syntax in principle allows it, a lifelineident cannot be empty.
The Lifeline head has a shape which is based on the classifier for the part that this lifeline represents. Often the head is a 
white rectangle containing the name.
If the name is the keyword self, then the lifeline represents the object of the classifier that encloses the Interaction that 
owns the Lifeline. Ports of the encloser may be shown separately even when self is included.
To depict method activations we apply a thin grey or white rectangle that covers the Lifeline line.
Examples
See Figure 337 where the Lifelines are pointed to.
See Figure 333 to see method activations.
Rationale
Not applicable.
Changes from UML 1.x
Lifelines are basically the same concept as before in UML 1.x.
14.3.14 Message (from BasicInteractions)
A Message defines a particular communication between Lifelines of an Interaction.A Message is a NamedElement that defines one specific kind of communication in an Interaction. A communication can 
be e.g. raising a signal, invoking an Operation, creating or destroying an Instance. The Message specifies not only the kind of communication given by the dispatching ExecutionOccurrence, but also the sender and the receiver.
A Message associates normally two EventOccurrences - one sending EventOccurrence and one receiving 
EventOccurrence.
Attributes
 messageKind:MessageKind The derived kind of the Message ( complete , lost, found  or unknown )
complete = sendEvent and receiveEvent are presentlost = sendEvent present and receiveEvent absentfound = sendEvent absent and receiveEvent presentunknown = sendEvent and receiveEvent absent (should not appear)
 messageSort:MessageSort The sort of communication reflected by the Message ( synchCall, synchSignal, asynchCall, 
asynchSignal )
Associations
 interaction:Interaction[1] The enclosing Interaction owning the Message
 sendEvent : MessageEnd[0..1] References the Sending of the Message. receiveEvent: MessageEnd[0..1]References the Receiving of the Message connector: Connector[0..1] The Connector on which this Message is sent.
UML Superstructure 2.0 Draft Adopted Specification        429 argument:ValueSpecification[*]The arguments of the Message
 signature:NamedElement[0..1] The definition of the type or signature of the Message (depending on its kind)
Constraints
[1]  If the sendEvent and the receiveEvent of the same Message are on the same Lifeline, the sendEvent must be ordered 
before the receiveEvent.
[2] The signature must either refer an Operation (in which case messageSort is either synchCall or asynchCall) or a Signal (in
which case messageSort is either synchSignal or asynchSignal). The name of the NamedElement referenced by signaturemust be the same as that of the Message.
[3] In the case when the Message signature is an Operation, the arguments of the Message must correspond to the parameters
of the Operation. A Parameter corresponds to an Argument if the Argument is of the same Class or a specialization of thatof the Parameter.
[4] In the case when the Message signature is a Signal, the arguments of the Message must correspond to the attributes of the
Signal. A Message Argument corresponds to a Signal Attribute if the Arguement is of the same Class or a specializationof that of the Attribute.
[5] Relations sendEvent  and receiveEvent  are mutually exclusive.
[6] Arguments of a Message must only be:
i) attributes of the sending lifelineii) constantsiii) symbolic values (which are wildcard values representing any legal value)iv) explicit parameters of the enclosing Interactionv) attributes of the class owning the Interaction
[7] Messages cannot cross bounderies of CombinedFragments or their operands.
[8] If the MessageEnds are both EventOccurrences then the connector must go between the Parts represented by the Lifelines
of the two MessageEnds.
Semantics
The semantics of a complete  Message is simply the trace <sendEvent, receiveEvent>.
A lost message is a message where the sending event occurrence is known, but there is no receiving event occurrence. We 
interpret this to be because the message never reached its destination. The semantics is simply the trace <sendEvent>.
A found  message is a message where the receiving event occurrence is known, but there is no (known) sending event 
occurrence. We interpret this to be because the origin of the message is outside the scope of the description. This may for 
example be noise or other activity that we do not want to describe in detail. The semantics is simply the trace 
<receiveEvent>.
A Message reflects either an Operation call and start of execution - or a sending and reception of a Signal.When a Message represents an Operation the arguments of the Message are the arguments of the CallAction on the 
sending Lifeline and the arguments of the CallEvent on the receiving Lifeline.
When a Message represents a Signal, the arguments of the Message are the arguments of the SendAction on the sending 
Lifeline and on the receiving Lifeline the arguments are available in the SignalEvent.
If the Message represents a CallAction, There will normally be a return message from the called lifeline back to the 
calling lifeline before the calling Lifeline will proceed.
430                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
A message is shown as a line from the sender message end to the receiver message end. The form of the line or arrowhead 
reflect properties of the message:
Asynchronous Messages have an open arrow head.Synchronous Messages typically represent method calls and are shown with a filled arrow head. The reply message from 
a method has a dashed line.
Object creation Message has a dashed line with an open arrow.Lost Messages are described as a small black circle at the arrow end of the Message.Found Messages are described as a small black circle at the starting end of the Message.On Communication Diagrams, the Messages are decorated by a small arrow along the connector close to the Message 
name and sequence number in the direction of the Message.
Syntax for the Message name is the following:
messageident ::= [attribute =] signal-or-operation-name [ ( arguments) ][: return-value] | ‘*’
arguments ::= argument [ , arguments]argument ::= [parameter-name=]argument-value | attribute= out-parameter-name [:argument-value]| - 
Messageident equalling ‘*’ is a shorthand for more complex alternative CombinedInteraction to represent a message of 
any type. This is to match asterisk triggers in State Machines.
Return-value and attribute assignment are used only for reply messages. Attribute assignment is a shorthand for including 
the Action that assigns the return-value to that attribute. This holds both for the possible return value of the message (the return value of the associated operation), and the out values of (in)out parameters.
When the argument list contains only argument-values, all the parameters must be matched either by a value or by a dash 
(-). If parameter-names are used to identify the argument-value, then arguments may freely be omitted. Omitted 
parameters get an unknown argument-value.
Examples
In Figure 337 we see only asynchronous Messages. Such Messages may overtake each other.
In Figure 333 we see method calls that are synchronous accompanied by replies. We also see a Message that represents 
the creation of an object.
In Figure 348 we see how Messages are denoted in Communication Diagrams.Examples of syntax:
mymessage(14, - , 3.14, “hello”) // second argument is undefined
v=mymsg(16, variab):96 // this is a reply message carrying the return value 96 assigning it to vmymsg(myint=16) // the input parameter ‘myint’ is given the argument value 16
See Figure 333 for a number of different applications of the textual syntax of message identification.
Rationale
Not applicable.
UML Superstructure 2.0 Draft Adopted Specification        431Changes from UML 1.x
We notice that Messages may have Gates on either end.
14.3.15 MessageEnd (from BasicInteractions)
A MessageEnd is an abstract NamedElement that represents what can occur at the end of a Message.
Associations
 sendMessage : Message[0..1] References the Message that contains the information of a sendEvent
 receiveMessage : Message[0..1]References the Message that contains the information of a receiveEvent
 interaction:Interaction[1] The enclosing Interaction owning the MessageEnd
Semantics
Subclasses of MessageEnd define the specific semantics appropriate to the concept they represent.
14.3.16 PartDecomposition (from Fragments)
PartDecomposition is a description of the internal interactions of one Lifeline relative to an Interaction.
A Lifeline has a class associated as the type of the ConnectableElement that the Lifeline represents. That class may have 
an internal structure and the PartDecomposition is an Interaction that describes the behavior of that internal structure 
relative to the Interaction where the decomposition is referenced.
A PartDecomposition is a specialization of InteractionOccurrence. It associates with the ConnectableElement that it 
decomposes.
Constraints
[1]  PartDecompositions apply only to Parts that are Parts of Internal Structures not to Parts of Collaborations.
[2] Assume that within Interaction X, Lifeline L is of class C and decomposed to D. Within X there is a sequence of con-
structs along L (such constructs are CombinedFragments, InteractionOccurrence and (plain) Eventoccurrences). Then acorresponding sequence of constructs must appear within D, matched one-to-one in the same order.i) CombinedFragment covering L are matched with an extra-global CombinedFragment in Dii) An InteractionOccurrence covering L are matched with a global (i.e. covering all Lifelines) InteractionOccurrence inD.iii) A plain EventOccurrence on L is considered an actualGate that must be matched by a formalGate of D
[3] Assume that within Interaction X, Lifeline L is of class C and decomposed to D. Assume also that there is within X an
InteractionOccurrence (say) U that covers L. According to the constraint above U will have a counterpart CU within D.Within the Interaction referenced by U, L should also be decomposed, and the decomposition should reference CU. (Thisrule is called commutativity of decomposition)
Semantics
Decomposition of a lifeline within one Interaction by an Interaction (owned by the type of the Lifeline’s associated 
ConnectableElement), is interpreted exactly as an InteractionOccurrence. The messages that go into (or go out from) the 
decomposed lifeline are interpreted as actual gates that are matched by corresponding formal gates on the decomposition.
432                 UML Superstructure 2.0 Draft Adopted SpecificationSince the decomposed Lifeline is interpreted as an InteractionOccurrence, the semantics of a PartDecomposition is the 
semantics of the Interaction referenced by the decomposition where the gates and parameters have been matched.
That a CombinedFragment is extra-global depicts that there is a CombinedFragment with the same operator covering the 
decomposed Lifeline in its Interaction. The full understanding of that (higher level) CombinedFragment must be acquired through combining the operands of the decompositions operand by operand.
Notation
PartDecomposition is designated by a referencing clause in the head of the Lifeline as can be seen in the notation section of “Lifeline (from BasicInteractions, Fragments)” on page 427. See also Figure 340.
Extraglobal CombinedFragments have their rectangular frame go outside the bounderies of the decomposition Interaction.
Style Guidelines
The name of an Interaction that are involved in decomposition would benefit from including in the name, the name of the 
type of the Part being decomposed and the name of the Interaction originating the decomposition. This is shown in Figure 
340 where the decomposition is called AC_UserAccess  where ‘AC’ refers to ACSystem  which is the type of the Lifeline 
and UserAccess  is the name of the Interaction where the decomposed lifeline is contained.
Examples
In Figure 340 we see how ACSystem  within UserAccess  is to be decomposed to AC_UserAccess  which is an Interaction 
owned by class ACSystem .Figure 340 - Part Decomposition - the decomposed partsd UserAccess
:User:ACSystem
ref AC_UserAccess
refEstablishAccess("Illegal PIN")
CardOut
opt Msg("Please Enter")
refOpenDoor[pin ok]Part decomposition
UML Superstructure 2.0 Draft Adopted Specification        433In Figure 341 we see that AC_UserAccess  has global constructs that match the constructs of UserAccess  covering 
ACSystem .
In particular we notice the “extra global interaction group” that goes beyond the frame of the Interaction. This construct 
corresponds to a CombinedFragment of UserAccess . However, we want to indicate that the operands of extra global 
interaction groups are combined one-to-one with similar extra global interaction groups of other decompositions of the same original CombinedFragment.
As a notational shorthand, decompositions can also be shown “inline”. In Figure 341 we see that the inner 
ConnectableElements of :AccessPoint  (p1 and p2) are represented by Lifelines already on this level. 
Rationale
Not applicable.
Changes from UML 1.x
PartDecomposition did not appear in UML 1.x.
14.3.17 StateInvariant (from BasicInteractions)
A StateInvariant is a constraint on the state of a Lifeline. In this case we mean by “state” also the values of eventual 
attributes of the Lifeline.
A StateInvariant is an InteractionFragment and it is placed on a Lifeline.Figure 341 - Part Decomposition - the decomposition:AccessPointsd AC_UserAccess
p1 p2:Authorizer :Console
refAC_EstablishAccess("Illegal PIN")
CardOut
opt
Msg("Please Enter")
refAC_OpenDoor[pin ok]Inner
extra global
CombinedFragmentConnectable
Elements
434                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 invariant: Constraint[1] A Constraint that should hold at runtime for this StateInvariant
 lifeline: Lifeline[1] References the Lifeline on which the StateInvariant appears. Specializes InteractionFrag-
ment.covered
Semantics
The Constraint is assumed to be evaluated during runtime. The Constraint is evaluated immediately prior to the execution 
of the next EventOccurrence such that all actions that are not explicitly modeled have been executed. If the Constraint is true the trace is a valid trace; if the Constraint is false the trace is an invalid trace. In other words all traces that has a  
StateInvariant with a false Constraint is considered invalid.
Notation
The possible associated Constraint is shown as text in curly brackets on the lifeline.
See example in Figure 345.
Presentation Options
A StateInvariant can optionally be shown as a Note associated with an EventOccurrence.State symbols may also be used to describe a Constraint. The State symbol represents the equivalent of a constraint that 
checks the state of the classifierBehavior of the enclosing Classifier. Since States may be hierarchical and orthogonal, the 
following syntax can be used for the state name:
<state-info>::= <region} {,<region> }*
<region>::= <trivial region> | <region-name> {::<state>}?<trivial region>::= <state><state>::= <state-name> {::<region-list>}?<region-list>::= <region> | ( <state-info> )
The regions represent the orthogonal regions of states. The identifier need only define the state partially. The value of the 
constraint is true if the specified state information is true.
The example in Figure 345 also shows this presentation option.
14.3.18 Stop (from BasicInteractions)
A Stop is an EventOccurrence that defines the termination of the instance specified by the Lifeline on which the Stop 
occurs.
Associations
No more associations
Constraints
[1]  No other EventOccurrences may appear below a Stop on a given Lifeline in an InteractionOperand.
Semantics
It is assumed that a Stop implies that the instance described by this Lifeline will terminate.
UML Superstructure 2.0 Draft Adopted Specification        435The trace representing its semantics only contains a “stop” EventOccurrence.
Notation
The Stop is depicted by a cross in the form of an X at the bottom of a Lifeline.
See example in Figure 333.
14.4 Diagrams
Interaction diagrams come in different variants. The most common variant is the Sequence Diagram (“Sequence 
Diagrams” on page 435) that focuses on the Message interchange between a number of Lifelines. Communication Diagrams (“Communication Diagrams” on page 444) show interactions through an architectural view where the arcs 
between the communicating Lifelines are decorated with description of the passed Messages and their sequencing. 
Interaction Overview Diagrams (“Interaction Overview Diagrams” on page 447) are a variant of Activity Diagrams that define interactions in a way that promotes overview of the control flow. In the Appendices one may also find optional 
diagram notations such as Timing Diagrams and Interaction Tables.
Sequence Diagrams
The most common kind of Interaction Diagram is the Sequence Diagram, which focuses on the Message interchange between a number of Lifelines.
A sequence diagram describes an Interaction by focusing on the sequence of Messages that are exchanged, along with 
their corresponding EventOccurrences on the Lifelines. The Interactions that are described by Sequence Diagrams are described in this chapter.Figure 342 - Stop symbol
436                 UML Superstructure 2.0 Draft Adopted SpecificationGraphic Nodes
The graphic nodes that can be included in structural diagrams are shown in Table 14.
Table 14 - Graphic nodes included in sequence diagrams
NODE TYPE NOTATION REFERENCE
Frame The notation shows a rectangular frame around 
the diagram with a name in a compartment in the upper left corner. See “Interaction (from Basi-cInteraction, Fragments)” on page 419.
Lifeline See “Lifeline (from BasicInteractions, Frag-
ments)” on page 427
ExecutionOccurrence See “CombinedFragment (from Fragments)” on 
page 409. See also “Lifeline (from BasicInterac-tions, Fragments)” on page 427 and “Execution-Occurrence (from BasicInteractions)” on page 417
InteractionOccurrence See “InteractionOccurrence (from Fragments)” 
on page 423.sd EventOccurrence
:Lifeline
ob2:C2
Nref
UML Superstructure 2.0 Draft Adopted Specification        437CombinedFragment See “CombinedFragment (from Fragments)” on 
page 409
StateInvariant / 
ContinuationsSee “Continuation (from Fragments)” on 
page 414 and “StateInvariant (from BasicInter-actions)” on page 433
Coregion See explanation under parallel  in “Combined-
Fragment (from Fragments)” on page 409
Stop See Figure 333Table 14 - Graphic nodes included in sequence diagrams
NODE TYPE NOTATION REFERENCE
alt
:Y
p==15
s[u]:B
m3
m2
438                 UML Superstructure 2.0 Draft Adopted SpecificationGraphic Paths
The graphic paths between the graphic nodes are given in Table 15Duration Constraint
Duration ObservationSee Figure 347
Time Constraint
Time ObservationSee Figure 347
Table 15 - Graphic paths included in sequence diagrams
NODE TYPE NOTATION REFERENCE
Message Messages come in different variants depending on 
what kind of Message they convey. Here we show an asynchronous message, a call and a reply. These are all complete  messages. See “Message (from 
BasicInteractions)” on page 428.
Lost Message Lost messages are messages with known sender, 
but the reception of the message does not happen. See “Message (from BasicInteractions)” on page 428Table 14 - Graphic nodes included in sequence diagrams
NODE TYPE NOTATION REFERENCE
:User
Code d= duration
CardOut {0..13}
OK{d..3*d}
CardOut {0..13}
OKt=now
{t..t+3}
Code
doit(z)
lost
UML Superstructure 2.0 Draft Adopted Specification        439ExamplesFound Message Found messages are messages with known 
receiver, but the sending of the message is not described within the specification. See “Message (from BasicInteractions)” on page 428
GeneralOrdering See “GeneralOrdering (from BasicInteractions)” 
on page 418
Figure 343  - Sequence Diagrams where two Lifelines refer to the same set of Parts (and Inter-
nal Structure)Table 15 - Graphic paths included in sequence diagrams
NODE TYPE NOTATION REFERENCE
found
sd N
s[u]:B s[k]:B
m3 m3
m3
m2
{x==2}
C
:rsdMsdN
s:B[*]sd M
:r s[k]:B s[u]:B
m1
m2
refNm3
PartInteractionsLifelineClass
Internal structureCoregion
State
Invariant
440                 UML Superstructure 2.0 Draft Adopted SpecificationThe sequence diagrams shown in Figure 343 shows a scenario where r sends m1 to s[k] (which is of type B), and s[k] 
sends m2 to s[u]. In the meantime independent of s[k] and s[u], r may have sent m3 towards the InteractionOccurrence N 
through a gate. Following the m3 message into N we see that s[u] then sends another m3 message to s[k]. s[k] then sends m3 and then m2 towards s[u]. s[u] receives the two latter messages in any order (coregion). Having received these 
messages, we state an invariant on a variable x (most certainly owned by s[u] ).
In order to explain the mapping of the notation onto the metamodel we have pointed out areas and their corresponding 
metamodel concept in Figure 344. Let us go through the simple diagram and explain how the metamodel is built up. The whole diagram is an Interaction (named N). There is a formal gate (with implicit name in_m3) and two Lifelines (named 
s[u] and s[k] ) that are contained in the Interaction. Furthermore the two Messages (occurrences) both of the same type 
m3, implicitly named m3_1 and m3_2 here, are also owned by the Interaction. Finally there are the three 
EventOccurrences.
We have omitted in this metamodel the objects that are more peripheral to the Interaction model, such as the Part s and 
the class B and the connector referred by the Message.
UML Superstructure 2.0 Draft Adopted Specification        441Figure 344 - Metamodel elements of a sequence diagramsd N
s[u]:B s[k]:B
m3
m3Interaction
Lifeline
(formal) GateMessage
(receiving)EventOccurrence
EventOccurrence
N:Interaction
in_m3:Gate s[u]:Lifeline
s[k]:Lifelinerec_m3_on_su:
EventOccurrence
send_m3_on_su:
EventOccurrence
rec_m3_on_sk:
EventOccurrencem3_1:Message
m3_2:Message
442                 UML Superstructure 2.0 Draft Adopted SpecificationIn Figure 345 we have an Interaction M which considers message types other than t and r. This means that if this 
Interaction is used to specify a test of an existing system and when running that system a t or an r occurs, these messages 
will be ignored by this specification. t and r will of course be handled in some manner by the running system, but how they are handled is irrelevant for our Interaction shown here.
The State invariant given as a state “mystate” will be evaluated at runtime directly prior to whatever event occurs on Y 
after “mystate”. This may be the reception of q as specified within the assert-fragment, or it may be an event that is 
specified to be insignificant by the filters.
The assert  fragment is nested in a consider  fragment to mean that we expect a q message to occur once a v has occurred 
here. Any occurrences of messages other than v,w and q will be ignored in a test situation. Thus the appearance of a w 
message after the v is an invalid trace.
The state invariant given in curly brackets will be evaluated prior to the next event occurrence after that on Y .Figure 345 - Ignore, Consider, assert with State Invariantssd M ignore  {t,r}
:X :Y :Z
s
mystate
assertq
{Y.p == 15}
vconsider {q,v,w}
v
UML Superstructure 2.0 Draft Adopted Specification        443Internal Structure and corresponding Collaboration Occurrence
The example in Figure 346 shows how collaboration occurrences are used to make Interactions of a Collaboration 
available in another classifier.
The collaboration W has two parts x and y that are of types (classes) superA and superB respectively. Classes A and B are 
specializations of superA and superB respectively. The Sequence Diagram Q shows a simple Interaction that we will 
reuse in another environment. The class E represents this other environment. There are two anonymous parts :A and :B 
and the CollaborationOccurrence w1 of Collaboration W binds x and y to :A and :B respectively. This binding is legal since :A and :B are parts of types that are specializations of the types of x and y.
In the Sequence Diagram P (owned by class E) we use the Interaction Q made available via the Collaboration Occurrence 
w1.Figure 346 - Describing collaborations and their binding<<collaboration>>
 W
sdQ
x:superA y:superB
sd Q
x:superA ysuperB
m1
m2E
sdP
w1:W
:A :Bx
y
CollaborationOccurrence
binding Partssd P
:A :B
refw1.Q
444                 UML Superstructure 2.0 Draft Adopted SpecificationThe Sequence Diagram in Figure 347 shows how time and timing notation may be applied to describe time observation 
and timing constraints. The :User sends a message Code and its duration is measured. The :ACSystem will send two messages back to the :User. CardOut is constrained to last between 0 and 13 time units. Furthermore the interval between 
the sending of Code and the reception of OK is constrained to last between d and 3*d where d is the measured duration 
of the Code signal. We also notice the observation of the time point t at the sending of OK and how this is used to constrain the time point of the reception of CardOut.
Communication Diagrams
Communication Diagrams focus on the interaction between Lifelines where the architecture of the internal structure and 
how this corresponds with the message passing is central. The sequencing of Messages is given through a sequence 
numbering scheme.
Communication Diagrams correspond to simple Sequence Diagrams that use none of the structuring mechanisms such as 
InteractionOccurrences and CombinedFragments. It is also assumed that message overtaking (i.e. the order of the 
receptions are different from the order of sending of a given set of messages) will not take place or is irrelevant.Figure 347 - Sequence Diagram with time and timing conceptssd UserAccepted
:User :ACSystem
Code d= duration
CardOut {0..13}
OK
Unlock{d..3*d}
t=now
{t..t+3}DurationConstraint
TimeObservationTimeConstraintDurationObservation
UML Superstructure 2.0 Draft Adopted Specification        445Graphical Nodes
Communication diagram nodes are shown in Table 16.
Graphic Paths
Graphic paths of communication diagrams are given in Table 17Table 16 - Graphic nodes included in communication diagrams
NODE TYPE NOTATION REFERENCE
Frame The notation shows a rectangular frame around the dia-
gram with a name in a compartment in the upper left corner. See “Interaction (from BasicInteraction, Frag-ments)” on page 419.
Lifeline See “Lifeline (from BasicInteractions, Fragments)” on 
page 427
Table 17 - Graphic paths included in communication diagrams
NODE TYPE NOTATION REFERENCE
Message See “Message (from BasicInteractions)” on page 428. and 
“Sequence expression” on page 446The arrow shown here indicates the communication direc-tion.sd EventOccurrence
s[k]:B
1a m1()
446                 UML Superstructure 2.0 Draft Adopted SpecificationExamples
The Interaction described by a Communication Diagram in Figure 348 shows messages m1 and m3 being sent 
concurrently from :r towards two instances of the part s. The sequence numbers shows how the other messages are 
sequenced. 1b.1 follows after 1b and 1b.1.1 thereafter etc. 2 follows after 1a and 1b.
Sequence expression 
The sequence-expression is a dot-separated list of sequence-terms followed by a colon (‘:’). 
sequence-term  ‘.’  . . .  ‘:’
Each term represents a level of procedural nesting within the overall interaction. If all the control is concurrent, then 
nesting does not occur. Each sequence-term has the following syntax:
[ integer | name ] [ recurrence ]
The integer  represents the sequential order of the Message within the next higher level of procedural calling. Messages 
that differ in one integer term are sequentially related at that level of nesting. Example: Message 3.1.4 follows Message 
3.1.3 within activation 3.1. The name  represents a concurrent thread of control. Messages that differ in the final name are 
concurrent at that level of nesting. Example: Message 3.1a and Message 3.1b are concurrent within activation 3.1. All threads of control are equal within the nesting depth.
The recurrence represents conditional or iterative execution. This represents zero or more Messages that are executed 
depending on the conditions involved. The choices are:
‘*’ ‘[’ iteration-clause ‘]’an iteration
‘[’ guard ‘]’a branchFigure 348 - Communication diagram sd M
:r s[k]:B
s[u]:B1a:m1
2:m2 1b:m3
1b.1:m3 1b.1.1:m3,
1b.1.1.1:m2Lifeline
Message
with
Sequencenumber
Messages
UML Superstructure 2.0 Draft Adopted Specification        447An iteration represents a sequence of Messages at the given nesting depth. The iteration clause may be omitted (in which 
case the iteration conditions are unspecified). The iteration-clause is meant to be expressed in pseudocode or an actual 
programming language, UML does not prescribe its format. An example would be: *[i := 1..n] .
A guard represents a Message whose execution is contingent on the truth of the condition clause. The guard is meant to 
be expressed in pseudocode or an actual programming language; UML does not prescribe its format. An example would 
be: [x > y] .
Note that a branch is notated the same as an iteration without a star. One might think of it as an iteration restricted to a 
single occurrence.
The iteration notation assumes that the Messages in the iteration will be executed sequentially. There is also the 
possibility of executing them concurrently. The notation for this is to follow the star by a double vertical line (for 
parallelism): *||.
Note that in a nested control structure, the recurrence is not repeated at inner levels. Each level of structure specifies its 
own iteration within the enclosing context.
Interaction Overview Diagrams
Interaction Overview Diagrams define Interactions (described in Chapter 14, “Interactions”) through a variant of Activity Diagrams (described in Chapter 6, “Activities”) in a way that promotes overview of the control flow.
Interaction Overview Diagrams focus on the overview of the flow of control where the nodes are Interactions or 
InteractionOccurrences. The Lifelines and the Messages do not appear at this overview level.
Graphic Nodes
Interaction Overview Diagrams are specialization of Activity Diagrams that represent Interactions
Interaction Overview Diagrams differ from Activity Diagrams in some respects.
1. In place of ObjectNodes of Activity Diagrams, Interaction Overview Diagrams can only have either (inline) Interac-
tions or InteractionOccurrences. Inline Interaction diagrams and InteractionOccurrences are considered special forms of ActivityInvocations.
2. Alternative Combined Fragments are represented by a Decision Node and a corresponding Merge Node.
3. Parallel Combined Fragments are represented by a Fork Node and a corresponding Join Node.
4. Loop Combined Fragments are represented by simple cycles.
5. Branching and joining of branches must in Interaction Overview Diagrams be properly nested. This is more restric-
tive than in Activity Diagrams.
6. Interaction Overview Diagrams are framed by the same kind of frame that encloses other forms of Interaction Dia-
grams. The heading text may also include a list of the contained Lifelines (that do not appear graphically)
448                 UML Superstructure 2.0 Draft Adopted Specification.
Table 18 - Graphic nodes included in Interaction Overview Diagrams in addition to those borrowed from Activity 
Diagrams
NODE TYPE NOTATION REFERENCE
Frame The notation shows a rectangular frame around the 
diagram with a name in a compartment in the upper left corner. See “Interaction (from Basi-cInteraction, Fragments)” on page 419.
Interaction An Interaction diagram of any kind may appear 
inline as an ActivityInvocation. See “Interaction (from BasicInteraction, Fragments)” on page 419. The inline Interaction diagrams may be either anonymous (as here) or named.
InteractionOccurrence ActivityInvocation in the form of InteractionOc-
currence. See “InteractionOccurrence (from Frag-ments)” on page 423. The tools may choose to “explode” the view of an InteractionOccurrence into an inline Interaction with the name of the Interaction referred by the occurrence. The inline Interaction will then replace the occurrence by a replica of the definition Interaction where eventual arguments have replaced parameters.sd EventOccurrence
sdUser AC System
CardOut
Nref
UML Superstructure 2.0 Draft Adopted Specification        449Examples
Figure 349 Interaction Overview Diagram representing a High Level Interaction diagramsd OverviewDiagram lifelines :User, :ACSystem
refEstablishAccess("Illegal PIN")
sd
:User :ACSystem
CardOut
sd
:User :ACSystem
Msg("Please Enter")
refOpenDoor[pin ok]{0..25}
{1..14}InteractionOccurrence
(inline) Interaction
decision
interaction constraintDuration Constraint
450                 UML Superstructure 2.0 Draft Adopted SpecificationInteraction Overview Diagrams use Activity diagram notation where the nodes are either Interactions or 
InteractionOccurrences. Interaction Overview Diagrams are a way to describe Interactions where Messages and Lifelines 
are abstracted away. In the purest form all Activities are InteractionOccurrences and then there are no Messages or Lifelines shown in the diagram at all.
The Figure 349 is another way to describe the behavior shown in Figure 338, with some added timing constraints. The 
Interaction EstablishAccess  occurs first (with argument “Illegal PIN”) followed by weak sequencing with the message 
CardOut  which is shown in an inline Interaction. Then there is an alternative as we find a decision node with an 
InteractionConstraint on one of the branches. Along that control flow we find another inline Interaction and an 
InteractionOccurrence in (weak) sequence.
Timing Diagram
Timing Diagrams are used to show interactions when a primary purpose of the diagram is to reason about time. Timing 
diagrams focus on conditions changing within and among Lifelines along a linear time axis. 
Timing diagrams describe behavior of both individual classifiers and interactions of classifiers, focusing attention on time 
of occurrence of events causing changes in the modeled conditions of the Lifelines. 
Graphic Nodes
The graphic nodes that can be included in structural diagrams are shown in Table 14 on page 436.
Table 19 - Graphic nodes and paths included in sequence diagrams
NODE TYPE NOTATION REFERENCE
Frame The notation shows a rectangular frame around the 
diagram with a name in a compartment in the upper left corner. See “Interaction (from BasicInteraction, Fragments)” on page 419.
Message Messages come in different variants depending on 
what kind of Message they convey. Here we show an asynchronous message, a call and a reply. See “Mes-sage (from BasicInteractions)” on page 428.sd EventOccurrence
VSense
doIt(w:int)
evAcquire(
void): long
UML Superstructure 2.0 Draft Adopted Specification        451Message label Labels are only notational shorthands used to prevent 
cluttering of the diagrams with a number of mes-sages crisscrossing the diagram between Lifelines that are far apart.The labels denote that a Message may be disrupted by introducing labels with the same name.
State or condition 
timelineThis is the state of the classifier or attribute, or some 
testable condition, such as an discrete enumerable value. See also “StateInvariant (from BasicInterac-tions)” on page 433.It is also permissable to let the state-dimension be continuous as well as discrete. This is illustrative for scenarios where certain entities undergo continuous state changes, such as temperature or density.
General value 
lifelineShows the value of the connectable element as a 
function of time. Value is explicitly denoted as text. Crossing reflects the event where the value changed.
Lifeline See “Lifeline (from BasicInteractions, Fragments)” 
on page 427
GeneralOrdering See “GeneralOrdering (from BasicInteractions)” on 
page 418Table 19 - Graphic nodes and paths included in sequence diagrams
NODE TYPE NOTATION REFERENCE
mymsglabmymsglab
Initializing
Acquiring
Reporting
Idle
x"00 x"FFFF"
instance 1
Instance 2
452                 UML Superstructure 2.0 Draft Adopted SpecificationExamples
Timing diagrams show change in state or other condition of a structural element over time. There are a few forms in use. 
We shall give examples of the simplest forms.
Sequence Diagrams as the primary form of Interactions may also depict time observation and timing constraints. We show 
in Figure 347 an example in Sequence Diagram that we will also give in Timing Diagrams.
The :User of the Sequence Diagram in Figure 347 is depicted with a simple Timing Diagram in Figure 350.Stop See “Stop (from BasicInteractions)” on page 434
Figure 350 - A Lifeline for a discrete objectTable 19 - Graphic nodes and paths included in sequence diagrams
NODE TYPE NOTATION REFERENCE
sd UserAcc_User
IdleWaitCardWaitAccess
CodeCardOut
OK {t..t+3}{d..3*d}:User
012 t
event or stimulustick mark valuesState or condition Lifeline
timing rulertime constraint
 DurationConstraint
UML Superstructure 2.0 Draft Adopted Specification        453The primary purpose of the timing diagram is to show the change in state or condition of a lifeline (representing a 
Classifier Instance or Classifier Role) over linear time. The most common usage is to show the change in state of an 
object over time in response to accepted events or stimuli. The received events are annotated as shown when it is desireable to show the event causing the change in condition or state.
Sometimes it is more economical and compact to show the state or condition on the vertical Lifeline as shown in Figure 
351.
Finally we may have an elaborate form of TimingDiagrams where more than one Lifeline is shown and where the messages are also depicted. We show such a Timing Diagram in Figure 352 corresponding to the Sequence Diagram in 
Figure 347.Figure 351 - Compact Lifeline with Statessd UserAcc_User
Idle WaitCard WaitAccess Idle{d..3*d}
:UserState or condition Lifeline DurationConstraint
454                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from UML 1.x
The Timing Diagrams were not available in UML 1.4.Figure 352 - Timing Diagram with more than one Lifeline and with Messagessd UserAccepted
IdleWaitCardWaitAccess
{t..t+3}{d..3*d}:User
012 tHasCardNoCard:ACSystemCodeCardOut
{0..13}
OK
Unlock
dt=nowState or condition Lifelines
Duration ObservationDuration Constraints
Time ObservationTime Constraint
Message
UML Superstructure 2.0 Draft Adopted Specification        45515 State Machines
15.1 Overview
The StateMachine package defines a set of concepts that can be used for modeling discrete behavior through finite state-
transition systems. In addition to expressing the behavior of a part of the system, state machines can also be used to express the usage protocol of part of a system. These two kinds of state machines are referred here as behavioral state 
machines  and protocol state machines . 
Behavioral state machines
State machines can be used to specify behavior of various model elements. For example, they can be used to model the 
behavior of individual entities (e.g., class instances). The state machine formalism described in this section is an object-based variant of Harel statecharts.
Protocol State machines
Protocol state machines are used to express usage protocols. Protocol state machines express the legal transitions that a classifier can trigger. The state machine notation is a convenient way to define a lifecycle for objects, or an order of the 
invocation of its operation. Because protocol state machines do not preclude any specific behavioral implementation, and 
inforces legal usage scenarios of classifiers, interfaces and ports can be associated to this kind of state machines.
456                 UML Superstructure 2.0 Draft Adopted Specification15.2 Abstract Syntax
Figure 353 - Package DependenciesBehaviorStateMachines
ProtocolStateMachines MaximumOneRegion<<merge>>Kernel
(f rom  Cl asses)Bas icBehaviors
(from CommonBehavi o...)
Interfaces
(f ro m Cl asses)Ports
(from Compos iteStruc ...)
<<merge>>
<<merge>><<merge>>
UML Superstructure 2.0 Draft Adopted Specification        457Package BehaviorStatemachines
Figure 354 - State MachinesPseudostateKind
init ial
de epH is to ry
shallowHis tory
joinfo rkjunction
ch oice
en t ry P oin t
ex it Poi nt
te rmina te<<enumeration>>
Behav ior
(from BasicBehaviors)
Fi n a l S ta teNa me d E l e me n t
(from  Kernel)Na me d E l e me n t
(fr om Ke rnel)
Pseudostate
kind : PseudostateKind
ConnectionPointRef erence*
0..1+entry*
0..1*
0..1+exit*
0..1StateMachine
*0..1
+connectionPoint
*{subsets ownedMember}0..1
State
/ isComposite : Boolean = f alse
/ isOrthogonal : Boolean = f alse/ isSimple : Boolean = f alse/ isSubmachineState : Boolean = f alse
0. .1
*0. .1
+connection*
{subsets ownedElement}*0..1
+submachineState*+submachine0..1
VertexRegion
*0..1 +subv ertex
*{subsets ownedElement}+container
0..1{redef ines owner}1. .*0..1
+region
1. .* {subsets ownedMember}0..1
*
0..1+region *
0..1
Tr igge r
(fr om  Communicat ions)**
+def errableTrigger **
Constraint
(from  Kernel)0..10..1
+stateInvariant0..1{subsets ownedElement}0..1Activ ity
(from BasicBehaviors)
0..10..1+doActiv ity
0..1{s ubs ets ownedElement}
0..10..10..1+exit
0..1{subsets ownedElement}
0..10..10..1+entry
0..1{subsets ownedElement}
0..1Transition
kind : TransitionKind 1 *+source
1+outgoing
*
1 *+target
1+incoming
**0..1+transitions
*{subsets ownedElement}+container
0..1{redef ines owner}
*
0..**
+trigger 0..*
0..10..1
+guard
0..1{subsets ownedElement}0..1
0..10..1
+ e ffe ct
0..1{subsets ownedElement}0..1TransitionKind
int ernal
loc al
ex ternal<<enumeration>>
458                 UML Superstructure 2.0 Draft Adopted SpecificationPackage Redefinitions
Package ProtocolStatemachinesFigure 355 - State Machine Redefinitions
Figure 356 - Protocol state machinesRedefinableElem ent
(from  Kernel)
Region
0..10..1
0..1+extendedRegion
0..1{redef ines redef inedElement}
State0..1
0..1+redef inedState
0..1{redef ines redef inedElement}
0..1
Transition0..1
0..1+redefi ned Trans itio n
0..1{redef ines redef inedElement}
0..1Classifier
(from  Kernel) 1*+/redef initionContext
1{subsets redef initionContext}
*
*
1*+/redef initionContext
1{su bsets redefin itio nCo ntext}
*1*+/redef initionContext
1{s ub s et s re def i ni t ion C on t ex t }
StateMachine
0..1 0..1 0..1
+extendedStateMachine0..1
{redef ines redef inedElement}BehavioredClassifier
*0..1
+ownedStateMachine
*{redef ines ownedBehav ior}0..1 {subsets redef initionContext}
Port
InterfaceProtocolConformance ProtocolStateM achine0..1*
+protocol0..1*
0..10..1
+protocol0..1
{subsets feature, 
subsets ownedM ember}+interface0..1
{subsets namespace}1 *
+generalMachine1
{subsets target}**
1+conformance*{subsets ownedElement}+specificM achine
1{subsets source, subsets owner}DirectedRelationship
(from Kernel)StateM achine
(f rom Behav iorStateMachines )
UML Superstructure 2.0 Draft Adopted Specification        459Package MaximumOneRegion
15.3 Class Descriptions
15.3.1 ConnectionPointReference (from BehaviorStatemachines)
A connection point reference represents a usage (as part of a submachine state) of an entry/exit point defined in the 
statemachine reference by the submachine state.
Description
Connection point references of a submachine state can be used as sources/targets of transitions. They represent entries into or exits out of the submachine state machine referenced by the submachine state.
Attributes
No additional attributes.Figure 357 - Constraints
Figure 358 - Statemachines and States with maximum one regionOperation ProtocolTransition* *
+/referred**
StateConstraint
(f rom Kernel)0..1
0..1+postCondition0..1
{subsets ownedElement}0..10..10..1+preCondition
0..1{subsets guard}0..1
0..1
0..1+stateInvariant 0..1
{subsets ownedEl ement}
0..1Transi ti on
(f rom Behav iorStateMachines)
StateMachineRegion
(from BehaviorStateMachines )
1 0..1+region
1{redefines region}
0..1State
0..1 0..1+region
0..1{redefines region}
0..1
460                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 entry: Pseudostate[1..*] The entryPoint kind pseudo states corresponding to this connection point.
 exit: Pseudostate[1..*] The exitPoints kind pseudo states corresponding to this connection point.
Constraints
[1]  The entry Pseudostates must be Pseudostates with kind entryPoint.
entry->notEmpty() implies  entry.kind = #entryPoint
[2] The exit Pseudostates must be Pseudostates with kind exitPoint
exit->notEmpty() implies  exit.kind = #exitPoint
Semantics
Connection point references are sources/targets of transitions implying exits out of/entries into the submachine state 
machine referenced by a submachine state.
An entry point connection point reference as the target of a transition implies that the target of the transition is the entry 
point pseudostate as defined in the submachine of the submachine state. As a result, the regions of the submachine state 
machine are entered at the corresponding entry point pseudo states.
An exit point connection point reference as the source of a transition implies that the source of the transition is the exit 
point pseudostate as defined in the submachine of the submachine state that has the exit point connection point defined. 
When a region of the submachine state machine has reached the corresponding exit points, the submachine state exits at 
this exit point.
Notation
A connection point reference to an entry point has the same notation as an entry point pseudostate. The circle is placed on the border of the state symbol of a submachine state.
Figure 359 - Entry PointReadAmount :
ReadAmountSM
againReadAmount :
ReadAmountSM
again
UML Superstructure 2.0 Draft Adopted Specification        461A connection point reference to an entry point can also be visualized using a rectangular symbol as shown in Figure 362. 
The text inside the symbol shall contain the keyword ‘via’ followed by the name of the connection point. This notation 
may only be used if the transition ending with the connection point is defined using the transition-oriented control icon notation as defined in “Transition (from BehaviorStatemachines)” on page 498.
Figure 360 - Alternative Entry Point notation
A connection point reference to an exit point has the same notation as an exit point pseudostate. The encircled cross is 
placed on the border of the state symbol of a submachine state.
A connection point reference to an exit point can also be visualized using a rectangular symbol as shown in Figure 362. 
The text inside the symbol shall contain the keyword ‘via’ followed by the name of the connection point. This notation may only be used if the transition associated with the connection point is defined using the transition-oriented control icon 
notation as defined in “Transition (from BehaviorStatemachines)” on page 498.
Figure 362 - Alternative Exit Point notation
15.3.2 Interface (from ProtocolStatemachines, as specialized)
Interface is defined as a specialization of the general Interface, adding an association to a protocol state machine.Figure 361 - Exit PointReadAmount:
ReadAmountSMvia aborted 
ReadAmount :
ReadAmountSMabortedabortedReadAmount :
ReadAmountSMabortedaborted
ReadAmount:
ReadAmountSM
via aborted 
462                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
Since an interface specifies conformance characteristics, it does not own detailed behavior specifications. Instead, 
interfaces may own a protocol state machine that specifies event sequences and pre/post conditions for the operations and 
receptions described by the interface.
Attributes
No additional attributes.
Associations
 protocol: ProtocolStateMachine [0..1]
References a protocol state machine specifying the legal sequences of the invocation of 
the behavioral features described in the interface. 
Semantics
Interfaces can specify behavioral constraints on the features using a protocol state machine. A classifier realizing an 
interface must comply with the protocol state machine owned by the interface.
Changes from UML 1.x
Interfaces can own a protocol state machine.
15.3.3 FinalState (from BehaviorStatemachines)
A special kind of state signifying that the enclosing region is completed. If the enclosing region is directly contained in a 
state machine and all other regions in the state machine also are completed, then it means that the entire state machine is 
completed.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
[1]  A final state cannot have any outgoing transitions
self.outgoing->size() = 0
[2] A final state cannot have regions
[3] A final state cannot reference a submachine[4] A final state has no entry activity
[5] A final state has no exit activity
[6] A final state has no state (doActivity) activity
UML Superstructure 2.0 Draft Adopted Specification        463Semantics
When the final state is entered, its containing region is completed, which means that it satisfies the completion condition. 
The containing state for this region is considered completed when all contained regions are completed. If the region is 
contained in a state machine and all other regions in the state machine also are completed, the entire state machine 
terminates, implying the termination of the context object of the state machine.
Notation
A final state is shown as a circle surrounding a small solid filled circle (see Figure 363). The corresponding completion transition on the enclosing state has as notation an unlabeled transition. 
Example
Figure 384 has an example of a final state (the rightmost of the states within the composite state).
15.3.4 Port ( (from ProtocolStatemachines, as specialized)
Port is defined as a specialization of the general Port, adding an association to a protocol state machine.
Attributes
No additional attributes.
Associations
 protocol: ProtocolStateMachine [0..1]
References an optional protocol state machine which describes valid interactions at this interaction point.
Semantics
The protocol references a protocol state machine (see “ProtocolStateMachine (from ProtocolStatemachines)” on page 464) 
that describes valid sequences of operation and reception invocations that may occur at this port.
15.3.5 ProtocolConformance (from ProtocolStatemachines)
Description
Protocol state machines can be redefined into more specific protocol state machines, or into behavioral state machines. 
Protocol conformance declares that the specific protocol state machine specifies a protocol that conforms to the general 
state machine one, or that the specific behavioral state machine abide by the protocol of the general protocol state machine.
A protocol state machine is owned by a classifier. The classifiers owning a general state machine and an associated 
specific state machine are generally also connected by a generalization or a realization link.Figure 363 - Final State 
464                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
No additional attributes.
Associations
 specificMachine: StateMachine [1] : 
Specifies the state machine which conforms to the general state machine.
 generalMachine: ProtocolStateMachine [1] : 
Specifies the protocol state machine to which the specific state machine conforms.
Constraints
No additional constraints
Semantics
Protocol conformance means that every rule and constraint specified for the general protocol state machine (state 
invariants, pre and post conditions for the operations referred by the protocol state machine) apply to the specific protocol 
or behavioral state machine.
In most cases, there are relationships between the classifier being the context of the specific state machine and the 
classifier being the context of the general protocol state machine. Generally, the former specializes or realizes the later. It  
is also possible that the specific state machine is a behavioral state machine that implements the general protocol state 
machine, both state machines having the same class as a context.
15.3.6 ProtocolStateMachine (from ProtocolStatemachines)
Description
A protocol state machine  is always defined in the context of a classifier. It specifies which operations of the classifier can 
be called in which state and under which condition, thus specifying the allowed call sequences on the classifier's 
operations. A protocol state machine presents the possible and permitted transitions on the instances of its context classifier, together with the operations which carry the transitions. In this manner, an instance lifecycle can be created for 
a classifier, by specifying the order in which the operations can be activated and the states through which an instance 
progresses during its existence.
Attributes
No additional attributes.
Associations
 conformance: ProtocolConformance[*] : Conformance between protocol state machines.
Constraints
[1]  A protocol state machine must only have a classifier context, not a behavioral feature context
[2] All transitions of a protocol state machine must be protocol transitions. (transitions as extended by the ProtocolStateMa-
chines package)
[3] If two ports are connected, then the protocol state machine of the required interface (if defined) must be conformant to the
protocol state machine of the provided interface (if defined).
UML Superstructure 2.0 Draft Adopted Specification        465Semantics
Protocol state machines help defining the usage mode of the operations and receptions of a classifier by specifying:
 ·in which context (under which states and pre conditions) they can be used
 ·if there is a protocol order between them ·what result is expected from their use
Using pre and post conditions on operations is a technique well suited for expressing such specifications. However, pre 
and post conditions are expressed at the operation level, and therefore do not provide a synthetic overview at the classifier 
level. Protocol state machines provide a global overview of the classifier protocol usage, in a simple formal 
representation. Protocol state machines may not express all the pre- and postconditions of operations. In that case, 
additional pre- or postconditions can be added at the operation level. Formally, the pre condition of an operation will be the addition (logical "and") of the constraint defined as pre condition of the operation, if any, to the constraint deduced 
from the protocol state machine if any. The same applies to the post condition of an operation.
The protocol state machine defines all allowed transitions for each operation. The protocol state machine must represent 
all operations that can generate a given change of state for a class. Those operations that do not generate a transition are not represented in the protocol state machine.
Protocol state machines constitute a means to formalize the interface of classes, and do not express anything except 
consistency rules for the implementation or dynamics of classes. 
Protocol state machine interpretation can vary from:
1. Declarative protocol state machines that specify the legal transitions for each operation. The exact triggering condi-
tion for the operations is not specified. This specification only defines the contract for the user of the context classi-fier.
2. Executable protocol state machines, that specify all events that an object may receive and handle, together with the 
transitions that are implied. In this case, the legal transitions for operations will exactly be the triggered transitions. 
The call trigger specifies the effect action, which is the call of the associated operation.
The representation for both interpretations is the same, the only difference being the direct dynamic implication that the interpretation 2 provides.
Elaborated forms of state machine modeling such as compound transitions, sub-statemeachines, composite states and 
concurrent regions can also be used for protocol state machines. For example, concurrent regions make it possible to 
express protocol where an instance can have several active states simultaneously. Sub-state machines and compound transitions are used as in behavioral state machines for factorizing complex protocol state machines.
A classifier may have several protocol state machines. This happens frequently, for example, when a class inherits several 
parent classes having protocol state machine, when the protocols are orthogonal. An alternative to multiple protocol state 
machines can always be found by having one protocol state machine, with sub-state machines in concurrent regions.
466                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
The notation for protocol state machine is very similar to the one of behavioral state machines. The keyword {protocol} 
placed close to the name of the state machine differentiates graphicaly protocol state machine diagrams. 
15.3.7 ProtocolTransition (from ProtocolStateMachines)
Description
A protocol transition (transition as specialized in the ProtocolStateMachines package) specifies a legal transition for an 
operation. Transitions of protocol state machines have the following information: a pre condition (guard), on trigger, and 
a post condition. Every protocol transition is associated to zero or one operation (referred BehavioralFeature) that belongs to the context classifier of the protocol state machine. 
The protocol transition specifies that the associated (referred) operation can be called for an instance in the origin state 
under the initial condition (guard), and that at the end of the transition, the destination state will be reached under the fin al 
condition (post).
Attributes
No additional attributes.
Associations
 \referred: Operation[0..*] This association refers to the associated operation. It is derived from the operation of the 
call trigger when applicable.
 postCondition: Constraint[0..1] Specifies the post condition of the transition which is the condition that should be 
obtained once the transition is triggered. This post condition is part of the post condition of the operation connected to the transition.
 preCondition: Constraint[0..1] Specifies the precondition of the transition. It specifies the condition that should be veri-
fied before triggering the transition. This guard condition added to the source state will be evaluated as part of the precondition of the operation refered by the transition if any. Figure 364 - Protocol state machineopened closed[doorWay -> isEmpty] Close/
lockedlock/
unlock/open/create/Door {protocol}
opened closed[doorWay -> isEmpty] Close/
lockedlock/
unlock/open/create/Door {protocol}
UML Superstructure 2.0 Draft Adopted Specification        467Constraints
[1]  A protocol transition always belongs to a protocol state machine.
container.belongsToPSM()
[2] A protocol transition never has associated actions.
effect->isEmpty()
[3] If a protocol transition refers to an operation (i. e. has a call trigger corresponding to an operation), then that operatio n
should apply to the context classifier of the state machine of the protocol transition.
Additional Operations
[1]  The operation belongsToPSM () checks if the region belongs to a protocol state machine
context  Region::belongsToPSM () : Boolean 
result = if not stateMachine->isEmpty() then  
oclIsTypeOf(ProtocolStateMachine)
else if not state->isEmpty() then  
state.container.belongsToPSM ()
else false
Semantics
No "effect" action
The effect action is never specified. It is implicit, when the transition has a call trigger: the effect action will be the 
operation specified by the call trigger. It is unspecified in the other cases, where the transition only defines that a given 
event can be received under a specific state and pre-condition, and that a transition will lead to another state under a 
specific post condition, whatever action will be made through this transition. 
Unexpected event reception
The interpretation of the reception of an event in an unexpected situation (current state, state invariant, and pre-condition) 
is a semantic variation point: the event can be ignored, rejected or deferred, an exception can be raised, or the application 
can stop on an error. It corresponds semantically to a pre-condition violation, for which no predefined behavior is defined 
in UML.
Unexpected behavior
The interpretation of an unexpected behavior, that is an unexpected result of a transition (wrong final state or final state 
invariant, or post condition) is also a semantic variation point. However, this should be interpreted as an error of the 
implementation of the protocol state machine.
Equivalences to pre and post conditions of operations
The protocol transition can always be translated into pre and post conditions of the associated operation. 
For example, the transition in Figure 365 specifies that:
1. the operation "m1" can be called on an instance when it is in the state S1 under the condition C1, 
2. when m1 is called in the state S1 under the condition C1, then the final state S2 must be reached under the condition 
C2.
This can be translated into the following pre and post conditions of the operation m1 (Figure 365).
468                 UML Superstructure 2.0 Draft Adopted SpecificationOperation m1()
Pre: S1 is in the configuration state and C1 Post: if the initial condition was “S1 is in the configuration state and C1” then S2 is in the configuration state and C2.
Operations referred by several transitions
In a protocol state machine, several transitions can refer to the same operation as illustrated below. In that case, all pre 
conditions and post conditions will be combined in the operation pre condition as below:Figure 365 - Example of a protocol transition associated to the "m1" operation
Figure 366 - Example of several transitions referring to the same operationS1 S2[C1]m1/[C2]
S1 S2[C1]m1/[C2]
S1 S2[C1]m1/[C2]
S3 S4[C3]m1/[C4]S1 S2[C1]m1/[C2]
S3 S4[C3]m1/[C4]
Operation m1()
Pre: S1 is in the configuration state and C1 
        or        S3 is in the configuration state and C3
Post: if the initial condition was “S1 is in the configuration state and C1” 
then S2 is in the configuration state and C2
         else
if the initial condition was “S3 is in the configuration state and C3” then S4 is in the configuration state and C4
UML Superstructure 2.0 Draft Adopted Specification        469A protocol state machine specifies all the legal transitions for each operation refered by its transitions. This means that for  
any operation refered by a protocol state machine, the part of its precondition relative to legal initial or final state is 
completely specified by the protocol stat machine. 
Unreferred Operations 
If an operation is not referred by any transition of a protocol state machine, then the operation can be called for any state 
of the protocol state machine, and does not change the current state.
Using events in protocol state machines
Apart from the operation call event, events are generally used for expressing a dynamic behavior interpretation of 
protocol state machines. An event which is not a call event can be specified on protocol transitions. 
In this case, this specification is a requirement to the environment external to the state machine : it is legal to send this 
event to an instance of the context classifier only under the conditions specified by the protocol state machine. 
Just like call event, this can also be interpreted in a dynamic way, as a semantic variation point. 
Notation
The usual state machine notation applies. The difference is that no actions are specified for protocol transitions, and that 
post conditions can exist. Post conditions have the same syntax as guard conditions, but appear at the end of the transition 
syntax.
15.3.8 PseudoState (from BehaviorStatemachines)
A pseudostate is an abstraction that encompasses different types of transient vertices in the state machine graph. 
Description
Pseudostate are typically used to connect multiple transitions into more complex state transitions paths. For example, by 
combining a transition entering a fork pseudostate with a set of transitions exiting the fork pseudostate, we get a 
compound transition that leads to a set of orthogonal target states.
Attributes
 kind: PseudoStateKind Determines the precise type of the PseudoState and can be one of: entryPoint, exitPoint, 
initial, deepHistory, shallowHistory, join, fork, junction, terminate or choice .
Associations
No additional associations.
Constraints
An initial vertex can have at most one outgoing transition.Figure 367 - Protocol transition notation[precondition] event / [post condition][precondition] event / [post condition]
470                 UML Superstructure 2.0 Draft Adopted Specification(self.kind = #initial) implies  
((self.outgoing->size <= 1)
[2] History vertices can have at most one outgoing transition.
((self.kind = #deepHistory) or (self.kind = #shallowHistory)) implies
(self.outgoing->size <= 1)
[3] In a complete statemachine, a join vertex must have at least two incoming transitions and exactly one outgoing transition.
(self.kind = #join) implies  
((self.outgoing->size = 1) and (self.incoming->size >= 2))
[4] All transitions incoming a join vertex must originate in different regions of an orthogonal state.
(self.kind = #join 
and not oclIsKindOf(self.stateMachine, ActivityGraph))
implies  
self.incoming->forAll (t1, t2 | t1<>t2 implies  
(self.stateMachine.LCA(t1.source, t2.source).
container.isOrthogonal) 
[5] In a complete statemachine, afork vertex must have at least two outgoing transitions and exactly one incoming transition.
(self.kind = #fork) implies 
((self.incoming->size = 1) and (self.outgoing->size >= 2))
[6] All transitions outgoing a fork vertex must target states in different regions of an orthogonal state.
(self.kind = #fork 
and not oclIsKindOf(self.stateMachine, ActivityGraph)) implies  
self.outgoing->forAll (t1, t2 | t1<>t2 implies  
(self.stateMachine.LCA(t1.target, t2.target).
container.isOrthogonal) 
[7] In a complete statemachine, ajunction vertex must have at least one incoming and one outgoing transition.
(self.kind = #junction) implies 
((self.incoming->size >= 1) and (self.outgoing->size >= 1))
[8] In a complete statemachine, a choice vertex must have at least one incoming and one outgoing transition.
(self.kind = #choice) implies 
((self.incoming->size >= 1) and (self.outgoing->size >= 1))
[9] Pseudostates of kind entryPoint can only be defined in the topmost regions of a StateMachine.
(kind = #entryPoint) implies  (owner.oclIsKindOf(Region) and owner.owner.oclIsKindOf(StateMachine))
[10] Pseudostates of kind exitPoint can only be defined in the topmost regions of a StateMachine.
(kind = #exitPoint) implies  (owner.oclIsKindOf(Region) and owner.owner.oclIsKindOf(StateMachine))
Semantics
The specific semantics of a Pseudostate depends on the setting of its kind attribute.
 An initial  pseudostate represents a default vertex that is the source for a single transition to the default  state of a com-
posite state. There can be at most one initial vertex in a region. The in itial transition may have an action.
 deepHistory  represents the most recent active configuration of the composite state that directly contains this pseu-
dostate; e.g. the state configuration that was active when the composite state was last exited. A composite state can have at most one deep history vertex. At most one transition may originate from the history connector to the default 
deep history state. This transition is taken in case the composite state had never been active before. Entry actions of states entered on the path to the state represented by a deep history are performed.
 shallowHistory  represents the most recent active substate of its containing state (but not the substates of that substate). 
A composite state can have at most one shallow history vertex. A transition coming into the shallow history vertex is equivalent to a transition coming into the most recent active substate of a state. At most one transition may originate 
UML Superstructure 2.0 Draft Adopted Specification        471from the history connector to the deafault shallow history state. This transition is taken in case the composite state had 
never been active before. Entry actions of states entered on the path to the state represented by a shallow history are performed.
 join vertices serve to merge several transitions emanating from source vertices in different orthogonal regions. The 
transitions entering a join vertex cannot have guards or triggers.
 fork vertices serve to split an incoming transition into two or more transitions terminating on orthogonal target vertices 
(i.e. vertices in different regions of a composite state). The segments outgoing from a fork vertex must not have guards or triggers.
 junction  vertices are semantic-free vertices that are used to chain together multiple transitions. They are used to con-
struct compound transition paths between states. For example, a junction can be used to converge multiple incoming 
transitions into a single outgoing transition representing a shared transition path (this is known as an merge ). Con-
versely, they can be used to split an incoming transition into multiple outgoing transition segments with different guard conditions. This realizes a static  conditional branch . (In the latter case, outgoing transitions whose guard conditions 
evaluate to false are disabled. A predefined guard denoted “else” may be defined for at most one outgoing transition. This transition is enabled if all the guards labeling the other transitions are false.) Static conditional branches are dis-tinct from dynamic conditional branches that are realized by choice vertices (described below).
 choice  vertices which, when reached, result in the dynamic evaluation of the guards of the triggers of its outgoing tran-
sitions. This realizes a dynamic conditional branch . It allows splitting of transitions into multiple outgoing paths such 
that the decision on which path to take may be a function of the results of prior actions performed in the same run-to-completion step. If more than one of the guards evaluates to true, an arbitrary one is selected. If none of the guards evaluates to true, then the model is considered ill-formed. (To avoid this, it is recommended to define one outgoing transition with the predefined “else” guard for every choice vertex.) Choice vertices should be distinguished from static branch points that are based on junction points (described above).
 An entry point  pseudostate is an entry point of a state machine. In each region of the state machine it has a single tran-
sition to a vertex within the same region.
 An exit point  pseudostate is an exit point of a state machine. Entering an exit point within any region of the state 
machine referenced by a submachine state implies the exit of this submachine state and the triggering of the transition that has this exit point as source in the state machine enclosing the submachinestate.
 Entering a terminate  pseudostate implies that the execution of this state machine by means of its context object is ter-
minated.
Notation
An initial pseudostate is shown as a small solid filled circle (see Figure 368). In a region of a classifierBehavior state 
machine, the transition from an initial pseudostate may be labeled with the trigger event that creates the object; otherwise, it must be unlabeled. If it is unlabeled, it represents any transition from the enclosing state.
A shallowHistory is indicated by a small circle containing an ‘H’ (see Figure 369). It applies to the state region that 
directly encloses it.Figure 368 - Initial Pseudo State
472                 UML Superstructure 2.0 Draft Adopted SpecificationA deepHistory is indicated by a small circle containing an ‘H*’ (see Figure 370). It applies to the state region that directly 
encloses it.
An entry point is shown as a small circle on the border of the state machine diagram, with the name associated with it (see Figure 371).
Optionally it may be placed both the within state machine diagram and outside the border of the state machine diagram.
An exit point is shown as a small circle with a cross on the border of the state machine diagram, with the name associated 
with it (see Figure 372). 
Optionally it may be placed both within the state machine diagram and outside the border of the state machine diagram.Figure 369 - Shallow History
Figure 370 - Deep History
Figure 371 - Entry point
Figure 372 - Exit pointH
H*
againagain
abortedabortedabortedaborted
UML Superstructure 2.0 Draft Adopted Specification        473A junction is represented by a small black circle (see Figure 373).
A choice pseudostate is shown as a diamond-shaped symbol as exemplified by Figure 374.
Figure 374 - Choice Pseudo State
A terminate pseudostate is shown as a cross, see Figure 375.Figure 373 - Junction
Figure 375 - Terminate node[a < 0]State1
State2 State3 State4e1[b < 0] e2[b < 0]State0
[a = 5][a > 7]
[Id>10]
[Id<=10][>10]
[<=10]Id
474                 UML Superstructure 2.0 Draft Adopted SpecificationThe notation for a fork and join is a short heavy bar (Figure 376). The bar may have one or more arrows from source 
states to the bar (when representing a joint) The bar may have one or more arrows from the bar to states (when 
representing a fork). A transition string may be shown near the bar. 
Presentation Options
If all guards associated with triggers of transitions leaving a choice PseudoState are binary expressions that share a common left operand, then the notation for choice PseudoState may be simplified. The left operand may be placed inside 
the diamond-shaped symbol and the rest of the Guard expressions placed on the outgoing transitions. This is exemplified 
in Figure 377.
Figure 377 - Alternative Notation for Choice Pseudostate
Multiple trigger-free and effect-free transitions originating on a set of states and targeting a junction vertex with a single outgoing transition may be presented as a state symbol with a list of the state names and an outgoing transition symbol corresponding to the outgoing transition from the junction. 
The special case of the transition from the junction having a history as target may optionally be presented as the target 
being the state list state symbol. See Figure 378 and Figure 379 for examples.Figure 376 - Fork and Join
Figure 378 - State List OptionProcess
Setup CleanupA1 A2
B2 B1
[>10]
[<=10]Id[Id>10]
[Id<=10]
s1, s2
s3e
f
UML Superstructure 2.0 Draft Adopted Specification        475Changes from previous UML
  Entry and exit point and terminate Pseudostates have been introduced.
  The semantics of deepHistory has been aligned with shallowHistory in that the containing state does not have to be 
exited in order for deepHistory to be defined. The implication of this is that deepHistory (as is the case for shallowHis-tory) can be the target of transitions also within the containing state and not only from states outside.
  The state list presentation option is an extension to UML1.x.
15.3.9 PseudoStateKind (from BehaviorStatemachines)
PseudoStateKind is an enumeration type.
Description
PseudoStateKind is an enumeration of the following literal values:
 initial  
 deepHistory  
 shallowHistory  
 join 
 fork 
 junction
 choice  
 entryPoint
 exitPoint
 terminate
Attributes
No additional attributes.
Associations
No additional associations.Figure 379 - State ListsVerifyCard, 
ReleaseCardVerifyCard, 
VerifyTransactionlogCardlogVerify
476                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from previous UML
EntryPoint, exitPoint, and terminate has been added.
15.3.10 Region (from BehaviorStatemachines)
A region is an orthogonal part of either a composite state or a state machine. It contains states and transitions.
Attributes
No additional attributes.
Associations
 transition:Transition[*] The set of transitions owned by the region. Note that internal transitions are owned by a 
region, but applies to the source state. 
 subvertex: Vertex[*] The set of vertices that are owned by this region.  extendedRegion: Region[0..1] The region of which this region is an extension. /redefinitionContext: Classifier[1]References the classifier in which context this element may be redefined. 
Constraints
[1]  A region can have at most one initial vertex
self.subvertex->select (v | v.oclIsKindOf(Pseudostate))->
select(p : Pseudostate | p.kind = #initial)->size() <= 1
[2] A region can have at most one deep history vertex
self.subvertex->select (v | v.oclIsKindOf(Pseudostate))->
select(p : Pseudostate | p.kind = #deepHistory)->size() <= 1
[3] A region can have at most one shallow history vertex
self.subvertex->select(v | v.oclIsKindOf(Pseudostate))->
select(p : Pseudostate | p.kind = #shallowHistory)->size() <= 1
[4] The redefinition context of a region is the nearest containing statemachine
redefinitionContext = 
let sm = containingStateMachine() in
if sm.context->isEmpty() or sm.general->notEmpty() then
sm
else
sm.context
endif
Additional constraints
[1]  The query isRedefinitionContextValid() specifies whether the redefinition contexts of a region are properly related to the  
redefinition contexts of the specified region to allow this element to redefine the other. The containing statemachine/state of a redefining region must redefine the containing statemachine/state of the redefined region.
[2] ‘The query isConsistentWith() specifies that a redefining region is consistent with a redefined region provided that the
redefining region is an extension of the redefined region, i.e. it adds vertices and transitions and it redefines states andtransitions of the redefined region.
UML Superstructure 2.0 Draft Adopted Specification        477Semantics
The semantics of regions is tightly coupled with states or state machines having regions, and it is therefore defined as part 
of the semantics for state and state machine.
When a composite state or state machine is extended, each inherited region may be extended, and regions may be added.
Notation
A composite state or state machine with regions is shown by tiling the graph region of the state/state machine using 
dashed lines to divide it into regions. Each region may have an optional name and contains the nested disjoint states and 
the transitions between these. The text compartments of the entire state are separated from the orthogonal regions by a 
solid line. 
A composite state or state machine with just one region is shown by showing a nested state diagram within the graph 
region.
In order to indicate that an inherited region is extended, the keyword «extended» is associated with the name of the 
region. 
15.3.11 State (from BehaviorStatemachines)
A state models a situation during which some (usually implicit) invariant condition holds.
Description
State in Behavioral State machines
A state models a situation during which some (usually implicit) invariant condition holds. The invariant may represent a 
static situation such as an object waiting for some external event to occur. However, it can also model dynamic conditions 
such as the process of performing some activity (i.e., the model element under consideration enters the state when the 
activity commences and leaves it as soon as the activity is completed).
The following kinds of states are distinguished: 
 Simple state, 
 composite state, and 
 submachine state.Figure 380 - Notation for composite state/state machine with regionsS 
478                 UML Superstructure 2.0 Draft Adopted SpecificationA composite state is either a simple composite state (with just one region) or an orthogonal state (with more than one 
region).
Simple state
A simple state is a state that does not have substates, i.e. it has no regions and it has no submachine state machine.
Composite state
A composite state either contains one region or is decomposed into two or more orthogonal regions . Each region has a set 
of mutually exclusive disjoint subvertices and a set of transitions. A given state may only be decomposed in one of these two ways. 
Any state enclosed within a region of a composite state is called a substate  of that composite state. It is called a direct  
substate  when it is not contained by any other state; otherwise it is referred to as a indirect substate .
Each region of a composite state may have an initial pseudostate and a final state. A transition to the enclosing state 
represents a transition to the initial pseudostate in each region. A newly-created object takes it’s topmost default 
transitions, originating from the topmost initial pseudostates of each region. 
A transition to a final state represents the completion of activity in the enclosing region. Completion of activity in all 
orthogonal regions represents completion of activity by the enclosing state and triggers a completion event on the enclosing state. Completion of the topmost regions of an object corresponds to its termination.
Submachine state
A submachine state specifies the insertion of the specification of a submachine state machine. The state machine that 
contains the submachine state is called the containing  state machine. The same state machine may be a submachine more 
than once in the context of a single containing state machine.
A submachine state is semantically equivalent to a composite state. The regions of the submachine state machine are the 
regions of the composite state. The entry, exit and activity actions, and internal transitions, are defined as part of the stat e. 
Submachine state is a decomposition mechanism that allows factoring of common behaviors and their reuse.
Transitions in the containing state machine can have entry/exit points of the inserted state machine as targets/sources.
State in Protocol State machines
The states of protocol state machines are exposed to the users of their context classifiers. A protocol state represents an 
exposed stable situation of its context classifier: when an instance of the classifier is not processing any operation, users of this instance can always know its state configuration.
Attributes
 /isComposite A state with isComposite=true is said to be a composite state . A composite state is a state 
that contains at least one region.
 /isOrthogonal: Boolean A state with isOrthogonal=true is said to be an orthogonal  composite state . An orthogonal 
composite state contains two or more regions. 
 /isSimple A state with isSimple=true is said to be a  simple state . A simple state does not have any 
regions and it does not refer to any submachine state machine.
 /isSubmachineState A state with isSubmachineState=true is said to be a submachine state . Such a state refers 
to a state machine (submachine).
UML Superstructure 2.0 Draft Adopted Specification        479Associations
BehaviorStateMachines
 connection: ConnectionPointReference The entry and exit connection points used in conjunction with this (submachine) 
state, i.e. as targets and sources, respectively, in the region with the submachine state. A connection point reference references the corresponding definition of a connection point pseudostate in the statemachine referenced by the submachinestate.
 deferrableTrigger: Trigger A list of triggers that are candidates to be retained by the state machine if they trigger no 
transitions out of the state (not consumed). A deferred trigger is retained until the state machine reaches a state configuration where it is no longer deferred.
 doActivity: Activity[0..1] An optional activity that is executed while being in the state. The execution starts when 
this state is entered, and stops either by itself, or when the state is exited, whichever comes first.
 entry: Activity[0..1] An optional activity that is executed whenever this state is entered regardless of the transi-
tion taken to reach the state. If defined, entry actions are always executed to completion prior to any internal activity or transitions performed within the state.
 exit: Activity[0..1] An optional activity that is executed whenever this state is exited regardless of which tran-
sition was taken out of the state. If defined, exit actions are always executed to completion only after all internal activities and transition actions have completed execution.
 redefinedState: State[0..1] The state of which this state is a redefinition. region: Region[*] The regions of the state. submachine: StateMachine[0..1]The state machine that is to be inserted in place of the (submachine) state. stateInvariant: Constraint [0..1]Specifies conditions that are always true when this state is the current state. In protocol 
state machines, state invariants are additional conditions to the preconditions of the outgo-ing transitions, and to the postcondition of the incoming transitions.
 /redefinitionContext: Classifier[1]References the classifier in which context this element may be redefined. 
MaximumOneRegion
 region: Region[0..1] A state with none or just one region.
Constraints
[1]  There have to be at least two regions in an orthogonal composite state
(self.isOrthogonal) implies  
(self.region->size >= 2)
[2] Only submachine states can have connection point references.
[3] The connection point references used as destinations/sources of transitions associated with a submachine state must be
defined as entry/exit points in the submachine state machine.
[4] A state is not allowed to have both a submachine and regions.
not ( self.isSubmachineState and self.isComposite )
[5] A simple state is a state without any regions.
isSimple = content.isEmpty()
[6] Acomposite state is a state with at least one region.
isComposite = content.notEmpty()
480                 UML Superstructure 2.0 Draft Adopted Specification[7] An orthogonal state is a composite state with at least 2 regions
isOrthogonal = (context.size() >= 2)
[8] Only submachine states can have a reference statemachine.
isSubmachineState = submachine.notEmpty()
[9] A Protocol state (state belonging to a protocol state machine) has no entry or exit or do activity actions.
entry->isEmpty() and
exit->isEmpty() and
doActivity->isEmpty()
[10] Protocol states cannot be deep or shallow history pseudo states.
if oclIsTypeOf(Pseudostate) then  (kind <> #deepHistory) and (kind <> #shallowHistory)
[11] The redefinition context of a state is the nearest containing statemachine
redefinitionContext = 
let sm = containingStateMachine() in
if sm.context->isEmpty() or sm.general->notEmpty() then
sm
else
sm.context
endif
Additional constraints
[1]  The query isRedefinitionContextValid() specifies whether the redefinition contexts of a state are properly related to the 
redefinition contexts of the specified state to allow this element to redefine the other. The containing region of a redefin-ing state must redefine the containing region of the redefined state.
[2] The query isConsistentWith() specifies that a redefining state is consistent with a redefined state provided that the rede-
fining state is an extension of the redefined state: A simple state can be redefined (extended) to become a composite state(by adding a region) and a composite state can be redefined (extended) by adding regions and by adding vertices, states,entry/exit/do activities (if the general state has none), and transitions to inherited regions.
Semantics
States in general
The following applies to states in general. Special semantics applies to composite states and submachine states.
Active states
A state can be active or inactive during execution. A state becomes active  when it is entered as a result of some transition, and 
becomes inactive  if it is exited as a result of a transition. A state can be exited and entered as a result of the same transition 
(e.g., self transition).
State entry and exit
Whenever a state is entered, it executes its entry activity before  any other action is executed. Conversely, whenever a state is 
exited, it executes its exit activity as the final step prior to leaving the state. 
Activity in state (do-activity)
UML Superstructure 2.0 Draft Adopted Specification        481The activity represents the execution of a activity, that occurs while the state machine is in the corresponding state. The 
activity starts executing upon entering the state, following the entry activity. If the activity completes while the state is 
still active, it raises a completion event. In case where there is an outgoing completion transition (see below) the state will  
be exited. Upon exit, the activity is terminated before the exit activity is executed. If the state is exited as a result of th e 
firing of an outgoing transition before the completion of the activity, the activity is aborted prior to its completion.
Deferred events
A state may specify a set of event types that may be deferred  in that state. An event that does not trigger any transitions 
in the current state, will not be dispatched if its type matches one of the types in the deferred event set of that state. 
Instead, it remains in the event pool while another non-deferred event is dispatched instead. This situation persists until a 
state is reached where either the event is no longer deferred or where the event triggers a transition. 
State redefinition
A state may be redefined, provided that the value of isFinal is False. A simple state can be redefined (extended) to become a composite state (by adding a region) and a composite state can be redefined (extended) by adding regions and by adding vertices, states, entry/exit/do activities (if the general state has none), and transitions to inherited regions. The  
redefinition of a state applies to the whole state machine, e.g. if a state list as part of the extended state machine includes  
a state that is redefined, then the state list for the extension state machine includes the redefined state.
Composite state
Active state configurations
In a hierarchical state machine more than one state can be active at the same time. If the state machine is in a simple state 
that is contained in a composite state, then all the composite states that either directly or transitively contain the simple 
state are also active. Furthermore, since the state machine as a whole and some of the composite states in this hierarchy may be orthogonal (i.e. containing regions), the current active “state” is actually represented by a set of trees of states 
starting with the top-most states of the root regions down to individual simple states at the leaves. We refer to such a state 
tree as a state configuration . 
Except during transition execution, the following invariants always apply to state configurations:
 If a composite state is active and not orthogonal, exactly one of its substates is active.
 If the composite state is active and orthogonal, all of its regions are active, one substate in each region.
Entering a non-orthogonal composite state
Upon entering a composite state, the following cases are differentiated:
  Default entry:  Graphically, this is indicated by an incoming transition that terminates on the outside edge of the com-
posite state. In this case, the default transition is taken. If there is a guard on the trigger of the transition it must be enabled (true). (A disabled initial transition is an ill-defined execution state and its handling is not defined.) The entry activity of the composite state is executed before the activity associated with the initial transition.
  Explicit entry:  If the transition goes to a substate of the composite state, then that substate becomes active and its entry 
code is executed after the execution of the entry code of the composite state. This rule applies recursively if the transi-tion terminates on a transitively nested substate.
  Shallow history entry:  If the transition terminates on a shallow history pseudostate, the active substate becomes the 
most recently active substate prior to this entry, unless the most recently active substate is the final state or if this is th e 
first entry into this state. In the latter two cases, the default history state  is entered. This is the substate that is target of 
the transition originating from the history pseudostate. (If no such transition is specified, the situation is il defined and 
482                 UML Superstructure 2.0 Draft Adopted Specificationits handling is not defined.) If the active substate determined by history is a composite state, then it proceeds with its 
default entry.
  Deep history entry:  The rule here is the same as for shallow history except that the rule is applied recursively to all lev-
els in the active state configuration below this one.
Entering an orthogonal composite state
Whenever an orthogonal composite state is entered, each one of its orthogonal regions is also entered, either by default or 
explicitly. If the transition terminates on the edge of the composite state, then all the regions are entered using default 
entry. If the transition explicitly enters one or more regions (in case of a fork), these regions are entered explicitly and th e 
others by default.
Exiting non-orthogonal state
When exiting from a composite state, the active substate is exited recursively. This means that the exit activities are executed in sequence starting with the innermost active state in the current state configuration.
Exiting an orthogonal state
When exiting from an orthogonal state, each of its regions is exited. After that, the exit activities of the state is executed.  
Deferred events
Composite states introduce potential event deferral conflicts. Each of the substates may defer or consume an event, 
potentially conflicting with the composite state, e.g. a substate defers an event while the composite state consumes it, or vice versa. In case of a composite orthogonal state, substates of orthogonal regions may also introduce deferral conflicts. 
The conflict resolution follows the triggering priorities, where nested states override enclosing states. In case of a conflict  
between states in different orthogonal regions, a consumer state overrides a deferring state.
Submachine state
A submachine state is semantically equivalent to the composite state defined by the referenced state machine. Entering 
and leaving this composite state is, in contrast to an ordinary composite state, via entry and exit points.
A submachine composite state machine can be entered via its default (initial) pseudostate or via any of its entry points, 
i.e. it may imply entering a non-orthogonal or an orthogonal composite state with regions. Entering via the initial 
pseudostate has the same meaning as for ordinary composite states. An entry point is equivalent with a junction pseudostate (fork in case the composite state is orthogonal): Entering via an entry point implies that the entry activity of 
the composite state is executed, followed by the (partial) transition(s) from the entry point to the target state(s) within the  
composite state. As for default initial transitions, guards associated with the triggers of these entry point transitions must evaluate to true in order for the specification not to be ill-formed.
Similarly, it can be exited as a result of reaching its final state, by a “group” transition that applies to all substates in t he 
submachine state composite state, or via any of its exit points. Exiting via a final state or by a group transition has the 
same meaning as for ordinary composite states. An exit point is equivalent with a junction pseudostate (join in case the composite state is orthogonal): Exiting via an exit point implies that first activity/activities of the transition(s) with the 
exit point as target is executed, followed exit activity of the composite state.
Notation
States in general
A state is in general shown as a rectangle with rounded corners, with the state name shown inside the rectangle.
UML Superstructure 2.0 Draft Adopted Specification        483Optionally, it may have an attached name tab, see Figure 382. The name tab is a rectangle, usually resting on the outside 
of the top side of a state and it contains the name of that state. It is normally used to keep the name of a composite state that has orthogonal regions, but may be used in other cases as well. The state in Figure 376 on page 474 illustrates the use 
of the name tab.
A state may be subdivided into multiple compartments separated from each other by a horizontal line, see Figure 383. 
The compartments of a state are:
 name compartment
 internal activities compartment
 internal transitions compartment
A composite state has in addition a 
 decomposition compartment
Each of these compartments is described below.Figure 381 - State
Figure 382 - State with name tab
Figure 383 - State with compartmentsTy ping 
Pas sw or d
Typing Password
Typing Password
entry / set echo invisible
exit / set echo normal
character / handle character
help / display help
484                 UML Superstructure 2.0 Draft Adopted Specification Name compartment
This compartment holds the (optional) name of the state, as a string. States without names are anonymous and are all 
distinct. It is undesirable to show the same named state twice in the same diagram, as confusion may ensue, unless control 
icons (page 502) are used to show a transition oriented view of the state machine. Name compartments should not be used 
if a name tab is used and vice versa.
In case of a submachine state, the name of the referenced state machine is shown as a string following ‘:’ after the name 
of the state.
 Internal activities compartment
This compartment holds a list of internal activities or state (do) activities that are performed while the element is in the 
state. 
The activity label identifies the circumstances under which the activity specified by the activity expression will be 
invoked. The activity expression may use any attributes and association ends that are in the scope of the owning entity. For list items where the activity expression is empty, the backslash separator is optional.
A number of activity labels are reserved for various special purposes and, therefore, cannot be used as event names. The 
following are the reserved activity labels and their meaning:
 entry
This label identifies an activity, specified by the corresponding activity expression, which is performed upon entry to the state (entry activity)
 exit
This label identifies an activity, specified by the corresponding activity expression, that is performed upon exit from the state (exit activity)
 do
This label identifies an ongoing activity (“do activity”) that is performed as long as the modeled element is in the state or until the computation specified by the activity expression is completed (the latter may result in a completion event being 
generated).
 Internal transition compartment
This compartment contains a list of internal transitions, where each item has the form as described for Trigger.
Each event name may appear more than once per state if the guard conditions are different. The event parameters and the 
guard conditions are optional. If the event has parameters, they can be used in the activity expression through the current 
event variable. 
Composite state
 decomposition compartment
This compartment shows its composition structure in terms of regions, states and transition. In addition to the (optional) 
name and internal transition compartments, the state may have an additional compartment that contains a nested diagram. 
For convenience and appearance, the text compartments may be shrunk horizontally within the graphic region. 
In some cases, it is convenient to hide the decomposition of a composite state. For example, there may be a large number 
of states nested inside a composite state and they may simply not  fit in the graphical space available for the diagram. In 
that case, the composite state may be represented by a simple state graphic with a special “composite” icon, usually in the 
UML Superstructure 2.0 Draft Adopted Specification        485lower right-hand corner (see Figure 385). This icon, consisting of two horizontally placed and connected states, is an 
optional  visual cue that the state has a decomposition that is not shown in this particular statechart diagram. Instead, the 
contents of the composite state are shown in a separate diagram. Note that the “hiding” here is purely a matter of graphical convenience and has no semantic significance in terms of access restrictions.
Examples
Figure 384 - Composite state with two statesStart
entry/ start dial tonePartial Dial
entry/number.append(n)digit(n)
digit(n)[number.isValid()]Dialing
exit/ stop dial tone
486                 UML Superstructure 2.0 Draft Adopted SpecificationSubmachine state
The submachine state is depicted as a normal state where the string in the name compartment has the following syntax
<state name> ‘:’ <name of referenced state machine>The submachine state symbol may contain the references to one or more entry points and to one or more exit points. The 
notation for these connection point references are entry/exit point pseudostates on the border of the submashine state. The names are the names of the corresponding entry/exit points defined  within the referenced state machine. See 
(“ConnectionPointReference (from BehaviorStatemachines)” on page 459).Figure 385 - Composite State with hidden decomposition indicator icon
Figure 386 - Orthogonal state with regionsentry / start dial tone
exit / stop dial toneHiddenComposite
entry / start dial tone
exit / stop dial toneHiddenComposite
CourseAttempt
FailedLab1 Lab2
Term Project
Final Testproject donelab done lab done
pass
failStudying
PassedCourseAttempt
FailedLab1 Lab2
Term Project
Final Testproject donelab done lab done
pass
failfailStudying
Passed
UML Superstructure 2.0 Draft Adopted Specification        487If the substate machine is entered through its default initial pseudostate or if it is exited as a result of the completion of 
the submachine, it is not necessary to use the entry/exit point notation. Similarly, an exit point is not required if the exit 
occurs through an explicit “group” transition that emanates from the boundary of the submachine state (implying that it applies to all the substates of the submachine).
Submachine states invoking the same submachine may occur multiple times in the same state diagram with the entry and 
exit points being part of different transitions.
Examples
The diagram in Figure 387 shows a fragment from a statechart diagram in which a sub state machine (the 
FailureSubmachine) is referenced. The actual sub state machine is defined in some enclosing or imported name space.
In the above example, the transition triggered by event “error1” will terminate on entry point “sub1” of the 
FailureSubmachine state machine. The “error3” transition implies taking of the default transition of the FailureSubmachine.
The transition emanating from the “subEnd” exit point of the submachine will execute the “fixed1” activity in addition to 
what is executed within the HandleFailure state machine. This transition must have been triggered within the 
HandleFailure state machine. Finally, the transition emanating from the edge of the submachine state is taken as a result of the completion event generated when the FailureSubmachine reaches its final state.Figure 387 - Submachine StateHandleFailure:
sub1
subEnderror1/
error3/
/fixed1FailureSubmachine
488                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 388 is an example of a state machine defined with two exit points. The entry and exit points may also be shown 
on the frame or outside the frame (but still associated with it), and not only within the state graph.
Figure 388 - State machine with exit point as part of the state graph
Figure 389 - State machine with exit point on the border of the statemachineReadAmountSM
selectAmount
enterAmount
okabortotherAmount
amountabort
abortedselectAmount
enterAmount
okabortotherAmount
amountabort
abortedReadAmountSM
selectAmount
enterAmount
okabortotherAmount
amountabort
abortedselectAmount
enterAmount
okabortotherAmount
amountabort
abortedselectAmount
enterAmount
okabortotherAmount
amountabort
abortedselectAmount
enterAmount
okabortotherAmount
amountabort
aborted
ReadAmountSM
selectAmount
enterAmount
okabortotherAmount
amountabort
selectAmount
okotherAmount
amountabort
abortedReadAmountSM
selectAmount
enterAmount
okabortotherAmount
amountabort
selectAmount
okotherAmount
amountabort
abortedselectAmount
enterAmount
okabortotherAmount
amountabort
selectAmount
okotherAmount
amountabort
aborted
UML Superstructure 2.0 Draft Adopted Specification        489In Figure 390 this state machine is referenced in a submachine state, and the presentation option with the exit points on 
the state symbol is shown.
Notation for protocol state machines
The two differences that exist for state in protocol state machine, versus states in behavioral state machine, are as follow: 
Several features in behavioral state machine do not exist for protocol state machines (entry, exit, do); States in protocol 
state machines can have an invariant. The textual expression of the invariant will be represented by placing it after or under the name of the state, surrounded by square braquets.
Figure 391 - State with invariant - notation
Rationale
Submachine states with usages of entry and exit points defined in the corresponding state machine has been introduced in order for state machines with submachines to scale and in order to provide encapsulation.
15.3.12 StateMachine (from BehaviorStatemachines)
State machines can be used to express the behavior of part of a system. Behavior is modeled as a traversal of a graph of 
state nodes interconnected by one or more joined transition arcs that are triggered by the dispatching of series of events. 
During this traversal, the state machine executes a series of activities associated with various elements of the state machine.Figure 390 - SubmachineState with usage of exit pointVerifyCard
acceptCard
ReleaseCard VerifyTransactionOutOfService
outOfServiceVerifyCard
acceptCard
ReleaseCard VerifyTransactionreleaseCardOutOfService
outOfServiceReadAmount :
ReadAmountSM abortedabortedATM
VerifyCard
acceptCard
ReleaseCard VerifyTransactionOutOfService
outOfServiceVerifyCard
acceptCard
ReleaseCard VerifyTransactionreleaseCardOutOfService
outOfServiceReadAmount :
ReadAmountSM abortedabortedReadAmount :
ReadAmountSM abortedabortedATM
Ty ping 
Pas sw or d
[invariant expr]
490                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
A state machine owns one or more regions, which in turn own vertices and transitions.
The behaviored classifier context owning a state machine defines which signal and call triggers are defined for the state 
machine, and which attributes and operations are available in activities of the state machine. Signal triggers and call 
triggers for the state machine are defined according to the receptions and operations of this classifier. 
As a kind of behavior, a state machine may have an associated behavioral feature (specification) and be the method of this 
behavioral feature. In this case the state machine specifies the behavior of this behavioral feature. The parameters of the state machine in this case match the parameters of the behavioral feature and provide the means for accessing (within the 
state machine) the behavioral feature parameters. 
A state machine without a context classifier may use triggers that are independent of receptions or operations of a 
classifier, i.e. either just signal triggers or call triggers based upon operation template parameters of the (parameterized) 
statemachine.
Attributes
No additional attributes.
Associations
BehaviorStateMachines
 region: Region[1..*] The regions of the state machine. connectionPoint: Pseudostate[*]The connection points defined for this state machine. They represent the interface of the 
state machine when used as part of submachine state.
 extendedStateMachine: StateMachine[*]The state machines of which this is an extension. /redefinitionContext: Classifier[1]References the classifier in which context this element may be redefined. 
MaximumOneRegion
 region: Region[1] A statemachine with just one region.
Constraints
[1]  The classifier context of a state machine cannot be an interface
[2] The context classifier of the method state machine of a behavioral feature must be the classifier that owns the behavioral
feature.
[3] The connection points of a state machine are pseudostates of kind entry point or exit point.
[4] A state machine as the method for a behavioral feature cannot have entry/exit connection points.[5] The redefinition context of a state is the nearest containing statemachine or context classifier
redefinitionContext = 
let sm = containingStateMachine() in
if sm.context->isEmpty() or sm.general->notEmpty() then
sm
else
sm.context
endif
UML Superstructure 2.0 Draft Adopted Specification        491Additional Operations
[1]  The operation LCA(s1,s2) returns the state which is the least common ancestor of states s1 and s2. 
context  StateMachine::LCA (s1 : State, s2 : State) : 
CompositeState 
result = if ancestor (s1, s2) then  
s1 
else if ancestor (s2, s1) then  
s2 
else (LCA (s1.container, s2.container)) 
[2] The query ancestor(s1, s2) checks whether s2 is an ancestor state of state s1.
context  StateMachine::ancestor (s1 : State, s2 : State) : Boolean 
result = if (s2 = s1) then  
true 
else if (s1.container->isEmpty) then  
true 
else if (s2.container->isEmpty) then  
false 
else (ancestor (s1, s2.container) 
[3] The query containingStateMachine() yields the statemachine owning a given element, either directly as for regions or
indirectly as for states and transitions.
[4] The query isRedefinitionContextValid() specifies whether the redefinition contexts of a statmachine are properly related
to the redefinition contexts of the specified statemachine to allow this element to redefine the other. The containing clasi-fier of a redefining statemachine must redefine the containing classifier of the redefined statemachine.
[5] The query isConsistentWith() specifies that a redefining state machine is consistent with a redefined state machine pro-
vided that the redefining state machine is an extension of the redefined state machine: Regions are inherited and regionscan be added, inherited regions can be redefined. In case of multiple redefining state machines, extension implies that theredefining state machine gets orthogonal regions for each of the redefined state machines.
Semantics
The event pool for the state machine is the event pool of the instance according to the behaviored context classifier, or the 
classifier owning the behavioral feature for which the state machine is a method.
Event processing - run-to-completion step
Events are dispatched and processed by the state machine, one at a time. The order of dequeuing is not defined, leaving 
open the possibility of modeling different priority-based schemes. 
The semantics of event processing is based on the run-to-completion assumption, interpreted as run-to-completion 
processing. Run-to-completion processing means that an event can only be taken from the pool and dispatched if the processing of the previous current event is fully completed. 
Run-to-completion may be implemented in various ways. For active classes, it may be realized by an event-loop running 
in its own thread, and that reads events from a pool. For passive classes it may be implemented as a monitor.
The processing of a single event by a state machine is known as a run-to-completion step . Before commencing on a run-
to-completion step, a state machine is in a stable state configuration with all entry/exit/internal activities (but not necessarily state (do) activities) completed. The same conditions apply after the run-to-completion step is completed. 
Thus, an event will never be processed while the state machine is in some intermediate and inconsistent situation. The 
run-to-completion step is the passage between two state configurations of the state machine.
492                 UML Superstructure 2.0 Draft Adopted SpecificationThe run-to-completion assumption simplifies the transition function of the state machine, since concurrency conflicts are 
avoided during the processing of event, allowing the state machine to safely complete its run-to-completion step. 
When an event is dispatched, it may result in one or more transitions being enabled for firing. If no transition is enabled 
and the event is not in the deferred event list of the current state configuration, the event is discarded and the run-to-completion step is completed. 
In the presence of orthogonal regions it is possible to fire multiple transitions as a result of the same event — as many as 
one transition in each region in the current state configuration. In case where one or more transitions are enabled, the state 
machine selects a subset and fires them. Which of the enabled transitions actually fire is determined by the transition selection algorithm described below. The order in which selected transitions fire is not defined.
Each orthogonal region in the active state configuration that is not decomposed into orthogonal regions (i.e., “bottom-
level” region) can fire at most one transition as a result of the current event. When all orthogonal regions have finished executing the transition, the current event is fully consumed, and the run-to-completion step is completed.
During a transition, a number of actions may be executed. If such an action is a synchronous operation invocation on an 
object executing a state machine, then the transition step is not completed until the invoked object complete its run-to-
completion step. 
Run-to-completion and concurrency
It is possible to define state machine semantics by allowing the run-to-completion steps to be applied orthogonally to the 
orthogonal regions of a composite state, rather than to the whole state machine. This would allow the event serialization 
constraint to be relaxed. However, such semantics are quite subtle and difficult to implement. Therefore, the dynamic 
semantics defined in this document are based on the premise that a single run-to-completion step applies to the entire state machine and includes the steps taken by orthogonal regions in the active state configuration.
In case of active objects, where each object has its own thread of execution, it is very important to clearly distinguish the 
notion of run to completion from the concept of thread pre-emption. Namely, run-to-completion event handling is 
performed by a thread that, in principle, can be pre-empted and its execution suspended in favor of another thread 
executing on the same processing node. (This is determined by the scheduling policy of the underlying thread 
environment — no assumptions are made about this policy.) When the suspended thread is assigned processor time again, 
it resumes its event processing from the point of pre-emption and, eventually, completes its event processing.
Conflicting transitions
It was already noted that it is possible for more than one transition to be enabled within a state machine. If that happens, 
then such transitions may be in conflict  with each other. For example, consider the case of two transitions originating 
from the same state, triggered by the same event, but with different guards. If that event occurs and both guard conditions 
are true, then only one transition will fire. In other words, in case of conflicting transitions, only one of them will fire in  
a single run-to-completion step.
Two transitions are said to conflict if they both exit the same state, or, more precisely, that the intersection of the set of 
states they exit is non-empty. Only transitions that occur in mutually orthogonal regions may be fired simultaneously. This 
constraint guarantees that the new active state configuration resulting from executing the set of transitions is well formed.
An internal transition in a state conflicts only with transitions that cause an exit from that state.
UML Superstructure 2.0 Draft Adopted Specification        493Firing priorities
In situations where there are conflicting transitions, the selection of which transitions will fire is based in part on an 
implicit  priority. These priorities resolve some transition conflicts, but not all of them. The priorities of conflicting 
transitions are based on their relative position in the state hierarchy. By definition, a transition originating from a substat e 
has higher priority than a conflicting transition originating from any of its containing states.
The priority of a transition is defined based on its source state. The priority of joined transitions is based on the priority 
of the transition with the most transitively nested source state.
In general, if t1 is a transition whose source state is s1, and t2 has source s2, then:
 If s1 is a direct or transitively nested substate of s2, then t1 has higher priority than t2.
 If s1 and s2 are not in the same state configuration, then there is no priority difference between t1 and t2.
Transition selection algorithm
The set of transitions that will fire is a maximal set of transitions that satisfies the following conditions:
  All transitions in the set are enabled.
  There are no conflicting transitions within the set.
  There is no transition outside the set that has higher priority than a transition in the set (that is, enabled transitions wit h 
highest priorities are in the set while conflicting transitions with lower priorities are left out). 
This can be easily implemented by a greedy selection algorithm, with a straightforward traversal of the active state 
configuration. States in the active state configuration are traversed starting with the innermost nested simple states and 
working outwards. For each state at a given level, all originating transitions are evaluated to determine if they are 
enabled. This traversal guarantees that the priority principle is not violated. The only non-trivial issue is resolving transition conflicts across orthogonal states on all levels. This is resolved by terminating the search in each orthogonal 
state once a transition inside any one of its components is fired.
StateMachine extension 
A state machine is generalizable. A specialised state machine is an extension of the general state machine, in that regions, 
vertices and transitions may be added, regions and states may be redefined (extended: simple states to composite states and composite states by adding states and transitions), and transitions can be redefined.
As part of a classifier generalization, the classifierBehavior state machine of the general classifier and the method state 
machines of behavioral features of the general classifier can be redefined (by other state machines). These state machines 
may be specializations (extensions) of the corresponding state machines of the general classifier or of its behavioral features. 
A specialised state machine will have all the elements of the general state machine, and it may have additional elements. 
Regions may be added. Inherited regions may be redefined by extension: States and vertices are inherited, and states and 
transitions of the regions of the state machine may be redefined.
A simple state can be redefined (extended) to a composite state, by adding one or more regions. A composite state can be redefined (extended) by either extending inherited regions or by adding regions. A region is 
extended by adding vertices, states and transitions and by redefining states and transitions. 
494                 UML Superstructure 2.0 Draft Adopted SpecificationA submachine state may be redefined. The submachine state machine may be replaced by another submachine state 
machine, provided that it has the same entry/exit points as the redefined submachine state machine, but it may add entry/
exit points.
Transitions can have their content and target state replaced, while the source state and trigger is preserved. In case of multiple general classifiers, extension implies that the extension state machine gets orthogonal regions for each 
of the state machines of the general classifiers in addition to the one of the specific classifier.
Notation
A statechart diagram is a graph that represents a state machine. States and various other types of vertices (pseudostates) 
in the state machine graph are rendered by appropriate state and pseudostate symbols, while transitions are generally 
rendered by directed arcs that connect them or by control icons representing the actions of the activity on the transition (page 502).
The association between a state machine and its context classifier or behavioral feature does not have a special notation.A state machine that is an extension of the state machine in a general classifier will have the keyword «extended» 
associated with the name of the state machine.
The default notation for classifier is used for denoting state machines. The keyword is «statemachine».Inherited states are drawn with dashed lines or 
Presentation option
Inherited states are drawn with gray-toned lines.
UML Superstructure 2.0 Draft Adopted Specification        495Examples
Figure 392 is an example statemachine diagram for the state machine for simple telephone object. In addition to the initial 
state, the state machine has an entry point called activeEntry, and in addition to the final state, it has an exit point called  
aborted.Figure 392 - State machine diagram representing a state machineDialTone
Dialing
TalkingRingingBusydial digit(n)
connected
callee answersIdle
busylift
receiver
callerhangs upcallee
hangs upActive
dial digit(n)
/get dial tone
do/ play busy
tone
do/ play ringing
tone /enable speech/disconnectdo/ play dial tone
Pinned
callee
answersConnectingdial digit(n)[valid]Time-out
do/ play message
dial digit(n)[invalid]
/connect Invalid
do/ play message[incomplete] after (15 sec.)
after (15 sec.)activeEntry
abortedabort terminate
496                 UML Superstructure 2.0 Draft Adopted SpecificationAs an example of state machine specialization, the states VerifyCard, OutOfService and VerifyTransaction in the ATM 
state machine in Figure 393 have been specified as {final}, which means that they can not redefined (i.e. extended) in 
specializations of ATM. The other states can be redefined. The (verifyTransaction,releaseCard) transition has also been specified as {final}, meaning that the effect activity and the target state cannot be redefined.
In Figure 394 a specialized ATM (which is the statemachine of a class that is a specialization of the class with the ATM 
statemachine of Figure 393) is defined by extending the composite state by adding a state and a transition, so that users can enter the desired amount. In addition a transition is added from an inherited state to the newly introduced state.Figure 393 - A general state machineVerifyCard
OutOfServiceReadAmount
selectAmountacceptCard
ReleaseCardVerifyTransactionselectAmount
amountoutOfService
releaseCard{final}
{final}
{final}{final}ATM
VerifyCard
OutOfServiceReadAmount
selectAmountacceptCard
ReleaseCardVerifyTransactionselectAmount
amountoutOfService
releaseCard{final}
{final}
{final}{final}VerifyCard
OutOfServiceReadAmount
selectAmountacceptCard
ReleaseCardReleaseCardVerifyTransactionselectAmount
amountoutOfService
releaseCard{final}
{final}
{final}{final}ATM
UML Superstructure 2.0 Draft Adopted Specification        497Rationale
The rationale for statemachie extension is that it shall be possible to define the redefined behavior of a special classifier 
as an extension of the behavior of the general classifier.
Changes from previous UML
  The association ownedStateMachine is introduced in order for StateMachines to have locally defined StateMachines 
that can be referenced from SubmachineStates.
  State machine extension is an extension of 1.x.
Rationale
State machines are used for the definition of behavior for e.g. classes that are generalizable. As part of the specialization 
of a class it is desirable also the specialize the behavior definition.
Changes from previous UML
This is an extension to 1.x. In 1.x state machine generalization is only described through a note.Figure 394 - An extended state machineReadAmount
Sel ectAmount
Ent erAmountSel ectAmount
VerifyTransactionEnt erAmount
okotherAmount
rejectTransaction{extended}ATM {extended}
ReadAmount
Sel ectAmount
Ent erAmountSel ectAmount
VerifyTransactionEnt erAmount
okotherAmount
rejectTransaction{extended}ATM {extended}
498                 UML Superstructure 2.0 Draft Adopted Specification15.3.13 TimeTrigger ( from BehaviorStatemachines, as specialized)
Description
Extends time triggers to be defined relative to entering the current state of the executing state machine. 
Constraints
[1]  The starting time for a relative time event may only be omitted for a time event that is the trigger of a state machine.
Semantics
If the deadline expression is relative and no explicit starting time is defined, then it is relative to the time of entry into the 
source state of the transition triggered by the event. In that case, the time event occurrence is generated only if the state machine is still in that state when the deadline expires.
Notation
If no starting point is indicated, then it is the time since the entry to the current state. 
15.3.14 Transition (from BehaviorStatemachines)
A transition is a directed relationship between a source vertex and a target vertex. It may be part of a compound 
transition, which takes the state machine from one state configuration to another, representing the complete response of 
the state machine to a particular event. 
Attributes
 kind: TransitionKind See definition of TransitionKind.
Associations
 trigger: Trigger[0..*] Specifies the triggers that may fire the transition.
 guard: Constraint[0..1] A guard is a constraint that provides a fine-grained control over the firing of the transition. 
The guard is evaluated when an event is dispatched by the state machine. If the guard is true at that time, the transition may be enabled, otherwise, it is disabled. Guards should be pure expressions without side effects. Guard expressions with side effects are ill formed.
 effect: Activity[0..1] Specifies an optional activity to be performed when the transition fires.  source: Vertex[1] Designates the originating vertex (state or pseudostate) of the transition. target: Vertex[1] Designates the target vertex that is reached when the transition is taken. replacedTransition: Transition[0..1]The transition of which this is a replacement. /redefinitionContext: Classifier[1]References the classifier in which context this element may be redefined. 
Constraints
[1]  A fork segment must not have guards or triggers.
(self.source.oclIsKindOf(Pseudostate)  
and not oclIsKindOf(self.stateMachine, ActivityGraph) ) implies
((self.source.oclAsType(Pseudostate).kind = #fork) implies  
((self.guard->isEmpty) and (self.trigger->isEmpty)))
UML Superstructure 2.0 Draft Adopted Specification        499[2] A join segment must not have guards or triggers.
self.target.oclIsKindOf(Pseudostate) implies
((self.target.oclAsType(Pseudostate).kind = #join) implies 
((self.guard->isEmpty) and (self.trigger->isEmpty)))
[3] A fork segment must always target a state.
(self.stateMachine->notEmpty  ) implies
self.source.oclIsKindOf(Pseudostate) implies
((self.source.oclAsType(Pseudostate).kind = #fork) implies  
(self.target.oclIsKindOf(State)))
[4] A join segment must always originate from a state.
(self.stateMachine->notEmpty  ) implies
self.target.oclIsKindOf(Pseudostate) implies
((self.target.oclAsType(Pseudostate).kind = #join) implies  
(self.source.oclIsKindOf(State)))
[5] Transitions outgoing pseudostates may not have a trigger.
self.source.oclIsKindOf(Pseudostate) 
implies (self.trigger->isEmpty))
[6] An initial transition at the topmost level (region of a statemachine) either has no trigger or it has a trigger with the ste reo-
type "create”.
self.source.oclIsKindOf(Pseudostate) implies
(self.source.oclAsType(Pseudostate).kind = #initial) implies
(self.source.container = self.stateMachine.top) implies
((self.trigger->isEmpty) or
 (self.trigger.stereotype.name = 'create')) 
[7] In case of more than one trigger, the signatures of these must be compatible in case the parameters of the signal are
assigned to local variables/attributes.
[8] The redefinition context of a transition is the nearest containing statemachine
redefinitionContext = 
let sm = containingStateMachine() inif sm.context->isEmpty() or sm.general->notEmpty() then
sm
else
sm.context
endif
Additional constraints
[1]  The query isConsistentWith() specifies that a redefining transition is consistent with a redefined transition provided tha t 
the redefining transition has the following relation to the redefined transition: A redefinining transition redefines all prop-erties of the corresponding redefined transition, except the source state and the trigger.
Semantics
High-level transitions
Transitions originating from composite states themselves are called high-level  or group  transitions. If triggered, they 
result in exiting of all the substates of the composite state executing their exit activities starting with the innermost state s 
in the active state configuration. Note that in terms of execution semantics, a high-level transition does not add 
specialized semantics, but rather reflects the semantics of exiting a composite state. A high-level transition with a target 
outside the composite state will imply the execution of the exit action of the composite state, while a high-level transition with a target inside the composite state will not imply execution of the exit action of the composite state.
500                 UML Superstructure 2.0 Draft Adopted SpecificationCompound transitions
A compound transition  is a derived semantic concept, represents a “semantically complete” path made of one or more 
transitions, originating from a set of states (as opposed to pseudo-state) and targeting a set of states. The transition 
execution semantics described below, refer to compound transitions.
In general, a compound transition is an acyclical unbroken chain of transitions joined via join, junction, choice, or fork 
pseudostates that define path from a set of source states (possibly a singleton) to a set of destination states, (possibly a singleton). For self-transitions, the same state acts as both the source and the destination set. A (simple) transition 
connecting two states is therefore a special common case of a compound transition. 
The tail of a compound transition may have multiple transitions originating from a set of mutually orthogonal regions that 
are joined by a join point.
The head of a compound transition may have multiple transitions originating from a fork pseudostate targeted to a set of 
mutually orthogonal regions. 
In a compound transition multiple outgoing transitions may emanate from a common junction  point. In that case, only one 
of the outgoing transition whose guard is true is taken. If multiple transitions have guards that are true, a transition from this set is chosen. The algorithm for selecting such a transition is not specified. Note that in this case, the guards are 
evaluated before the compound transition is taken.
In a compound transition where multiple outgoing transitions emanate from a common choice  point, the outgoing 
transition whose guard is true at the time the choice point is reached , will be taken. If multiple transitions have guards 
that are true, one transition from this set is chosen. The algorithm for selecting this transition is not specified. If no guar ds 
are true after the choice point has been reached, the model is ill formed.
Internal transitions
An internal transition executes without exiting or re-entering the state in which it is defined. This is true even if the state  
machine is in a nested state within this state. 
Completion transitions and completion events
A completion transition  is a transition where the source is a composite state, a submachine state or an exit point, and 
without an explicit trigger, although it may have a guard defined. When all transitions and entry activities and state (do) 
activities in the currently active state are completed, a completion event is generated. This event is the implicit trigger for 
a completion transition. The completion event is dispatched before any other events in the pool and has no associated parameters. For instance, a completion transition emanating from an orthogonal composite state will be taken 
automatically as soon as all the orthogonal regions have reached their final state.
If multiple completion transitions are defined for a state, then they should have mutually exclusive guard conditions.
Enabled (compound) transitions
A transition is enabled  if and only if:
  All of its source states are in the active state configuration.
  One of the triggers of the transition is satisfied by the current event. An event satisfies  a trigger if it matches the event 
specified by the trigger. In case of signal events, since signals are generalized concepts, a signal event satisfies a signal event associated with the same signal or a generalization thereof.
  If there exists at least one full path from the source state configuration to either the target state configuration or to a 
UML Superstructure 2.0 Draft Adopted Specification        501dynamic choice point in which all guard conditions are true (transitions without guards are treated as if their guards are 
always true). 
Since more than one transition may be enabled by the same event, being enabled is a necessary but not sufficient 
condition for the firing of a transition.
Guards
In a simple transition with a guard, the guard is evaluated before the transition is triggered. 
In compound transitions involving multiple guards, all guards are evaluated before a transition is triggered, unless there 
are choice points along one or more of the paths. The order in which the guards are evaluated is not defined. 
If there are choice points in a compound transition, only guards that precede the choice point are evaluated according to 
the above rule. Guards downstream of a choice point are evaluated if and when the choice point is reached (using the 
same rule as above). In other words, for guard evaluation, a choice point has the same effect as a state.
Guards should not include expressions causing side effects. Models that violate this are considered ill formed.
Transition execution sequence
Every transition, except for internal and local transitions, causes exiting of a source state, and entering of the target state . 
These two states, which may be composite, are designated as the main source  and the main target  of a transition. 
The least common ancestor  (LCA) state of a transition is the lowest composite state that contains all the explicit source 
states and explicit target states of the compound transition. In case of junction segments, only the states related to the 
dynamically selected path are considered explicit targets (bypassed branches are not considered). 
If the LCA is not an orthogonal state, the main source is a direct substate of the least common ancestor that contains the 
explicit source states, and the main target is a substate of the least common ancestor that contains the explicit target states . 
In case where the LCA is an orthogonal state, the main source and main target are the orthogonal state itself. The reason 
is that if an orthogonal region is exited, it forces exit of the entire orthogonal state.
Example
  The common simple case: A transition t between two simple states s1 and s2, in a composite states. Here the least com-
mon ancestor of t is s, the main source is s1 and the main target is s2.
Note that a transition from one region to another in the same immediate enclosing composite state is not allowed: the two 
regions must be part of two different composite states. Here least common ancestor of t is s, the main source is s and the 
main target is s, since s is an orthogonal state as specified above.
Once a transition is enabled and is selected to fire, the following steps are carried out in order:
  The main source state is properly exited. 
  Activities are executed in sequence following their linear order along the segments of the transition: The closer the 
activity to the source state, the earlier it is executed.
  If a choice point is encountered, the guards following that choice point are evaluated dynamically and a path whose 
guards are true is selected.
  The main target state is properly entered.
502                 UML Superstructure 2.0 Draft Adopted SpecificationTransition redefinition
A transition of an extended state machine may in the state machine extension be redefined, provided that the value of 
isFinal is False. A redefinition transition redefines all properties of the corresponding replaced transition in the extended 
state machine, except the source state and the trigger.
Transitions are identified by the (source state, trigger) pair. Only transitions that can be uniquely defined by this pair can 
be redefined. This excludes transitions with the same source, same trigger but different guards from being redefined.
Notation
In addition to the notation defined in Common Behaviors, an item of an assignment-specification  can have this form:
attr-name ‘:’ type-name:  this implies an implicit declaration of a local attribute in the effect activity instance and an 
implicit assignment of the corresponding event parameter to this local attribute.
The guard-constraint  is a Boolean expression written in terms of parameters of the triggering event and attributes and 
links of the context object. The guard constraint may also involve tests of orthogonal states of the current state machine, 
or explicitly designated states of some reachable object (for example, “ in State1” or “ not in State2”). State names may be 
fully qualified by the nested states and regions that contain them, yielding pathnames of the form “(RegionOrState1::RegionOrState2::State3.” This may be used in case the same state name occurs in different composite 
state regions.
The activity-expression  is executed if and when the transition fires. It may be written in terms of operations, attributes, 
and links of the context object and the parameters of the triggering event, or any other features visible in it’s scope. The activity expression may be an action sequence comprising a number of distinct actions including actions that explicitly 
generate events, such as sending signals or invoking operations. The details of this expression are dependent on the action 
language chosen for the model.
Both in the activity-expression and in actions of the effect transition specified graphically, the values of the signal 
instance (in case of a signal trigger) are denoted by signal-name  ‘.’attribute-name  in case of just one signal trigger, and 
by ‘msg.’ attr-name  in case of more than one trigger. 
Internal transitions are specified in a special compartment of the source state, see Figure 383.The following icons provide explicit symbols for certain kinds of information that can be specified on transitions. The 
control icons are intended to provide a transition-oriented view of a state machine as exemplified in Figure 395. These icons are not necessary for constructing state machine diagrams, but many users prefer the added impact that they 
provide.
Signal receipt 
The receipt of a signal may be shown as a concave pentagon that looks like a rectangle with a triangular notch in its side 
(either side). The signature of the signal is shown inside the symbol. A unlabeled transition arrow is drawn from the source state to the pentagon and another unlabeled transition arrow is drawn from the pentagon to the target state. 
Signal sending 
The sending of a signal may be shown as a convex pentagon that looks like a rectangle with a triangular point on one side 
(either side). The actual parameters of the signal is shown inside the symbol. A unlabeled transition arrow is drawn from 
the source state to the pentagon and another unlabeled transition arrow is drawn from the pentagon to the target state.
UML Superstructure 2.0 Draft Adopted Specification        503Action sequence
A sequence of actions in a transition may be shown as a rectangle that contains a textual description of the actions. The 
syntax used in the textual description is tool specific but must map to a sequence of Actions.
Deferred triggers 
A deferrable trigger is shown by listing it within the state followed by a slash and the special operation defer . If the event 
occurs, it is saved and it recurs when the object transitions to another state, where it may be deferred again. When the object reaches a state in which the event is not deferred, it must be accepted or lost. The indication may be placed on a 
composite state or its equivalents, submachine states, in which case it remains deferrable throughout the composite state. 
A contained transition may still be triggered by a deferrable event, whereupon it is removed from the pool.Figure 395 - Symbols for Signal Receipt, Sending and Actions on transitionIdle
BusyMinor(Id)Req(Id)
Major(Id)[Id>10]
[Id<=10]
MinorReq = Id; MajorReq = Id;
504                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 397 shows an example of adding transitions in a specialized state machine.Figure 396 - Deferred Trigger NotationTurn on
Machine
Brew coffee
Pour CoffeeturnOn
light goes out / defer
Get Cups
light goes outlight goes out / defer
UML Superstructure 2.0 Draft Adopted Specification        505Example
Transition, with guard constraint and transition string:
right-mouse-down (location) [location in window] / object := pick-object (location);object.highlight ()The trigger may be any of the standard trigger types. Selecting the type depends on the syntax of the name (for time 
triggers, for example); however, SignalTriggers and CallTriggers are not distinguishable by syntax and must be discriminated by their declaration elsewhere.
Changes from previous UML
  Transition redefinition has been added, in order to express if a transition of a general state machine can be redefined or 
not.
  Along with this, an association to the redefined transition has been added.
  Guard has been replaced by a Constraint.
15.3.15 Vertex (from BehaviorStatemachines)
A vertex is an abstraction of a node in a statechart graph. In general, it can be the source or destination of any number of 
transitions.Figure 397 -  Adding TransitionsReadAmount
SelectAmount
EnterAmount
ReleaseCardSelectAmount
EnterAmountabort
abortATM {extended}
506                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
No additional attributes.
Associations
 outgoing: Transition[1..*] Specifies the transitions departing from this vertex.
 incoming: Transition[1..*] Specifies the transitions entering this vertex. container: Region[0..1] The region that contains this vertex.
15.3.16 TransitionKind
TransitionKind is an enumeration type.
Description
TransitionKind is an enumeration of the following literal values:
 external
 internal
 local
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
[1]  The source state of a transition with transition kind local  must be a composite state.
[2] The source state of a transition with transition kind external  must be a composite state.
Semantics
 kind=internal implies that the transition, if triggered, occur without exiting or entering the source state. Thus, it does not  
cause a state change. This means that the entry or exit condition of the source state will not be invoked. An internal transition can be taken even if the state machine is in one or more regions nested within this state.
 kind=local implies that the transition, if triggered, will not exit the composite (source) state, but it will apply to any sta te 
within the composite stat, and these will be exited and entered.
 kind=external implies that the transition, if triggered, will exit the composite (source) state.
Notation
 Transitions of kind local  will be on the inside of the frame of the composite state, leaving the border of the composite state 
and end at a vertex inside  the composite state. Alternatively a transition of kind local can 
be shown as a transition leaving a state symbol containing the text “*”. The transition is then considered to belong to the enclosing composite state.
UML Superstructure 2.0 Draft Adopted Specification        507 Transitions of kind external  will leave the border of the composite state and end at either a vertex outside  the composite 
state or the composite state itself.
Changes from previous UML
The semantics implied by local  is new.
15.4 Diagrams
State machine diagrams specify state machines. This chapter outlines the graphic elements that may be shown in state 
machine diagrams, and provides cross references where detailed information about the semantics and concrete notation 
for each element can be found. It also furnishes examples that illustrate how the graphic elements can be assembled into 
diagrams.
Graphic Nodes
The graphic nodes that can be included in state machine diagrams are shown in Table 20.
Table 20 - Graphic nodes included in state machine diagrams
NODE TYPE NOTATION REFERENCE
Choice pseudo state See “ProtocolTransition (from Protocol-
StateMachines)” on page 466.
Composite state See “State (from BehaviorStatema-
chines)” on page 477.
Entry point See “ProtocolTransition (from Protocol-
StateMachines)” on page 466.
Exit point See “ProtocolTransition (from Protocol-
StateMachines)” on page 466.[Id>10]
<=10]
S 
Sb1 Sb3Sb2
againagain
abortedabortedabortedaborted
508                 UML Superstructure 2.0 Draft Adopted SpecificationFinal state See “FinalState (from BehaviorStatema-
chines)” on page 462.
History, Deep
Pseudo stateSee “ProtocolTransition (from Protocol-
StateMachines)” on page 466.
History, Shallow 
pseudo stateSee “ProtocolTransition (from Protocol-
StateMachines)” on page 466.
Initial pseudo state See “ProtocolTransition (from Protocol-
StateMachines)” on page 466.
Junction pseudo state See “ProtocolTransition (from Protocol-
StateMachines)” on page 466.
Region See “Region (from BehaviorStatema-
chines)” on page 476.
Simple state See “State (from BehaviorStatema-
chines)” on page 477.
State list See “ProtocolTransition (from Protocol-
StateMachines)” on page 466.Table 20 - Graphic nodes included in state machine diagrams
NODE TYPE NOTATION REFERENCE
H*
H
S 
S
S1,S2
UML Superstructure 2.0 Draft Adopted Specification        509Graphic Paths
The graphic paths that can be included in state machine diagrams are shown in Table 21.
Examples
The following are examples of state machine diagrams.State Machine See “StateMachine (from BehaviorState-
machines)” on page 489.
Terminate node See “ProtocolTransition (from Protocol-
StateMachines)” on page 466
Submachine state See “State (from BehaviorStatema-
chines)” on page 477.
Table 21 - Graphic paths included in state machine diagrams
PATH TYPE NOTATION REFERENCE
Transition See “Transition (from BehaviorStatemachines)” on 
page 498.Table 20 - Graphic nodes included in state machine diagrams
NODE TYPE NOTATION REFERENCE
ReadAmountSM
aborted
ReadAmount :
ReadAmountSM abortedabortedReadAmount :
ReadAmountSM abortedaborted
e[g]/ ae[g]/ a
510                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 398 - State machine with exit point definition
Figure 399 - SubmachineState with usage of exit pointReadAmountSM
selectAmount
enterAmount
okabortotherAmount
amountabort
selectAmount
okotherAmount
amountabort
abortedReadAmountSM
selectAmount
enterAmount
okabortotherAmount
amountabort
selectAmount
okotherAmount
amountabort
abortedselectAmount
enterAmount
okabortotherAmount
amountabort
selectAmount
okotherAmount
amountabort
aborted
VerifyCard
acceptCard
ReleaseCard VerifyTransactionOutOfService
outOfServiceVerifyCard
acceptCard
ReleaseCard VerifyTransactionreleaseCardOutOfService
outOfServiceReadAmount :
ReadAmountSM abortedabortedATM
VerifyCard
acceptCard
ReleaseCard VerifyTransactionOutOfService
outOfServiceVerifyCard
acceptCard
ReleaseCard VerifyTransactionreleaseCardOutOfService
outOfServiceReadAmount :
ReadAmountSM abortedabortedReadAmount :
ReadAmountSM abortedabortedATM
UML Superstructure 2.0 Draft Adopted Specification        51116 Use Cases
16.1 Overview
Use cases are a means for specifying required usages of a system. Typically, they are used to capture the requirements of 
a system, that is, what a system is supposed to do. The key concepts associated with use cases are actors , use cases,  and 
the subject . The subject is the system under consideration to which the use cases apply. The users and any other systems 
that may interact with the subject are represented as actors. Actors always model entities that are outside the system. The 
required behavior of the subject is specified by one or more use cases, which are defined according to the needs of actors.
Strictly speaking, the term “use case” refers to a use case type. An instance of a use case refers to an occurrence of the 
emergent behavior that conforms to the corresponding use case type. Such instances are often described by interaction 
specifications.
Use cases, actors, and systems are described using use case diagrams. 
16.2 Abstract syntax
Figure 400 - Dependencies of the UseCases packageUseCases
(from UML)Kernel
(from Classes)BasicBehaviors
(from CommonBehaviors)
<<merge>><<m erge>>
512                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 401 - The concepts used for modeling use cases
16.3 Class Descriptions
16.3.1 Actor (from UseCases)
An actor specifies a role played by a user or any other system that interacts with the subject. (The term “role” is used 
informally here and does not necessarily imply the technical definition of that term found elsewhere in this specification.)
Description
An Actor models a type of role played by an entity that interacts with the subject (e.g., by exchanging signals and data), but which is external  to the subject (i.e., in the sense that an instance of an actor is not a part of the instance of its 
corresponding subject). Actors may represent roles played by human users, external hardware, or other subjects. Note that 
an actor does not necessarily represent a specific physical entity but merely a particular facet (i.e., “role”) of some entity that is relevant to the specification of its associated use cases. Thus, a single physical instance may play the role of 
several different actors and, conversely, a given actor may be played by multiple different instances.
Since an actor is external to the subject, it is typically defined in the some classifier or package that incorporates the 
subject classifier.DirectedRelationship
(from Kernel)RedefinableElement
(from Kernel)BehavioredClassifier
(from BasicBehaviors)
Actor
Constraint
(from Kernel)IncludeExtensionPoint
Ex tend
0..10..1
+condition0..10..11..*
*+extensionLocation 1..*
*Classifier
(from Kernel)
UseCase
1
*+includingCase 1
+include
*1
*+addition1
** 1+extensionPoint
*+useCase
11
*+extendedCase1
*1
*+extension1
+extend
**
*+subject *
+useCase*Classifier
*0..1
+ownedUseCase
*0..1
{subsets ownedMember}{subsets ownedMember}{subsets source}{ordered}{subsets feature,
subsets ownedMember}{subsets ownedMember}
{subsets target} {subsets source}
{subsets ownedMember}{subsets target}
UML Superstructure 2.0 Draft Adopted Specification        513Attributes
No additional attributes.
Associations
No additional associations.
Constraints
[1]  An actor can only have associations to use cases, subsystems, components and classes, and these associations must be 
binary.
[2] An actor must have a name.
name->notEmpty()
Semantics
Actors model entities external to the subject. Each actor represents a coherent set of roles that users of the subject can 
play when interacting with it. When an external entity interacts with the subject, it plays the role of a specific actor. 
Notation
An actor is represented by “stick man” icon with the name of the actor in the vicinity (usually above or below) the icon.
Presentation Options
An actor may also be shown as a class rectangle with the keyword «actor», with the usual notation for all compartments. 
Other icons that convey the kind of actor may also be used to denote an actor, such as using a separate icon for non-
human actors.
Style Guidelines
Actor names should follow the capitalization and punctuation guidelines used for classes in the model. The names of abstract actors should be shown in italics.
Rationale
Not applicable.Customer
«actor»
Customer
User
514                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from previous UML
There are no changes to the Actor concept except for the addition of a constraint that requires that all actors must have 
names.
16.3.2 Classifier (from UseCases, as specialized)
Description
Extends a classifier with the capability to own use cases. Although the owning classifier typically represents the subject to which the owned use cases apply, this is not necessarily the case. In principle, the same use case can be applied to multiple subjects, as identified by the subject  association role of a UseCase (see “UseCase (from UseCases)” on page 
519).
Attributes
No additional attributes
Associations
 ownedUseCase: UseCase References the use cases owned by this classifier. (Specializes 
Namespace.ownedMember .) 
Constraints
No additional constraints. 
Semantics
See “UseCase (from UseCases)” on page 519.
Notation
The nesting (owning) of a use case by a classifier is represented using the standard notation for nested classifiers.
Rationale 
This extension to the Classifier concept was added to allow classifiers in general to own use cases.
Changes from previous UML
No changes.DepartmentStore
MakePurchase
UML Superstructure 2.0 Draft Adopted Specification        51516.3.3 Extend (from UseCases)
A relationship from an extending use case to an extended use case that specifies how and when the behavior defined in 
the extending use case can be inserted into the behavior defined in the extended use case.
Description
This relationship specifies that the behavior of a use case may be extended by the behavior of another (usually supplementary) use case. The extension takes place at one or more specific extension points defined in the extended use 
case. Note, however, that the extended use case is defined independently of the extending use case and is meaningful 
independently of the extending use case. On the other hand, the extending use case typically defines behavior that may 
not necessarily be meaningful by itself. Instead, the extending use case defines a set of modular behavior increments that 
augment an execution of the extended use case under specific conditions.
Note that the same extending use case can extend more than one use case. Furthermore, an extending use case may itself 
be extended.
It is a kind of DirectedRelationship, such that the source is the extending use case and the destination is the extended use 
case. The extend relationship itself is owned by the extending use case.
Attributes
No additional attributes.
Associations
 extendedCase : UseCase [ 1 ] References the use case that is being extended. (Specializes DirectedRelationship.target .)
 extension : UseCase [ 1 ] References the use case that represents the extension and owns the extend relationship. 
(Specializes DirectedRelationship.source .)
 condition : Constraint [ 0..1 ] References the condition that must hold when the first extension point is reached for the 
extension to take place. If no constraint is associated with the extend relationship, the extension is unconditional. (Specializes Namespace.ownedMember .)
 extensionLocation: ExtensionPoint [ 1..* ]
An ordered list of extension points belonging to the extended use case, specifying where the respective behavioral fragments of the extending use case are to be inserted. The first fragment in the extending use case is associated with the first extension point in the list, the second fragment with the second point, and so on. (Note that, in most practical cases, the extending use case has just a single behavior fragment, so that the list of extension points is trivial.)
Constraints
[1]  The extension points referenced by the extend relationship must belong to the use case that is being extended.
extensionLocation->forAll (xp | extendedCase.extensionPoint->include(xp))
Semantics
If the condition of the extension is true at the time the first extension point is reached during the execution of the 
extended use case, then all of the appropriate behavior fragments of the extending use case will also be executed. If the condition is false, the extension does not occur. The individual fragments are executed as the corresponding extension 
516                 UML Superstructure 2.0 Draft Adopted Specificationpoints of the extending use case are reached. Once a given fragment is completed, execution continues with the behavior 
of the extended use case following the extension point. Note that even though there are multiple use cases involved, there 
is just a single behavior execution. 
Notation
An extend relationship between use cases is shown by a dashed arrow with an open arrowhead from the use case providing the extension to the base use case. The arrow is labeled with the keyword «extend». The condition of the relationship as well as the references to the extension points are optionally shown in a Note attached to the corresponding 
extend relationship.(See Figure 402.)
Examples
Figure 402 - Example of an extend relationship between use cases
In the use case diagram above, the use case “Perform ATM Transaction” has an extension point “Selection”. This use case 
is extended via that extension point by the use case “On-Line Help” whenever execution of the “Perform ATM Transaction” use case occurrence is at the location referenced by the “Selection” extension point and the customer selects 
the HELP key. Note that the “Perform ATM Transaction” use case is defined independently of the “On-Line Help” use 
case.
Rationale
This relationship is intended to be used when there is some additional behavior that should be added, possibly conditionally, to the behavior defined in another use case (which is meaningful independently of the extending use case).
Changes from previous UML
The notation for conditions has been changed such that the condition and the referenced extension points may now be included in a Note attached to the extend relationship, instead of merely being a textual comment that is located in the vicinity of the relationship. 
16.3.4 ExtensionPoint (from UseCases)
An extension point identifies a point in the behavior of a use case where that behavior can be extended by the behavior of some other (extending) use case, as specified by an extend relationship.
Description
An ExtensionPoint is a feature of a use case that identifies a point where the behavior of a use case can be augmented with elements of another (extending) use case. Perform ATM Transaction On-Line Help«extend»Condition: {customer selected HELP}
extension point: Selection
extension points
Selection
UML Superstructure 2.0 Draft Adopted Specification        517Attributes
No additional attributes.
Associations
No additional associations.
Constraints
[1]  An ExtensionPoint must have a name.
self.name->notEmpty ()
Semantics
An extension point is a reference to a location within a use case at which parts of the behavior of other use cases may be 
inserted. Each extension point has a unique name within a use case.
Semantic Variation Points
The specific manner in which the location of an extension point is defined is left as a semantic variation point.
Notation
Extension points are indicated by a text string within in the Use Case oval symbol or use case rectangle according to the 
syntax below:
<extension point> ::= <name> [: <explanation>]
Note that explanation, which is optional, may be any informal text or a more precise definition of the location in the 
behavior of the use case where the extension point occurs.
Examples
See Figure 402 on page 516 and Figure 408 on page 522.
Rationale
ExtensionPoint supports the use case extension mechanism (see “Extend (from UseCases)” on page 515).
Changes from previous UML
In 1.x, ExtensionPoint was modeled as a kind of ModelElement, which due to a multiplicity constraint, was always 
associated with a specific use case. This relationship is now modeled as an owned feature of a use case. Semantically, this is equivalent and the change will not be visible to users.
ExtensionPoints in 1.x had an attribute called location , which was a kind of LocationReference. Since the latter had no 
specific semantics it was relegated to a semantic variation point. When converting to UML 2.0, models in which 
ExtensionPoints had a location  attribute defined, the contents of the attribute should be included in a note attached to the 
ExtensionPoint.
16.3.5 Include (from UseCases)
An include relationship defines that a use case contains the behavior defined in another use case.
518                 UML Superstructure 2.0 Draft Adopted SpecificationDescription
Include is a directed relationship between two use cases, implying that the behavior of the included use case is inserted 
into the behavior of the including use case. The including use case may only depend on the result (value) of the included 
use case. This value is obtained as a result of the execution of the included use case. 
Note that the included use case is not optional, and is always required for the including use case to execute correctly.
Attributes
No additional attributes.
Associations
 addition : UseCase [ 1 ] References the use case that is to be included. (Specializes 
DirectedRelationship.target .)
 includingCase : UseCase [ 1 ] References the use case which will include the addition and owns the include relationship. 
(Specializes DirectedRelationship.source .)
Constraints
No additional constraints.
Semantics
An include relationship between two use cases means that the behavior defined in the including use case is included in the 
behavior of the base use case. The include relationship is intended to be used when there are common parts of the behavior of two or more use cases. This common part is then extracted to a separate use case, to be included by all the 
base use cases having this part in common. Since the primary use of the include relationship is for reuse of common parts, 
what is left in a base use case is usually not complete in itself but dependent on the included parts to be meaningful. This is reflected in the direction of the relationship, indicating that the base use case depends on the addition but not vice 
versa.
Execution of the included use case is analogous to a subroutine call. All of the behavior of the included use case are 
executed at a single location in the included use case before execution of the including use case is resumed.
Notation
An include relationship between use cases is shown by a dashed arrow with an open arrowhead from the base use case to the included use case. The arrow is labeled with the keyword «include». (See Figure 403.)
Examples
A use case “Withdraw” includes an independently defined use case “Card Identification”.
Figure 403 - Example of the Include relationship
Rationale
The Include relationship allows hierarchical composition of use cases as well as reuse of use cases.WithdrawCard
Identification«include»
UML Superstructure 2.0 Draft Adopted Specification        519Changes from previous UML
There are no changes to the semantics or notation of the Include relationship relative to UML 1.x.
16.3.6 UseCase (from UseCases)
A use case is the specification of a set of actions performed by a system, which yields an observable result that is, 
typically, of value for one or more actors or other stakeholders of the system.
Description
A UseCase is a kind of behaviored classifier that represents a declaration of an offered behavior. Each use case specifies some behavior, possibly including variants, that the subject can perform in collaboration with one or more actors. Use 
cases define the offered behavior of the subject without reference to its internal structure. These behaviors, involving 
interactions between the actor and the subject, may result in changes to the state of the subject and communications with 
its environment. A use case can include possible variations of its basic behavior, including exceptional behavior and error handling.
The subject of a use case could be a physical system or any other element that may have behavior, such as a component, 
subsystem or class. Each use case specifies a unit of useful functionality that the subject provides to its users, i.e., a 
specific way of interacting with the subject. This functionality, which is initiated by an actor, must always be completed for the use case to complete. It is deemed complete if, after its execution, the subject will be in a state in which no further  
inputs or actions are expected and the use case can be initiated again or in an error state. 
Use cases can be used both for specification of the (external) requirements on a subject and for the specification of the 
functionality offered by a subject. Moreover, the use cases also state the requirements the specified subject poses on its environment by defining how they should interact with the subject so that it will be able to perform its services.
The behavior of a use case can be described by a specification that is some kind of Behavior (through its ownedBehavior 
relationship), such as interactions, activities, and state machines, or by pre-conditions and post-conditions as well as by 
natural language text where appropriate. It may also be described indirectly through a Collaboration that uses the use case and its actors as the classifiers that type its parts. Which of these techniques to use depends on the nature of the use case 
behavior as well as on the intended reader. These descriptions can be combined. An example of a use case with an 
associated state machine description is shown in  Figure 405.
Attributes
No additional attributes.
Associations
 subject : Classifier References the subjects to which this use case applies. The subject or its parts realize all 
the use cases that apply to this subject. Use cases need not be attached to any specific sub-ject, however. The subject may, but need not, own the use cases that apply to it.
 include : Include References the Include relationships owned by this use case. (Specializes 
Classifier.feature and Namespace.ownedMember .)
 extend : Extend References the Extend relationships owned by this use case. (Specializes 
Classifier.feature and Namespace.ownedMember .)
 extensionPoint: ExtensionPoint
References the ExtensionPoints owned by the use case. (Specializes Classifier.feature and Namespace.ownedMember .)
520                 UML Superstructure 2.0 Draft Adopted SpecificationConstraints
[1]  A UseCase must have a name.
self.name -> notEmpty ()
[2] UseCases can only be involved in binary Associations.
[3] UseCases can not have Associations to UseCases specifying the same subject.
Semantics
An execution of a use case is an occurrence of emergent behavior. 
Every instance of a classifier realizing a use case must behave in the manner described by the use case.
Use cases may have associated actors, which describes how an instance of the classifier realizing the use case and a user 
playing one of the roles of the actor interact. Two use cases specifying the same subject cannot be associated since each of them individually describes a complete usage of the subject. It is not possible to state anything about the internal 
behavior of the actor apart from its communications with the subject. 
Notation
A use case is shown as an ellipse, either containing the name of the use case or with the name of the use case placed below the ellipse. An optional stereotype keyword may be placed above the name and a list of properties included below 
the name. If a subject (or system boundary) is displayed, the use case ellipse is visually located inside the system boundary rectangle. Note that this does not necessarily mean that the subject classifier owns the contained use cases, but 
merely that the use case applies to that classifier. For example, the use cases shown in Figure 404 on page 520 apply to 
the “ATMsystem” c lassifier but are owned by various packages as shown in Figure 406 
Figure 404 - Example of the use cases and actors for an ATM systemCustomer
Administrator«subsystem»
ATMsystem
BankWithdraw
Transfer Funds
Deposit
Money
Register ATM
at Bank
Read Log0..1
1
0..11
0..11
0..1 1
0..110..*1
0..*1
UML Superstructure 2.0 Draft Adopted Specification        521Figure 405 - Example of a use case with an associated state machine behavior
 
Figure 406 - Example of use cases owned by various packages statemachine Call
Dialing
Ringing
TalkinglastDigit
answer
onHookusecase MakeCall
package TransactionUseCases
package ATM Services
package AdministrationCard
IdentificationPerform ATM
TransactionOn-Line
Help«extends»condition: {customerselected HELP}
extension point: Selection
Withdraw Transfer FundsDeposit
Funds«includes»
«includes»
Read LogRegister ATM
at Bank
522                 UML Superstructure 2.0 Draft Adopted SpecificationExtension points may be listed in a compartment of the use case with the heading extension points . The description of 
the locations of the extension point is given in a suitable form, usually as ordinary text, but can also be given in other 
forms, such as the name of a state in a state machine, an activity in an activity diagram, a precondition, or a postcondition.
Use cases may have other associations and dependencies to other classifiers, e.g. to denote input/output, events and 
behaviors.
The detailed behavior defined by a use case is notated according to the chosen description technique, in a separate 
diagram or textual document. Operations and attributes are shown in a compartment within the use case. 
Use cases and actors may represent roles in collaborations as indicated in Figure 407.
Figure 407 - Example of a use case for withdrawal and transfer of funds
Presentation Options
A use case can also be shown using the standard rectangle notation for classifiers with an ellipse icon in the upper-right-hand corner of the rectangle with optional separate list compartments for its features. This rendering is more suitable 
when there are a large number of extension points. 
Figure 408 - Example of the classifier based notation for a use case
Examples
See Figure 402 through Figure 408.
Rationale
The purpose of use cases is to identify the required functionality of a system.«subsystem»
: ATMsystem
: Customer : Bank: Withdraw
: Transfer Funds
extension points
order created : in Created state
order processed : in Processed stateorder cancelled : in Cancelled state
order rejected : in Rejected state
order completed : in Completed stateorder destroyed : in Destroyed stateorder delivered : in Delivered stateorder obfuscated : in Obfuscated stateOrderStationery : PlaceOrder
UML Superstructure 2.0 Draft Adopted Specification        523Changes from previous UML
The relationship between a use case and its subject has been made explicit. Also, it is now possible for use cases to be 
owned by classifiers in general and not just packages.
16.4 Diagrams
Description
Use Case Diagrams are a specialization of Class Diagrams such that the classifiers shown are restricted to being either Actors or Use Cases.
Graphic Nodes
The graphic nodes that can be included in structural diagrams are shown in Table 22.
Table 22 - Graphic nodes included in sequence diagrams
NODE TYPE NOTATION REFERENCE
Actor (default) See “Actor (from UseCases)” on page 512
Actor 
(optional user-defined icon - example)
Extend See “Extend (from UseCases)” on page 515
Extend (with 
Condition)Customer
erform ATM Transaction«extends»extension points
Selection
extended (use case) extending (use case)
«extends»Condition: {customer selected HELP}
extension point: Selection
524                 UML Superstructure 2.0 Draft Adopted SpecificationExtension-
Point See “ExtensionPoint (from UseCases)” on 
page 516
Include See “Include (from UseCases)” on page 517Table 22 - Graphic nodes included in sequence diagrams
NODE TYPE NOTATION REFERENCE
extension points
Selection
extension point 
extension points
order created : in Created state
order shipped : in Shipped stateOrderStationery
extension point 
WithdrawCard
Identification«includes»
included (use case) including (use case)
UML Superstructure 2.0 Draft Adopted Specification        525Use Case See “UseCase (from UseCases)” on page 519Table 22 - Graphic nodes included in sequence diagrams
NODE TYPE NOTATION REFERENCE
Withdraw
On-Line Help
Perform ATM Transactionextension points
Selection
OrderStationery
526                 UML Superstructure 2.0 Draft Adopted SpecificationExamples
The use case diagram in Figure 409 shows a set of use cases used by four actors of a physical system that is the subject 
of those use cases. The subject can be optionally represented by a rectangle as shown in this example.Figure 409 - Use Case diagram with a rectangle representing the 
                        boundary of the subject.Customer
SupervisorSalesperson
Establish CreditTelephone Catalog
Shipping ClerkCheck Status
Place Order
Fill Ordersuse case
actor
subject
UML Superstructure 2.0 Draft Adopted Specification        527Figure 410 illustrates a package that owns a set of use cases (NB: a use case may be owned either by a package or by a 
classifier (typically the classifier specifying the subject)). 
Figure 410 - Use cases owned by a package 
Changes from previous UML
There are no changes from UML 1.x, although some aspects of notation to model element mapping have been clarified.package ATMtopPkg
Customer
Administrator«subsystem»
ATMsystem
BankWithdraw
Transfer Funds
Deposit
Money
Register ATM
at Bank
Read Log0..1
1
0..11
0..11
0..11
0..110..*1
0..*1
528                 UML Superstructure 2.0 Draft Adopted Specification
UML Infrastructure 2.0 Draft Adopted Specification        529Part III - Supplement
This part defines auxiliary constructs (e.g., information flows, models, templates, primitive types) and the profiles used to 
customize UML for various domains, platforms and methods. The UML packages that support auxiliary constructs, along 
with the structure packages they depend upon (InternalStructures, Dependencies and Kernel) are shown in Figure 411.
The function and contents of these packages are described in following chapters, which are organized by major subject 
areas.Figure 411 - UML packages that support auxiliary constructsAuxiliaryConstructs ProfilesKe r ne l
(from Classes)
Dependencies
(from  Clas ses)<<merge>>
<<merge>>InternalStructures
(from CompositeStructures)
530                 UML Infrastructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        53117 Auxiliary Constructs
17.1 Overview
This chapter defines mechanisms for information flows, models, primitive types, and templates. 
Package structure
17.2 InformationFlows
The InformationFlows package provides mechanisms for specifying the exchange of information between entities of a 
system at a high level of abstraction. Information flows describe circulation of information in a system in a general manner. They do not specify the nature of the information (type, initial value), nor the mechanisms by which this 
information is conveyed (message passing, signal, common data store, parameter of operation, etc.). They also do not 
specify sequences or any control conditions. It is intended that, while modeling in detail, representation and realization links will be able to specify which model element implements the specified information flow, and how the information 
will be conveyed.Figure 412 - Dependencies between packages described in this chapterInformationFlowsModelsPri mitiveTypes Kernel
(from Classes)
<<me rge >><<merge>>
TemplatesInternalStructures
(from CompositeStructures)
<<merge>>
532                 UML Superstructure 2.0 Draft Adopted SpecificationThe contents of the InfromationFlows package is shown in Figure 413. The InformationFlows package is one of the 
packages of the AuxiliaryConstructs package.
17.2.1 InformationFlow (from InformationFlows)
Description
An Information Flow specifies that one or more information items circulate from its sources to its targets. 
Attributes
None.
Associations
 realization : Relationship [*] : Determines which Relationship will realize the specified flow
 conveyed : Classifier [1..*] : Specifies the information items that may circulate on this information flow.
Constraints
[1]  The sources and targets of the information flow can only be of the following kind : Actor, Node, Use Case, Artifact, Class , 
Component, Port, Property, Interface, Package, and InstanceSpecification except when its classifier is a relationship (i.e. it represents a link).
[2] The sources and targets of the information flow must conform with the sources and targets or conversely the target and
sources of the realization relationships, if any.
[3] An information flow can only convey classifiers that are allowed to represent an information item. (see constraints on
InformationItem)
Semantics
An information flow is an abstraction of the communication of an information item from its sources to its targets. It is used t o 
abstract the communication of information between entities of a system. Sources or targets of an information flow designate sets of objects that can send or receive the conveyed information item. When a source or a target is a classifier, it represent s all 
the potential instances of the classifier; when it is a part, it represents all instances that can play the role specified by t he part; 
when it is a package, it represents all potential instances of the directly or indirectly owned classifiers of the package.Figure 413 - The contents of the InformationFlows packageDirectedRelationship
(f rom  Kernel)
InformationItemRelationship
(f rom  Kernel) Classifier
(from  Kernel)
*
*+represented *
+representation
*
InformationFlow*
*+realization
*
+abstraction
*1..*
*+conveyed
1..*
*
UML Superstructure 2.0 Draft Adopted Specification        533An information flow may directly indicate a concrete classifier, such as a class, that is conveyed instead of using an 
information item.
Notation
An information flow is represented as a dependency, with the keyword <<flow>>.
Figure 414 - Example of information flows conveying information items
Changes from UML1.x
InformationFlow does not exist in UML 1.4.
17.2.2 InformationItem (from InformationFlows)
An information Item is an abstraction of all kinds of information that can be exchanged between objects. It is a kind of classifier intended for representing information at a very abstract way, which is cannot be instanciated.
One purpose of Information Items is to be able to define preliminary models, before having taken detailed modeling decisions on types or stuctures. One other purpose of information items and information flows is to abstract complex models by a less precise but more general representation of the information exchanged betwen entities of a system.
Attributes 
No additional attributes.
Associations
 represented : Classifier [*] : Determines the classifiers that will specify the structure and nature of the information. An 
information item represents all its represented classifiers.
Constraints
[4] The sources and targets of an information item (its related information flows) must designate subsets of the sources and
targets of the representation information item, if any.The Classifiers that can realize an information item can only be ofthe following kind : Class, Interface, InformationItem, Signal, Component.
[5] An informationItem has no feature, no generalization, and no associations.
[6] It is not instanciable
Semantics
"Information" as represented by an information item encompasses all sorts of data, events, facts that are exploited inside 
the modeled system. For example, the information item "wage" can represent a Salary Class, or a Bonus Class (see 
example Figure 416). An information item does not specify the structure, the type or the nature of the represented information. It specifies at an abstract level the elements of information that will be exchanged inside a system. More 
accurate description will be provided by defining the classifiers represented by information item.Customer CompanyEmployee
product
wage
<<flow>><<flow>>
534                 UML Superstructure 2.0 Draft Adopted SpecificationInformation items can be decomposed into more specific information item, using representation links between them. This 
gives the ability to express that in specific contexts (specific information flows) a specific information is exchanged. 
Information Items cannot have properties, or associations. Specifying these detailed informations belongs to the 
represented classifiers.
Notation
Being a classifier, an information item can be represented as a name inside a rectangle. The keyword «information», or the 
black triangle icon on top of this rectangle indicates that it is an information item. 
Figure 415 - Information Item represented as a classifier
Representation links between a classifier and a representation item are represented as dashed lines with the keyword «representation».
Figure 416 - Examples of «representation» notation
An information item is usually represented attached to an information flow, or to a relationship realizing an information 
flow. When it is attached to an information flow (see Figure 414) its name is displayed close to the information flow line. 
When it is attached to an information channel, a black triangle on the information channel indicates the direction (source 
and target) of the realized information flow conveying the information item, and its name is displayed close to that triangle. In the example Figure 418, two associations are realizing informations flows. The black triangle indicates that an 
information flow is realized, and the information item name is displayed close to the triangle.
The example Figure 417 shows the case of information items represented on connectors. When several information items 
having the same direction are represented, only one triangle is shown, and the list of information item names, separated by a comma is presented.
The name of the information item can be prefixed by the names of the container elements, such as a container information 
flow, or a container package or classifier, separated by a colon.wage< < in fo rm a tio n > >
wage
wageSalary
<<representation>>
Bonus
<<representation>>travel
document <<representation>>
<<representation>> fly ticketpassport
UML Superstructure 2.0 Draft Adopted Specification        535Figure 417 - Information item attached to connectors
Figure 418 - Information Items attached to associations
17.3 Models
The contents of the Models package is shown in Figure 419. The Models package is one of the packages of the 
AuxiliaryConstructs package.
17.3.1 Model (from Models)
A model captures a view of a physical system. It is an abstraction of the physical system, with a certain purpose. This 
purpose determines what is to be included in the model and what is irrelevant. Thus the model completely describes those 
aspects of the physical system that are relevant to the purpose of the model, at the appropriate level of detail.
Description
The Model construct is defined as a Package. It contains a (hierarchical) set of elements that together describe the physical system being modeled. A Model may also contain a set of elements that represents the environment of the system, typically Actors, together with their interrelationships, such as Associations and DependenciesFigure 419 - The contents of the Models packagem1 : my C1 m2 : my Cp q a b,  d
Customer CompanyEmployee
productwage
* *provider*
0..1employer
Mod el
viewpoint : StringPackage
(from Kernel)
536                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
 viewpoint : String [*] The name of the viewpoint that is expressed by a model (This name may refer to a profile 
definition).
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
A model is a description of a physical system with a certain purpose, such as to describe logical or behavioral aspects of 
the physical system to a certain category of readers.
Thus, a model is an abstraction of a physical system. It specifies the physical system from a certain vantage point (or 
viewpoint), i.e. for a certain category of stakeholders, e.g. designers, users, or orderers of the system, and at a certain level of abstraction, both given by the purpose of the model. A model is complete in the sense that it covers the whole 
physical system, although only those aspects relevant to its purpose, i.e. within the given level of abstraction and vantage 
point, are represented in the model. Furthermore, it describes the physical system only once, i.e. there is no overlapping; no part of the physical system is captured more than once in a model.
A model owns or imports all the elements needed to represent a physical system completely according to the purpose of 
this particular model. The elements are organized into a containment hierarchy where the top-most package or subsystem 
represents the boundary of the physical system. It is possible to have more than one containment hierarchy within a model, i.e. the model contains a set of top-most packages/subsystems each being the root of a containment hierarchy. In 
this case there is no single package/subsystem that represents the physical system boundary. 
The model may also contain elements describing relevant parts of the system’s environment. The environment is typically 
modeled by actors and their interfaces. As these are external to the physical system, they reside outside the package/subsystem hierarchy. They may be collected in a separate package, or owned directly by the model. These elements and 
the elements representing the physical system may be associated with each other. 
Different models can be defined for the same physical system, where each model represents a view of the physical system 
defined by its purpose and abstraction level. Typically different models are complementary and defined from the perspectives (viewpoints) of different system stakeholders. When models are nested, the container model represents the 
comprehensive view of the physical system given by the different views defined by the contained models.
Models can have refinement or mapping dependencies between them. These are typically decomposed into dependencies 
between the elements contained in the models. Relationships between elements in different models have no semantic impact on the contents of the models because of the self-containment of models. However, they are useful for tracing 
refinements and for keeping track of requirements between models.
Notation
A model is notated using the ordinary package symbol (a folder icon) with a small triangle in the upper right corner of the large rectangle. Optionally, especially if contents of the model is shown within the large rectangle, the triangle may be 
drawn to the right of the model name in the tab.
UML Superstructure 2.0 Draft Adopted Specification        537Presentation Options
A model is notated as a package, using the ordinary package symbol with the keyword «model» placed above the name 
of the model.
Examples
Figure 420 - Three models representing parts of a system
Figure 421 - Two views of one and the same physical system 
                        collected in a container model.
17.4 PrimitiveTypes
A number of primitive types have been defined for use in the specification of the UML metamodel. These include 
prmitive types such as Integer, Boolean, and String. These types are reused by both MOF and UML, and may potentially be reused also in user models. Tool vendors, however, typically provide their own libraries of data types to be used when 
modeling with UML. 
The contents of the PrimitiveTypes package is shown in Figure 422. The PrimitiveTypes package is one of the packages 
of the AuxiliaryConstructs package.
Figure 422 - The contents of the PrimitiveTypes packageClient tier Business
tierData tier
 Analysis  Design
 Model  Model«model»
 OrderEntry
Integer<<primitive>>
Boolean<<primitive>>
String<<primitive>>
UnlimitedNatural<<primitive>>
538                 UML Superstructure 2.0 Draft Adopted Specification17.4.1 Boolean (from PrimitiveTypes)
A boolean type is used for logical expression, consisting of the predefined values true and false. 
Description
Boolean is an instance of PrimitiveType. In the metamodel, Boolean defines an enumeration that denotes a logical 
condition. Its enumeration literals are:
 true The Boolean condition is satisfied.
 false The Boolean condition is not satisfied.
It is used for boolean attribute and boolean expressions in the metamodel, such as OCL expression.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
Boolean is an instance of PrimitiveType. 
Notation
Boolean will appear as the type of attributes in the metamodel. Boolean instances will be values associated to slots, and can have literally the following values : true, or false.
Examples
17.4.2 Integer (from PrimitiveTypes)
An integer is a primitive type representing integer values.Figure 423 - An example of a boolean attributeCar
isAutomatic: Boolean = true
UML Superstructure 2.0 Draft Adopted Specification        539Description
An instance of Integer is an element in the (infinite) set of integers (…-2, -1, 0, 1, 2…). It is used for integer attributes 
and integer expressions in the metamodel.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
Integer is an instance of PrimitiveType.
Notation
Integer will appear as the type of attributes in the metamodel. Integer instances will be values associated to slots such as 1, -5, 2, 34, 26524, etc.
Examples
17.4.3 String (from PrimitiveTypes)
A string is a sequence of characters in some suitable character set used to display information about the model. Character 
sets may include non-Roman alphabets and characters.
Description
An instance of String defines a piece of text. The semantics of the string itself depends on its purpose, it can be a comment, computational language expression, OCL expression, etc. It is used for String attributes and String expressions 
in the metamodel.
Attributes
No additional attributes.Figure 424 - An example of an integer attributeMagazine
pages: Integer = 64
540                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
No additional associations.
Constraints
No additional constraints.
Semantics
String is an instance of PrimitiveType. 
Notation
String appears as the type of attributes in the metamodel. String instances are values associated to slots. The value is a 
sequence of characters surrounded by double quotes ("). It is assumed that the underlying character set is sufficient for 
representing multibyte characters in various human languages; in particular, the traditional 8-bit ASCII character set is insufficient. It is assumed that tools and computers manipulate and store strings correctly, including escape conventions 
for special characters, and this document will assume that arbitrary strings can be used.
A string is displayed as a text string graphic. Normal printable characters should be displayed directly. The display of 
nonprintable characters is unspecified and platform-dependent.
Examples
17.4.4 UnlimitedNatural (from PrimitiveTypes)
An unlimited natural is a primitive type representing unlimited natural values.
Description
An instance of UnlimitedNatural is an element in the (infinite) set of naturals (0, 1, 2…). The value of infinity is shown using an asterisk (‘*’).
Attributes
No additional attributes.
Associations
No additional associations.Figure 425 - An example of a string attributeBook
author: String = "Joe"
UML Superstructure 2.0 Draft Adopted Specification        541Constraints
No additional constraints.
Semantics
UnlimitedNatural is an instance of PrimitiveType. 
Notation
UnlimitedNatural will appear as the type of upper bounds of multiplicities in the metamodel. UnlimitedNatural instances 
will be values associated to slots such as 1, 5, 398475, etc. The value infinity may be shown using an asterisk (‘*’).
Examples
17.5 Templates
The Templates package specifies how both Classifiers, Packages and Operations can be parameterized with Classifier, ValueSpecification and Feature (Property and Operation) template parameters. The package introduces mechanisms for 
defining templates, template parameters, and bound elements in general, and the specialization of these for classifiers and packages.
Classifier, package and operation templates were covered in 1.x in the sense that any model element could be 
templateable. This new metamodel restricts the templateable elements to those for which it is meaningful to have template 
parameters.Figure 426 - An example of an unlimited naturalTeacher Student
*student
542                 UML Superstructure 2.0 Draft Adopted SpecificationTemplates
Figure 427 - TemplatesElement
(from  Kernel)Element
(from  Kernel)
Element
(from  Kernel)Element
(from  Kernel)TemplateableElementTemplateSignature
0..11ownedTemplateSignat ure
0..1
{subsets ownedElement}template
1
{subsets owner}
ParameterableElementTe mpla tePa ram eter1..*parameter
1..**1
ownedParameter
*{subsets ownedElement, 
subsets parameter}signature 1
{subsets owner}
0..1 1templateParameter
0..1parameteredElement
10..10..1ownedParameteredElement
0..1
{subsets ownedElement, 
subsets parameteredElement}owningParameter
0..1{subsets owner}
0..1default
0..1
0..1 0..1ownedDefault
0..1 {subsets default,
subsets ownedElement}owningDefault
0..1
{subsets owner}
UML Superstructure 2.0 Draft Adopted Specification        54317.5.1 ParameterableElement
A parameterable element is an element that can be exposed as a formal template parameter for a template, or specified as 
an actual parameter in a binding of a template.
Description
A ParameterableElement can be referenced by a TemplateParameter when defining a formal template parameter for a template. A ParameterableElement can be referenced by a TemplateParameterSubstitution when used as an actual 
parameter in a binding of a template.
ParameterableElement is an abstract metaclass.
Attributes
No additional attributes
Associations
 owningParameter : TemplateParameter[0..1]The formal template parameter that owns this element. Subsets Ele-
ment::owner.Figure 428 - Template parametersDirectedRelationship
(from Kernel)Element
(f ro m Ke rn el)
TemplateSignatureTemplateableElement TemplateBinding
1signature
1 {subsets target}1 *boundElement
1{subsets owner,
subsets source}te mpl at eBinding
*
{subsets ownedElement}TemplateParameter
ParameterableElementTemplateParameterSubstitution
*
1parameterSubstitution*
{subsets ownedElement}
templateBinding
1 {subsets owner}1formal
1
1..*actual
1..*
0..1 0..1ownedActual
0..1{subsets actual,
subsets ownedElement}owningSubstitution
0..1
{subsets owner}
544                 UML Superstructure 2.0 Draft Adopted Specification templateParameter : TemplateParameter [0..1] The template parameter that exposes this element as a formal parameter.
Constraints
No additional constraints.
Additional Operations
[1]  The query isCompatibleWith() determines if this parameterable element is compatible with the specified parameterable 
element. By default parameterable element P is compatible with parameterable element Q if the kind of P is the same or a subtype as the kind of Q. Subclasses should override this operation to specify different compatibility constraints.
ParameterableElement::isCompatibleWith(p : ParameterableElement) : Boolean;
isCompatibleWith = p->oclIsKindOf(self.oclType)
[2] The query isTemplateParameter() determines if this parameterable element is exposed as a formal template parameter.
ParameterableElement::isTemplateParameter() : Boolean;
isTemplateParameter = parameter->notEmpty()
Semantics
A ParameterableElement may be part of the definition of a template parameter. The ParameterableElement is used to 
constrain the actual arguments that may be specified for this template parameter in a binding of the template. 
A ParameterableElement exposed as a template parameter can be used in the template as any other element of this kind 
defined in the namespace of the template, e.g. a classifier template parameter can be used as the type of typed elements. In a element bound to the template, any use of the template parameter will be substituted by the use of the actual 
parameter. 
If a ParameterableElement is exposed as a template parameter, then the parameterable element is only meaningful within 
the template (it may not be used in other parts of the model). 
Semantic Variation Points
The enforcement of template parameter constraints is a semantic variation point:
  If template parameter constraints apply, then within the template element a template parameter can only be used 
according to its constraint, e.g. an operation template parameter can only be called with actual parameters matching the constraint in terms of the signature constraint of the operation template parameter. Applying constraints will imply that a bound element is well-formed if the template element is well-formed and if actual parameters comply with the formal parameter constraints.
  If template parameter constraints do not apply, then within the template element a template parameter can be used 
without being constrained, e.g. an operation template parameter will have no signature in terms of parameters and it can be called with arbitrary actual parameters. Not applying constraints provides more flexibility, but some actual tem-plate parameters may not yield a well-formed bound element.
Notation
See TemplateParameter for a description of the notation for exposing a ParameterableElement as a formal parameter of a 
template.
See TemplateBinding for a description of the notation for using a ParameterableElement as an actual parameter in a 
binding of a template.
UML Superstructure 2.0 Draft Adopted Specification        545Within these notations, the parameterable element is typically shown as the name of the parametered element (if that 
element is a named element).
Examples
See TemplateParameter.
17.5.2 TemplateableElement
A templateable element is an element that can optionally be defined as a template and bound to other templates.
Description
TemplateableElement may contain a template signature which specifies the formal template parameters. A 
TemplateableElement that contains a template signature is often referred to as a template.
TemplateableElement may contain bindings to templates that describe how the templateable element is constructed by 
replacing the formal template parameters with actual parameters. A TemplateableElement containing bindings is often 
referred to as a bound element.
Attributes
No additional attributes
Associations
 ownedSignature : TemplateSignature[0..1]The optional template signature specifying the formal template parameters. 
Subsets Element::ownedElement.
 templateBinding : TemplateBinding[*]The optional bindings from this element to templates.
Constraints
No additional constraints.
Additional Operations
[1]  The query getParameterableElements() returns the set of elements that may be used as the parametered element for a tem-
plate parameter if this templateable element. By default this set includes all the owned elements. Subclasses may override this operation if they choose to restrict the set of parameterable elements.
TemplateableElement::getParameterableElements() : Set(ParameterableElement);
getParameterableElements = allOwnedElements->select(oclIsKindOf(ParameterableElement))
[2] The query isTemplate() returns whether this templateable element is actually a template.
TemplateableElement::isTemplate() : Boolean;
isTemplate = ownedSignature->notEmpty()
Semantics
A TemplateableElement that has a template signature is a specification of a template. A template is a parameterized 
element that can be used to generate other model elements using TemplateBinding relationships. The template parameters 
for the template signature specify the formal parameters that will be substituted by actual parameters (or the default) in a 
binding.
546                 UML Superstructure 2.0 Draft Adopted SpecificationA template parameter is defined in the namespace of the template, but the template parameter represents a model element 
which is defined in the context of the binding.
A templateable element can be bound to other templates. This is represented by the bound element having bindings to the 
template signatures of the target templates. In a canonical model a bound element does not explicitly contain the model elements implied by expanding the templates it binds to, since those expansions are regarded as derived. The semantics 
and well-formedness rules for the bound element must be evaluated as if the bindings were expanded with the 
subsititutions of actual elements for formal parameters.
The semantics of a binding relationship is equivalent to the model elements that would result from copying the contents 
of the template into the bound element, replacing any elements exposed as a template parameter with the corresponding 
element(s) specified as actual parameters in this binding. 
A bound element may have multiple bindings, possibly to the same template. In addition, the bound element may contain 
elements other than the bindings. The specific details of how the expansions of multiple bindings, and any other elements 
owned by the bound element, are combined together to fully specify the bound element are found in the subclasses of 
TemplateableElement. The general principle is that one evaluates the bindings in isolation to produce intermediate results (one for each binding) which are then merged to produce the final result. It is the way the merging is done, that is specific 
to each kind of templateable element.
A templateable element may contain both a template signature and bindings. Thus a templateable element may be both a 
template and a bound element.
A template cannot be used in the same manner as a non-template element of the same kind. The template element can 
only be used to generate bound elements, e.g. a template class cannot be used as the type of a typed element, or as part of 
the specification of another template, e.g. a template class may specialize another template class. 
A bound (non-template) element is an ordinary element and can be used in the same manner as a non-bound (and non-
template) element of the same kind. For example, a bound class may be used as the type of a typed element.
Notation
If a TemplateableElement has template parameters, a small dashed rectangle is superimposed on the symbol for the templateable element, typically on the upper right-hand corner of the notation (if possible). The dashed rectangle contains a list of the formal template parameters. The parameter list must not be empty, although it might be suppressed in the 
presentation. Any other compartments in the notation of the templateable element will appear as normal.
The formal template parameter list may be shown as a comma-separated list , or it may be one formal template parameter 
per line. See TemplateParameter for the general syntax of each template parameter.
A bound element has the same graphical notation as other elements of that kind. Each binding is shown using the notation 
described under TemplateBinding.
Presentation Options
An alternative presentation for the bindings for a bound element is to include the binding information within the notation for the bound element. Typically the name compartment would be extended to contain a string with the following syntax:
element-name ’:’ binding-expression-list
where binding-expression-list is a comma-separated list of  binding-expression defined to be:
template-element-name  ‘<‘ { template-parameter-substitution }* ‘>’
and template-parameter-substitution  is defined in TemplateBinding.
UML Superstructure 2.0 Draft Adopted Specification        547Examples
For examples of templates, the reader is referred to those sections which deal with specializations of 
TemplateableElement, in particular ClassifierTemplate and PackageTemplate.
17.5.3 TemplateBinding
A template binding represents a relationship between a templateable element and a template. A template binding specifies the substitutions of actual parameters for the formal parameters of the template.
Description
TemplateBinding is a directed relationship from a bound templateable element to the template signature of the target template. A TemplateBinding owns a set of template parameter substitutions.
Attributes
No additional attributes.
Associations
 parameterSubstitution : TemplateParameterSubstitution[*]The parameter substitutions owned by this template binding. 
Subsets Element::ownedElement.
 boundElement : TemplateableElement[1]The element that is bound by this binding. Subsets DirectedRelationship::source. template : TemplateSignature[1]The template signature for the template that is the target of the binding. Subsets Directe-
dRelationship::target.
Constraints
[1]  Each parameter substitution must refer to a formal template parameter of the target template signature.
parameterSubstitution->forAll(b | template.parameter->includes(b.formal))
[2] A binding contains at most one parameter substitution for each formal template parameter of the target template signa-
ture.
template.parameter->forAll(p | parameterSubstitution->select(b | b.formal = p)->size() <= 1)
Semantics
The presence of a TemplateBinding relationship implies the same semantics as if the contents of the template owning the 
target template signature were copied into the bound element, substituting any elements exposed as formal template parameters by the corresponding elements specified as actual parameters in this binding. If no actual parameter is 
specified in this binding for a formal parameter, then the default element for that formal template parameter (if specified) 
is used.
Semantic Variation Points
It is a semantic variation point 
 if all formal template parameters must be bound as part of a binding (complete binding), or 
 if a subset of the formal template parameters may be bound in a binding (partial binding). 
548                 UML Superstructure 2.0 Draft Adopted SpecificationIn case of complete binding, the bound element may have its own formal template parameters, and these template 
parameters can be provided as actual parameters of the binding. In case of partial binding, the unbound formal template 
parameters are formal template parameters of the bound element. 
Notation
A TemplateBinding is shown as a dashed arrow with the tail on the bound element and the arrowhead on the template and the keyword <<bind>>. The binding information is generally displayed as a comma-separated list of template parameter substitutions:
template-parameter-substitition  : template-parameter-name  ‘->’ actual-template-parameter
where the syntax of template-parameter-name  depends on the kind of parameteredElement for this template parameter 
substitution and of actual-template-parameter  depend upon the kind of element. See ParameterableElement (and its 
subclasses).
Examples
For examples of templates, the reader is referred to those sections which deal with specializations of TemplateableElement, in particular ClassifierTemplate and PackageTemplate.
17.5.4 TemplateParameter
A template parameter exposes a parameterable element as a formal template parameter of a template.
Description
TemplateParameter references a ParameterableElement which is exposed as a formal template parameter in the containing 
template.
Attributes
No additional attributes
Associations
 default : ParameterableElement[0..1]The element that is the default for this formal template parameter.
 ownedDefault : ParameterableElement[0..1]The element that is owned by this template parameter for the purpose of pro-
viding a default. Subsets default and Element::ownedElement.
 ownedParameteredElement : ParameterableElement[0..1]The element that is owned by this template parameter. Subsets 
parameteredElement and Element::ownedElement.
 parameteredElement : ParameterableElement[1]The element exposed by this template parameter. signature : TemplateSignature[1]The template signature that owns this template parameter. Subsets Element::owner.
Constraints
[1]  The default must be compatible with the formal template parameter.
default->notEmpty() implies default->isCompatibleWith(parameteredElement)
[2] The default can only be owned if the parametered element is not owned.
ownedDefault->notEmpty() implies ownedParameteredElement->isEmpty()
UML Superstructure 2.0 Draft Adopted Specification        549Semantics
A TemplateParameter references a ParameterableElement that is exposed as a formal template parameter in the containing 
template. This parameterable element is meaningful only within the template, or other templates that may have access to 
its internals (e.g. if the template supports specialization). The exposed parameterable element may not be used in other 
parts of the model. A TemplateParameter may own the exposed ParameterableElement in situations where that element is only referenced from within the template.
Each the exposed element constrains the elements that may be substituted as actual parameters in a binding.A TemplateParameter may reference a ParameterableElement as the default for this formal parameter in any binding that 
does not provide an explicit substitution. The TemplateParameter may own this default ParameterableElement in 
situations where the exposed ParameterableElement is not owned by the TemplateParameter.
Notation
The general notation for a template parameter is a string displayed within the template parameter list for the template:
template-parameter ::= template-parameter-name [ ‘:‘ parameter-kind  ] [‘=’ default ]
where parameter-kind  is the name of the metaclass for the exposed element. The syntax of template-parameter-name  
depends on the kind of parameteredElement for this template parameter substitution and of default  depend upon the kind 
of element. See ParameterableElement (and its subclasses).
Examples
See TemplateableElement.
17.5.5 TemplateParameterSubstitution
A template parameter substitution relates the actual parameter(s) to a formal template parameter as part of a template 
binding.
Description
TemplateParameterSubstitution associates one or more actual parameters with a formal template parameter within the context of a TemplateBinding.
Attributes
No additional attributes
Associations
 actual : ParameterableElement[1..*]The elements that are the actual parameters for this substitution.
 binding : TemplateBinding[1] The template binding that owns this substitution. Subsets Element::owner formal : TemplateParameter[1] The formal template parameter that is associated with this substitution. ownedActual : ParameterableElement[1..*] The actual parameters that are owned by this substitution. Subsets Ele-
ment::ownedElement and actual.
550                 UML Superstructure 2.0 Draft Adopted SpecificationConstraints
[1]  The actual parameter must be compatible with the formal template parameter, e.g. the actual parameter for a class template  
parameter must be a class.
actual->forAll(a | a.isCompatibleWith(formal.parameteredElement))
Semantics
A TemplateParameterSubstitution specifies the set of actual parameters to be substituted for a formal template parameter 
within the context of a template binding.
Notation
See TemplateBinding.
Examples
See TemplateBinding.
17.5.6 TemplateSignature
A template signature bundles the set of formal template parameters for a templated element.
Description
A TemplateSignature is owned by a TemplateableElement and has one or more TemplateParameters that define the signature for binding this template. A TemplateSignature may reference a set of nested template signatures to reflect the 
hierarchical nature of a template.
Attributes
No additional attributes.
Associations
 ownedParameter : TemplateParameter[*] The formal template parameters that are owned by this template signature. Sub-
sets parameter and Element::ownedElement.
 parameter : TemplateParameter[1..*] The complete set of formal template parameters for this template signature. template : TemplateableElementr[1]The element that owns this template signature. Subsets Element::owner.
Constraints
[1]  Parameters must own the elements they parameter or those elements must be owned by the element being templated.
templatedElement.ownedElement->includesAll(parameter.parameteredElement - parameter.ownedParameteredElement)
[2] parameter are the owned parameter.
parameter = ownedParameter
Semantics
A TemplateSignature specifies the set of formal template parameters for the associated templated element. The formal 
template parameters specify the elements that may be substituted in a binding of the template.
UML Superstructure 2.0 Draft Adopted Specification        551There are constraints on what may be parametered by a template parameter. Either the parameter owns the parametered 
element, or the element is owned, directly or indirectly, by the template.  Subclasses of TemplateSignature can add 
additional rules constraining what a parameter can reference in the context of a particular kind of template.
Notation
See TemplateableElement for a description of how the template parameters are shown as part of the notation for the template.
Examples
See TemplateableElement.
ClassifierTemplates
The Classifier templates diagram specifies the abstract mechanisms that support defining classifier templates, bound 
classifiers, and classifier template parameters. Specific subclasses of Classifier must also specialize one or more of the 
abstract metaclasses defined in this diagram in order to expose these capabilities in a concrete manner.
Figure 429 - Classifier templatesTemplateableElement
(from Templates)
TemplateSignature
(from Templates)
ParameterableElement
(f ro m Te mp l a t e s)
TemplateParameter
(from Templates )RedefinableT emplateSignature
**
*extendedSignature*
{subsets redefinedElement}
*+/inheritedParameter
* {subsets parameter}Class ifier
0..1 1+ownedSignature +classifier
1{subsets redefinitionContext,
subsets templatedElement}
Clas sifierTemplateParameter
allowSubstitutable : Boolean = true1
0..1+parameteredElement 1
+parameter 0..10..1RedefinableElement
(from Kernel) Classifier
(from Kernel)
552                 UML Superstructure 2.0 Draft Adopted Specification17.5.7 Classifier (as specialized)
Classifier is defined to be a kind of templateable element so that a classifier can be parameterized, and as a kind of 
parameterable element so that a classifier that can be exposed as a formal template parameter, and provided as an actual 
parameter in a binding of a template.
Description
Classifier specializes Kernel::Classifier TemplateableElement and ParameterableElement to specify that a classifier can be parameterized, be exposed as a formal template parameter, and can be specified as an actual parameter in a binding of a 
template.
A classifier with template parameters is often called a template classifier, while a classifier with a binding is often called 
a bound classifier.
By virtue of Classifier being defined here, all subclasses of Classifier (such as Class, Collaboration, Component, 
Datatype, Interface, Signal and Use Cases) can be parameterized, bound and used as template parameters. The same holds for Behavior as a subclass of Class, and thereby all subclasses of Behavior (such as Activity, Interaction, Statemachine).
Attributes
No additional attributes.
Associations
 ownedSignature : RedefinableTemplateSignature[0..1]The optional template signature specifying the formal template 
parameters. Subsets Element::ownedElement.
 parameter : ParameterableElement [0..1]The template parameter that exposes this element as a formal parameter. Rede-
fines ParameterableElement::parameter.
Constraints
No additional constraints.
Additional Operations
[1]  The query isTemplate() returns whether this templateable element is actually a template.
Classifier::isTemplate() : Boolean;
isTemplate = TemplatableElement::isTemplate() or general->exists(isTemplate())
Semantics
Classifier in general
Classifier provides the abstract mechanism that can be specialized to support subclass of Classifiers to be templates, 
exposing subclasses of Classifier as formal template parameters, and as actual parameters in a binding of a template.
Classifier as a kind of templateable element provides the abstract mechanism that can be specialized by subclasses of 
Classifier to support being defined as a template, or being bound to a template.
A bound classifier may have contents in addition to those of the template classifier. In this case the semantics are 
equivalent to inserting an anonymous general classifier which contains the contents, and the bound classifier is defined to 
be a specialization this anonymous general classifier. This supports the use of elements within the bound classifier as actual parameters in a binding.
UML Superstructure 2.0 Draft Adopted Specification        553A bound classifier may have multiple bindings. In this case the semantics are equivalent to inserting an anonymous 
general bound classifier for each binding, and specializing all these bound classifiers by this (formerly) bound classifier.
The formal template parameters for a classifier include all the formal template parameters of all the templates it 
specializes. For this reason the classifier may reference elements that are exposed as template parameters of the specializes templates.
Collaboration
A Collaboration supports the ability to be defined as a template. A collaboration may be defined to be bound from 
template collaboration(s).
A collaboration template will typically have the types of it parts as class template parameters. Consider the Collaboration 
in Figure 104 on page 159. This Collaboration can be bound from a Collaboration template of the form found in Figure 
434, by means of the binding described in Figure 435. We have here used that the default kind of template parameter is a 
class, i.e., SubjectType and ObserverType are class template parameters.
A bound Collaboration is not the same as a CollaborationOccurrence; in fact, parameterized Collaborations (and binding) 
can not express what CollaborationOccurrences can. Consider the Sale Collaboration in Figure 107 on page 161. It is 
defined by means of two parts (Buyer and Seller) representing roles in this collaboration. The two 
CollaborationOccurrences ’wholesale’ and ‘retail’ in Figure 108 on page 162 cannot be defined as bound Collaborations.
A bound Collaboration is a Collaboration, while a CollaborationOccurrence is not. A CollaborationOccurrence is defined 
by means of RoleBindings, binding parts in a Collaboration (here Buyer and Seller) to parts in another classifier (here 
broker, produce and consumer in NrokeredSale) with the semantics that the interaction described in Sale will occur 
between broker, producer and consumer. Binding eventual Buyer and Seller part template parameters (of a Sale Collaboration template) to broker and producer would just provide that the parts broker and producer are visible within 
the bound Sale Collaboration. And anyway, even if Sale had two part template parameters Buyer and Seller, it could not 
use these for defining an internal structure as is the case in Figure 108 on page 162. Parameters, by the very nature, represent elements that are defined ‘outside’ a Collaboration template and can therefore not be parts of an internal 
structure of the Collaboration template.
Semantic Variation Points
If template parameter constraints apply, then the actual classifier is constrained as follows:
  if the classifier template parameter has a generalization, then an actual classifier must have generalization with the 
same general classifier
  if the classifier template parameter has a substitution, then an actual classifier must have a substitution with the same 
contract
  if the classifier template parameter has neither a generalization nor a substitution, then an actual classifier can be any 
classifier.
If template parameter constraints do not apply, then an actual classifier can be any classifier.
Notation
See ClassifierTemplateParameter for a description of how a parameterable classifier is displayed as a formal template 
parameter.
See TemplateableElement for the general notation for displaying a template and a bound element.
554                 UML Superstructure 2.0 Draft Adopted SpecificationWhen a bound classifier is used directly as the type of an attribute, then < classifier expression > acts as the type of the 
attribute in the notation for an attribute: 
[visibility ] [/] name [: type ] [multiplicity ] [= default ] [{ property-string } ]
When a bound classifier is used directly as the type of a part, then < classifier-expression>  acts as the classname of the 
part in the notation for a part: 
{{ [ name  ] ‘:’ classname  } | name  } [ ‘[‘ multiplicity ‘ ]’ ]
Presentation Options
Collaboration extends the presentation option for bound elements described under TemplateableElement so that the 
binding information can be displayed in the internal structure compartment.
Examples
Class templates
As Classifier is an abstract class, the following example is an example of concrete subclass (Class) of Classifier being a 
template.
The example shows a class template (named FArray) with two formal template parameters. The first formal template 
parameter (named T) is an unconstrained class template parameter. The second formal template parameter (named k) is an integer expression template parameter that has a default of 10. There is also a bound class (named AddressList) which 
substitutes the Address for T and 3 for k.
Figure 430 - Template Class and Bound Class
The following figure shows an anonymous bound class that substitutes the Point class for T. Since there is to substitution 
for k, the default (10) will be used.
Figure 431 - Anonymous Bound ClassFArray
contents: T [0..k]T, k : IntegerExpression = 10
AddressList<<bind>> <T -> Address, k -> 3>FArray
contents: T [0..k]T, k : IntegerExpression = 10
AddressList<<bind>> <T -> Address, k -> 3>
FArray<T -> Point>
UML Superstructure 2.0 Draft Adopted Specification        555The following figure shows a template class (named Car) with two formal template parameters. The first formal template 
parameter (named CarEngine) is a class template parameter that is constrained to conform to the Engine class. The second 
formal template parameter (named n) is an integer expression template parameter.
Figure 432 - Template Class with a constrained class parameter
The following figure shows a bound class (named DieselCar) that binds CarEngine to DieselEngine and n to 2.
Figure 433 - Bound Class
Collaboration templates
The example below shows a collaboration template (named ObserverPattern) with two formal template parameters 
(named SubjectType and ObserverType). Both formal template parameters are unconstrained class template parameters.
Figure 434 - Template Collaboration
The following figure shows a bound collaboration (named Observer) which substitutes CallQueue for SubjectType, and 
SlidingBarIcon for ObserverType.CarCarEngine > Engine, n : IntegerExpression
e : CarEngine dw : Wheel[n + 1]
DieselCar : Car<CarEngine -> DieselEngine, n -> 2>
ObserverPattern
Observer : ObserverType Subject : SubjectTypeSubjectType, ObserverType
556                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 435 - Bound Collaboration
17.5.8 ClassifierTemplateParameter
A classifier template parameter exposes a classifier as a formal template parameter.
Description
ClassifierTemplateParameter is a template parameter where the parametered element is a Classifier in its capacity of being 
a kind of ParameterableElement.
Attributes
 allowSubstitutable : Boolean[1]Constrains the required relationship between an actual parameter and the parameteredEle-
ment for this formal parameter. Default is true.
Associations
 parameteredElement : Classifier[1]The parameterable classifier for this template parameter. Redefines TemplateParame-
ter::parameteredElement.
Constraints
No additional constraints.
Semantics
See Classifier for additional semantics related to the compatibility of actual and formal classifier parameters.
Notation
A classifier template parameter extends the notation for a template parameter to include an optional type constraint:
classifier- template-parameter ::= parameter [ ‘:‘ parameter-kind  ] [‘>’ constraint ] [‘=’ default ]
parameter  ::= parameter-name
constraint  ::= [‘{contract }’] classifier-name
default  ::= classifier-name
The parameter-kind  indicates the metaclass of the parametered element. It may be suppressed if it is ‘class’. Observer
ObserverPattern<SubjectType \ CallQueue, ObserverType \ SlidingBarIcon>
UML Superstructure 2.0 Draft Adopted Specification        557The classifier-name  of constraint  designates the type constraint of the parameter, which reflects the general classifier for 
the parametered element for this template parameter. The ‘contract’ option indicates that allowsSubstitutable is true, 
meaning the actual parameter must be a classifier that may substitute for the classifier designated by the classifier-name. A classifier template parameter with a constraint but without ‘contract’ indicates that the actual classifier must be a 
specialization of the classifier designated by the classifier-name .
Examples
See Classifier.
17.5.9 RedefinableTemplateSignature
A redefinable template signature supports the addition of formal template parameters in a specialization of a template 
classifier.
Description
RedefinableTemplateSignature specializes both TemplateSignature and RedefinableElement in order to allow the addition of new formal template parameters in the context of a specializing template Classifier.
Attributes
No additional attributes.
Associations
 classifier : Classifier[1] The classifier that owns this template signature. Subsets RedefinableElement::redefini-
tionContext and Template::templatedElement.
 / inheritedParameter : TemplateParameter[*]The formal template parameters of the extendedSignature. Subsets Tem-
plate::parameter.
 extendedSignature : RedefinableTemplateSignature[*]The template signature that is extended by this template signature. 
Subsets RedefinableElement::redefinedElement.
Constraints
[1]  The inherited parameters are the parameters of the extended template signature.
inheritedParameter = if extendedSignature->isEmpty() then Set{} else extendedSignature.parameter endif
Additional Operations
[1]  The query isConsistentWith() specifies, for any two RedefinableTemplateSignatures in a context in which redefinition is 
possible, whether redefinition would be logically consistent. A redefining template signature is always consistent with a redefined template signature, since redefinition only adds new formal parameters.
RedefineableTemplateSignature::isConsistentWith(redefinee: RedefinableElement): Boolean;
pre: redefinee.isRedefinitionContextValid(self)
isConsistentWith = redefinee.oclIsKindOf(RedefineableTemplateSignature)
Semantics
A RedefinableTemplateSignature may extend an inherited template signature in order to specify additional formal 
template parameters that apply within the templateable classifier that owns this RedefinableTemplateSignature. All the 
formal template parameters of the extended signatures are included as formal template parameters of the extending 
signature, along with any parameters locally specified for the extending signature.
558                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
Notation as for redefinition in general.
PackageTemplates
The Package templates diagram supports the specification of template packages and package template parameters.
Figure 436 - Package templates
17.5.10 Package (as specialized)
Description
Package specializes TemplateableElement and PackageableElement specializes ParameterableElement to specify that a 
package can be used as a template and a PackageableElement as a template parameter.
Attributes
No additional attributes
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
A Package supports the ability to be defined as a template, and PackageableElements may, therefore, be parametered in a package template. A package template parameter may refer to any element owned or used by the package template, or 
templates nested within it, and so on recursively. That is, there are no special rules concerning how 
A package may be defined to be bound to one or more template packages. The semantics for these bindings is as 
described in the general case, with the exception that we need to spell out the rules for merging the results of multiple bindings. In that case, the effect is the same as taking the intermediate results and merging them into the eventual result 
using package merge. This is illustrated by the example below.
Notation
See TemplateableElement for a description of the general notation that is defined to support these added capabilities.ParameterableElement
(from Templates)TemplateableElement
(from Templates)
Package PackageableElement
UML Superstructure 2.0 Draft Adopted Specification        559Examples
The example below shows a package template (named ResourceAllocation) with three formal template parameters. All 
three formal template parameters (named Resource, ResourceKind, and System) are unconstrained class template 
parameters. There is also a bound package (named CarRental) which substitutes Car for Resource, CarSpec for 
ResourceKind, and CarRentalSystem for System.
Figure 437 - Template Package and Bound Package
NameExpressions
The NameExpressions diagram supports the use of string expressions to specify the name of a named element.ResourceAllocation Resource,
ResourceKind,
System
Resource
Resource
KindSystemAllocation
RequestTimeSlotresource
kindtimeSlot
kind requestallocation
* resource1
11
11 request
**resource
kind*
*
CarRental<<bind>>
<Resource -> Car, ResourceKind -> CarSpec, System -> CarRentalSystem>
560                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 438 - Name expression
17.5.11 NamedElement (as specialized)
A named element is extended to support using a string expression to specify its name. This allows names of model 
elements to involve template parameters. The actual name is evaluated from the string expression only when it is sensible to do so, e.g. when a template is bound.
Description
NamedElement specializes Kernel::NamedElement and adds a composition association to Expression.
Attributes
No additional attributes.
Associations
 nameExpression : Expression [0..1] The expression used to define the name of this named element.
Constraints
[1]  The name expression must be a string expression.
nameExpression->notEmpty() implies nameExpression.type = String
[2] The name is derived from the name expression only in the case that the nameExpression is a string literal.
nameExpression.oclIsKindOf(LiteralString) implies name = nameExpression.value
Semantics
A NamedElement may, in addition to a name, be associated with a string expression. This expression is used to calculate the name in the special case when it is a string literal. This allows string expressions, whose sub-expressions may be 
parametered elements, to be associated with named elements in a template. When a template is bound, the sub-
expressions are substituted with the actuals substituted for the template parameters. In many cases, the resultant expression will be a string literal (if we assume that a concatenation of string literals is itself a string literal), in which  
case this will provide the name of the named element.
A NamedElement may have both a name and a name expression associated with it. In which case, the name can be used 
as an alias for the named element, which will surface, for example, in an OCL string. This avoids the need to use string expressions in surface notation, which is often cumbersome, although it doesn’t preclude it.NamedElement
(from Kernel)Expression
(from Kernel)
NamedElement
name : String [0..1]Expression
0..1 0.. 1nameExpression
0..1
{subsets ownedElement}namedElement
0.. 1
{subsets owner}
UML Superstructure 2.0 Draft Adopted Specification        561Notation
The expression associated with a named element can be shown in two ways, depending on whether an alias is required or 
not. Both notations are illustrated in Figure 439.
No alias:  The string expression appears as the name of the model element.
With alias:  Both the the string expression and the alias is shown wherever the name usually appears. The alias is given 
first and the string expression underneath.
In both cases the string expression appears between $ signs. The specification of expressions in UML supports the use of 
alternative string expression languages in the abstract syntax - they have to have String as their type and can be some 
structure of operator expressions with operands. The notation for this is discussed in the section on Expressions. In the 
context of templates, sub-expressions of a string expression (usually string literals) which are parametered in the template are shown between angle brackets (see section on ValueSpecificationTemplateParameters).
Examples
The figure shows a modified version of the ResourceAllocation package template where the first two formal template 
parameters have been changed to be string expression parameters. These formal template parameters are used within the package template to name some of the classes and association ends. The figure also shows a bound package (named TrainingAdmin) that has two bindings to this ResourceAllocation template. The first binding substitutes the string “Instructor”  
for Resource, the string “Qualification” for ResourceKind, and the class TrainingAdminSystem for System. The second binding substitutes the string “Facility” for Resource, the string “FacilitySpecification” for ResourceKind, and the class TrainingAdminSystem is again substituted for System.
The result of the binding includes both classes Instructor, Qualification and InstructorAllocation as well as classes Facility,  
FacilitySpecification and FacilityAllocation. The associations are similarly replicated. Note that Request will have two attributes derived from the single <resourceKind> attribute (shown here by an arrow), namely qualification and facilitySpecification.
562                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 439 - Template Package with string parameters
Operation templates
The Operation templates diagramsupports the specification of operation templates.
Figure 440 - Operation templatesResourceAllocation Resource:StringExpression,
ResourceKind:StringExpression,System
$<Resource>$
$<Resource
Kind>$SystemAllocation
$<Resource>Allocation$
RequestTimeSlotresource
kindtimeSlot
$<resourceKind>$ requestallocation
$<resource>Allocation$
* resource1
11
11 request
**$<resource>$
$<resourceKind>$*
*
TrainingAdmin<<bind>>
<Resource -> "Facility,"ResourceKind -> "FacilitySpecification",
System -> TrainingAdminSystem><<bind>>
<Resource -> "Instructor",
ResourceKind -> "Qualification",
System -> TrainingAdminSystem>
OperationTemplateableElement
(from  T em pl ate s )
UML Superstructure 2.0 Draft Adopted Specification        56317.5.12 Operation (as specialized)
Description
Class specializes TemplateableElement in order to support specification of template operations and bound operations. 
Attributes
No additional attributes
Associations
No additional associations.
Constraints
No additional constraints.
Semantics
An Operation supports the ability to be defined as a template. An operation may be defined to be bound to template 
operation(s).
Notation
The template parameters and template parameter binding of a template operation are two lists in between the name of the operation and the parameters of the operation
visibility name ‘<‘ template-parameter-list ‘>’ ‘<<‘binding-expression-list ‘>>’‘ ( ‘ parameter-list ‘)’ ‘:’ property-string
where template-parameter-list  is a comma-separated list of  template-parameter.
OperationTemplateParameters
The Operation template parameters diagram supports the specification of operation template parameters.
Figure 441 - Operation template parameters
17.5.13 Operation (as specialized)
Description
Operation specializes ParameterableElement to specify that an operation can be exposed as a formal template parameter, 
and provided as an actual parameter in a binding of a template.ParameterableElement
(from Templates)TemplateParameter
(from  T em plates)
Operation OperationTemplateParameter
10..1parameteredElement
1parameter
0..1
564                 UML Superstructure 2.0 Draft Adopted SpecificationAttributes
No additional attributes
Associations
 parameter : ParameterableElement [0..1]The template parameter that exposes this element as a formal parameter. Rede-
fines ParameterableElement::parameter.
Constraints
No additional constraints.
Semantics
An Operation may be exposed by a template as a formal template parameter. Within a template classifier an operation 
template parameter may be used as any other operation defined in an enclosing namespace. Any references to the 
operation template parameter within the template will end up being a reference to the actual operation in the bound classifier. For example, a call to the operation template parameter will be a call to the actual operation.
Notation
See OperationTemplateParameter for a description of the general notation that is defined to support these added capabilities.
Within the notation for formal template parameters and template parameter bindings, an operation is shown as operation-
name  ‘(‘ operation-parameters ‘)’.
17.5.14 OperationTemplateParameter
An operation template parameter exposes an operation as a formal parameter for a template.
Description
OperationTemplateParameter is a template parameter where the parametered element is an Operation.
Attributes
No additional attributes.
Associations
 parameteredElement : Operation[1]The operation for this template parameter. Redefines TemplateParameter::parame-
teredElement.
Constraints
No additional constraints.
Semantics
See Operation for additional semantics related to the compatibility of actual and formal operation parameters.
UML Superstructure 2.0 Draft Adopted Specification        565Notation
An operation template parameter extends the notation for a template parameter to include the parameters for the 
operation:
operation -template-parameter ::= parameter [ ‘:‘ parameter-kind  ] [‘=’ default ]
parameter  ::= operation-name  ( parameter-list  )
default  ::= operation-name ( parameter-list )
ConnectableElement template parameters
The Connectable element template parameters package supports the specification of ConnectableElement template 
parameters.
17.5.15 ConnectableElement (as specialized)
A connectable element may be exposed as a connectable element template parameter.
Description
ConnectableElement is the connectable element of a ConnectableElementTemplateParameter.
Attributes
No additional attributes.
Associations
 parameter : ConnectableElementTemplateParameter [0..1]The ConnectableElementTemplateParameter for this Connect-
ableElement parameter. Redefines TemplateParameter::parameter.
Constraints
No additional constraints.
Semantics
No additional semantics.Figure 442 - Connectable element template parametersParam eterableElem ent
(from Templates)Template Param eter
( fr om Templates )
ConnectableElement ConnectableElementTemplate
Para meter
0..1 110 . . 1parameter parameteredElement
566                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
No additional notation.
17.5.16 ConnectableElementTemplateParameter
A connectable element template parameter exposes a connectable element as a formal parameter for a template.
Description
ConnectableElementTemplateParameter is a template parameter where the parametered element is a ConnectableElement.
Attributes
No additional attributes.
Associations
 parameteredElement : ConnectableElement[1]The ConnectableElement for this template parameter. Redefines Tem-
plateParameter::parameteredElement.
Constraints
No additional constraints.
Semantics
No additional semantics.
Notation
No additional notation.
PropertyTemplateParameters
The Property template parameters diagram supports the specification of property template parameters.
Figure 443 - The elements defined in the PropertyTemplates packageParameterableElement
(f ro m Te mp la te s)
Property
UML Superstructure 2.0 Draft Adopted Specification        56717.5.17 Property (as specialized)
Description
Property specializes ParameterableElement to specify that a property can be exposed as a formal template parameter, and 
provided as an actual parameter in a binding of a template.
Attributes
No additional attributes
Associations
No additional associations.
Constraints
[1]  A binding of an property template parameter representing an attribute must be to an attribute.
Additional Operations
[1]  The query isCompatibleWith() determines if this parameterable element is compatible with the specified parameterable 
element. By default parameterable element P is compatible with parameterable element Q if the kind of P is the same or a subtype as the kind of Q. In addition, for properties, the type must be conformant with the type of the specified parameter-able element.
Property::isCompatibleWith(p : ParameterableElement) : Boolean;
isCompatibleWith = p->oclIsKindOf(self.oclType) and self.type.conformsTo(p.oclAsType(TypedElement).type)
Semantics
A Property may be exposed by a template as a formal template parameter. Within a template a property template 
parameter may be used as any other property defined in an enclosing namespace. Any references to the property template parameter within the template will end up being a reference to the actual property in the bound element.
Notation
See ParameterableElement for a description of the general notation that is defined to support these added capabilities.
ValueSpecificationTemplateParametersThe ValueSpecification template parameters diagram supports the specification of value specification template 
parameters.
Figure 444 - ValueSpecification template parametersParameterableElement
(from Templates)
ValueSpecification
568                 UML Superstructure 2.0 Draft Adopted Specification17.5.18 ValueSpecification (as specialized)
Description
ValueSpecification specializes ParameterableElement to specify that a value specification can be exposed as a formal 
template parameter, and provided as an actual parameter in a binding of a template.
Attributes
No additional attributes.
Associations
 typeConstraint : Classifier[0..1] Optional specification of the type of the value.
Constraints
No additional attributes.
Additional Operations
[1]  The query isCompatibleWith() determines if this parameterable element is compatible with the specified parameterable 
element. By default parameterable element P is compatible with parameterable element Q if the kind of P is the same or a subtype as the kind of Q. In addition, for ValueSpecification, the type must be conformant with the type of the specified parameterable element.
Property::isCompatibleWith(p : ParameterableElement) : Boolean;
isCompatibleWith = p->oclIsKindOf(self.oclType) and self.type.conformsTo(p.oclAsType(TypedElement).type)
Semantics
The semantics is as in the general case. However, two aspects are worth commenting on. The first is to note that a value 
specification may be an expression with substructure (i.e. an instance of the Expression class), in which case a template parameter may expose a subexpression, not necessarily the whole expression itself. An example of this is given in Figure 
432 where the paremetered element with label ‘n’ appears within the expression ‘n+1’. Secondly, to note that by 
extending NamedElement to optionally own a name expression, strings that are part of these named expressions may be parametered.
Notation
Where a parametered ValueSpecification is used within an expression, the name of the parameter is used instead of any symbol (in case of an Expression) or value (in case of a Literal) would otherwise appear.
UML Superstructure 2.0 Draft Adopted Specification        56918 Profiles
18.1 Overview
The Profiles package contains mechanisms that allow metaclasses from existing metamodels to be extended to adapt them 
for different purposes. This includes the ability to tailor the UML metamodel for different platforms (such as J2EE or .NET) or domains (such as real-time or business process modeling). The profiles mechanism is consistent with the OMG 
Meta Object Facility (MOF).
Extensibility
The profiles mechanism is not a first-class extension mechanism, i.e., it does not allow for modifying existing 
metamodels. Rather, the intention of profiles is to give a straightforward mechanism for adapting an existing metamodel with constructs that are specific to a particular domain, platform, or method. Each such adaption is grouped in a profile. 
It is not possible to take away any of the constraints that apply to a metamodel such as UML using a profile, but it is 
possible to add new constraints that are specific to the profile. The only other restrictions are those inherent in the profile s 
mechanism; there is nothing else that is intended to limit the way in which a metamodel is customized.
First-class extensibility is handled through MOF, where there are no restrictions on what you are allowed to do with a 
metamodel: you can add and remove metaclasses and relationships as you find necessary. Of course, it is then possible to 
impose methodology restrictions that you are not allowed to modify existing metamodels, but only extend them. In this case, the mechanisms for first-class extensibility and profiles start coalescing. 
There are several reasons why you may want to customize a metamodel:
  Give a terminology that is adapted to a particular platform or domain (such as capturing EJB terminology like home 
interfaces, enterprise java beans, and archives).
  Give a syntax for constructs that do not have a notation (such as in the case of actions).
  Give a different notation for already existing symbols (such as being able to use a picture of a computer instead of the 
ordinary node symbol to represent a computer in a network).
  Add semantics that is left unspecified in the metamodel (such as how to deal with priority when receiving signals in a 
statemachine).
  Add semantics that does not exist in the metamodel (such as defining a timer, clock, or continuous time)
  Add constraints that restrict the way you may use the metamodel and its constructs (such as disallowing actions from 
being able to execute in parallel within a single transition).
  Add information that can be used when transforming a model to another model or code (such as defining mapping 
rules between a model and Java code).
Profiles and Metamodels
There is no simple answer for when you should create a new metamodel and when you instead should create a new 
profile. 
570                 UML Superstructure 2.0 Draft Adopted Specification18.2 Abstract syntax
Package structure
The classes of the Profiles package are depicted in Figure 446, and subsequently specified textually. 
18.3 Class descriptions
18.3.1 Extension (from Profiles)
An extension is used to indicate that the properties of a metaclass are extended through a stereotype, and gives the ability 
to flexibly add (and later remove) stereotypes to classes.
Description
Extension is a kind of Association. One end of the Extension is an ordinary Property and the other end is an ExtensionEnd. The former ties the Extension to a Class, while the latter ties the Extension to a Stereotype that extends the Class. Figure 445 - Dependencies between packages described in this chapter
Figure 446 - The elements defined in the Profiles packageConstructs
Profiles
Class Exte nsion
/ isRequired : Boolean
* 1/extension
*/metaclass
1/ Package ExtensionEnd
1 1ownedEnd
1 1ProfileApplication
1*1appliedProfile
*{subsets packageImport}
Ster eotype
1*
type
1*
ElementImport
(from Constructs)
PackageImport
(from Constructs)Profile
1*
importedProfile
1{subsets importedPackage}*
*1ownedStereotype
*{subsets ownedMember} 1
* 0..1metaclassReference
*{subsets elementImport}0..1
* 0..1metamodelReference
*{subsets packageImport}0..1Package
(from Constructs)PackageImport
(fr om Constr ucts)Class
(from Cons tructs)Property
( fr om C ons tr uc ts )As sociation
(from Constructs )
UML Superstructure 2.0 Draft Adopted Specification        571Attributes
 / isRequired: Boolean Indicates whether an instance of the extending stereotype must be created when an 
instance of the extended class is created. The attribute value is derived from the multiplic-ity of Extension::ownedEnd ; a multiplicity of 1 means that isRequired is true, but other-
wise it is false . Since the default multiplicity of an ExtensionEnd is 0..1, the default value 
of isRequired is false . 
Associations
 ownedEnd: ExtensionEnd [1] References the end of the extension that is typed by a Stereotype. Redefines Associa-
tion::ownedEnd .
 / metaclass: Class [1] References the Class that is extended through an Extension. The property is derived from 
the type of the memberEnd that is not the ownedEnd.
Constraints
[1]  The non-owned end of an Extension is typed by a Class.
metaclassEnd()->notEmpty() and metaclass()->oclIsKindOf(Class)
[2] An Extension is binary, i.e., it has only two memberEnds.
memberEnd->size() = 2
Additional Operations
[1]  The query metaclassEnd() returns the Property that is typed by a metaclass (as opposed to a stereotype)
Extension::metaclassEnd(): Property;
metaclassEnd = memberEnd->reject(ownedEnd)
[2] The query metaclass() returns the metaclass that is being extended (as opposed to the extending stereotype).
Extension::metaclass(): Class;
metaclass = metaclassEnd().type
[3] The query isRequired() is true if the owned end has a multiplicity with the lower bound of 1.
Extension::isRequired(): Boolean;isRequired = (ownedEnd->lowerBound() = 1)
Semantics
A required extension means that an instance of a stereotype must always be linked to an instance of the extended 
metaclass. The instance of the stereotype is typically deleted only when either the instance of the extended metaclass is deleted, or when the profile defining the stereotype is removed from the applied profiles of the package. The model is not 
well-formed if an instance of the stereotype is not present when isRequired is true.
A non-required extension means that an instance of a stereotype can be linked to an instance of an extended metaclass at 
will, and also later deleted at will; however, there is no requirement that each instance of a metaclass be extended. An instance of a stereotype is further deleted when either the instance of the extended metaclass is deleted, or when the 
profile defining the stereotype is removed from the applied profiles of the package.
In order to be able to navigate to the extended metaclass when writing constraints, the end must have a name. If no name 
is given, the default name is baseClass.
572                 UML Superstructure 2.0 Draft Adopted SpecificationNotation
The notation for an Extension is an arrow pointing from a Stereotype to the extended Class, where the arrowhead is 
shown as a filled triangle. An Extension may have the same adornments as an ordinary association, but navigability 
arrows are never shown. If isRequired is true, the property {required} is shown near the ExtensionEnd. 
Presentation Option
It is possible to use the multiplicities 0..1 or 1 on the ExtensionEnd as an alternative to the property {required}. Due to 
how isRequired is derived, the multiplicity 0..1 corresponds to isRequired being false . 
Style Guidelines
Adornments of an Extension are typically elided. 
Examples
In Figure 448, a simple example of using an extension is shown, where the stereotype Home  extends the metaclass 
Interface . 
An instance of the stereotype Home  can be added to and deleted from an instance of the class Interface  at will, which 
provides for a flexible approach of dynamically adding (and removing) information specific to a profile to a model.
In Figure 449, an instance of the stereotype Bean  always needs to be linked to an instance of class Component  since the 
Extension is defined to be required. (Since the stereotype Bean  is abstract, this means that an instance of one of its 
concrete subclasses always has to be linked to an instance of class Component .) The model is not well-formed unless such 
a stereotype is applied. This provides for a way to express extensions that should always be present for all instances of the base metaclass depending on which profiles are applied. 
Changes from UML 1.4
Extension did not exist as a metaclass in UML 1.x.Figure 447 - The notation for an Extension
Figure 448 - An example of using an Extension
Figure 449 - An example of a required Extension«stereotype»
HomeInterface
Component«stereotype»
Bean{required}
UML Superstructure 2.0 Draft Adopted Specification        573Occurrences of Stereotype::baseClass of UML 1.4 is mapped to an instance of Extension, where the ownedEnd is typed 
by Stereotype and the other end is typed by the metaclass that is indicated by the baseClass.
18.3.2 ExtensionEnd (from Profiles)
An extension end is used to tie an extension to a stereotype when extending a metaclass.
Description
ExtensionEnd is a kind of Property that is always typed by a Stereotype. 
An ExtensionEnd is never navigable. If it was navigable, it would be a property of the extended classifier. Since a profile 
is not allowed to changed the referenced metamodel, it is not possible to add properties to the extended classifier. As a 
consequence, an ExtensionEnd can only be owned by an Extension.
The aggregation of an ExtensionEnd is always composite.The default multiplicity of an ExtensionEnd is 0..1.
Attributes
No additional attributes.
Associations
 type: Stereotype [1] References the type of the ExtensionEnd. Note that this association restricts the possible 
types of an ExtensionEnd to only be Stereotypes. Redefines Property::type . 
Constraints
[1]  The multiplicity of ExtensionEnd is 0..1 or 1. 
(self->lowerBound() = 0 or self->lowerBound() = 1) and self->upperBound() = 1
[2] The aggregation of an ExtensionEnd is composite.
self.aggregation = #composite
Additional Operations
[1]  The query lowerBound() returns the lower bound of the multiplicity as an Integer. This is a redefinition of the default 
lower bound, which was 1.
ExtensionEnd::lowerBound() : [Integer];
lowerBound = if lowerValue->isEmpty() then  0 else lowerValue->IntegerValue() endif
Semantics
No additional semantics.
Notation
No additional notation.
Examples
See “Extension (from Profiles)” on page 570. 
574                 UML Superstructure 2.0 Draft Adopted SpecificationChanges from UML 1.4
ExtensionEnd did not exist as a metaclass in UML 1.4. See “Extension (from Profiles)” on page 570 for further details.
18.3.3 Class (from Constructs, Profiles)
Description
Class has derived association that indicates how it may be extended through one or more stereotypes. 
Because a stereotype is a class, it is possible to apply a stereotype not only to classes, but also to definitions of 
stereotypes.
Attributes
No additional attributes.
Associations
 / extension: Extension [*] References the Extensions that specify additional properties of the metaclass. The prop-
erty is derived from the extensions whose memberEnds are typed by the Class.
Constraints
No additional constraints.
Semantics
No additional semantics.
Notation
No additional notation.
Presentation Option
A Class that is extended by a Stereotype may have the optional keyword «metaclass» shown above or before its name.
Examples
In Figure 450, an example is given where it is made explicit that the extended class Interface  is in fact a metaclass (from 
a reference metamodel). 
Changes from UML 1.4
A link typed by UML 1.4 ModelElement::stereotype is mapped to a link that is typed by Class::extension.Figure 450 - Showing that the extended class is a metaclass«metaclass»
Interface«stereotype»
Remote
UML Superstructure 2.0 Draft Adopted Specification        57518.3.4 Package (from Constructs, Profiles)
Description
A package can have one or more ProfileApplications to indicate which profiles have been applied.
Because a profile is a package, it is possible to apply a profile not only to packages, but also to profiles.
Attributes
No additional attributes.
Associations
 appliedProfile: ProfileApplication [*]References the ProfileApplications that indicate which profiles have been applied to 
the Package. Subsets Package::packageImport .
Constraints
No additional constraints.
Semantics
No additional semantics.
Notation
No additional notation.
Changes from UML 1.4
In UML 1.4, it was not possible to indicate which profiles were applied to a package.
18.3.5 Profile (from Profiles)
A profile defines limited extensions to a reference metamodel with the purpose of adapting the metamodel to a specific 
platform or domain. 
Description
A Profile is a kind of Package that extends a reference metamodel. The primary extension construct is the Stereotype, which are defined as part of Profiles.
A profile introduces several constraints, or restrictions, on ordinary metamodeling through the use of the metaclasses 
defined in this package.
A profile is a restricted form of a metamodel that must always be related to a reference metamodel , such as UML, as 
described below. A profile cannot be used without its reference metamodel, and defines a limited capability to extend 
metaclasses of the reference metamodel. The extensions are defined as stereotypes that apply to existing metaclasses.
Attributes
No additional attributes.
576                 UML Superstructure 2.0 Draft Adopted SpecificationAssociations
 metaclassReference: ElementImport [*]References a metaclass that may be extended. Subsets Package::elementImport .
 metamodelReference: PackageImport [*] References a package containing (directly or indirectly) metaclasses that may 
be extended. Subsets Package::packageImport . 
 ownedStereotype: Stereotype [*] References the Stereotypes that are owned by the Profile. Subsets Package::ownedMem-
ber.
Constraints
[1]  An element imported as a metaclassReference is not specialized or generalized in a Profile.
self.metaclassReference.importedElement->
select(c | c.oclIsKindOf(Classifier) and
(c.generalization.namespace = self or
(c.specialization.namespace = self) )->isEmpty()
[2] All elements imported either as metaclassReferences or through metamodelReferences are members of the same base ref-
erence metamodel. 
self.metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages())->
union(self.metaclassReference.importedElement.allOwningPackages() )->notEmpty()
Additional Operations
[1]  The query allOwningPackages() returns all the directly or indirectly owning packages.
NamedElement::allOwningPackages(): Set(Package)allOwningPackages = self.namespace->select(p | p.oclIsKindOf(Package))->
union(p.allOwningPackages())
Semantics
A profile by definition extends a reference metamodel or another profile. It is not possible to define a standalone profile 
that does not directly or indirectly extend an existing metamodel. The profile mechanism may be used with any 
metamodel that is created from MOF, including UML and CWM. 
A reference metamodel typically consists of metaclasses that are either imported or locally owned. All metaclasses that 
are extended by a profile have to be members of the same reference metamodel. A tool can make use of the information about which metaclasses are extended in different ways, for example to filter or hide elements when a profile is applied, 
or to provide specific tool bars that apply to certain profiles. However, elements of a package or model cannot be deleted 
simply through the application of a profile. Each profile thus provides a simple viewing mechanism. 
As part of a profile, it is not possible to have an association between two stereotypes or between a stereotype and a 
metaclass unless they are subsets of existing associations in the reference metamodel. However, it is possible to have 
associations between ordinary classes, and from stereotypes to ordinary classes. Likewise, properties of stereotypes may 
not be typed by metaclasses or stereotypes.
Notation
A Profile uses the same notation as a Package, with the addition that the keyword «profile» is shown before or above the name of the Package. Profile::metaclassReference  and Profile::metamodelReference  uses the same notation as 
Package::elementImport  and Package::packageImport , respectively. 
UML Superstructure 2.0 Draft Adopted Specification        577Examples
In Figure 451, a simple example of an EJB profile is shown. 
The profile states that the abstract stereotype Bean  is required to be applied to metaclass Component , which means that an 
instance of either of the concrete subclasses Entity  and Session  of Bean  must be linked to each instance of Component . 
The constraints that are part of the profile are evaluated when the profile has been applied to a package, and need to be 
satisfied in order for the model to be well formed.Figure 451 - Defining a simple EJB profile«profile» EJB
«metaclass»
Interface«stereotype»
Remote
«stereotype»
HomeArtifact«stereotype»
JARComponent«stereotype»
Bean{required}
«stereotype»
Entity«stereotype»
Session
«enumeration»
StateKind{A component
cannot begeneralized orspecialized. }{A Bean mustrealize exactlyone  Homeinterface.}
stateless
statefulstate: StateKind
578                 UML Superstructure 2.0 Draft Adopted SpecificationIn Figure 452, the package Types  is imported from the profile Manufacturer . The data type Color  is then used as the type 
of one of the properties of the stereotype Device , just like the predefined type String is also used. Note that the class 
JavaInteger  may also be used as the type of a property.
If the profile Manufacturer  is later applied to a package, then the types from Types  are also available for use in the 
package to which the profile is applied (since profile application is a kind of import). This means that for example the class JavaInteger  can be used as both a metaproperty (as part of the stereotype Device ) and an ordinary property (as part 
of the class TV). Note how the metaproperty is given a value when the stereotype Device  is applied to the class TV. 
18.3.6 ProfileApplication (from Profiles)
A profile application is used to show which profiles have been applied to a package. 
Description
ProfileApplication is a kind of PackageImport that adds the capability to state that a Profile is applied to a Package.
Attributes
No additional attributes.
Associations
 importedProfile: Profile [1] References the Profiles that is applied to a Package through this ProfileApplication. Sub-
sets PackageImport::importedPackage .Figure 452 - Importing a package from a profile«profile»
Manufacturer
«metaclass»
Class«stereotype»
Device
author: String
color: Colorvolume: JavaIntegerTypes
«enumeration»
Color
redgreenblueJavaInteger
«import»
Factory
«device»
TV
channel: JavaInteger«apply»
«device»
volume=10
UML Superstructure 2.0 Draft Adopted Specification        579Constraints
No additional constraints.
Semantics
One or more profiles may be applied at will to a package that is created from the same metamodel that is extended by the 
profile. Applying a profile means that it is allowed, but not necessarily required, to apply the stereotypes that are defined as part of the profile. It is possible to apply multiple profiles to a package as long as they do not have conflicting 
constraints. If a profile that is being applied depends on other profiles, then those profiles must be applied first.
When a profile is applied, instances of the appropriate stereotypes should be created for those elements that are instances 
of metaclasses with required extensions. The model is not well-formed without these instances.
Once a profile has been applied to a package, it is allowed to remove the applied profile at will. Removing a profile 
implies that all elements that are instances of elements defined in a profile are deleted. A profile that has been applied 
cannot be removed unless other applied profiles that depend on it are first removed. 
Note – The removal of an applied profile leaves the instances of elements from the referenced metamodel intact. It is only the
instances of the elements from the profile that are deleted. This means that for example a profiled UML model can always beinterchanged with another tool that does not support the profile and be interpreted as a pure UML model.
Notation
The names of Profiles are shown using a dashed arrow with an open stick arrowhead from the package to the applied 
profile. The keyword «apply» is shown near the arrow.
If multiple applied profiles have stereotypes with the same name, it may be necessary to qualify the name of the 
stereotype (with the profile name).
Examples
Given the profiles Java  and EJB, Figure 453 shows how these have been applied to the package WebShopping . 
Figure 453 - Profiles applied to a packageWebShopping«profile»
Java«profile»
EJB
«apply»
«apply»
580                 UML Superstructure 2.0 Draft Adopted Specification18.3.7 Stereotype (from Profiles)
A stereotype defines how an existing metaclass (or stereotype) may be extended, and enables the use of platform or 
domain specific terminology or notation in addition to the ones used for the extended metaclass.
Description
Stereotype is a kind of Class that extends Classes through Extensions. 
Just like a class, a stereotype may have properties, which may be referred to as tag definitions. When a stereotype is 
applied to a model element, the values of the properties may be referred to as tagged values.
Attributes
No additional attributes.
Associations
No additional associations.
Constraints
[1]  A Stereotype may only generalize or specialize another Stereotype.
self.generalization.general->forAll(e | e.oclIsKindOf(Stereotype)) and
self.specialization.specific->forAll(e | e.oclIsKindOf(Stereotype))
[2] A concrete Stereotype must directly or indirectly extend a Class.
not self.isAbstract implies  self.extensionEnd->union(self.parents.extensionEnd)->notEmpty()
Semantics
A stereotype is a limited kind of metaclass that cannot be used by itself, but must always be used in conjunction with one of the metaclasses it extends. Each stereotype may extend one or more classes through extensions as part of a profile. 
Similarly, a class may be extended by one or more stereotypes. 
An instance of a stereotype is linked to an instance of an extended metaclass (or stereotype) by virtue of the extension 
between their types.
Notation
A Stereotype uses the same notation as a Class, with the addition that the keyword «stereotype» is shown before or above the name of the Class. 
When a stereotype is applied to a model element (an instance of a stereotype is linked to an instance of a metaclass), the 
name of the stereotype is shown within a pair of guillemets above or before the name of the Stereotype. If multiple 
stereotypes are applied, the names of the applied stereotypes is shown as a comma-separated list with a pair of guillemets. 
Presentation Options
If multiple stereotypes are applied to an element, it is possible to show this by enclosing each stereotype name within a pair of guillemets and list them after each other.
The values of a stereotype that has been applied to a model element can be shown as part of a comment symbol tied to 
the model element. The values from a specific stereotype are optionally preceded with the name of the applied stereotype within a pair of guillemets, which is useful if values of more than one applied stereotype should be shown.
UML Superstructure 2.0 Draft Adopted Specification        581If the extension end is given a name, this name can be used in lieu of the stereotype name within the pair of guillemets 
when the stereotype is applied to a model element. 
It is possible to attach a specific notation to a stereotype that can be used in lieu of the notation of a model element to 
which the stereotype is applied.
Style Guidelines
The first letter of an applied stereotype should not be capitalized. The values of an applied stereotype are normally not shown. 
Examples
In Figure 454, a simple stereotype Clock  is defined to be applicable at will (dynamically) to instances of the metaclass 
Class. 
Note that in order to be able to write constraints on the stereotype Clock that should be applied to the metaclass Class or 
any of its relationships, it is necessary to give the end typed by the metaclass a name for navigation purposes. A typical such name would be for example base .
In Figure 455, an instance specification of the example in Figure 454 is shown. Note that the extension must be 
composite, and that the the derived required attribute in this case is false. Figure 454 - Defining a stereotype
Figure 455 - An instance specification when defining a stereotype«metaclass»
Class«stereotype»
Clock
resolution: Integer
:Class
name="Class":Stereotype
name="Clock"
:Property :Extension :ExtensionEnd
ownedEnd,
memberEndmemberEndtype type
isRequired = falsemetaclass
extensionownedAttribute:Property
name="resolution"
ownedAttribute
isComposite = true isComposite = false:PrimitiveType
name="Integer"type
582                 UML Superstructure 2.0 Draft Adopted SpecificationIn Figure 456, it is shown how the same stereotype Clock  can extend either the metaclass Component or the metaclass 
Class. It is also shown how different stereotypes can extend the same metaclass. 
Figure 457 shows how the stereotype Clock , as defined in Figure 456, is applied to a class called StopWatch . 
Figure 458 shows an example instance model for when the stereotype Clock  is applied to a class called StopWatch . The 
extension between the stereotype and the metaclass results in a link between the instance of stereotype Clock  and the 
(user-defined) class StopWatch . Figure 456 - Defining multiple stereotypes on multiple stereotypes
Figure 457 - Using a stereotype
Figure 458 - Showing values of stereotypes and a simple instance specificiation«metaclass»
Component«stereotype»
Clock
resolution: Integer
«metaclass»
Class«stereotype»
Creator
author: String
date: String{required}
«clock»
StopWatch
«clock»
StopWatch«clock»
resolution = 2
:Class
name="StopWatch":Clock
resolution = 2
UML Superstructure 2.0 Draft Adopted Specification        583Next, two stereotypes, Clock  and Creator , are applied to the same model element, as is shown in Figure 459. Note that the 
attribute values of each of the applied stereotypes can be shown in a comment symbol attached to the model element.
18.4 Diagrams
Structure diagrams
This section outlines the graphic elements that may be shown in structure diagrams, and provides cross references where 
detailed information about the semantics and concrete notation for each element can be found. It also furnishes examples 
that illustrate how the graphic elements can be assembled into diagrams.
Graphical nodes
The graphic nodes that can be included in structure diagrams are shown in Table 23.Figure 459 - Using stereotypes and showing values
Table 23 - Graphic nodes included in structure diagrams
NODE TYPE NOTATION REFERENCE
Stereotype See “Stereotype (from Profiles)” on page 580.
Metaclass See  “Class (from Constructs, Profiles)” on 
page 574
Profile See “Profile (from Profiles)” on page 575.«clock»
resolution = 2
«creator»
author = "Jones"date = "02-04-15"«creator, clock»
StopWatch
«stereotype»
Name
«metaclass»
Name
«profile»
Name
584                 UML Superstructure 2.0 Draft Adopted SpecificationGraphical paths
The graphic paths that can be included in structure diagrams are shown in Table 24.
Table 24 - Graphic paths included in structure diagrams
NODE TYPE NOTATION REFERENCE
Extension See “Extension (from Profiles)” on page 570.
ProfileAppli-
cationSee “ProfileApplication (from Profiles)” on 
page 578
«apply»
UML Infrastructure 2.0 Draft Adopted Specification        585Part IV - Appendices
This section contains the appendices for this specification. 
 Appendix A - Diagrams
 Appendix B - Standard Stereotypes
 Appendix C - Component Profile Examples
 Appendix D - Tabular Notations
 Appendix E - Classifiers Taxonomy
 Appendix F - XMI Serialization and Schema
586                 UML Infrastructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        587Appendix A.Diagrams
This appendix describes the general properties of UML diagrams and how they relate to a UML (repository) model and to 
elements of this. It also introduces the different diagram types of UML. 
A UML model consists of elements such as packages, classes, and associations. The corresponding UML diagrams are 
graphical representations of parts of the UML model. UML diagrams contains graphical elements (nodes connected by paths) that represent elements in the UML model. As an example, two associated classes defined in a package will in a 
diagram for the package be represented by two class symbols and an association path connecting these two class symbols.
Each diagram has a frame , a contents area , and a heading, see Figure 460. 
The frame is a rectangle. The frame is primarily used in cases where the diagrammed element has graphical border 
elements, like ports for classes and components (in connection with composite structures), and entry/exit points on statemachines. In cases where not needed, the frame may be omitted and implied by the border of the diagram area 
provided by a tool. In case the frame is omitted, the headning is also omitted.
The diagram contents area contains the graphical symbols; the primary graphical symbols defines the type of the diagram, 
e.g. a class diagram is a diagram where the primary symbols in the contents area are class symbols.
The heading is a string contained in a name tag (rectangle with cutoff corner) in the upper leftmost corner of the 
rectangle, with the following syntax:
[<kind>]<name>[<parameters>]The heading of a diagram represents the kind, name and parameters of the namespace enclosing or the model element 
owning elements that are represented by symbols in the contents area. Most elements of a diagram contents area represent 
model elements that are defined in the namespace or are owned by another model element. 
As an example, Figure 461 is a class diagram of a package P: classes C1 and C1 are defined in the namespace of the 
package P.Figure 460 <heading>
<contents area>
588                 UML Superstructure 2.0 Draft Adopted SpecificationFigure 462 illustrates that a package symbol for package P (in some containing package CP) may show the same contents 
as the class diagram for the package. i) is a diagram for package CP with a graphical symbols representing the fact that 
the CP package contains a package P. ii) is a class diagram for this package P. Note that the package symbol in i) does not have to contain the class symbols and the assocition symbol; for more realistic models, the package symbols will typically 
just have the package names, while the class diagrams for the packages will have class symbols for the classes defined in 
the packages. 
In Figure 463 i) is a class diagram for the package Cars, with a class symbol representing the fact that the Cars package 
contains a class Car. ii) is a composite structure diagram for this class Car. The class symbol in i) does not have to contain 
the structure of the class in a compartment ; for more realistic models, the class symbols will typically just have the class 
names, while the composite structure diagrams for the classes will have symbols for the composite structures. Figure 461 - Class diagram of package P
Figure 462 - Two diagrams of packagesC1 C2package P
C1 C2 C1 C2package P
C1 C2PC1 C2package Pi)  Package symbol (as part of a larger diagram)                                              ii) Class diagram for the same pack age
package CP
C1 C2 C1 C2PC1 C2package P
C1 C2 C1 C2package Pi)  Package symbol (as part of a larger diagram)                                              ii) Class diagram for the same pack age
package CP package CP
UML Superstructure 2.0 Draft Adopted Specification        589UML diagrams may have the following kinds frame names as part of the heading.:
 activity
 class
 component
 interaction
 package
 state machine
 use case
Note – Short forms of these names should also be defined, e.g. pkg for package .Figure 463 - A class diagram and a composite structure diagramrear : Wheel [2] e : Engineaxle pclass Cari)  Class sym bol for class Car(as part of a larger diagram )                                           ii)  Com posite structure dia gram for the same class Car
Car
e : Engineaxle p
rear : Wheel [2]package Cars
rear : Wheel [2] e : Engineaxle p
rear : Wheel [2] e : Engineaxle pclass Cari)  Class sym bol for class Car(as part of a larger diagram )                                           ii)  Com posite structure dia gram for the same class Car
Car
e : Engineaxle p
rear : Wheel [2]Car
e : Engineaxle p
rear : Wheel [2]package Cars
590                 UML Superstructure 2.0 Draft Adopted SpecificationAs is shown in Figure 464, there are two major kinds of diagram types: structure diagrams and behavior diagrams.
Structure diagrams show the static structure of the objects in a system. That is, they depict those elements in a 
specification that are irrespective of time. The elements in a structure diagram represent the meaningful concepts of an 
application, and may include abstract, real-world and implementation concepts. For example, a structure diagram for an 
airline reservation system might include classifiers that represent seat assignment algorithms, tickets, and a credit authorization service. Structure diagrams do not show the details of dynamic behavior, which are illustrated by behavioral 
diagrams. However, they may show relationships to the behaviors of the classifiers exhibited in the structure diagrams.
Behavior diagrams show the dynamic behavior of the objects in a system, including their methods, collaborations, 
activities and state histories. The dynamic behavior of a system can be described as a series of changes to the system over time. Behavior diagrams can be further classified into several other kinds as illustrated in Figure 464.
Please note that this taxonomy provides a logical organization for the various major kinds of diagrams. However, it does 
not preclude the mixing different kinds of diagram types, as one might do when one combines structural and behavioral 
elements (e.g., showing a state machine nested inside an internal structure). Consequently, the boundaries between the various kinds of diagram types are not strictly enforced.
The constructs contained in each of the thirteen UML diagrams is described in the Superstructure chapters as indicated 
below.
 Activity Diagram - Activities chapter
 Class Diagram - Classses chapter
 Communication Diagram - Interactions chapter
 Component Diagram - Components chapter
 Composite Structure Diagram - Composite Structures chapter
 Deployment diagram - Deployments chapterFigure 464 - The taxonomy of structure and behavior diagramsDiagram
Structure
DiagramBehavior
Diagram
Interaction
DiagramUse Case
Di agramActivity
Di agram
Composite
Structure
 Di agramClass DiagramComponent
Diagram
Deployment
Diagram
Sequence
Di agramInteraction
Overview
Di agramObj ect
Di agramState Machine
Diagram
Package
Di agram
Collaboration
DiagramTiming
Diagram
UML Superstructure 2.0 Draft Adopted Specification        591 Interaction Overview Diagram - Interactions chapter
 Object Diagram - Classses chapter
 Package Diagram - Classses chapter
 State Machine Diagram - State Machines chapter
 Sequence Diagram - Interactions chapter
 Timing Diagram - Interactions chapter
 Use Case Diagram - Use Cases chapter
592                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        593Appendix B.Standard Stereotypes
This appendix describes the predefined standard stereotypes for UML. The standard stereotypes are organized by 
compliance levels: Basic, Intermediate and Complete.
B.1 Basic
Table 25 
Name Subpackage Applies to Description
«auxiliary» Kernel Class A class that supports another more central or fundamental 
class, typically by implementing secondary logic or control flow. The class that the auxiliary supports may be defined explicitly using a Focus class or implicitly by a dependency relationship. Auxiliary classes are typically used together with Focus classes, and are particularly useful for specifying the secondary business logic or control flow of components during design. See also: «focus».
«buildComponent» Components Component A collection component that defines a set for organizational 
or system leveldevelopment purposes.
«call» Dependencies Usage A usage dependency whose source is an operation and 
whose target is an operation. The relationship may also be subsumed to the class containing an operation, with the meaning that there exists an operation in the class to which the dependency applies.A call dependency specifies that the source operation or an operation in the source class invokes the target operation or an operation in the target class. A call dependency may connect a source operation to any target operation that is within scope including, but not limited to, operations of the enclosing classifier and operations of other visibleclassifiers.
«create» Dependencies Usage A usage dependency denoting that the client classifier 
creates instances of the supplier classifier.
«create» Kernel BehavioralFeatu
reSpecifies that the designated feature creates an instance of 
the classifier to which the feature is attached. May be promoted to theClassifier containing the feature.
594                 UML Superstructure 2.0 Draft Adopted Specification«derive» Dependencies Abstraction Specifies a derivation relationship among model elements 
that are usually, but not necessarily, of the same type. A derived dependency specifies that the client may be computed from the supplier. The mapping specifies the computation. The client may be implemented for design reasons, such as efficiency, even though it is logically redundant.
«destroy» Kernel BehavioralFeatu
reSpecifies that the designated feature destroys an instance of 
the classifier to which the feature is attached. May be promoted to theclassifier containing the feature.
«focus» Kernel Class A class that defines the core logic or control flow for one or 
more auxiliary classes that support it. Support classes may be defined explicitly using Auxiliary classes or implicitly by dependency relationships. Focus classes are typically used together with one or more Auxiliary classes, and are particularly useful for specifying the core business logic or control flow of components during design. See also: «auxiliary».
«framework» Kernel Package A package that contains model elements which specify a 
reusable architecture for all or part of asystem. Frameworks typically include classes, patterns or templates. When frameworks are specialized for an application domain, they are sometimes referred to as application frameworks.
«implement» Components Component A component definition that is not intended to have a 
specification itself. Rather, it is an implementation for a separate «specification» to which it has a Dependency.
«implementation
Class»Classes Class The implementation of a class in some programming 
language (e.g., C++, Smalltalk, Java) in which an instance may not have more than one class. This is in contrast to Class, for which an instance may have multiple classes at one time and may gain or lose classes over time, and an object (a child of instance) may dynamicallyhave multiple classes.An Implementation class is said to realize a Classifier if it provides all of the operations defined for the Classifier with the same behavior as specified for the Classifier's operations. An Implementation Class may realize a number of different Types. Note that the physical attributes and associations of the Implementation class do not have to be the same as those of any Classifier it realizes and that the Implementation Class may provide methods for its operations in terms of its physical attributes and associations. See also: «type».Table 25 
UML Superstructure 2.0 Draft Adopted Specification        595«instantiate» Dependencies Usage A usage dependency among classifiers indicating that 
operations on the client create instances of the supplier.
«metaclass» Kernel Class A class whose instances are also classes.«modelLibrary» Kernel Package A package that contains model elements which are intended 
to be reused by other packages. A model library differs from a profile in that a model library does not extend the metamodel using stereotypes and tagged definitions. A model library is analogous to a class library in some programming languages.
«refine» Dependencies Abstraction Specifies a refinement relationship between model elements 
at different semantic levels, such as analysis and design. The mapping specifies the relationship between the two elements or sets of elements. The mapping may or may not be computable, and it may be unidirectional or bidirectional. Refinement can be used to model transformations from analysis to design and other such changes.
«responsibility» Kernel Usage A contract or an obligation of an element in its relationship 
to other elements.
«script» Deployments Artifiact A script file that can be interpreted by a computer system. 
Subclass of «file».
«send» Dependencies Usage A usage dependency whose source is an operation and 
whose target is a signal, specifying that the source sends the target signal.
«trace» Dependencies Abstraction Specifies a trace relationship between model elements or sets 
of model elements that represent the same concept in different models. Traces are mainly used for tracking requirements and changes across models. Since model changes can occur in both directions, the directionality of the dependency can often be ignored. The mapping specifies the relationship between the two, but it is rarely computable and is usually informal.
«type» Classes Class A class that specifies a domain of objects together with the 
operations applicable to the objects, without defining the physical implementation of those objects. However, it may have attributes and associations. Behavioral specifications for type operations may be expressed using, for example, activity diagrams. An object may have at most one implementation class, however it may conform to multiple different types. See also: «implementationClass».
«utility» Classes Class A class that has no instances, but rather denotes a named 
collection of non-member attributes and operations, all of which are class-scoped.Table 25 
596                 UML Superstructure 2.0 Draft Adopted SpecificationB.2 Intermediate
Table 26 
Name Subpackage Applies to Description
«document» Deployments Artifact A generic file that is not a «source» file or «executable». 
Subclass of «file».
«entity» Components Component A persistent information component representing a business 
concept.
«executable» Deployments Artifact A program file that can be executed on a computer system. 
Subclass of «file».
«file» Deployments Artifact A physical file in the context of the system developed.«library» Deployments Artifact A static or dynamic library file. Subclass of «file».
«process» Components Component A transaction based component.
«realization» Kernel Classifier A classifier that specifies a domain of objects and that also 
defines the physical implementation of those objects. For example, a Component stereotyped by «realization» will only have realizing Classifiers that implement behavior specified by a separate «specification» Component. See «specification». This differs from «implementation class» because an «implementation class» ia a realization of a Class which can have features such as attributes and methods which is useful to system designers.
«service» Components Component A stateless, functional component (computes a value).
«source» Deployments Artifact A source file that can be compiled into an executable file. 
Subclass of «file».
«specification» Kernel Classifier A classifier that specifies a domain of objects without 
defining the physical implementation of those objects. For example, a Component stereotyped by «specification» will only have provided and required interfaces, and is not intended to have any realizingClassifiers as part of its definition. This differs from «type» because a «type» can have features such as attributes and methods which is useful to analysts modeling systems. Also see: «realization»
«subsystem» Components Component A unit of hierarchical decomposition for large systems. A 
subsystem is commonly instantiated indirectly. Definitions of subsystems vary widely among domains and methods, and it is expected that domain and method profiles will specialize this construct. A subsystem may be defined to have specification and realization elements. See also: «specification» and «realization».
UML Superstructure 2.0 Draft Adopted Specification        597B.3 Complete
Changes from previous UML
The following table lists predefined standard elements for UML 1.x that are now obsolete.Table 27 
Name Subpackage Applies to Description
«buildComponent» Components Component A collection component that defines a set for organizational 
or system level development purposes.
«metamodel» Model 
ManagementModel A model of a model, that typically contains containing 
metaclasses. See <<metaclass>>.
«systemModel» Model 
ManagementModel A systemModel is a stereotyped model that contains a 
collection of models of the same physical system. A systemModel also contains all relationships and constraints between model elements contained indifferent models.
Table 28 - Retired standard elements
Standard Element Name Applies to Base Element
«access» Permission
«appliedProfile» Package«association» AssociationEnd«copy» Flow«create» CallEvent«create» Usage«destroy» CallEvent«facade» Package«friend» Permission«invariant» Constraint«local» AssociationEnd«parameter» AssociationEnd«postcondition» Constraint«powertype» Class«precondition» Constraint«profile» Package«realize» Abstraction«requirement» Comment
598                 UML Superstructure 2.0 Draft Adopted Specification«self» AssociationEnd
«signalflow» ObjectFlowState«stateInvariant» Constraint«stub» Package«table» Artifact«thread» Classifier
«topLevel» PackageTable 28 - Retired standard elements
UML Superstructure 2.0 Draft Adopted Specification        599Appendix C. Component Profile Examples
This appendix describes example profiles for J2EE/Enterprise Java Beans (EJB), NET, COM and CORBA Component 
Model (CCM) components. These profiles are not meant to be either normative or complete, but are provided as an 
illustration of how UML 2.0 can be customized to model component architectures.
C.1 J2EE/EJB Component Profile Example
Table 29 shows an example profile for Enterprise Java Beans components:
Table 29 - Example Profile for Enterprise Java Beans
Stereotype Base Class Parent Tags Constraints Description
EJBEntityBean
«EJBEntityBean»Component N/A N/A N/A Indicates that a Component represents an 
EJB Entity Bean, a component that manages the business logic of an application.
EJBSessionBean
«EJBSessionBean»Component N/A N/A N/A Indicates that a Component represents an 
EJB Session Bean, a component that pro-
cesses transactions.
EJBMessage
DrivenBean
«EJBMessage
DrivenBean»Component N/A N/A N/A Indicates that a Component represents an 
EJB Message-Driven Bean, a component 
that handles messages, and is invoked on the arrival of a message.
EJBHome
«EJBHome»Interface N/A N/A N/A Indicates that the Interface is an EJB Home 
interface that supports lifecycle and class-level operations.
EJBRemote
«EJBRemote»Interface N/A N/A N/A Indicates that the Interface is an EJB Remote 
interface that supports business-specific 
operations.
EJBService
«EJBRemote»Interface N/A N/A N/A Indicates that the Interface is an EJB Service 
interface that is exposed as a webservice 
definition.
EJBCreate
«EJBCreate»Method N/A N/A N/A Indicates that the Method is an EJB Create 
Method that facilitates a create operation.
EJBBusiness
«EJBBusiness»Method N/A N/A N/A Indicates that the Method is an EJB instance-
level methods that supports the buisness 
logic of the EJB associated with the Remote 
interface.
EJBSecurityRoleRef
«EJBSecurity
RoleRef »Association N/A N/A N/A Indicates an Association between an EJB cli-
ent and an EJB Role Name Reference sup-plier.
EJBRoleName
«EJBRoleName »Actor N/A N/A N/A Indicates the name of a security role used in 
the definitions of method permissions, etc.
EJBRoleNameRef
«EJBRoleNameRef »Actor N/A N/A N/A Indicates the name of a security role refer-
ence used programmatically in an EJB’s 
source code and mapped to an EJB Role Name.
JavaSourceFile
«JavaSourceFile »Artifact «file» N/A N/A Indicates that the Artifact represents a Java 
source file.
600                 UML Superstructure 2.0 Draft Adopted SpecificationC.2 COM Component Profile Example
Table 30 shows an example profile for COM components:  
C.3 .NET Component Profile Example
Table 31 shows an example profile for .NET components:JAR
«JAR»Artifact «file» N/A N/A Indicates that the Artifact represents a JAR 
(Java ARchive) file.
EJBQL
«EJBQL»Expression N/A N/A N/A Indicates that the expression conforms to the 
EJB Query Language syntax.
Table 30 - Example Profile for COM Components
Stereotype Base Class Parent Tags Constraints Description
COMCoClass
«COMCoClass»Component N/A N/A N/A Indicates a Component specification in COM 
(as defined in a type library). Specifies all 
externally visible aspects of a component.
COMAtlClass
«COMAtlClass»Component N/A N/A N/A Indicates a component implementation class 
using the ATL framework. An ATL class real-
izes a CoClass and provides its implementa-tion.
COMInterface
«COMInterface»Interface N/A N/A N/A Indicates a component interface. COMInter-
faces are oferred or required by CoClasses 
and realized by COMAtlClasses.
COMConnectionPoint
«COMConnection-
Point»Dependency N/A N/A N/A Indicates that a component publishes an inter-
face for subscribers. It is a special kind of a 
provided interface.
COMTypeLibrary
«COMTypeLibrary»Package N/A N/A N/A Indicates a packaging of COM types (COMCo-
Classes, COMInterface) to be deployed as a 
library.
COMTLB
«COMTLB»Artifact Indicates a (runtime) component specification 
file (similar to a deployment descriptor).
COMExe
«COMExe »Artifact «file» N/A N/A An artifact that deployes an executable COM 
server application.
COMDLL
«COMDLL»Artifact «file» N/A N/A An artifact that deployes a component library.
Table 31 - Example Profile for .NET Components
Stereotype Base Class Parent Tags Constraints Description
NetComponent
«NetComponent»Component N/A N/A N/A Indicates that a Component represents a com-
ponent in the .NET framework.
NETProperty
«NETProperty»Property N/A N/A N/A Indicates a Property oferred by a component 
for public get/set operations.Table 29 - Example Profile for Enterprise Java Beans
Stereotype Base Class Parent Tags Constraints Description
UML Superstructure 2.0 Draft Adopted Specification        601C.4 CCM Component Profile Example
Table 32 shows an example profile for CCM components.NETAssembly
«NETAssembly»Package N/A N/A N/A Indicates that a .NET assembly, which is a 
runtime packaging entitiy for components and 
other type definitions.
MSI
«MSI»Artifact N/A N/A N/A Indicates a component self installer file.
DLL
«DLL»Artifact «file» N/A N/A Indicates a portable executable (PE) of type 
DLL
EXE
«EXE»Artifact «file» N/A N/A Indicates a portable executable (PE) of type 
EXE
Table 32 - Example Profile for CCM Components
Stereotype Base Class Parent Tags Constraints Description
CCMEntity
«CCMEntity»Component N/A N/A N/A Indicates that a Component represents an 
Entity CC, a component that manages the 
business logic of an application.
CCMSession
«CCMSession»Component N/A N/A N/A Indicates that a Component represents a 
Session CC, a component that processes 
transactions.
CCMService
«CCMService»Component N/A N/A N/A Indicates that a Component represents a 
Service CC, a component that models sin-gle independent execution of an “opera-
tion.
CCMProcess
«CCMService»Component N/A N/A N/A Indicates that a Component represents a 
service CC, a component realizing a long-
lived business process.
CCMHome
«CCMHome»Interface N/A Must have a 
manages depen-
dencyIndicates that the Interface is an CCM-
Home that provides factory and finder 
methods for a particular CC. 
CCMManages
«CCMManages»Dependency N/A allways between 
a CCMHome 
and some CCM componentAssociates a CCM home with the CC com-
ponent it manages.
CCMFactory
«CCMFactory»Operation N/A N/A Operation is 
owned by CCM-
HomeIndicates that the Operation is a CCM-
home Create Method that facilitates a cre-
ate operation.
CCMFinder
«CCMFinder»Operation N/A N/A Operation is 
owned by CCM-HomeIndicates that the operation is a finder 
method of a CCMHome.
CCMProvided
«CCMProvided »Port N/A N/A Port owns a sin-
gle provided 
interfaceIndicates a port that models a CC facet.Table 31 - Example Profile for .NET Components
Stereotype Base Class Parent Tags Constraints Description
602                 UML Superstructure 2.0 Draft Adopted SpecificationCCMRequired
«CCMRequired »Port N/A N/A Port owns a sin-
gle provided 
interfaceIndicates a port that models a CC Recep-
tacle.
CCMPackage
«CCMPackage »Artifact N/A N/A N/A Indicates an artifact that deploys a set of 
CCs.
CCMComponentDe-
scriptor
«CCMComponent
Descrip tor»Artifact «file» N/A N/A Indicates that the Artifact represents a 
CCMComponentDescriptor.
CCMSoftPkgDescrip-
tor
«CCMComponent
Descrip tor»Artifact «file» N/A N/A Indicates that the Artifact represents a 
CCM softPkg descriptor.Table 32 - Example Profile for CCM Components
Stereotype Base Class Parent Tags Constraints Description
UML Superstructure 2.0 Draft Adopted Specification        603Appendix D. Tabular Notations
This appendix describes optional tabular notations for UML behavioral diagrams, that some vendors or users may want to 
use as alternatives to UML’s graphic notation. Although this appendix mostly describes tabular notations for sequence 
diagrams, the approach may also be applied to other kinds of behavioral diagrams.
D.1 Tabular Notation for Sequence Diagrams
This section describes an optional tabular notation for sequence diagrams. The table row descriptions for this notation follow:
1. Lifeline Class: Designates Class name of Lifeline. If there is no Class name on the Lifeline symbol, this class name is 
omitted.
2. Lifeline Instance: Designates Instance name of Lifeline. If there is no Instance name on the Lifeline symbol, this 
instance name is omitted.
3. Constraint: Designates some kind of constraint. For example, indication of oblique line is denoted as "{delay}". To 
represent CombinedFragments, those operators are denoted with an index adorned by square bracket. In a case of 
InteractionOccurrence, it is shown as parenthesized "Diagram ID", which designates referred Interaction Diagram, 
with "ref" tag, like "ref(M.sq)"..
4. Message Sending Class: Designates the message sending class name for each incoming arrow.
5. Message Sending instance: Designates the message sending instance name for each incoming arrow. In a case of Gate 
message that is outgoing message from InteractionOccurrence, it is shown as parenthesized "Diagram ID", which 
designates referred Interaction Diagram, with underscore, like "_(M.sq)".
6. Diagram ID: Identifies the document that describes the corresponding sequence/communication diagram and can be 
the name of the file that contains the corresponding sequence or communication diagram.
7. Generated instance name: An identifier name that is given to each instance symbol in the sequence /communication 
diagram.  The identifier name is unique in each document.
8. Sequence Number: The corresponding message number on the sequence /communication diagram.
9. Weak Order: Designates partial (relative) orders of events, as ordered on individual lifelines and across lifelines, 
given a message receive event has to occur after its message send event. See definition of weak order (section 34.1 in 
the U2 partners submission.) Events are shown as "e" + event order + event direction (incoming or outgoing).
10. Message name: The corresponding message name on the sequence /communication diagram.
11. Parameter: A set of parameter variable names and parameter types of the corresponding message on the sequence/
communication diagrams.
12. Return value: The return value type of the corresponding message on the sequence/communication diagram.
13. Message Receiving Class: Designates the message receiving class name for each outgoing arrow.
14. Message Receiving Instance: Designates the message receiving instance name for each outgoing arrow. In a case of 
Gate message that is outgoing message from ordinary instance symbol, it is shown as parenthesized message name 
with "out_"  tag, like "(out_s)".
15. Other End: Designates event order of another end on the each message.
604                 UML Superstructure 2.0 Draft Adopted SpecificationExamples
Figure 465 - Sequence diagram enhanced with identification 
                       of the Event occurrences
Table 33 - Interaction Table describing Figure 465
 sd N
A B C
Mreft()
s()
alt [x==5]
u()
[x==0]v()e1oe2i
e3o(ref)
e4i
e5o
e6i
e7osd N
A B C
Mreft()
s()
alt [x==5]
u()
[x==0]v()e1oe2i
e3o(ref)
e4i
e5o
e6i
e7o
Lifeline  
Class Lifeline  
Inst ConstraintM essage
Sending 
Class Message 
Sending 
Instance Diag 
ID Generated
Instance 
Na me Sequence
No Weak 
Order  Mes g Na me
 Par ameter
 ReturnValue
 MessageReceiving
Clas s Mes s age
 
Receive 
Instance Other 
End 
  C       N.sq     e1o t       B e2i 
  B     C N.sq     e2i t         e1o 
  A Ref(M.sq)     N.sq     e3o(ref)  s       C e4i 
  B Ref(M.sq)     N.sq     e3o(ref)  s       C e4i 
  C     _(M.sq) N.sq     e4i s         e3o(ref )  
  C alt [1]x==5     N.sq     e5o u       B e6i 
  B alt[1] x==5   B N.sq     e6i u         e5o 
  C alt[2] x==o     N.sq     e7o v        out_v    
UML Superstructure 2.0 Draft Adopted Specification        605D.2 Tabular Notation for Other Behavioral Diagrams
The approach for defining tabular notation for sequence diagrams should also be applicable to other major behavioral 
diagram types, such as state machine diagrams and activity diagrams.Figure 466  - Sequence diagram with guards, parallel 
                        composition and alternatives 
Table 34 - Interaction Table for Figure 466

606                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        607Appendix E. Classifiers Taxonomy
The class inheritance hierarchy of the Classifiers in the UML 2.0 Superstructure is shown in Figure 467. The root of the 
Classifier hierarchy is the Classifier defined in the Classes::Kernel package, and includes over 30 subclasses. The 
Classifier hierarchy includes package references, so that readers can refer to their definitions in the appropriate packages.
Figure 467 - Classifier hierarchy for UML 2.0 SuperstructureClass
(from Kernel)DataType
(from Kernel)
Enumeration
(from Kernel)Association
(from Kernel)
Classifier
(from Dependencies)StructuredClassifier
(from InternalStructures)Signal
(from Communications)Interface
(from Interfaces)
AssociationClass
(from AssociationClasses)Class
(from C om mu nicatio ns)Collaboration
(from C ollaborations)Behavior
(from BasicBehaviors)Classifier
(from Collaborations)Prim itiveT ype
(from Kernel)Classifier
(from PowerTypes)
Artifact
(from Arti facts)UseCase
(from UseCases)Actor
(from UseCases)Classifier
(from Kernel)
InformationItem
(from InformationFlows)
EncapsulatedClassifier
(from Ports)
Node
(from Nodes)
Device
(from Nodes)Class
(from StructuredC ...)
Executi onEnvi ronment
(from Nodes)CommunicationPath
(from Nodes)
Activity
(from BasicActivities)Activity
(from BasicBehaviors)
Interaction
(from BasicInteractions)StateMachine
(from Behav iorSta teM achine s)BehavioredClassifier
(from BasicBehaviors)
Activity
(from CompleteActivities)ProtocolStateMachine
(from ProtocolStateMachines)
608                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        609Appendix F.XMI Serialization and Schema
UML 2.0 models are serialized in XMI 2.0 according to the rules specified by the proposed MOF 2.0 XMI specification 
(OMG document ad/2002-12-07). The XML schema for MOF 2.0 models that support the MOF 2.0 XMI specification is 
available in OMG document ad/2002-12-09.
The XMI for serializing the UML 2.0 Superstructure as an instance of MOF 2.0 according to the rules specified by the 
proposed MOF2 XMI specification is available in OMG document ad/2003-04-04. It is expected that the normative XMI 
for this specification will be generated by a Finalization Task Force, which will architectually align and finalize the 
relevant specifications.
610                 UML Superstructure 2.0 Draft Adopted Specification
UML Superstructure 2.0 Draft Adopted Specification        611Index
A
Abstraction (from Dependencies) 107
AcceptCallAction 216AcceptEventAction 217
Action 280
Activity 283activity 293, 301, 302, 307
Activity (from BasicBehaviors) 378
ActivityEdge 293ActivityFinalNode 298
ActivityGroup 301
ActivityNode 302ActivityParameterNode 304
ActivityPartition 307
Actor 512Actor (from UseCases) 512
actual 549
actualGate 423AddAttributeValueAction 219
addition 518
AddStructuralFeatureValueAction 219AddVariableValueAction 220
after 419
aggregation 89AggregationKind (from Kernel) 80
alias 31
allFeatures 62allowSubstitutable 556
alt 426
ancestor 491annotatedElement 28
AnyTrigger (from Communications) 379
appliedProfile 575ApplyFunctionAction 222
argument 222, 236, 423, 429
Artifact 184AssemblyConnector 136
assert 426
association 90, 229Association (from Kernel) 81
AssociationClass (from AssociationClasses) 118
associationEnd 90attribute 62
B
behavior 225, 393, 417Behavior (from BasicBehaviors) 379BehavioralFeature (from BasicBehaviors, Communications, specialized) 382
BehavioralFeature (from Kernel) 72
BehavioredClassifier (from BasicBehaviors) 383BehavioredClassifier (from Interfaces) 113
binding 549
BlockActivityGroup 318body 28, 46, 240, 313, 378
bodyCondition 77
bodyOutput 313, 342bodyPart 341
Boolean (from PrimitiveTypes) 538
booleanValue 48, 53
612                 UML Superstructure 2.0 Draft Adopted SpecificationboundElement 547
BroadcastSignalAction 223
C
CallAction 224CallBehaviorAction 224CallConcurrencyKind (from Communications) 384
CallOperationAction 227
CallTrigger (from Communications) 385CentralBufferNode 311
cfragmentGate 409
changeExpression 386ChangeSignal 318
ChangeTrigger (from Communications) 385
class 77Class (from Communications, specialized) 386
Class (from Constructs, Profiles) 574
Class (from Kernel) 86Class (from StructuredClasses, as specialized) 156
Classifier 514
classifier 58, 233, 243, 244, 557Classifier (as specialized) 552
Classifier (from Collaborations, as specialized) 157
Classifier (from Dependencies) 107Classifier (from Kernel, Dependencies, PowerTypes) 61
Classifier (from PowerTypes) 121
classifierBehavior 383ClassifierTemplateParameter 556
Clause 232, 313
clause 314Clause (extended) 232
ClearAssociationAction 228
ClearAttributeAction 229ClearStructurealFeatureAction 229
ClearVariableAction 230
clientDependency 34Collaboration (from Collaborations) 157
CollaborationOccurrence (from Collaborations) 160
collaborationRole 158CombinedFragment (from Fragments) 409
Comment 28
CommunicationPath 186Component 136
composite 80
concurrency 382concurrent 384
condition 515
ConditionalNode 313configuration 188
conformance (of StateMachine) 464, 490
conformsTo 44ConnectableElement (as specialized) 565
ConnectableElement (from InternalStructures) 163
ConnectableElementTemplateParameter 566connection 479
connectionPoint (of StateMachine) 490
ConnectionPointReference (from BehaviorStatemachines) 459connector 428
Connector (from InternalStructures) 163
Connector (from InternalStructures, as specialized) 143ConnectorEnd (from InternalStructures, Ports) 165
UML Superstructure 2.0 Draft Adopted Specification        613consider 426
constrainedElement 54
Constraint (from Kernel) 54
container (StateVertex) 506containingStateMachine 491
context 54, 280, 380
Continuation (from Fragments) 414ControlFlow 315
ControlNode 316
conveyed 532covered 416, 422
CreateLinkAction 231
CreateLinkObjectAction 232CreateObjectAction 233
critical 426
D
DataStoreNode 318
datatype 90
DataType (from Kernel) 95
decider 313, 341decisionInput 320
DecisionNode 319
declarative protocol state machines 465decomposedAs 427
default 74, 89, 548
defaultValue 74, 90deferrableEvent (State) 479
deferrableTrigger 479
definingEnd 165definingFeature 60
DelegationConnector 187
Dependency (from Dependencies) 108DeployedArtifact 187
deployedArtifact 188
deployedElement 189Deployment 187
deployment 189, 190, 195
deploymentLocation 190DeploymentSpecification 190, 195
DeploymentTarget 189
DestroyLinkAction 234DestroyObjectAction 235
Device 191
DirectedRelationship 28direction 74
doActivity 479
doActivity (State) 479duration 390
Duration (from Time) 387
DurationConstraint (from Time) 388DurationInterval (from Time) 389
DurationObservationAction (from Time) 390
E
edge 285
edgeContents 301
effect 280, 345
effect (Transition) 498Element 29
Element (from Kernel) 29
614                 UML Superstructure 2.0 Draft Adopted SpecificationElementImport 31
elementImport 36
ElementImport (from Kernel) 31
EncapsulatedClassifier (from Ports) 166enclosingOperand 422
end 163, 164, 239, 246
endData 231, 236endType 81
entry (ConnectionPoint) 460
entry (State) 479entry point (kind of Pseudostate) 471
enumeration 97
Enumeration (from Kernel) 96EnumerationLiteral (from Kernel) 97
event 387, 398, 419
EventOccurrence 416EventOccurrence (from BasicInteractions) 416
exception 242
ExceptionHandler 322exceptionInput 322
exceptionType 322
executable protocol state machines 465ExecutableNode 324
ExecutionEnvironment 192
executionLocation 190ExecutionOccurrence (from BasicInteractions) 417
exit (ConnectionPoint) 460
exit (State) 479ExpansionKind 324
ExpansionNode 325
ExpansionRegion 325expression 52
Expression (from Kernel) 45
extend 519Extend (from UseCases) 515
extendedCase 515
extendedRegion 476extendedSignature 557
extendedState 479
extendedStateMachine 490extension 515, 574
Extension (from Profiles) 570
ExtensionEnd (from Profiles) 573extensionLocation 515
extensionPoint 519
ExtensionPoint (from UseCases) 516external 506
F
feature 62Feature (from Kernel) 73featuringClassifier 73
FIFO 352
filename 184FinalNode 331
FinalState (from BehaviorStatemachines) 462
finish 417finishExec 416
first 259
firstTime 387, 397FlowFinalNode 333
UML Superstructure 2.0 Draft Adopted Specification        615ForkNode 334
formal 549
formalGate 419
formalParameter 72, 77, 380fragment 419, 426
function 222
G
Gate 418
Gate (from Fragments) 418
general 62, 66
generalization 62Generalization (from Kernel, PowerTypes) 66
Generalization (from PowerTypes) 121
generalizationSet 66GeneralizationSet (from PowerTypes) 121
generalMachine 464
generalOrdering 422GeneralOrdering (from BasicInteractions) 418
group 285
guard 293, 426Guard (Trigger) 498
guarded 384
H
handler 324
handlerBody 322
I
ignore 426Implementation (from Interfaces) 113importedElement 32
importedMember 36
importedPackage 38importedProfile 578
importingNamespace 32, 38
in 74include 519
Include (from UseCases) 517
includedCase 518incoming 302
incoming (StateVertex) 506
InformationFlow (from InformationFlows) 532InformationItem (from InformationFlows) 533
inGroup 293, 302
inheritedMember 62inheritedParameter 557
InitialNode 335
inout 74inPartition 293, 302
input 236, 280
inputElement 326InputPin 336
insertAt 219, 221, 238
instance 48InstanceSpecification (from Kernel) 57
InstanceSpecification (from Kernel, as specialized) 194
InstanceValue (from Kernel) 47inState 349
inStructuredGroup 293, 302
Integer (from PrimitiveTypes) 538
616                 UML Superstructure 2.0 Draft Adopted SpecificationintegerValue 49, 53
interaction 427, 428, 431
Interaction (from BasicInteraction, Fragments) 419
InteractionConstraint (from Fragments) 421InteractionFragment (from Fragments) 422
InteractionOccurrence (from Fragments) 423
InteractionOperand (from Fragments) 425interactionOperator 409
InteractionOperator (from Fragments) 426
Interface (from Communications, specialized) 391Interface (from Interfaces) 114
Interface (from ProtocolStatemachines, as specialized) 461
internal 506InterruptibleActivityRegion 336
interruptibleRegion 293, 302
interruptingEdge 337Interval (from Time) 391
IntervalConstraint (from Time) 391
invariant 434InvocationAction 236
InvocationAction (from Actions, as specialized) 167
isAbstract 61, 382isActive 386
isAssured 314
isBehavior 168isComposite 89
isComposite (derived attribute of State) 478
isComputable 48, 49, 50, 51, 52isConcurrent (CompositeState) 478
isConsistentWith 91
isDerived 81, 89, 90isDeterminate 314
isDimension 307
isDirect 244isException 352
isExternal 307
isIndirectlyInstantiated 137isInternal (Transition) 498
isLeaf 70
isMultiCast 345isMultireceive 345
isNull 50, 53
isOrdered 41, 77isOrthogonal (derived attribute of State) 478
isQuery 77
isReadOnly 75, 90, 285isRedefinitionContextValid 491
isReentrant 380
isRelative 400isReplaceAll 219, 220, 238, 251
isRequired 571
isService 168isSimple (derived attribute of State) 478
isSingleCopy 285
isSingleExecution 285isStatic 73
isStream 352
isSubmachineState (derived attribute of State) 478isSubstitutable 66
isSynchronous 224
isTestedFirst 341
UML Superstructure 2.0 Draft Adopted Specification        617isUnique 41, 77
iterative 325
J
JoinNode 338joinSpec 339
K
kind 143
kind (PseudoState) 469
L
language 46, 240, 378
LCA 491
Lifeline 427
lifeline 419, 434Lifeline (from BasicInteractions, Fragments) 427
LIFO 352
LinkAction 236LinkEndCreationData 237
LinkEndData 239
LiteralBoolean (from Kernel) 48LiteralInteger (from Kernel) 49
LiteralNull (from Kernel) 49
LiteralSpecification (from Kernel) 50LiteralString (from Kernel) 51
LiteralUnlimitedNatural 51
local 506localPostcondition 280
localPrecondition 280
location 188loop 426
LoopNode 341
loopVariable 342loopVariableInput 342
lower 41, 77
lowerValue 41
M
Manifestation 194
manifestation 185
mapping 107max 389, 391, 398
maxint 422
member 36memberEnd 81
mergedPackage 102
MergeNode 343mergingPackage 102
message 419
Message (from BasicInteractions) 428MessageEnd (from BasicInteractions) 431
messageKind 428
messageSort 428MessageTrigger (from Communications) 392
metaclass 571
metaclassReference 576metamodelReference 576
method 382
min 389, 391, 398minint 422
mode 326
618                 UML Superstructure 2.0 Draft Adopted SpecificationModel (from Models) 535
MultiplicityElement (as specialized) 240
MultiplicityElement (from Kernel) 40
mustIsolate 302
N
name 34
NamedElement 33
NamedElement (as specialized) 560NamedElement (from Dependencies) 109
NamedElement (from Kernel, Dependencies) 33
nameExpression 560Namespace 35
namespace 34
Namespace (from Kernel) 35neg 426
nestedArtifact 185
nestedClassifier 87nestedPackage 100
newClassifier 251
Node 195node 285
nodeContents 301
none 80now 399
O
object 229, 244, 246, 247, 251, 257, 258ObjectFlow 344ObjectFlowEffectKind 349
ObjectNode 349
ObjectNodeOrderingKind 352occurrence 157
oldClassifier 251
onPort 167OpaqueExpression (from BasicBehaviors, specialized) 393
OpaqueExpression (from Kernel) 46
operand 46, 409operation 74, 227, 385
Operation (as specialized) 563
Operation (from Communications, as specialized) 393Operation (from Kernel) 76
OperationTemplateParameter 564
opposite 90opt 426
ordered 352
ordering 349out 74
outgoing 302
outgoing (StateVertex) 506output 280
outputElement 326
OutputPin 352ownedActual 549
ownedAttribute 87, 95, 173
ownedBehavior 383ownedComment 29
ownedConnector 174
ownedDefault 548ownedElement 29
ownedEnd 81, 571
UML Superstructure 2.0 Draft Adopted Specification        619ownedLiteral 96
ownedMember 36, 100, 137
ownedOperation 87, 95, 185
ownedParameter 550ownedParameteredElement 548
ownedPort 166
ownedProperty 185ownedReception 386, 391
ownedRule 36
ownedSignature 545, 552ownedStereotype 576
ownedType 100
ownedUseCase 514owner 29
owningAssociation 90
owningInstance 60owningParameter 543
P
package 39, 62, 100Package (as specialized) 558Package (from Constructs, Profiles) 575
Package (from Kernel) 99
PackageableElement (from Kernel) 37packageImport 36
PackageImport (from Kernel) 38
packageMerge 100PackageMerge (from Kernel) 101
par 426
parallel 325parameter 72, 304, 380, 550, 552, 564, 565
Parameter (as specialized) 352
Parameter (Collaboration, as specialized) 167Parameter (from Kernel) 73
ParameterableElement 543
ParameterDirectionKind (from Kernel) 74parameteredElement 548, 556, 564, 566
parameterInSet 354
ParameterSet 354parameterSet 352
parameterSubstitution 547
part 174Part (as extended) 198
PartDecomposition (from Fragments) 431
partition 285, 307partWithPort 165
Permission (from Dependencies) 109
Pin 355Port ( (from ProtocolStatemachines, as specialized) 463
port (Event in Statemachine) 177, 379, 392, 400
Port (from Ports) 167postCondition 466
postcondition 77, 381
powertypeExtent 62preCondition 466
precondition 77, 381
predecessorClause 313PrimitiveFunction 240
PrimitiveType (from Kernel) 98
private 39Profile 129, 130, 147, 148, 179, 198, 199, 263, 365, 366, 367, 436, 445, 450, 507, 509, 523
620                 UML Superstructure 2.0 Draft Adopted SpecificationProfile (from Profiles) 575
ProfileApplication (from Profiles) 578
Property (as specialized) 567
Property (from InternalStructures, as specialized) 171, 197Property (from Kernel, AssociationClasses) 89
protected 39
protectedNode 322protocol 462, 463
ProtocolConformance (from ProtocolStatemachines) 463
ProtocolStateMachine (from ProtocolStatemachines) 464ProtocolTransition (from ProtocolStateMachines) 466
provided 137, 168
PseudoState (from BehaviorStatemachines) 469PseudoStateKind (from BehaviorStatemachines) 475
public 39
Q
qualifiedName 34
qualifier 90, 238, 239, 241, 247
QualifierValue 241
R
raisedException 72, 77, 382
RaiseExceptionAction 242
ReadAttributeAction 249
ReadExtentAction 243ReadIsClassifiedObjectAction 243
ReadLinkAction 244
ReadLinkObjectEndAction 246ReadLinkObjectEndQualifierAction 247
ReadSelfAction 248
ReadStructuralFeatureAction 249ReadVariableAction 250
realization 137, 532
Realization (from Dependencies) 110Realization (from Dependencies, as specialized) 146
receiveEvent 428
receiveMessage 431Reception (from Communications) 394
ReclassifyObjectAction 251
RedefinableElement (from Kernel) 70RedefinableTemplateSignature 557
redefinedBehavior 380
redefinedClassifier 62redefinedConnector 164
redefinedElement 70, 293, 302
redefinedOperation 77redefinedPort 168
redefinedProperty 90
redefinitionContext 70, 476, 479, 490, 498referred 466
refersTo 423
region 479, 490Region (from BehaviorStatemachines) 476
region (of StateMachine) 490
regionAsInput 325regionAsOutput 325
relatedElement 30
Relationship 30Relationship (from Kernel) 30
RemoveStructuralFeatureValueAction 252
UML Superstructure 2.0 Draft Adopted Specification        621RemoveVariableValueAction 253
replacedTransition (Transition) 498
ReplyAction 254
replyToCall 254replyValue 254
representation 157
represented 533represents 307, 427
request 255
required 137, 168result 217, 222, 224, 232, 233, 243, 244, 245, 246, 247, 248, 249, 250, 259, 314, 342, 393
return 74
returnedResult 380returnInformation 216, 254
returnResult 72
role 165, 173roleBinding 160
S
scope 364second 259selection 345, 349
selector 427
sendEvent 428sendMessage 431
SendObjectAction 254
SendSignalAction 255seq 426
sequential 384
setting 414setupPart 341
shared 80
signal 223, 256, 394, 396Signal (from Communications) 395
SignalTrigger (from Communications) 396
signature 429, 548slot 58
Slot (from Kernel) 60
source 29, 293source (Transition) 498
specific 66
specification 54, 58, 380specificMachine 464
start 417
startExec 416StartOwnedBehaviorAction 257
State (from BehaviorStatemachines) 477
stateGroup 469stateInvariant 479
StateInvariant (from BasicInteractions) 433
StateMachine (from BehaviorStatemachines) 489Stereotype (from Profiles) 580
Stop (from BasicInteractions) 434
stream 325strict 426
String (from PrimitiveTypes) 539
stringValue 51, 53structuralFeature 258
StructuralFeature (from Kernel) 75
StructuralFeatureAction 258StructuredActivityNode 361
622                 UML Superstructure 2.0 Draft Adopted SpecificationStructuredClassifier (from InternalStructures) 173
structuredNode 285
subgroup 301
subject 519submachine 479
submachineState 469
subsettedProperty 90subsettingContext 91
substitution 62
Substitution (from Dependencies) 110subvertex (Region) 476
successorClause 313
superClass 87superGroup 301
superPartition 307
supplierDependency 34symbol 45
T
target 29, 227, 235, 255, 256, 293target (Transition) 498template 547, 550
TemplateableElement 545
TemplateBinding 547templateBinding 545
TemplateParameter 548
templateParameter 544TemplateParameterSubstitution 549
TemplateSignature 550
test 313, 341TestIdentityAction 259
TimeConstraint (from Time) 396
TimeExpression (from Time) 397TimeInterval (from Time) 398
TimeObservationAction (from Time) 399
TimeTrigger ( from BehaviorStatemachines, as specialized) 498TimeTrigger (from Communications) 399
toAfter 416
toBefore 416top 464, 490
transformation 345
transition 464, 476, 490Transition (from BehaviorStatemachines) 498
TransitionKind 506
trigger 216, 217Trigger (from Communications) 400
Trigger (from InvocationActions, as specialized) 177
trigger (Transition) 498type 44, 77, 160, 164, 573
Type (from Kernel) 43
typeConstraint 568TypedElement (from Kernel) 44
U
UnlimitedNatural (from PrimitiveTypes) 540unlimitedValue 52, 53unordered 352
upper 41, 77
upperBound 349upperValue 41
Usage (from Dependencies) 111
UML Superstructure 2.0 Draft Adopted Specification        623UseCase (from UseCases) 519
utilizedElement 195
V
value 48, 49, 51, 60, 239, 241, 261, 262, 363ValuePin 363ValueSpecification (as specialized) 568
ValueSpecification (from Kernel) 52
Variable 363variable 260, 362
Variable (from StructuredActivities, as specialized) 178
VariableAction 260Vertex (from BehaviorStatemachines) 505
viewpoint 536
visibility 31, 34, 37, 38VisibilityKind 39
VisibilityKind (from Kernel) 39
W
weight 293
when 400
WriteLinkAction 261
WriteStructuralFeatureAction 260WriteVariableAction 262
624                 UML Superstructure 2.0 Draft Adopted Specification
