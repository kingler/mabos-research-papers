Executable Modeling with UML
 - A Vision or a Nightmare? -
Bernhard Rumpe
Software & Systems Engineering
Munich University of Technology
D-80230 Munich, Germany
Tel: +49-89-45364800,  fax-4738,
Rumpe@in.tum.de
Abstract
Extreme Programming is the most prominent new, ligh t-weight (or agile) methods, defined to
contrast the current heavy-weight and partially ove rloaded object-oriented methods. It
focuses on the core issues of software technology. One of its principles is not to rely on
diagrams to document a system. In this paper, we ex amine what properties a modeling
language like UML must have in order to support the  Extreme Programming approach
effectively. In particular, we discuss how such a d iagrammatic programming language must
look like to replace a textual programming language  and what benefits and problems such an
approach may bring..
Keywords: UML, extreme modeling, visual programming  language, executability.
1. INTRODUCTION
Extreme Programming (XP) [1] is a light-weight meth odology for small and medium-sized
teams developing software with rapidly changing or enhancing requirements. XP is an
explicit reaction to the complexity of today’ s mode ling methods like the Unified Process [12],
the OPEN Toolbox of Techniques [7], or Catalysis [3 ]. XP primarily tries to focus on the best
practices of software development, and contrasts st rongly the heavy-weight and partially
overloaded object-oriented methods by its simplicit y.
In all engineering disciplines nowadays, software e ngineering excluded, there exists an
established engineering process to develop a system , which is accompanied by a number of
suited modeling description techniques. Software en gineering, being a rather new field, has
not as yet established any clear methodical guidanc e or a fully standardized modeling
notation. The XP approach does not try to create a detailed software engineering process, but
to focus mainly on programming since it is "fun for  the programmer" [1]. The current success
of this approach suggests that software engineering  may either be completely different from
other engineering disciplines or that the software engineering discipline simply isn’t mature
yet. The former has its justification in the fact t hat software is totally immaterial, whereas all
other engineering products have a physical manifest ation. Therefore, it is in principle far
[Rum02c] B. Rumpe. 
Executable Modeling with UML. A Vision or a Nightmare? 
In: Issues & Trends of Information Technology Management in Contemporary Associations, Seattle. Idea Group Publishing, Hershey, London, pp. 697-701. 2002. 
www.se-rwth.de/publications
easier to change already existing software, even if  it had been shipped and installed millions
of times.
One of the distinct features of XP is the lack of a ny documentation whatsoever, except for
the code itself. This is a contraposition to the mo deling techniques like the Unified Modeling
Language (UML) [2], [15] which strongly focus on do cumentation. XP takes an extreme
position there, not even documenting the architectu re of the system. Often, it is very difficult
to extract the overall structure, behavior or inter actions with the environment from the code.
The code is a rather detailed and fragile represent ation of the system’ s tasks. Even though the
code contains all necessary information about the s ystem, this information is often burdened
with details and it is tedious to extract the aspec ts one is interested in. Therefore, it would be
useful to have a more compact system representation . The UML does provide a number of
notations that are suited for this purpose. However , the tools so far are not capable of
supporting UML in such a manner that it can be well -integrated with the approach of Extreme
Programming.
This paper explores which kind of concepts, tools a nd techniques are needed to make UML
suitable for an "extreme modeling" approach. The XP  approach is basically a programming
approach, but replacing the underlying programming language by an executable version of
UML.
In Section 2, we explore techniques and tools neede d for the UML to support the extreme
modeling approach. In Section 3, we examine in deta il UML’ s actual version and how far it
supports extreme modeling. In Section 4, we are goi ng to examine description techniques of
the UML that are executable or of use for testing. In Section 5, we discuss our vision of the
UML to support the extreme modeling process in the future. In Section 6 we finally discuss
drawbacks and changes of such an approach.
2. PROPERTIES NEEDED FOR UML TO SUPPORT EXTREME
MODELING
UML is, as its name states, a modeling language. Th e OMG, standardizing UML,
explicitly wants it to remain independent from meth odical issues. Therefore, the language
UML is usable for a variety of purposes. Unfortunat ely, current tool support for UML is
definitely insufficient for many of the purposes fo r which UML can be used. In this section,
we are going to explore what UML needs in order to be able to replace a programming
language in the XP approach. We have identified the  following six important issues:
1. UML needs to be fully expressive,
2. UML needs to be a more compact notation than an ord inary programming language,
3. UML needs an effective translation into efficient c ode,
4. UML needs support for testing,
5. UML needs a simple and usable module concept,
6. The tool support must be adequate.
Let’ s explain the above issues: if UML is going to replace an ordinary programming
language, it needs full expressiveness. This has tw o different flavors; from theory, we know
that full expressiveness means Turing computability . All ordinary programming languages, be
they object-oriented, structured or functional, hav e basically the same power of
computability, namely, the power of the Turing mach ine. Therefore, the executable version of
UML must also provide the possibility of defining a ny computable function.
For practical purposes, it is also important that t he modeling language we use is expressive
enough to describe the connection to the graphical user interface and to the operating system,
as well as e.g. distribution aspects, just as today ’ s ordinary programming languages provide
by means of appropriate libraries.
One of the advantages of a diagrammatic language wi ll surely be that it can describe
structural and behavioral issues in a way more comp act and easy to survey than ordinary
textual programming languages can. In the case that  the UML becomes fully expressive, this
advantage has to be maintained.
An effective translation into efficient code is the  most critical issue for the Extreme
Programming approach. The effective translation mea ns that a compiler from UML to
executable code is fast and reliable. The generated  code itself must be fast and robust in order
to be accepted by users and programmers. Of course,  each translation of higher order
concepts into a less rich language generates some o verhead, but this overhead must be
efficient, small, and not too time-consuming. This situation can be compared to object-
oriented languages versus structured languages, whe re the concept of objects generates some
overhead which is today efficient enough to have no  serious impact on computation time.
In Extreme Programming, the system code and the tes ting code are both written in the
same programming language. In UML, it may be of int erest to identify a subset of the
language dedicated to specification of tests and to  check them during the run-time against the
executable model. Moreover, like in any other langu age, it is important to have a module
concept that allows us to encapsulate internal impl ementations. Only a clear concept of
interfaces between the modules and concepts used in  the language allow us to distribute and
thus parallelize labor among the team.
Finally, tool-support for the techniques discussed above are crucial to the whole approach.
Extreme Programming and extreme modeling as such he avily rely on appropriate tool
support.
3. UML TODAY
Based on the needs identified in the last section, we are now going to identify which
properties are already satisfied by UML or how to r eshape UML to make it usable for the XP
approach.
3.1. Is UML fully expressive?
UML consists of several parts. Looking at the diagr ammatic part only, UML is not
expressive enough to describe each computable funct ion. However, this is not fully clear
today because UML semantics is not as precisely def ined as necessary to clarify this question.
If we also regard the Object Constraint Language (O CL) [21] we find a rich textual language
to describe properties of our system. Even though t he OCL is a first-order language, it is very
much in the spirit of being executable. UML coupled  with an executable sub-language of
OCL will be expressive enough to describe each poss ible computation function.
The question of how to access graphical user interf aces and operating systems, and other
issues of this kind will probably be solved in the same way as in ordinary programming
languages. This means, we need to provide modeling libraries especially suited for these
issues, that have a hard-coded implementation. Prov iding modeling libraries for reusable code
would, of course, always be useful.
3.2. Is UML more abstract than an ordinary programm ing language?
If used in a version similar to the current UML 1.3 , we can clearly say: Yes, it is more
compact than any existing ordinary programming lang uage. This comes from the fact that
UML offers a number of higher-level modeling concep ts, allowing a rather compact
description of certain properties of the system. De scribing such a property in ordinary
programming language needs considerably more lines of code.
Besides being more compact, abstraction has a secon d, closely related advantage. A
notation is more abstract, if it allows to disregar d certain details of the implementation. In
UML e.g. it is possible to draw an association with out specifying how this association is
implemented. Instead, a tool may decide what is the  best way to implement the association if
this is at all necessary. This may depend on the us age of associations, as well as on the used
heuristics to produce code in the tool. However, th e implementers should not care about this.
3.3. Is there a UML compiler into efficient code?
Not today. For a large part of UML diagrams today, exists not even a single translation into
code at all, though many of the UML diagrams look l ike being executable (see also Section
4.).
Today’ s tools mainly focus on translating class dia grams into codes and vice versa. This
technique is called round-trip engineering and remi nds on early stages of compilers from
Pascal, Basic or Cobol into assembler code. In thes e early phases, people had less confidence
in their compiler, so they generated assembler code  which could be viewed and changed by
hand, if necessary, before generating object code. If history repeats, round-trip engineering
will vanish sometime and UML models will directly b e translated into object code without
any intermediate programming language notation.
3.4. Is UML suited for testing?
Yes, UML clearly has potential to model tests as we ll as the executable code. Sequence
diagrams and collaboration diagrams both are exempl aric notations that allow especially to
describe expected behavior and expected changes of the object structures. Thus both notations
are well-suited to describe tests for the system. W e already know that UML provides a more
compact code description than an ordinary programmi ng language does. But, the tests can
also be described in a more compact way, giving ris e for specification-based testing. This is,
of course, only feasible if appropriate tools for t his kind of testing actually exist.
3.5. Does UML have an appropriate module concept?
The concept of a module is the basic constituent fo r programming in the large. Only
appropriate module concepts allow to structure the work in a team leading to a parallelization
of work, therefore, to a smaller time-to-market. As  modules interact, a clear concept of
interfaces between modules of the software system b ecomes indispensable.
In object-oriented programming languages, the conce pts of class and package fulfill the
requirements for modules. Classes provide a name sp ace that allows hiding of the
implementation details and having a clear interface  to clients of the class. However, classes
are rather low-level. If a system has hundreds of c lasses, it is necessary to have appropriate
structuring mechanism beyond single classes. Theref ore, UML uses its package concept to
structure classes. This package concept is rather p owerful but, so far, not fully elaborated and
understood. It seems to be inappropriate to some ex tent due to the lack of clear interfaces
between the packages, even if the package concept c an be probably adapted to describe
interfaces between modeling elements. Packages do h ave a name space. However in their
current usage, it is not possible to define package  interfaces explicitly. Such an interface
could be used to explicitly export parts of a packa ge to another one, i.e. to a part of defined
classes or type definitions. Due to the lack of suf ficient, precise specification or even of a
powerful tool support for UML packages, it is not c lear so far whether packages will fully
support the possibility of separation of concerns, and therefore, localizing changes of the
software to smaller parts.
3.6. Is there adequate tool support for UML as extr eme modeling notation?
Today UML does have an extensive tool support. Thes e tools, however, focus strongly on
editing and version control support. Apart from gen erating code frames and supporting round-
trip engineering with class diagrams to a limited e xtent, there is no extensive tool support
today for the UML. Besides the main-stream UML tool s, there are a number of tools
originating from earlier efforts that have at least  some of the concepts mentioned above.
Some examples are ROOM [20] or as called today UML- RT, Statemate based on the
StateChart formalism [5], and a number of more acad emic tools like AUTOFOCUS [8].
To summarize - UML has potential for a high-level p rogramming language. However, a
number of minor flaws need to be fixed, and especia lly an executable subset of UML needs to
be identified. The main obstacle remains the lack o f appropriate tool support for an
executable UML that goes far beyond class diagrams and that is reliable enough.
4. CAN UML BE EXECUTED?
UML has many interesting facets, some of them alrea dy investigated in the last
section. Here, we discuss which of the UML models c an be executed.
Apart from the question whether UML should  be executable, that will be discussed in
Section 6, let us discuss the question of whether U ML can be executable. The answer is: yes.
There is a large subset of UML modeling techniques that can actually be animated. Among
them are the UML class diagrams, StateChart diagram s, the Object Constraint Language,
activity diagrams and sequence diagrams.
StateCharts
class diagrams
object codesequence diagrams ✂✁☎✄☎✆✞✝✟✆✡✠✟✆✂☛✌☞☎✍ ✎ ✁✡✠
test codeobject diagrams
_
__
OCL
4.1. Class Diagrams
How to generate code out of class diagrams is alrea dy well-understood. Also, the reverse
direction, how to generate class diagrams out of th e code is implemented in many UML-
based tools today to allow round-trip engineering. From the mathematical point of view, these
two mappings are not isomorphisms, which means that  mapping class-diagrams to code
looses information. It especially looses informatio n about weak or strong aggregation and
some information about its associations. Mapping co de to class diagrams also looses
information, since e.g. method bodies are not (offi cially) represented in the class diagram.
This is due to the fact that a class diagram is an abstraction of the real system that mainly
deals with structure.
Besides class diagrams, there are also object diagr ams that deal with structure. Whereas
class diagrams define and constrain potential struc tures of a system, an object diagram defines
an actual structure of objects in a system in a cer tain situation. Therefore, object diagrams
operate on the instance level. This makes it easy t o generate code out of an object diagram,
e.g. a code that builds up the object structure. Ho wever, there is only poor tool support today
for this kind of diagrams.
4.2. StateChart Diagrams
In the embedded systems area where control states a re a major issue, one is acquainted
with the description of complex controlling systems  using state machines. In UML, the
corresponding notation called StateCharts can also be used to describe behavior of single
objects. According to David Harel, StateCharts are the engine of the UML model [6].
StateCharts are a more descriptive and elegant way to describe automata or state machines,
and StateCharts are therefore strategies of how to execute the behavior. Thus, it is not
surprising that StateCharts are executable and a nu mber of tools, among them also Statemate,
demonstrate their efficient executability. Even tho ugh and syntax of StateCharts, as used
within UML, are syntactically and semantically, as well as from methodical usage slightly
different from the original StateCharts definition [5], StateCharts in UML still remain
executable, as e.g. the tool ROSE-RT demonstrates.
4.3. OCL
The UML diagrams are a powerful set of techniques t o describe different views on a
software system. Generally though, they are not cap able of describing every possible
property. The textual constraint language OCL, ther efore, has been added to the UML in
order to describe properties not to be conveniently  captured by diagrams. OCL claims to be a
first-order specification language and it has actua lly the concept of quantification included.
However, a close examination of OCL shows that almo st all concepts are executable and
OCL can be regarded to a large extent as a function al programming language like ML [17],
Haskell [9] or Gofer [13]. An interesting aspect co ncerns the quantifiers. There is an
existential and an universal quantification. Assumi ng there exists a class Person with an
attribute age, we can write the following OCL const raint:
Person.allInstances->forall(p | p.age > 4)
For a specification language, OCL does have an unus ual syntax. The above invariant
ensures for all existing persons in a system the at tribute age greater than 4. As in any point
of time, each running system has a finite set of ex isting Person  objects, this quantification is
always finite. Therefore, OCL does not possess the power of first-order logic, but of a
propositional logic only and the OCL constraints ca n be checked at runtime.
Any usage of universal and existential quantificati on ranges over finite sets only. - With
one exception: in UML 1.3 both quantifiers may be u sed over basic datatypes like Integer or
String. The UML 1.3 specification does not define e xactly what this really means. We
basically have two possible interpretations at hand . In one interpretation, the following
constraint
Integer.allInstances->forall(x | x <> 5)
is not necessarily false. In one interpretation the  expression Integer.allinstances
corresponds to all existing integers in a system sn apshot. This set is finite and the constraint
above simply states that integer 5 is not assigned to any variable of the system at a ll. In the
other interpretation, Integer.allinstances  is the actual set of all integers, and the
above statement wrong. This means we have infinite quantifications at hand to describe
properties, but of course, such quantification norm ally cannot be executed.
Even if we assume that OCL is completely executable , we still have the problem that
describing a constraint does not tell us how to est ablish it. For example, if we describe a post-
condition or an invariant with OCL, there is no aut omatic way to generate code from it that is
capable of actually establishing the post-condition  or the invariant.
Because of this big difference between checking a c onstraint and establishing it, UML 2.0
will probably be extended by an action language. So  long, it is not quite clear what the action
language will look like, but its purpose will be to  describe behavior. We expect the action
language to be basically executable and to allow us  to describe the actions an object performs
when receiving a stimulus.
4.4. Activity Diagrams
Apart from the discussed kinds of diagrams, UML con tains a number of additional
diagrams, which play a less important role in the U ML of today. One of them is the newly
introduced activity diagram. Even though activity d iagrams are presented as a specialization
of StateCharts, they actually extend the properties  of StateCharts allowing us to describe
several concurrent threads of execution. Depending on their actual semantics, activity
diagrams are a mixture between dataflow diagrams, w hich have already been present in OMT
[19], and Petri-Nets [18]. For both, dataflow and P etri-Nets, exist tools to execute them, so we
can expect with high certainty that activity diagra ms will also be executable.
4.5. Sequence Diagrams, Collaborations
The diagrams discussed so far, are capable of descr ibing complete sets of possible
structures or possible behaviors. In contrast, sequ ence diagrams and collaboration diagrams
describe the system on an instance level. Both diag rams show one possible, exemplaric
behavior. This is perfect to model stories and to d iscuss them with users, but having a finite
set of sequence diagrams available, we cannot gener ate complete code out of it. Regarding
code generation, this flaw has been addressed by ex tending sequence diagrams with
techniques for describing alternatives, iteration a nd repetition. Some of these techniques are
already available in UML sequence diagrams. Deeper considerations have been published in
[14] and partly included in the Message Sequence Di agrams (MSC) as standardized by ITU
[11]. If we extend further sequence diagrams, i.e. by concepts like actions in the activity bars,
then we will probably have sequence diagrams that a llow to generate complete code.
However, these techniques make sequence diagrams mo re complicated, and we have plenty
other description techniques at hand which allow co de-generation.
The exemplaric nature of sequence diagrams on the o ther hand, offers an opportunity to
specify test cases. A sequence diagram can be inter preted as a test-driver, sending a sequence
of stimuli to an initially created object structure . The sequence diagram is furthermore
capable to describe the responses of the object str ucture under test as well as internal flow of
messages. Thus it can be expected that sequence dia grams will be used for coding test-drivers
and expected message flows.
5. UML APPLIED IN THE EXTREME MODELING APPROACH
XP pretends to use a number of common sense princip les and practices to rather extreme
levels. In this section, we are going to examine th ese practices in detail and see how our
vision of UML supports them. We refer to the best p ractices given in [1]:
• XP wants an early, concrete and continuing feedback  through short development
cycles. This is even more true when we have a more compact modeling language at
hand, which allows us to describe more effectively the properties of the system. We
achieve even shorter development cycles than an ord inary programming language
could enable.
• XP relies on an incremental programming approach wh ich allows to come up quickly
with an overall plan that is continuously evolved d uring a project’ s life. Having a
notation such as class diagrams at hand, the increm ental planning is even easier than
only working with a programming language. Furthermo re, evolution of a system is
also strongly supported as refactoring techniques [ 16], [4] strongly rely on class
diagrams. So both incremental planning and evolutio n are even better supported by
UML than by some ordinary programming languages.
• XP relies on its ability to flexibly schedule the i mplementation of new functionality
directly responding to enhancing or changing busine ss needs. This is a methodical
issue, there is no reason why the use of UML as pro gramming language should not
better support this than the current programming la nguages.
• XP strongly relies on automated tests written by pr ogrammers and customers to ensure
and monitor the progress of development in order to  catch the facts as early as
possible. Using an ordinary programming language, t he program code and the testing
code both have to be written in the same language. This is feasible, of course, but
having specialized notations for description of the  system and of its tests makes it even
easier. As discussed in the previous section, we fo und a number of description
techniques, i.e. class diagrams, StateCharts and a subset of OCL, to be well-suited for
high level executable modeling. Because of their ex emplaric nature, sequence,
collaboration, and object diagrams are especially s uited to describe tests on an instance
level. For example, we can use object diagrams to d escribe a start situation for a
method call and the structural part of its post-con dition, namely, the final situation for
that method call. The interactions happening during  this method can be described by a
sequence diagram or a collaboration. These kinds of  diagrams are specifically suited to
describe tests and test situations, tools could gra phically show where a test situation
has been violated. This is easy to grasp when the t est is broken. XP expects tests not
only to be written by programmers but also by custo mers. Some customers can
describe tests in diagrams more easily than describ e tests as code. Needless to say, we
need a good set of tools supporting diagrams that w e are going to use in the XP
approach, not only for the purpose of testing.
• XP relies on communication, tests and source code w ithout further documentation to
communicate system structure and intent. Of course,  it is easier to discuss on precise
and abstract pictures than relying only on textual source code. If the source code is
partly replaced by UML diagrams, then documentation  and code again coincide
without having much redundancy - a goal that XP tri es to achieve. The more
sophisticated and higher level concepts a programmi ng language has, the more
compact the notation is, the easier it is to grasp the system structure and intent. We
expect from UML as a programming language to be of high advantage regarding the
understanding of and the communication of a system.
• XP aims at evolutionary design as long as the syste m is in use. This is a highly critical
point because systems that are unstable tend to cha nge their functionality as well.
Unfortunately tests cannot capture the possible beh avior totally. Thus, it may happen
that certain subtle changes of system functionality  are not detected by tests. Of course,
this is still possible with the extreme modeling ap proach, but we hope that using a
more compact, higher-level language better assists maintenance and evolution of an
existing system than a lower-level programming lang uage does. In particular, the
program parts to be adapted in a task might be less  distributed in the code and
therefore easier to grasp and overview.
• In XP the skills of programmers play an important r ole. XP tries to match short-term
instincts of programmers with long-term interests o f the project. Using an extreme
modeling approach means that the programmers need s ome skills and specially some
interest in high-level modeling with UML instead of  using an ordinary object-oriented
or structural programming language. As we still do not have sufficiently powerful tools
to support UML as a high-programming language, we c annot have programmers with
that skill. We expect that as soon as such tools ex ist, a great deal of programmers is
interested enough to learn the skills necessary to use them. But this is a kind of
paradigm shift which is equally difficult or even m ore difficult than the shift from
structural programming like using programming langu age C to an object-oriented
programming language like C++.
In summary, had we a sufficient, useful tool suppor t for a subset of UML as a high-level
programming language, the extreme modeling approach  as discussed above would be a
natural evolution of Extreme Programming process as  introduced in [1]. It would have
advantages over XP in many common sense principles and practices that XP already relies on
today.
6. PROBLEMS WITH EXECUTABLE UML
Executing a specification or a specified model has both benefits and drawbacks. As
discussed some benefits are the early feedback for developer, experiencing his model’ s actual
behavior. Another important advantage is the fact t he earlier you get the code running, the
more market you have. Certainly, generating code ou t of a model gives distinctive time and
market advantage. On the other hand such an approac h suffers from serious drawbacks.
6.1. Efficient specifications
Known from the early efforts when defining executab le specification languages, the
modeler tends to focus not only on the properties h e is modeling, but also on efficiency of the
execution. It is hard enough to specify properties concisely and accurately, and it becomes
even harder if we are simultaneously concerned with  efficiency. Such experience has been
made with algebraic specification languages however , and it is not clear whether these
considerations also hold for modern diagrammatic la nguages like UML.
Executable specification of functionality such as s orting are harder to read and
understand than abstract and compact property speci fications. As OCL is conceptually
similar to algebraic specification languages, at le ast OCL-specifications will suffer
from efficiency considerations. On the other hand t his problem will be less dramatic for
other UML notations, as those mainly deal with stru cture (class diagrams), or are
efficiently executable by their nature (StateCharts ).
6.2.The Problem of Over-Specification
Our examination has shown that a large sub-language  of UML can be executable.
The question remains: shall UML be an executable, h igh-level programming language?
Today, UML based tools often force developers to sp ecify details unknown at the
moment, or details they wanted to be left open. Thi s is well-known as the problem of
over-specification and will surely become worse if the tools are going to head towards
being high-level programming language compilers. Lo oking at SDL, which had a
similar fate starting of as specification language in the telecommunication area, ending
up as a high-level programming language, we will pr obably witness UML making a
shift from a property-description language to an ex ecutable language, used mainly for
programming.
Repeating earlier arguments, it is doubtlessly usef ul to have an immediate simulation
of your model at hand; nevertheless during modeling , especially architectural or
requirements modeling, the possibility to under-spe cify unwanted or unavailable
properties is highly important. Therefore, it is us eful in general to have both an
executable sub-language of UML and a highly non-exe cutable sub-language that allows
us to specify system properties declaratively. High -level UML specifications must then
be transformed into low-level detailed executable m odels by adding details and
refactoring the models. For example, whereas we nee d for execution purposes mostly
one StateChart for each class during the specificat ion, it might be of great use to have
several abstract StateCharts that describe parts of  behavior of a class from different
points of view, and that are merged into one, more detailed StateChart during the
development process. As we know, this kind of mergi ng cannot be done automatically,
it needs methodical assistance beyond today’ s tools  that mainly allow drawing diagrams
and generate code out of them.
6.3. Focus on the target language
When using code generators that map UML to a target  language, the semantics of the
target language as well as its notational capabilit ies tend to become visible on the UML
level. For example, missing multiple inheritance in  Java may restrict executable UML
to single inheritance as well. Furthermore, the lan guage internal concurrency concept,
message passing or exception handling may impose a certain dialect of executable
UML. This proliferates UML dialects as semantically  incompatible. In particular it will
not (easily) be possible to transfer UML models fro m one target language to another.
6.4. UML in the early phases
Executable UML will be useful for a number of proje cts. However in many other
software development approaches, there are early ph ases with explicit requirements
analysis, specification of the system functionality  and development of an explicit
architecture of the system. Executable UML will hav e a number of deficiencies to
describe this artifacts. We already mentioned the p roblem of over-specification and the
dependency on the target language. Furthermore, an executable UML will not cover the
full UML 1.3 as it is today. For example, we do not  expect use cases to become an
executable notation, even though there are attempts  to generate code from them.
As a consequence, executable UML should be a subset  of a larger UML that is
capable to assist the developers in the early phase s. This extended version of UML
relaxes certain restrictions of executable UML, use s more diagrams, and offers a
number of high-level concepts within the mentioned diagrams, that cannot be executed.
7. CONCLUDING REMARKS
This paper discusses how and whether to integrate m odeling techniques that a language
like the UML offers in an executable form with the Extreme Programming approach. We
have called the result "executable modeling" based on the idea to replace ordinary
programming by high-level modeling.
The basic idea of executable modeling is to replace  the programming language on which
XP heavily relies on by a high-level executable mod eling language. We examined the UML
potential for this approach and found that it would  support most of our needs. However,
today’ s tool support is poor and insufficient. As l ong as tools do not fully support our needs,
the vision in this paper will only remain a vision.  However, looking at present situation of
UML tools, it seems rather likely that the fate of the Unified Modeling Language will be
similar to the fate of SDL [10], which also started  as high-level description language in
telecommunication area and ended up as a high-level  programming language.
Although the development of an executable UML-versi on has a number of advantages,
there are also a number of drawbacks. Most critical ly, it has to be made clear to software
developers, that in the early phases a non-executab le UML should be used. There should be
no emphasis on efficiency or completeness of the mo dels. Instead the models should be
abstract and focused on the information they are in tended to describe.
To conclude, there is a necessity for a non-executa ble as well as an executable version in
the UML language family that both will co-exist and  be used where appropriate.
Acknowledgements
The author wishes to thank Kent Beck and Jutta Ecks tein for fruitful discussions on XP, also Wolfgang
Schwerin for his comments. This work was partially supported by the Bayerische Forschungsstiftung unde r the
FORSOFT research consortium and the Bayerisches Sta atsministerium für Wissenschaft, Forschung und Kuns t
under the Habilitation-Förderpreis program.
Literature
[1] K. Beck . Extreme Programming explained, Addison -Wesley. 1999.
[2] G. Booch, J. Rumbaugh., I. Jacobson. The Unified  Modeling Language User Guide. Addison-Wesley. 1998 .
[3] D. D 'Souza, A. C. Wills. Objects, Components and Framew orks with UML. The Catalysis Approach.
Addison-Wesley. 1998.
[4] M. Fowler. Refactoring. Addison-Wesley. 1999.
[5] D. Harel: Statecharts: A Visual Formalism for Co mplex Systems. Science of Computer Programming 8,
1987, 231 -274.
[6] D. Harel. On the Behavior of Complex Object-Orie nted Systems. Invited Talk in: R. France, B. Rumpe
(eds.): <<UML>>'99 - Proceedings. Springer Verlag. LNCS 1723. 1999.
[7] B. Henderson-Sellers, A. Simons, H. Younessi. Th e OPEN Toolbox of Techniques. Addison-Wesley. 1998.
[8] F.Huber, B. Schätz, A. Schmidt, K. Spies. AutoFo cus-A Tool for Distributed Systems Specification. I N:
Proceedings of FTRTFT'96, Formal Techniques in Real -Time and Fault-Tolerant Systems, p. 467-470.
Springer Verlag. LNCS 1135. 1996.
[9] P. Hudak et al. Report on the Programming Langua ge HASKELL. Yale University, CS Dept. Technical
Report. YALEU/DCS/RR-777. 1990.
[10] ITU-T. Recommendation Z.100, Specification and Description Language (SDL). ITU-T, Geneva. 1993.
[11] ITU-T. Message Sequence Chart (MSC). Z.120:96. ITU-T, Geneva. 1996.
[12] I. Jacobson, G. Booch, J. Rumbaugh. The Unified  Software Development Process. Addison-Wesley. 1999 .
[13] M. P. Jones. An Introduction to Gofer. 1993.
[14] I. Krüger. Towards the Methodical Usage of Mess age Sequence Charts. In: Formale Beschrei-
bungstechniken für verteilte Systeme. FBT99. K. Spi es and B. Schätz (eds.). 9. GI/ITG Fachgespräch, p.
123-134. Herbert Utz Verlag. 1999.
[15] OMG - Object Management Group. Unified Modeling  Language Specification. V1.3. 1999.
[16] W. Opdyke, R. Johnson. Creating Abstract Superc lasses by Refactoring. Technical Report. Dept. of
Computer Science, University of Illinois and AT&T B ell Laboratories. 1993.
[17] L. Paulson. ML for the Working Programmer. Camb ridge University Press. 1991.
[18] W. Reisig. Petri-Nets - An Introduction. EATCS Monograph, No. 4. Springer Verlag, 1985.
[19] J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, W. Lorensen. Object-Oriented Modeling and Design.
Prentice Hall. 1994.
[20] B. Selic, G. Gullekson, P. Ward. Real-Time Obje ct-Oriented Modeling. John Wiley & Sons. 1994.
[21] J. Warmer, A. Kleppe. The Object Constraint Lan guage. Addison-Wesley. 1998.
