                                                                                                                      Date : January 2011
OMG Unified Modeling LanguageTM (OMG UML),  
Infrastructure
Version 2.4
OMG Document Number:  ptc/2010-11-16
Standard document URL:  http://www.o mg.org/spec/UML/2.4/Infrastructure
Associated Normative Ma chine-Readable Files: 
ptc/2010-11-17 -- http://www.omg.org /spec/UML/20 101101/Infrastructure.xmi  
ptc/2010-11-19 -- http://www.o mg.org/spec/UML/20 101101/L0.xmi  
ptc/2010-11-23 -- http://www.omg.org/spec/UML/20 101101/LM.xmi  
ptc/2010-11-24 -- http://www.omg.org /spec/UML/20101101/PrimitiveTypes.xmi  
Version 2.4 is a minor revision to the UML 2. 3 specification. It supersedes formal/2010-05-04.
After adoption: Updated URLs to match file names. 

Copyright © 2009-2010 88Solutions
Copyright © 2009-2010 Artisan Software ToolsCopyright © 2001-2010 Adaptive
Copyright © 2009-2010 Armstrong Process Group, Inc.
Copyright © 2001-2010 Alcatel Copyright © 2001-2010 Borland Software Corporation Copyright © 2009-2010 Commissariat à l'Energie AtomiqueCopyright © 2001-2010 Computer Associates International, Inc. 
Copyright © 2009-2010 Computer Sciences CorporationCopyright © 2009-2010 European Aeronautic Defence and Space CompanyCopyright © 2001-2010 Fujitsu Copyright © 2001-2010 Hewlett-Packard Company Copyright © 2001-2010 I-Logix Inc. Copyright © 2001-2010 International Business Machines Corporation 
Copyright © 2001-2010 IONA Technologies Copyright © 2001-2010 Kabira Technologies, Inc. Copyright © 2009-2010 Lockheed MartinCopyright © 2001-2010 MEGA International Copyright © 2009-2010 Mentor Graphics CorporationCopyright © 2009-2010 Microsoft CorporationCopyright © 2009-2010 Model Driven SolutionsCopyright © 2001-2010 Motorola, Inc. Copyright © 2009-2010 National Aeronautics and Space Administration
Copyright © 2009-2010 National Institute of Standards & TechnologyCopyright © 2009-2010 No Magic, Inc.Copyright © 2009-2010 oose Innovative Informatik GmbHCopyright © 2001-2010 Oracle Corporation 
Copyright © 2009-2010 Oslo Software, Inc.
Copyright © 2009-2010 Perdue UniversityCopyright © 2009-2010 SINTEFCopyright © 2001-2010 SOFTEAM Copyright © 2009-2010 Sparx Systems Pty LtdCopyright © 2001-2010 Telefonaktiebolaget LM Ericsson Copyright © 2009-2010 THALESCopyright © 2001-2010 Unisys Copyright © 2001-2010 X-Change Technologies Group, LLC
                                                                                                                      
USE OF SPECIFICATION - TERMS, CONDITIONS & NOTICES
The material in this document details an Object Management  Group specification in accordan ce with the terms, conditions 
and notices set forth below. This document does not represent a commitment to implement any portion of this 
specification in any company's products. Th e information contained in this documen t is subject to change without notice.
LICENSES
The companies listed above have grante d to the Object Management Group, Inc. (OMG) a nonexclusive, royalty-free, 
paid up, worldwide license to copy and distribute this document  and to modify this document and distribute copies of the 
modified version. Each of the copyright holders listed above has agreed that no person shall be deemed to have infringed 
the copyright in the included material of  any such copyright holder by reason of having used the specification set forth 
herein or having conformed any computer software to the specification.
Subject to all of the terms and conditions below, the owners of the copyright in this specification hereby grant you a fully-
paid up, non-exclusive, nontransferable, perpetual, worldwid e license (without the right to  sublicense), to use this 
specification to create and distribute soft ware and special purpose specifications th at are based upon this specification, 
and to use, copy, and distribute this specification as provided under the Copyright Act; provided that: (1) both the copyright notice identified above and this permission notice appear on any copies of this specification; (2) the use of the specifications is for informational purposes  and will not be copied or posted on a ny network computer or broadcast in any 
media and will not be otherwise resold or transferred for co mmercial purposes; a nd (3) no modifications are made to this 
specification. This limited pe rmission automatically terminates without notice if you breach a ny of these terms or 
conditions. Upon termination, you will destroy immediately any co pies of the specifications in your possession or control. 
PATENTS
The attention of adopters is directed to the possibility th at compliance with or adopti on of OMG specifications may 
require use of an invention covered by patent rights. OMG shall not be responsible for identifying patents for which a 
license may be required by any OMG specification, or for condu cting legal inquiries into the legal validity or scope of 
those patents that are brought to its attention. OMG specifica tions are prospective and adviso ry only. Prospective users are 
responsible for protecting themselves against liability for infringement of patents.
GENERAL USE RESTRICTIONS
Any unauthorized use of this specificat ion may violate copyright laws, trademark laws, and communications regulations 
and statutes. This document contains information which is prot ected by copyright. All Rights Reserved. No part of this 
work covered by copyright herein may be reproduced or us ed in any form or by any means--graphic, electronic, or 
mechanical, including photocopying, recording, taping, or in formation storage and retrieval systems--without permission 
of the copyright owner.
DISCLAIMER OF WARRANTY
WHILE THIS PUBLICATION IS BELIEVED TO BE AC CURATE, IT IS PROVIDED "AS IS" AND MAY CONTAIN 
ERRORS OR MISPRINTS. THE OB JECT MANAGEMENT GROUP AND THE COMPANIES LISTED ABOVE 
MAKE NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS PUBLICATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF  TITLE OR OWNERSHIP, IMPLIED WARRANTY OF 
MERCHANTABILITY OR WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE. IN NO EVENT SHALL THE OBJECT MANAGEMENT GR OUP OR ANY OF THE COMPANIES LISTED ABOVE 
BE LIABLE FOR ERRORS CONTAINED HEREIN OR  FOR DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
CONSEQUENTIAL, RELIANCE OR COVER DAMAGES, IN CLUDING LOSS OF PROFITS, REVENUE, DATA OR 
USE, INCURRED BY ANY USER OR ANY THIRD PARTY IN CONNECTION WITH THE FURNISHING, 
PERFORMANCE, OR USE OF THIS MATERIAL, EVEN  IF ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES. 
The entire risk as to the qu ality and performance of software developed using this specification is borne by you. This 
disclaimer of warranty constitutes an essential part of the license granted to y ou to use this specification.
RESTRICTED RIGHTS LEGEND
Use, duplication or disclosure by the U.S. Government  is subj ect to the restrictions set forth in subparagraph (c) (1) (ii) of  
The Rights in Technical Data and Comput er Software Clause at DFARS 252.227-7 013 or in subparagraph (c)(1) and (2) 
of the Commercial Computer Software - Restricted Rights clau ses at 48 C.F.R. 52.227-19 or as specified in 48 C.F.R. 227-
7202-2 of the DoD F.A.R. Supplement and its successors, or as  specified in 48 C.F.R. 12.212 of the Federal Acquisition 
Regulations and its successors, as applicable. The specificat ion copyright owners are as indicated above and may be 
contacted through the Object Management Group, 140 Kendrick Street, Needham, MA 02494, U.S.A.
TRADEMARKS
MDA®, Model Driven Architecture®, UML®, UML Cube logo®, OMG Logo®, CO RBA® and XMI® are registered 
trademarks of the Object Management  Group, Inc., and Object Management Group™, OMG™ , Unified Modeling 
Language™, Model Driven Architect ure Logo™, Model Driven Architect ure Diagram™, CORBA logos™, XMI 
Logo™, CWM™, CWM Logo™, IIOP™ , IMM™, MOF™ , OM G Interface Definition Language (IDL)™, and OMG 
Systems Modeling Language (OMG SysML)™ are trademarks of  the Object Management Group. All other products or 
company names mentioned are used for identification purposes only, and may be trademarks of their respective owners.
COMPLIANCE
The copyright holders listed above acknowledge that the Object Management Group (acting itself or through its 
designees) is and shall at all times be th e sole entity that may authorize developers, suppliers and sellers of computer 
software to use certification marks, trad emarks or other special designations to indicate compliance with these materials.
Software developed under the terms of this license may clai m compliance or conformance wi th this specification if and 
only if the software compliance is of  a nature fully matching the applicable compliance points as stated in the 
specification. Software developed only partially matching the applicable compliance points may claim only that the 
software was based on this specification, but may not claim compliance or conformance with  this specification. In the 
event that testing suites  are implemented or approved by Object Management Group, Inc., software developed using this 
specification may claim compliance or conf ormance with the specification only if the software satisfactorily completes 
the testing suites.
UML Infrastructure Specification, v2.4        OMG’s Issue Reporting Procedure
All OMG specifications are subject to  continuous review and improvement . As part of this process we 
encourage readers to report any ambi guities, inconsistencies, or inaccu racies they may find by complet-
ing the Issue Reporting Form li sted on the main web page http://www.omg.org , under Documents, Report 
a Bug/Issue (http://www.omg.o rg/technology/agreement.htm).
                UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4        iTable of Contents
1.Scope  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2.Conformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
2.1 Language Units  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2
2.2 Compliance Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2
2.3 Meaning and Types of Compliance  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3
2.4 Compliance Level Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .5
3.Normative References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
4.Terms and Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
5.Notational Conventions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
6.Additional Information  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
6.1 Architectural Alignmen t and MDA Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6
6.2 How to Proceed  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6
6.2.1 Diagram format .......................................................................................................... ........... 7
Part I - Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
7.Language Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
7.1 Design Principles  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .11
7.2 Infrastructure Architecture  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .11
7.3 Core  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
7.4 Profiles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1 4
7.5 Architectural Alignment between UML and MOF . . . . . . . . . . . . . . . . . . . . . . . . .15
7.6 Superstructure Architectu re  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .15
7.7 Reusing Infrastructure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .16
7.8 The Kernel Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .17
7.9 Metamodel Layeri ng . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .17
7.10 The Four-layer Metam odel Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .17
ii                 UML Infrastructure Specification, v2.47.11 Metamodeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .18
7.12 An Example of the F our-level Metamodel Hierarchy  . . . . . . . . . . . . . . . . . . . . . .19
8.Language Formalism  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .21
8.1 Levels of Formalism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .21
8.2 Package Specification Structure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .22
8.2.1 Class Descriptions ...................................................................................................... ........ 22
8.2.2 Diagrams ................................................................................................................ ............ 22
8.2.3 Instance Model .......................................................................................................... ......... 22
8.3 Class Specification Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .22
8.3.1 Description ............................................................................................................. ............. 23
8.3.2 Attributes .............................................................................................................. ............... 23
8.3.3 Associations ............................................................................................................ ............ 23
8.3.4 Constraints ............................................................................................................. ............. 23
8.3.5 Additional Operations (optional) ........................................................................................ .2 3
8.3.6 Semantics ............................................................................................................... ............ 23
8.3.7 Semantic Variation Points (optional) ................................................................................... 2 3
8.3.8 Notation ................................................................................................................ .............. 24
8.3.9 Presentation Options (optional) ............. ............................................................................ .2 4
8.3.10 Style Guidelines (optional) ................ ............................................................................ .... 24
8.3.11 Examples (optional) .................................................................................................... ...... 24
8.3.12 Rationale (optional) ................................................................................................... ........ 24
8.3.13 Changes from UML 1.4 ................................................................................................... .. 24
8.4 Use of a Constraint Langua ge  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .24
8.5 Use of Natural Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25
8.6 Conventions and Typography  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25
Part II - Infrastructure Library  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
9.Core::Abstractions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .29
9.1 BehavioralFeatures Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .31
9.1.1 BehavioralFeature ....................................................................................................... ....... 31
9.2 Parameter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .32
9.3 Changeabilities Package  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .33
9.3.1 StructuralFeature (as spec ialized) ...................................................................................... 34
9.4 Classifiers Package  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .34
9.4.1 Classifier .............................................................................................................. ............... 35
9.4.2 Feature ................................................................................................................. .............. 36
9.5 Comments Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .37
9.5.1 Comment ................................................................................................................. ........... 37
UML Infrastructure Specification, v2.4        iii9.5.2 Element ............................................................................................................................... 38
9.6 Constraints Package  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .39
9.6.1 Constraint .............................................................................................................. ............. 40
9.6.2 Namespace (as specialized) .............................................................................................. .4 3
9.7 Elements Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .44
9.7.1 Element ............................................................................................................................... 44
9.8 Expressions Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .45
9.8.1 Expression .............................................................................................................. ............ 45
9.8.2 OpaqueExpression ........................................................................................................ ..... 46
9.8.3 ValueSpecification ...................................................................................................... ........ 48
9.9 Generalizations Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .49
9.9.1 Classifier (as specialized) ............................................................................................. ...... 50
9.9.2 Generalization ..................................................................................................................... 51
9.10 Instances Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .53
9.10.1 InstanceSpecification ........................ .......................................................................... ...... 54
9.10.2 InstanceValue ............ .............................................................................................. ......... 57
9.10.3 Slot ............................................................................................................................... ..... 58
9.11 Literals Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .59
9.11.1 LiteralBoo lean ......................................................................................................... .......... 59
9.11.2 LiteralInteger ......................................................................................................... ............ 60
9.11.3 LiteralNull ... ......................................................................................................... .............. 61
9.11.4 LiteralReal ......................................................................................................................... 62
9.11.5 LiteralSpecification ............................................................................................................ 63
9.11.6 LiteralString ....................................................................................................................... 63
9.11.7 LiteralUnlimitedNatural ................................................................................................ ..... 64
9.12 Multiplicities Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .65
9.12.1 MultiplicityElement .................................................................................................... ........ 66
9.13 MultiplicityExpressions Package  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .69
9.13.1 MultiplicityElement (specialized) ...................................................................................... .7 0
9.14 Namespaces Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .72
9.14.1 NamedElement .................................... ....................................................................... ...... 72
9.14.2 Namespace ....................................................................................................................... 74
9.15 Ownerships Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .75
9.15.1 Element (as specialized) ...................... ......................................................................... .... 76
9.16 Redefinitions Package  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .77
9.16.1 RedefinableElement ..................................................................................................... .... 78
9.17 Relationships Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .80
9.17.1 DirectedRelationship ......................................................................................................... 80
9.17.2 Relationship .. ......................................................................................................... ........... 81
iv                 UML Infrastructure Specification, v2.49.18 StructuralFeatures Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .82
9.18.1 StructuralFeature ...................................................................................................... ........ 82
9.19 Super Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .83
9.19.1 Classifier (as specialized) ................. ........................................................................... ..... 84
9.20 TypedElements Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .86
9.20.1 Type ................................................................................................................... ............... 87
9.20.2 TypedElement ........................................................................................................... ........ 88
9.21 Visibilities Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .88
9.21.1 NamedElement (as specialized) ................. ...................................................................... 89
9.21.2 VisibilityKind ......................................................................................................... ............. 90
10.Core::Basic  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .91
10.1 Types Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .92
10.1.1 Comment ................................................................................................................ .......... 92
10.1.2 Element ......... ....................................................................................................... ............. 93
10.1.3 NamedElement .......... ................................................................................................. ...... 93
10.1.4 Type ................................................................................................................... ............... 94
10.1.5 TypedElement ................ ........................................................................................... ........ 94
10.2 Classes Diagram  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .95
10.2.1 Class .................................................................................................................. ............... 95
10.2.2 MultiplicityElem ent .................................................................................................... ........ 96
10.2.3 Operation .............................................................................................................. ............ 97
10.2.4 Parameter .................. ............................................................................................ ........... 97
10.2.5 Property ............................................................................................................... ............. 98
10.3 DataTypes Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .99
10.3.1 DataType ............................................................................................................... ........... 99
10.3.2 Enumeration ............................................................................................................ ....... 100
10.3.3 EnumerationLiteral ............................ ......................................................................... ..... 100
10.3.4 PrimitiveType .......................................................................................................... ........ 101
10.4 Packages Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .101
10.4.1 Package ........ ........................................................................................................ .......... 101
10.4.2 Type ................................................................................................................... ............. 102
11.Core::Constructs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .103
11.1 Root Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .105
11.1.1 Comment ................................................................................................................ ........ 105
11.1.2 DirectedRelationship .. ................................................................................................. .... 106
11.1.3 Element ......... ....................................................................................................... ........... 106
11.1.4 Relationship ............ ............................................................................................... ......... 107
11.2 Expressions Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .108
11.2.1 Expression ............................................................................................................. ......... 108
11.2.2 OpaqueExpression ........ ............................................................................................... .. 109
UML Infrastructure Specification, v2.4        v11.2.3 ValueSpecification ..... ................................................................................................ ..... 109
11.3 Classes Diagram  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .110
11.3.1 Association ............................................................................................................ ......... 111
11.3.2 Class .................................................................................................................. ............. 118
11.3.3 Classifier .... ......................................................................................................... ............ 121
11.3.4 Operation .............................................................................................................. .......... 124
11.3.5 Property ............................................................................................................... ........... 124
11.4 Classifiers Diagram  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .129
11.4.1 Classifier .... ......................................................................................................... ............ 130
11.4.2 Feature ................................................................................................................ ........... 131
11.4.3 MultiplicityElement .................................................................................................... ...... 132
11.4.4 RedefinableElement ............................... ...................................................................... .. 132
11.4.5 StructuralFeature ...................................................................................................... ...... 133
11.4.6 Type ................................................................................................................... ............. 134
11.4.7 TypedElement ................................................................................................................. 135
11.5 Constraints Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .135
11.5.1 Constraint ...................................... ....................................................................... .......... 136
11.5.2 Namespace ..................................................................................................................... 136
11.6 DataTypes Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .137
11.6.1 DataType ................... ............................................................................................ ......... 138
11.6.2 Enumeration . ........................................................................................................... ....... 139
11.6.3 EnumerationLiteral .......................................................................................................... 140
11.6.4 Operation .............................................................................................................. .......... 141
11.6.5 PrimitiveType .......................................................................................................... ........ 141
11.6.6 Property ............................................................................................................... ........... 142
11.7 Namespaces Diagram  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .143
11.7.1 ElementImport ........... ............................................................................................... ...... 144
11.7.2 NamedElement .......... ................................................................................................. .... 146
11.7.3 Namespace ..................................................................................................................... 147
11.7.4 PackageableElement .............................. ....................................................................... .1 4 8
11.7.5 PackageImport ................................................................................................................ 149
11.8 Operations Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .150
11.8.1 BehavioralFeature ............................... ....................................................................... .... 151
11.8.2 Operation .............................................................................................................. .......... 152
11.8.3 Parameter .................. ............................................................................................ ......... 156
11.8.4 ParameterDirectionKind .................................................................................................. 157
11.9 Packages Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .157
11.9.1 Type ................................................................................................................... ............. 158
11.9.2 Package ................................................................................................................ .......... 159
11.9.3 PackageMerge ................................................................................................................ 161
12.Core::Profiles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
12.1 Profiles package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .179
vi                 UML Infrastructure Specification, v2.412.1.1 Class (from Profiles) ......................... ......................................................................... ..... 180
12.1.2 Extension (from Profiles)  .............................................................................................. .. 181
12.1.3 ExtensionEnd (from Prof iles) .......................................................................................... 1 84
12.1.4 Image (from Profiles) ........................ .......................................................................... .... 185
12.1.5 Package (from Profiles) ................................................................................................ .. 186
12.1.6 PackageableElement (fro m Profiles) .............................................................................. 188
12.1.7 Profile (from Profiles) ................................................................................................ ...... 188
12.1.8 ProfileApplication (from Profiles) .................................................................................... 1 95
12.1.9 Stereotype (fro m Profiles) ............................................................................................. .. 196
13.PrimitiveTypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .171
13.1 PrimitiveTypes Package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .171
13.1.1 Boolean ............................................. ................................................................... ........... 171
13.1.2 Integer ................................................................................................................ ............. 172
13.1.3 Real ................................................................................................................... ............. 173
13.1.4 String ................................................................................................................. ............. 174
13.1.5 UnlimitedNatural ....................................................................................................... ...... 175
Part III - Annexes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
Annex A: XMI Serialization and Schema . . . . . . . . . . . . . . . . . . . . . . . . . . . .207
Annex B: Support for Model Dri ven Architecture  . . . . . . . . . . . . . . . . . . . .209
Annex C: UML XMI Documents  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .207
INDEX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .211
UML Infrastructure Specification, v2.4        11S c o p e
This specification defines the Unified M odeling Language (UML), revisi on 2. The objective of UML is to provide system 
architects, software engineers, and soft ware developers with tools for analysis , design, and implementation of software-
based systems as well as for mode ling business and similar processes.
The initial versions of UML (UML 1) originated with thre e leading object-oriented methods (Booch, OMT, and OOSE), 
and incorporated a number of best practices from m odeling language design, object-oriented programming, and 
architectural description languages. Relativ e to UML 1, this revision of UML has been enhanced with significantly more 
precise definitions of its abstract syntax  rules and semantics, a more modular la nguage structure, and a greatly improved 
capability for modeling large-scale systems.
One of the primary goals of UML is to advance the state of the industry by enabling object visual modeling tool 
interoperability. However, to enable meaningful exchange of  model information between tools, agreement on semantics 
and notation is required. UML meets the following requirements:
• A formal definition of a common MOF-based metamodel that specifies the abstract syntax of the UML. The abstract 
syntax defines the set of UML modeling concepts, their attributes and their relationships, as well as the rules for 
combining these concepts to construct partial or complete UML models.
• A detailed explanation of the seman tics of each UML modeling concept. Th e semantics define, in a technology-
independent manner, how the UML concep ts are to be realized by computers.
• A specification of the human-r eadable notation elements for representing the individual  UML modeling concepts as 
well as rules for combining them into a variety of different diagra m types corresponding to different aspects of modeled 
systems.
• A detailed definition of ways in which UML tools can be made  compliant with this specification. This is supported (in 
a separate specification) with an XM L-based specification of corresponding model interchange formats (XMI) that 
must be realized by compliant tools.
2 Conformance
UML is a language with a very broad scope  that covers a large and diverse set of  application domains. Not all of its 
modeling capabilities are necessarily  useful in all domains or applications. Th is suggests that the language should be 
structured modularly, with the ability to select only those pa rts of the language that are of direct interest. On the other 
hand, an excess of this type of flexibility increases the likelihood that two different UML tools will be supporting 
different subsets of the language, leading to interchange problems between them. Consequently, the definition of 
compliance for UML requires a bala nce to be drawn between modularity and ease of interchange. 
Experience with previous versions of UML has indicated that the ability to exchange models between tools is of 
paramount interest to a large community of users. For th at reason, this specification defines a small number of compliance 
levels  thereby increasing the likelihood that two or more complia nt tools will support the same or compatible language 
subsets. However, in recognition of the need for flexibility in learning and using the language, UML also provides the 
concept of language units .
2                 UML Infrastructure Specification, v2.42.1 Language Units
The modeling concepts of UML are grouped into language units . A language unit consists of a collection of tightly-
coupled modeling concepts that provide users with the power to  represent aspects of the system under study according to 
a particular paradigm or formalism. For example, the State Machines language unit enables modelers to specify discrete 
event-driven behavior using a variant of the well-known statecharts formalism, while the Activities language unit 
provides for modeling behavior based on a workflow-like paradigm. From the user’s perspective, this partitioning of 
UML means that they need only be concer ned with those parts of the language th at they consider necessary for their 
models. If those needs change over time, furt her language units can be added to the us er’s repertoire as required. Hence, 
a UML user does not have to know the full language to use it effectively. 
In addition, most language units are partitioned into multiple  increments, each adding more modeling capabilities to the 
previous ones. This fine-grained decom position of UML serves to make the langua ge easier to learn and use, but the 
individual segments within this structure do not represent sepa rate compliance points. The latter strategy would lead to an 
excess of compliance points and result to the interoperability  problems described above. Nevertheless, the groupings 
provided by language units and their increments do serve to  simplify the definition of UML compliance as explained 
below.
2.2 Compliance Levels
The stratification of language units is used as the founda tion for defining compliance in UML. Namely, the set of 
modeling concepts of UML is partitioned into hor izontal layers of increasing capability called compliance levels . 
Compliance levels cut across the various language units, alth ough some language units are only present in the upper 
levels. As their name suggests, each complia nce level is a distinct compliance point.
For ease of model interchange, there are just tw o compliance levels define d for UML Infrastructure:
• Level 0 (L0)  - This contains a single language unit that provide s for modeling the kinds of class-based structures 
encountered in most popular object-oriented programming la nguages. As such, it provides an entry-level modeling 
capability. More importantly, it represents  a low-cost common denominator that can  serve as a basis for interoperability 
between different categories of modeling tools.
• Metamodel Constructs (LM)  - This adds an extra language unit for more  advanced class-based structures used for 
building metamodels (using CMOF) such as UML itself.
As noted, compliance levels build on s upporting compliance levels. The principal me chanism used in this specification 
for achieving this is package merge  (see Section 11.9.3, “PackageMerge,” on page 161). Package merge allows modeling 
concepts defined at one level to be extended with new features. Most importantly, this is achieved in the context of the 
same namespace , which enables interchange of models at different levels of compliance as described in “Meaning and 
Types of Compliance.”For this reason, all compliance levels are defined as extensions to a single core “UML” package that defines the common 
namespace shared by all the complianc e levels. Level 0 is defined by th e top-level metamodel shown below.
UML Infrastructure Specification, v2.4        3Figure 2.1 - Level 0 package diagram
In this model, ”UML” is originally an empty package that s imply merges in the contents of the Basic package from the 
UML Infrastructure. This package, contains elementary conc epts such as Class, Package, DataType, Operation, etc.
At the next level (Level LM), the cont ents of the “UML” package, now includin g the packages merged into Level 0 and 
their contents, are extended with the Constructs package.
Figure 2.2 - Level M package diagram
Note that LM does not explicitly merge Basic, since the elemen ts in Basic are already incorporated into the corresponding 
elements in Constructs.
2.3 Meaning and Types of Compliance
Compliance to a given level entails full realization of  all language units that are defined for that compliance level. This 
also implies full realization of all language units in all the levels below that level.  “Full realization” for a language unit at 
a given level means supporting the complete set of modeling concepts  defined for that language unit at that level .
Thus, it is not meaningful to claim compliance to, say, Leve l 2 without also being compliant with the Level 0 and Level 
1. A tool that is compliant at a given level must be able to  import models from tools that are compliant to lower levels 
without loss of information. 

4                 UML Infrastructure Specification, v2.4There are two distinct types of compliance. They are:
• Abstract syntax  compliance . For a given compliance level, this entails: 
• compliance with the metaclasse s, their structural relationships, and any co nstraints defined as part of the merged 
UML metamodel for that compliance level, and
• the ability to output models and to read in models based on the XMI schema corresponding to that compliance 
level.
• Concrete syntax compliance . For a given compliance level, this entails:
• compliance to the notation defined in the “Notation” sub clauses in this specification for those metamodel elements 
that are defined as part of the merged metamodel for th at compliance level and, by im plication, the diagram types 
in which those elements may appear; and optionally
• the ability to output diagrams and to read in diagrams based on the XMI schema defined by the Diagram 
Interchange specification for notation at that level. This  option requires abstract syntax and concrete syntax 
compliance.  
 
Concrete syntax compliance does not re quire compliance to any presentation optio ns that are defined as part of the 
notation.
Compliance for a given level can be expressed as: 
• abstract syntax compliance
• concrete syntax compliance 
• abstract syntax with c oncrete syntax compliance
• abstract syntax with concrete synt ax and diagram interchange compliance
In case of tools that generate program c ode from models or those that are capable of  executing models, it is also useful to 
understand the level of support for the run-time semantics de scribed in the various “Semantics” sub clauses of the 
specification. However, the presence of numerous variation points in these semantics (and the fact that they are defined 
informally using natural language), make it impractical to defi ne this as a formal compliance type, since the number of 
possible combinations is very large.
A similar situation exists with presentation options, since different implementers may make different choices on which 
ones to support. Finally, it is recognized th at some implementers and profile designers may want to support only a subset 
of features from levels that are above th eir formal compliance level. (Note, howeve r, that they can only claim compliance 
to the level that they fully support, even if they implement significant parts of the capabilities of higher levels.) Given thi s 
potential variability, it is useful to be able to specify cl early and efficiently, which capabilities are supported by a given 
implementation. To this end, in addition to a formal stat ement of compliance, implemente rs and profile designers may Table 2.1 - Example compliance statement
Compliance Summary
Compliance level Abstract Syntax Concrete Syntax Diagram Interchange Option
L0 YES YES NO
LM NO YES NO
UML Infrastructure Specification, v2.4        5also provide informal feature support statements . These statements identify support for additional features in terms of 
language units and/or individual metam odel packages, as well as for less precisely define d dimensions such as 
presentation options and semantic variation points. 
An example feature support statement is shown in Table 2.2 for an implementation whose compliance statement is given 
in Table 2.1. In this case, the implementation adds two new language units from higher levels.
2.4 Compliance Level Contents
Table 2.3 identifies the packages by individual compliance levels  in addition to those that are defined in lower levels (as 
a rule, Level (N) includes all the packages supported by Level (N-1)). The set of actual mode ling features added by each 
of the packages are described in the appropr iate clauses of the related language unit.
3 Normative References
The following normative documents contain provisions which, thro ugh reference in this text, co nstitute provisions of this 
specification. For dated references, subs equent amendments to, or revisions of, any of these publications do not apply. 
• RFC2119, http://ietf.org/rfc/rfc2119, Key words for use in RFCs to Indicate Requirement Levels, S. Bradner, March 
1997.
• ISO/IEC 19505-2 , Information technology — OMG Unified M odeling Language (OMG UML) Version 2.4 — Part 2: 
Superstructure
• OMG Specification formal/??-??- ??, UML Superstructure, v2.4
• OMG Specification formal/2010-02-01, Object Constraint  Language, v2.2
• OMG Specification formal/??-??-??, Meta Object Facility (MOF) Core, v2.4 
• OMG Specification formal/??-??-??, Meta Object Facility(MOF) 2.4 XMI Mapping Specification, v2.4
• OMG Specification formal/ ??-??-??, XMI Metadata Interchange (XMI) v2.4Table 2.2 - Example f eature support statement
Feature Support Statement
Language Unit Feature
Constructs An Association A1 specializes another Association A2 if each end of A1 subsets the 
corresponding end of A2.
Constructs A redefining property must have the same name as the redefined property.
Table 2.3 - Metamodel packages added to compliance levels
Level Metamodel Package Added
L0 Basic
LM Constructs
6                 UML Infrastructure Specification, v2.4• OMG Specification formal/06-04-04 , UML 2.0 Diagram Interchange
Note – UML 2 is based on a different generation of MOF and XMI than that specified in ISO/IEC 19502:2005  Information 
technology - Meta Object Facility (MOF) and ISO/IEC 19503:2005  Information technology - XML Metadata Interchange 
(XMI) that are compatible with ISO/IEC 19501 UML version 1.4.1.
4 Terms and Definitions
There are no formal definitions in this speci fication that are taken from other documents.
5 Notational Conventions
The keywords “must,” “must not,”  “shall,” “shall not,” “should,” “should not,” an d “may” in this specification are to be 
interpreted as desc ribed in RFC 2119.
6 Additional Information
6.1 Architectural Alig nment and MDA Support
Clause 7, “Langua ge Architecture,”  explains how the UML 2: Infrastructure  is architecturally aligned with the UML 2: 
Superstructure  that complements it. It also explains how  the InfrastructureLibrary defined in the UML 2: Infrastructure 
can be strictly reused by MOF 2 specifications. 
The MOF 2: Core Specification is architecturally a ligned with this specification. 
The OMG’s Model Driven Architecture (MDA) initiative is an e volving conceptual architecture for a set of industry-wide 
technology specifications that will support a model-driven approa ch to software development. Although MDA is not itself 
a technology specification, it represents an important approach and a plan to ac hieve a cohesive set of model-driven 
technology specifications. This specifica tion’s support for MDA is discussed in Annex B: “Support for Model Driven 
Architecture,” on page 209.
6.2 How to Proceed
The rest of this document contains the technical content of this  specification. Readers are encouraged to first read “Part I 
- Introduction” to familiarize th emselves with the structure of the language  and the formal approach used for its 
specification. Afterwards th e reader may choose to either explore the In frastructureLibrary, described in “Part II - 
Infrastructure Library” or the UML::Classes::Ker nel package that reuses  it, described in the UML 2: Superstructure . The 
former specifies the flexible metamodel library that is reused by the latter.
Readers who want to explore the user le vel constructs that are built upon the infr astructural construc ts specified here 
should investigate the specifica tion that complements this, the UML 2: Superstructure . 
UML Infrastructure Specification, v2.4        7Although the clauses are organized in a logical manner and can be read sequentially, this is  a reference specification  
intended to be read in a non-sequential manner. Consequently, extensive cross-re ferences are provided to facilitate 
browsing and search.
6.2.1 Diagram format
The following conventions are adopted for all meta model diagrams throughout this specification:
• An association with one end marked by a navigability arrow means that: 
• the association is navigable in  the direction of that end, 
• the marked association end is owned by the classifier, and
• the opposite (unmarked) association end is owned by the association.
• An association with neither end marked  by navigability arrows means that:
• the association is navigable in both directions,
• each association end is owned by the classifier at the opposite end (i.e., neither end is owned by the association).
• Association specialization and redefinition are indicated by appropriate constraints situat ed in the proximity of the 
association ends to which they apply. Thus:
• the constraint {subsets endA} means th at the association end to which this co nstraint is applied is a specialization 
of association end endA that is part  of the association being specialized.
• a constraint {redefines endA} means that the association end to which this  constraint is applied redefines the 
association end endA that  is part of the associ ation being specialized.
• If no multiplicity is shown on an association end, it implies a multiplicity of exactly 1.
• If an association end is unlabeled, the default name for that  end is the name of the class to which the end is attached, 
modified such that the first letter is a lowercase letter. (Note that, by conven tion, non-navigable a ssociation ends are 
often left unlabeled since, in general, there is no need to refer to them explicitly either  in the text or in formal 
constraints – although they may be needed for other purposes, such as MOF language bindings that use the 
metamodel.)
• Associations that are not explicitly na med, are given names that are construc ted according to the following production 
rule: 
 
“A_” <association-end-name1>  “_” <association-end-name2>  
 
where <association-end-name1>  is the name of the first association end and <association-end-name2>  is the name of 
the second association end.
• An unlabeled dependency between two packages is  interpreted as a package import relationship.
Note that some of these conventions were adopted to contend with practical issues related to the mechanics of producing 
this specification, such as the unavailability of conforming modeling tools at the time the specification itself was being 
defined. Therefore, they should not necessarily be deemed as recommendations for general use.
8                 UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4        9Part I - Introduction
The Unified Modeling Language is a visual language for spec ifying, constructing, and documenting the artifacts of 
systems. It is a general-purpose modeling language that can be  used with all major object and component methods, and 
that can be applied to all application domains (e.g., health, finance, telecom,  aerospace) and implementation platforms 
(e.g., J2EE, .NET).
The OMG adopted the UML 1.1 specification in November 1997 . Since then UML Revision Ta sk Forces have produced 
several minor revisions, the most recent being the UM L 1.4 specification, which was adopted in May 2001.
Under the stewardship of the OMG, the UML has emerged as the software industr y’s dominant modeling language. It has 
been successfully applied to a wide ra nge of domains, ranging from health and finance to aerospace to e-commerce. As 
should be expected, its extensive use ha s raised numerous application and imp lementation issues by modelers and 
vendors. As of the time of th is writing over 500 formal usage and implementa tion issues have been submitted to the OMG 
for consideration.
Although many of the issues have been resolved in minor revi sions by Revision Task Forces, other issues require major 
changes to the language that are outside the scope of an RTF. Consequently, the OMG issued four complementary and 
architecturally aligned RFPs to define UML: UML Infra structure, UML Superstructure, UML Object Constraint 
Language, and UML Diagram Interchange. This UML specification is organized into two volumes ( UML 2: Infrastructure and UML 2: Superstructure ), consistent 
with the breakdown of modeling language requirements into two RFPs ( UML Infrastructure RFP  and UML 
Superstructure RFP ). Since the two volumes cross-refe rence each other and the specifica tions are fully integrated, these 
two volumes could easily be combined  into a single volume at a later time.
The next two clauses describe the la nguage architecture and the specificatio n approach used to define UML 2.
10                 UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4        117 Language Architecture
The UML specification is defined using a metamodeling approach (i.e., a metamode l is used to specify the model that 
comprises UML) that adapts formal specification techniques. While this approach lacks some of the rigor of a formal 
specification method, it offers the advantages of being more intuitive and pragmatic for most implementors and 
practitioners.1 This clause explains the architecture of the UML metamodel.
The following sub clauses summarize the design principles follo wed, and show how they are applied to organize UML’s 
Infrastructure and Superstructure. The last sub clause explai ns how the UML metamodel conforms to a 4-layer metamodel 
architectural pattern.
7.1 Design Principles
The UML metamodel has been architected with  the following design principles in mind: 
• Modularity — This principle of strong cohesion and loose c oupling is applied to group constructs into packages and 
organize features into metaclasses. 
• Layering — Layering is applied in two ways to the UML meta model. First, the package stru cture is layered to separate 
the metalanguage core constructs from  the higher-level constructs that use them. Second, a 4-layer metamodel 
architectural pattern is consis tently applied to separate concerns (especial ly regarding instantiation) across layers of 
abstraction.
• Partitioning — Partitioning is used to organize conceptu al areas within the same layer. In the case of the 
InfrastructureLibrary, fine-grained par titioning is used to provide the flexibility required by current and future 
metamodeling standards. In the case of the UML metamodel, th e partitioning is coarser-grai ned in order to increase the 
cohesion within packag es and loosening the coupling across packages.
• Extensibility — The UML can be extended in two ways: 
• A new dialect of UML can be defined by using Profiles to  customize the language for particular platforms (e.g., 
J2EE/EJB, .NET/COM+) and domains (e.g., finance, telecommun ications, aerospace).
• A new language related to UML can be specified by reusing part of the Infras tructureLibrary package and 
augmenting with appropriate metaclasses and metarelations hips. The former case defines a new dialect of UML, 
while the latter case defines a new member of the UML family of languages.
• Reuse — A fine-grained, flexible metamodel library is provided that is reused to define the UML metamodel, as well as 
other architecturally related metamodels, such as the Meta Object Facility (MOF) and the Common Warehouse 
Metamodel (CWM).
7.2 Infrastructure Architecture
The Infrastructure of the UML is defined by the InfrastructureLibrary, which satisfi es the following design requirements:
1. It is important to note that the specification of UML as  a metamodel does not preclude it from being specified via a 
mathematically formal language (e.g., Object-Z or VDM) at a later time.
12                 UML Infrastructure Specification, v2.4• Define a metalanguage core that can be reused to defi ne a variety of metamodels, including UML, MOF, and CWM. 
• Architecturally align UML, MOF, and XMI so that model interchange is fully supported.
• Allow customization of UML through Profil es and creation of new languages (fam ily of languages) based on the same 
metalanguage core as UML.
As shown in Figure 7.1, Infrastruct ure is represented by two packages: InfrastructureLibrary  and PrimitiveTypes . The 
package InfrastructureLibrary  consists of the packages Core  and Profiles , where the latter defines the mechanisms that 
are used to customize metamodels and the former contains core concepts used when metamodeling. The package 
PrimitiveTypes  consists of a few predefined primitive types that ar e commonly used when metamodeling, and is designed 
specifically with the needs of UML and MOF in mind.
Figure 7.1  - The InfrastructureLibrary packages 
7.3 Core
In its first capacity, the Core  package is a complete metamodel particular ly designed for high reusability, where other 
metamodels at the same metale vel (see Section 7.6, “Superstructure Architect ure,” on page 15) either import or specialize 
its specified metaclasses. This is illust rated in Figure 7.2, where it is shown ho w UML, CWM, and MOF each depends on 
a common  core. Since these metamodels are at the very heart of  the Model Driven Architecture (MDA), the common core InfrastructureLibrary
Core Profiles PrimitiveTypes
UML Infrastructure Specification, v2.4        13may also be considered the architectural kernel of MDA. Th e intent is for UML and other MDA metamodels to reuse all 
or parts of the Core  package, which allows other meta models to benefit from the abstract  syntax and semantics that have 
already been defined. 
In order to facilitate reuse, the Core  package is subdivided into a number of packages: Abstractions , Basic , and 
Constructs  as shown in Figure 7.3. As we will se e in subsequent clauses, some of thes e are then further divided into even 
more fine-grained packages to make it possible to pick and choose the relevant parts when defining a new metamodel. 
Note, however, that choosing a specific package also imp lies choosing the dependent packages. There are minor 
differences in the design rationale for the other three packages. The package Abstractions  mostly contains abstract 
metaclasses that are intended to be furthe r specialized or that are expected to be  commonly reused by many metamodels. 
Very few assumptions are made about the metamodels that may want to reuse this package; for this reason, the package 
Abstractions  is also subdivided into severa l smaller packages. The package Constructs , on the other hand, mostly contains 
concrete metaclasses that lend themselves primarily to object-oriented modeling;  this package in particular is reused by 
both MOF and UML, and represents a signi ficant part of the work that has gone into aligning the two metamodels. The 
package Basic  represents a few constructs that are used as the basis for the produced XMI for UML, MOF, and other 
metamodels based on the InfrastructureLibrary .Figure 7.2 - The role of the common CoreCoreUML
MOFCWM
Profiles
14                 UML Infrastructure Specification, v2.4In its second capacity, the Core  package is used to define the modeling constr ucts used to create metamodels. This is done 
through instantiation of metaclasses in the InfrastructureLibrary  (see Section 7.9, “Metamode l Layering,” on page 17). 
While instantiation of metaclasses is carried out through MOF, the InfrastructureLibrary  defines the actual metaclasses 
that are used to instantiate the elements of UM L, MOF, CWM, and indeed the elements of the InfrastructureLibrary  itself. 
In this respect, the InfrastructureLibrary  is said to be self-describing, or reflective .
7.4 Profiles
As was depicted in Figure 7.1, the Profiles  package depends on the Core  package, and defines the mechanisms used to 
tailor existing metamodels towards specific platforms, such as C++, CORBA, or EJB; or domains such as real-time, 
business objects, or software pr ocess modeling. The primary target for profiles is UML, but it is poss ible to use profiles 
together with any metamodel that is based on (i.e., instan tiated from) the common core. A profile must be based on a 
metamodel such as the UML that it extends , and is not very useful standalone.
Profiles have been aligned with the extension mechanism offe red by MOF, but provide a more light-weight approach with 
restrictions that are enforced to ensure that the implementa tion and usage of profiles should be straightforward and more 
easily supported by tool vendors. Figure 7.3 - The Core packagesConstructs
ConstructsBasicAbstractionsPrimitiveTypes
«import»
«import»«import»
UML Infrastructure Specification, v2.4        157.5 Architectural Alignm ent between UML and MOF
One of the major goals of the Infrastructure has been to architecturally align UML and MOF. The first approach to 
accomplish this has been to define the comm on core, which is realized as the package Core , in such a way that the model 
elements are shared between UML and MOF. The second approach has been to make sure that UML is defined as a model 
that is based on MOF used as a metamodel,  as is illustrated in Figure 7.4. Note that MOF is used as the metamodel for 
not only UML, but also for other languages such as CWM. 
How these metalevel hierarchies work is explained in more  detail in Section 7.6, “Superstructure Architecture,” on 
page 15. An important aspect that deserv es mentioning here is that every model el ement of UML is an instance of exactly 
one model element in MOF. Note that the InfrastructureLibrary  is used at both the M2 and M3 metalevels, since it is 
being reused by UML and MOF, respectively,  as was shown in Figure 7.2. In the case of MOF, the metaclasses of the 
InfrastructureLibrary  are used as is, while in the case of UML these model elements are given additional properties. The 
reason for these differences is that the requirements when metamodeling differ slightly from the requirements when 
modeling applications of a very diverse nature. 
MOF defines for example how UML models are interchanged between tools using XML Meta data Interchange (XMI). 
MOF also defines reflective interfaces (M OF::Reflection) for introspection that work for not only MOF itself, but also for 
CWM, UML, and for any other metamodel that is an instance of  MOF. It further defines an extension mechanism that can 
be used to extend metamodels as an alternative to or in conjunction with profiles (as described in Clause 13, 
“Core::Profiles”). In fact, profiles are defined to be a subset of the MOF extension mechanism.
7.6 Superstructure Architecture
The UML Superstructure metamodel is specified by the UML  package, which is divided into a number of packages that 
deal with structural and behavioral  modeling, as shown in Figure 7.5. 
Each of these areas is describe d in a separate clause of the UML 2: Superstructure  specification. Note that there are some 
packages that are dependent on each othe r in circular dependencies. This is be cause the dependencies between the top-
level packages show a summary of all relationships between their subpackages; there are no circular dependencies 
between subpackages of those packages. Figure 7.4 - UML and MOF are at different metalevels«metamodel»
MOF
«metamodel»
UML«metamodel»
CWM«instanceOf» «instanceOf»M3
M2
16                 UML Infrastructure Specification, v2.4Figure 7.5 - The top-level package structure of the UML 2 Superstructure
7.7 Reusing Infrastructure
One of the primary uses of the UML 2 Infrastructure specifi cation is that it should be reused when creating other 
metamodels. The UML metamodel reuses the InfrastructureLibrary  in two different ways:
• All of the UML metamodel is instantiated fr om meta-metaclasses that  are defined in the InfrastructureLibrary .
• The UML metamodel imports and speci alizes all metaclasses in the InfrastructureLibrary .
As was discussed earlier, it is possible for a model to be used as a metamode l, and here we make use of this fact. The 
InfrastructureLibrary  is in one capacity used as a meta-metamodel and in the other aspect as a metamodel, and is thus 
reused in two dimensions.CommonBehaviors
UseCasesClasses
StateMachines Interactions
CompositeStructures
Components
DeploymentsAuxiliaryConstructs Activities
Actions
UML Infrastructure Specification, v2.4        177.8 The Kernel Package
The InfrastructureLibrary  is primarily reused in the Kernel  package of Classes  in UML 2: Superstructure ; this is done by 
bringing together the different packages of  the Infrastructure using package merge. The Kernel  package is at the very 
heart of UML, and the meta classes of every other package are directly or indirectly dependent on it. The Kernel  package 
is very similar to the Constructs  package of the InfrastructureLibrary , but adds more capabilities to the modeling 
constructs that were not necessary to include  for purposes of reuse or alignment with MOF.
Because the Infrastructure has be en designed for reuse, there are metaclasses—particularly in Abstractions —that are 
partially defined in several different pack ages. These different aspects are for the most part brought together into a single 
metaclass already in Constructs , but in some cases this is done only in Kernel . In general, if metaclasses with the same 
name occur in multiple packages, they are meant to represen t the same metaclass, and each package where it is defined 
(specialized) represents a specific factor ization. This same pattern of partial de finitions also occurs in Superstructure, 
where some aspects of, for example, the metaclass Class  are factored out into separate packages to form compliance 
points (see below). 
7.9 Metamodel Layering
The architecture that is centered around the Core  package is a complementary view of the four-layer metamodel hierarchy 
on which the UML metamodel has traditionally been based. When  dealing with meta-layers to define languages there are 
generally three layers that always  have to be taken into account: 
1. the language specification, or the metamodel, 
2. the user specification, or the model, and 3. objects of the model. 
This structure can be applied recursively many times so that we  get a possibly infinite number of meta-layers; what is a 
metamodel in one case can be a model in  another case, and this is  what happens with UML and MOF. UML is a language 
specification (metamodel) from which users can define their ow n models. Similarly, MOF is also a language specification 
(metamodel) from which users can define their own models. Fr om the perspective of MOF, however, UML is viewed as 
a user (i.e., the members of the OMG that have developed th e language) specification that is based on MOF as a language 
specification. In the four-layer metamodel hierarchy, MOF is commonly referred to as a meta-metamodel, even though 
strictly speaking it is a metamodel.
7.10 The Four-layer Metamodel Hierarchy
The meta-metamodeling layer forms the foundation of the meta modeling hierarchy. The primary responsibility of this 
layer is to define the language for spec ifying a metamodel. The layer is often re ferred to as M3, and MOF is an example 
of a meta-metamodel. A meta-metamodel is typically more comp act than a metamodel that it describes, and often defines 
several metamodels. It is generally de sirable that related metamodels and meta-metamodels share common design 
philosophies and constructs. However, each  layer can be viewed independently of other layers, and needs to maintain its 
own design integrity.A metamodel is an instance of a meta-metamodel, meaning th at every element of the metamodel is an instance of an 
element in the meta-metamodel. The primary responsibility of th e metamodel layer is to define a language for specifying 
models. The layer is often referred to  as M2; UML and the OMG Common Ware house Metamodel (CWM) are examples 
18                 UML Infrastructure Specification, v2.4of metamodels. Metamodels are typically more elaborate than  the meta-metamodels that describe them, especially when 
they define dynamic semantics. The UM L metamodel is an instance of the MOF (in effect, each UML metaclass is an 
instance of an element in InfrastructureLibrary ).
A model is an instance of a metamodel. The primary responsibility  of the model layer is to de fine languages that describe 
semantic domains, i.e., to allow users to model a wide variet y of different problem domains,  such as software, business 
processes, and requirements. The things that are being modeled reside outside th e metamodel hierarchy. This layer is 
often referred to as M1. A user model is  an instance of the UML metamodel. Note that the user model contains both 
model elements and snapshots (illustrations ) of instances of these model elements.
The metamodel hierarchy bottoms out at M0, which contains  the run-time instances of model elements defined in a 
model. The snapshots that are modeled at M1 are constrained versions of the M0 run-time instances.
When dealing with more than three meta-layers, it is usually  the case that the ones above M2 gradually get smaller and 
more compact the higher up they are in the hierarchy. In the case of MOF, which is at M3, it consequently only shares 
some of the metaclasses that are defined in UML. A specif ic characteristic about metamode ling is the ability to define 
languages as being reflective, i. e., languages that can be used to define themselves. The InfrastructureLibrary  is an 
example of this, since it contains all the metaclasses required to define itself. MOF is refl ective since it is based on the 
InfrastructureLibrary . This allows it to be used to define itself. For this reason, no additional meta-layers above MOF are 
defined.
7.11 Metamodeling
When metamodeling, we primarily distinguish between meta models and models. As already stated, a model that is 
instantiated from a metamodel can in turn be used as a me tamodel of another model in a recursive manner. A model 
typically contains model elements. These are created by inst antiating model elements from a metamodel, i.e., metamodel 
elements. 
The typical role of a metamodel is to define the semantics for how model elemen ts in a model get instantiated. As an 
example, consider Figure 7.6, where th e metaclasses Association and Class are both defined as part of the UML 
metamodel. These are instantiated in a user model in such a way that the classes Person and Car are both instances of the 
metaclass Class, and the association Person.car between the cl asses is an instance of the metaclass Association. The 
semantics of UML defines what happens when the user defined model elements are instantiated at M0, and we get an 
instance of Person, an instance of Car, and a link (i.e., an instance of the association) between them.
Figure 7.6 - An example of meta modeling; note that not all instance-of relationships are shownAssociation
Person Car«instanceOf»Class
«instanceOf»
*
carmetamodel
model
UML Infrastructure Specification, v2.4        19The instances, which are sometimes referred to as “run-time” instances, that are created at M0 from for example Person 
should not be confused with instances of  the metaclass InstanceSpecification that  are also defined as part of the UML 
metamodel. An instance of an InstanceSpecification is defined in a model at the same level as the model elements that it 
illustrates, as is depicted in Figure 7.7, where the instance  specification Mike is an illustration (or a snapshot) of an 
instance of class Person. 
7.12 An Example of the Four -level Metamodel Hierarchy
An illustration of how these meta-layers rela te to each other is shown in Figure 7.8. It should be noted that we are by no 
means restricted to only these four meta-layers, and it would be  possible to define additional ones. As is shown, the meta-
layers are usually numbered from M0 a nd upwards, depending on how many meta-layer s are used. In this particular case, 
the numbering goes up to M3, which corresponds to MOF.Figure 7.7 - Giving an illustration of a class using an instance specificationInstanceSpecification
Person Mike: Person«instanceOf»Class
«instanceOf»metamodel
model
age: Integer age = 11
20                 UML Infrastructure Specification, v2.4.
Figure 7.8 - An example of the four-layer metamodel hierarchyClass
Attribute Class
Video
+title: String«instanceOf» «instanceOf»
: Video
title = "2001: A Space Odyssey"«instanceOf» «instanceOf»M3 (MOF)
M2 (UML)
M1 (User model)Instance
«instanceOf»«instanceOf»
classifier
«instanceOf»
M0 (Run-time instances)aVideo«instanceOf»«snapshot»
UML Infrastructure Specification, v2.4        218 Language Formalism
The UML specification is defined by usi ng a metamodeling approach that adapts  formal specification techniques. The 
formal specification techniques are used to increase the pr ecision and correctness of the specification. This clause 
explains the specification techniques used to define UML.
The following are the goals of the specific ation techniques used to define UML: 
• Correctness — The specification techniques should improve the correctness of the metamodel by helping to validate it. 
For example, the well-formedness rules should help valid ate the abstract syntax a nd help identify errors.
• Precision — The specification techniques should increase the precision of both th e syntax and semantics. The precision 
should be sufficient so that there is no syntactic nor semantic ambiguity for either implementors or users.1 
• Conciseness — The specification techniques should be parsimonious, so that the precise syntax and semantics are 
defined without superfluous detail.
• Consistency — The specification techniques should complement  the metamodeling approach by adding essential detail 
in a consistent manner.
• Understandability — While increasing the precision and concis eness, the specification techni ques should also improve 
the readability of the specificati on. For this reason a less than strict formal ism is applied, since a strict formalism would 
require formal techniques. 
The specification technique used describes the metamodel in  three views using both text and graphic presentations.
It is important to note that the current description is not a completely formal specification of the language because to do 
so would have added significant complexity without clear benefit. 
The structure of the language is neverthele ss given a precise specification, which is  required for tool interoperability. The 
detailed semantics are describe d using natural language, although in a precise way so they can easily be understood. 
Currently, the semantics are not considered  essential for the development of tools; however, this will probably change in 
the future.
8.1 Levels of Formalism
A common technique for specification of languages is to first de fine the syntax of the language and then to describe its 
static and dynamic semantics. Th e syntax defines what construc ts exist in the language and how the constructs are built 
up in terms of other constructs. Sometimes,  especially if the language has a graphi c syntax, it is important to define the 
syntax in a notation independent way (i.e., to define the abstract syntax of the language). The concrete syntax is then 
defined by mapping the notation onto the abstract syntax. The static semantics of a language define how an instance of a construct should be connected to other instances to be 
meaningful, and the dynamic semantics define the meaning of  a well formed construct. The meaning of a description 
written in the language is defined only if th e description is well formed  (i.e., if it fulfills the rules defined in the static  
semantics).
1. By definition semantic variation points are an exception to this.
22                 UML Infrastructure Specification, v2.4The specification uses a combination of languages - a subset of UML, an object constraint  language, and precise natural 
language to describe the abstract syntax and semantics of the full UML. The description is self-contained; no other 
sources of information are needed to read the document2. Although this is a metacircular description3, understanding this 
document is practical since only a small subset of UM L constructs are needed to describe its semantics.
In constructing the UML metamodel differen t techniques have been used to specif y language constructs, using some of 
the capabilities of UML. The main language constructs are reified into metaclasses in the metamodel. Other constructs, in 
essence being variants of other ones, are defined as stereotypes of metaclasses in  the metamodel. This mechanism allows 
the semantics of the variant construct to be significantly di fferent from the base metaclass. Another more “lightweight” 
way of defining variants is to use metaa ttributes. As an example, the aggregation construct is specified by an attribute of 
the metaclass Property, which is used to i ndicate if an association is an ordinary aggregate, a composite aggregate, or a 
common association.
8.2 Package Specification Structure
This sub clause provides information for each package and ea ch class in the UML metamodel. Each package has one or 
more of the following sub clauses.
8.2.1 Class Descriptions
The sub clause contains an enumeration of the classes specifying the constructs defined in the package. It begins with one 
diagram or several diagrams depicting the ab stract syntax of the constructs (i.e., the classes and their relationships) in the 
package, together with some of the well-formedness re quirements (multiplicity and ordering). Then follows a 
specification of each class in  alphabetic order (see below).
8.2.2 Diagrams
If a specific kind of diagram usually presen ts the constructs that are defined in the package, a sub clause describing this 
kind of diagram is included.
8.2.3 Instance Model
An example may be provided to show how an instance model of  the contained classes may be populated. The elements in 
the example are instances of the classes contained in the package (or in an imported package).
8.3 Class Specification Structure
The specification of a class starts with a presentation of the general meaning of the concept that sets the context for the 
definition.
2. Although a comprehension of the UML’s fo ur-layer metamodel architecture and its und erlying meta-metamodel is helpful, it is 
not essential to unders tand the UML semantics.
3. In order to understand the description of the UML semantics, you must unders tand some UML semantics.
UML Infrastructure Specification, v2.4        238.3.1 Description
The sub clause includes an informal definition of the metaclas s specifying the construct in UML. The sub clause states if 
the metaclass is abstract. This sub clause, together with the following two, constitutes a description of the abstract syntax 
of the construct.
8.3.2 Attributes
Each of the attributes of the class are enumerated together w ith a short explanation. The sub clause states if the attribute 
is derived, or if it is a specialization of another attribute. The multiplicity of th e attribute is suppressed it defaults to ‘ 1’ 
(default in UML).
8.3.3 Associations
The member ends of associations connected to the class are also listed in the same way. The sub clause states if the 
property is derived, or if it s ubsets or redefines another end. 
8.3.4 Constraints
The well-formedness rules of the metaclass, except for mu ltiplicity and ordering constraints that are defined in the 
diagram at the beginning of the package sub clause, are defined as a (possibly empty) set of invariants for the metaclass, 
which must be satisfied by all instances of that metaclas s for the model to be meaningful. The rules thus specify 
constraints over attributes and associations defined in the metamodel. Most invariants are defined by OCL expressions 
together with an informal explanation of the expression, but  in some cases invariants are expressed by other means (in 
exceptional cases with natural language). The statement ‘No a dditional constraints’ means that all well-formedness rules 
are expressed in the superclasses together with the multip licity and type information expressed in the diagrams. 
8.3.5 Additional Operations (optional)
In many cases, additional operations on the classes are needed for the OCL expressions. These are then defined in a 
separate sub clause after the constraint s for the construct, using the same appr oach as the Constraints sub clause: an 
informal explanation followed by the OCL expression defining the operation.
8.3.6 Semantics
The meaning of a well formed construc t is defined using natural language.
8.3.7 Semantic Variation Points (optional)
The term semantic variation point  is used throughout this document to denote  a part of the UML specification whose 
purpose in the overall specification is know n but whose form or semantics may be varied in some way. The objective of 
a semantic variation point is to enable specialization of that part of UML for a particular situation or domain.
There are several forms in which semantic variation points appear in the standard:
• Changeable default — in this case, a single default specification for the semantic variation point is provided in the 
standard but it may be replaced. For ex ample, the standard prov ides a default set of rules for specializing state 
24                 UML Infrastructure Specification, v2.4machines, but this default can be overridd en (e.g., in a profile) by a different se t of rules (the choice typically depends 
on which definition of behavioral compatibility is used).
• Multiple choice — in this case, the standard explicitly specifies a number of possible mutually exclusive choices, one 
of which may be marked as the default. Language designers ma y either select one of those alternatives or define a new 
one. An example of this type of variation point can be foun d in the handling of unexpected events in state machines; the 
choices include (a) ignoring the event (the default), (b) explicitly rejecting it, or (c) deferring it.
• Undefined — in this case, the standard does not provide any pre-de fined specifications for the semantic variation point. 
For instance, the rules for selecting the method to be executed when a polymorphic operation is invoked are not defined 
in the standard.
8.3.8 Notation
The notation of the construct is presented in this sub clause.
8.3.9 Presentation Options (optional)
If there are different ways to show the construct (e.g., it is not necessary to show all parts of the construct in every 
occurrence), these possibilities are described in this sub clause.
8.3.10 Style Guidelines (optional)
Often non-normative conventions are used in representing some part of a model. Fo r example, one such convention is to 
always have the name of a class in bold  and centered within the class rectangle.
8.3.11 Examples (optional)
In this sub clause, examples of how the construct is to be depicted are given.
8.3.12 Rationale (optional)
If there is a reason why a construct is defined like it is, or why its notation is defined as it is , this reason is given in th is 
sub clause.
8.3.13 Changes from UML 1.4
Here, changes compared with UML 1.4 are described an d a migration approach from 1.4 to 2 is specified.
8.4 Use of a Constraint Language
The specification uses the Object Constraint Language (OCL),  as defined in Clause 6, “Object Constraint Language 
Specification” of the UML 1.4 specification, for expressing we ll-formedness rules. The following conventions are used to 
promote readability:
• Self — which can be omitted as a reference to the metacla ss defining the context of the in variant, has been kept for 
clarity.
UML Infrastructure Specification, v2.4        25• In expressions where a collection is iterate d, an iterator is used for clarity, even  when formally unnecessary. The type of 
the iterator is usually omitted, but included when it adds to understanding. 
• The ‘collect’ operation is left implicit where this is practical. 
• The context part of an OCL constraint is not included explicitly, as it is well defined in the sub clause where the 
constraint appears.
8.5 Use of Natural Language
We strove to be precise in our use of natural language, in  this case English. For exam ple, the description of UML 
semantics includes phrases such as “X provides the ability to…” and “X is a Y .” In each of these cases, the usual English 
meaning is assumed, although a deeply formal description wo uld demand a specification of the semantics of even these 
simple phrases. 
The following general rules apply:
• When referring to an instance of some metaclass, we often omit the word “instance.” For example, instead of saying “a 
Class instance” or “an Associatio n instance,” we just say “a Cla ss” or “an Association.” By pr efixing it with an “a” or 
“an,” assume that we mean “an instance of.” In the same wa y, by saying something like “Elements” we mean “a set (or 
the set) of instances of the metaclass Element.”
• Every time a word coinciding with the name of some  construct in UML is used, that construct is meant.
• Terms including one of the pr efixes sub, super, or meta are written as one word (e.g., metamodel, subclass).
8.6 Conventions and Typography 
In the description of UML, the follo wing conventions have been used:
• When referring to constructs in UML, not their repr esentation in the metamodel, normal text is used.
• Metaclass names that consist of appended nouns/adjectives, initial embedded capitals are used (e.g., ‘ModelElement,’ 
‘StructuralFeature’).
• Names of metaassociations are written in the same manner as metaclasses (e.g., ‘ElementReference’).
• Initial embedded capital is used for names that consist of appended noun s/adjectives (e.g.,  ‘ownedElement,’ 
‘allContents’).
• Boolean metaattribute names always start with ‘is’ (e.g., ‘isAbstract’).
• Enumeration types always end with “Kind” (e.g., ‘AggregationKind’).
• While referring to metaclasses, metaassociations, metaattributes , etc. in the text, the exact names as they appear in the 
model are always used. 
• No visibilities are presented in the diagrams, as all elements are public.
• If a mandatory section does not apply fo r a metaclass, the text ‘No additional XXX’ is used, where ‘XXX’ is the name 
of the heading. If an optional section is not applicable, it is not included.
For textual notations a variant of the Backus-Naur Form (BNF) is  often used to specify the legal formats. The conventions of 
this BNF are:
26                 UML Infrastructure Specification, v2.4• All non-terminals are in italics and enclosed between angle brackets (e.g. , <non-terminal> ).
• All terminals (keywords, strings, etc.), are enclosed between single quotes (e.g.,  'or').
• Non-terminal production rule definitions are signified with the '::=' operator.
• Repetition of an item is signified by an asterisk placed after that item: '*'
• Alternative choices in a production ar e separated by the '|' symbol; e.g.,  
<alternative-A>  | <alternative-B> .
• Items that are optional are enclos ed in square brackets (e.g., [<item-x>] ).
• Where items need to be groupe d they are enclosed in simp le parenthesis. For example , 
(<item-1> | <item-2> ) * signifies a sequence of one or  more items, each of which is <item-1>  or <item-2> .
UML Infrastructure Specification, v2.4        27Part II - Infrastructure Library
This part describes the structure and contents of the Infrastructure packages for th e UML metamodel and related 
metamodels, such as the Meta Object Facility (MOF) and the Common Warehouse Metamodel (CWM). The first top level 
package is InfrastructureLibrary , which defines a reusable metalanguage ke rnel and a metamodel extension mechanism 
for UML. The metalanguage kernel can be used to specify a variety of metamodels, including UML, MOF, and CWM. In 
addition, the library defines a profiling extension mechanism th at can be used to customize UML for different platforms 
and domains without supporting a complete metamo deling capability. The nested packages of the InfrastructureLibrary  
are Core  and Profile . The other top level package is PrimitiveTypes , which consists of a small number of primitive types 
that are commonly used for metamodeling. The PrimitiveTypes  package is imported by nested packages in the 
InfrastructureLibrary  and can be imported by other packages, libraries and metamodels that need  to define primitive data. 
The high level architecture of the Infrastructure  packages is shown in Part II, Figure 1.
Part II, Figure 1  - The Metamodel Library package contains the packages Core and Profiles 
The Core  package is the central reusable part of the Infrastructur eLibrary, and is further subdivided as shown in the figure 
below.
Part II, Figure 2 - The Core package contains the pack ages PrimitiveTypes, Abstractions, Basic, and Constructs 
The package PrimitiveTypes  is a simple package that contains a number of  predefined types that are commonly used when 
metamodeling, and as such they are used both in the infrast ructure library itself, but also in metamodels like MOF and 
UML. The package Abstractions  contains a number of fine-grained packages with only a few metaclasses each, most of 
which are abstract. The purpose of this package is to provide a highly reusable set of metaclasses to be specialized when 
defining new metamodels. The package Constructs  also contains a number of fine-grained packages, and brings together 
many of the aspects of the Abstractions . The metaclasses in Constructs  tend to be concrete rather than abstract, and are 
geared towards an object-oriented mode ling paradigm. Looking at metamodels such as MOF and UML, they typically 
import the Constructs  package since the contents of the other packages  of Core are then automatically included. The 
package Basic  contains a subset of Constructs  that is used primarily for XMI purposes.InfrastructureLibrary
Core Profiles PrimitiveTypes
Constructs
ConstructsBasicAbstractionsPrimitiveTypes
«import»
«import»«import»
28                 UML Infrastructure Specification, v2.4The Profiles  package contains the mechanisms used to create prof iles of specific metamodels, an d in particular of UML. 
This extension mechanism subsets the capabilities offere d by the more general MOF extension mechanism. 
The detailed structure and contents of the PrimitiveTypes , Abstractions , Basic , Constructs , and Profiles  packages are 
further described in subsequent clauses.
UML Infrastructure Specification, v2.4        299 Core::Abstractions
The Abstractions package of InfrastructureLibrary::Core is divi ded into a number of finer-gr ained packages to facilitate 
flexible reuse when creating metamodels.
Figure 9.1 - The Core package is owned by the Infrast ructureLibrary pack and contains several subpackages 
The subpackages of Abstractions  are all shown in Figure 9.2.Constructs
ConstructsBasicAbstractionsPrimitiveTypes
«import»
«import»«import»
30                 UML Infrastructure Specification, v2.4Figure 9.2 - The Abstractions package contains several subpackages, all of which are specified in this clause 
The contents of each subpackage of  Abstractions is described in  a separate sub clause below.Elements
Ownerships
Relationships Namespaces
Expressions Comments
MultiplicitiesVisibilities
TypedElementsClassifiersConstraints
Literals
GeneralizationsSuper
RedefinitionsStructuralFeatures
BehavioralFeatures
ChangeabilitiesInstancesMultiplicityExpressions
UML Infrastructure Specification, v2.4        319.1 BehavioralFeatures Package
The BehavioralFeatures subpackag e of the Abstractions package specifies the basic classes for mode ling dynamic features 
of model elements.
Figure 9.3 - The BehavioralFeatures package
Figure 9.4 - The elements defined in the BehavioralFeatures package
9.1.1 BehavioralFeature
A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.
Description
A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances. BehavioralFeature 
is an abstract me taclass specializing Feature  and Namespace . Kinds of behavioral aspects are modeled by subclasses of 
BehavioralFeature.
Generalizations
• “Feature” on page 36
• “Namespace” on page 74
Attributes
No additional attributesBehavioralFeaturesClassifiersTypedElements
BehavioralFeatureFeature
(from Classifiers)Namespace
(from Namespaces)
ParameterNamedElement
(from Namespaces)TypedElement
(from TypedElements)
32                 UML Infrastructure Specification, v2.4Constraints
No additional constraints
Additional Operations
[1]  The query isDistinguishableFrom() determines whether tw o BehavioralFeatures may coexis t in the same Namespace. It 
specifies that they have to have different signatures.
BehavioralFeature::isDistinguishableFrom(n: NamedElement, ns: Namespace): Boolean;
isDistinguishableFrom =
if n.oclIsKindOf(BehavioralFeature)
then
if ns.getNamesOfMember(self)->intersec tion(ns.getNamesOfM ember(n))->notEmpty()
then  Set{}->including(self)->including(n)->is Unique( bf | bf.parameter->collect(type))
else true
endif
else true
endif
Semantics
The list of parameters describes the order and type of argume nts that can be given when the BehavioralFeature is invoked.
Notation
No additional notation
9.2 Parameter
A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral 
feature.
Description
Parameter is an abstract metaclass specializing TypedElement  and NamedElement .
Generalizations
• “TypedElement” on page 88
• “NamedElement” on page 72
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
UML Infrastructure Specification, v2.4        33Semantics
A parameter specifies arguments that are passed into or out of  an invocation of a behavioral element like an operation. A 
parameter’s type restricts wh at values can be passed.
A parameter may be given a name, which then identifies the parameter uniquely within th e parameters of the same 
behavioral feature. If it is unnamed, it is distinguished only by its position in the ordered list of parameters.
Notation
No general notation. Specific subcla sses of BehavioralFeature will define  the notation for their parameters. 
Style GuidelinesA parameter name typically st arts with a lowercase letter.
9.3 Changeabilities Package
The Changeabilities subpackage of the Abstractions package de fines when a structural feature may be modified by a 
client.
Figure 9.5 - The Changeabilities package
Figure 9.6 - The elements defined in the Changeabilities packageStructuralFeatures
Changeabilities
StructuralFeature
isReadOnly : Boolean = falseStructuralFeature
(from  StructuralFeatures)
34                 UML Infrastructure Specification, v2.49.3.1 StructuralFeature (as specialized)
Description
StructuralFeature is specialized to add an attribute th at determines whether a client may modify its value.
Generalizations
• “StructuralFeature” on page 82
Attributes
• isReadOnly: Boolean — States whether the feature’s value may be modified by a client. Default is false.
Associations
No additional associations 
Constraints
No additional constraints
Semantics
No additional semantics
Notation
A read only structural feature is shown using {readOnly} as part  of the notation for the structural feature. This annotation 
may be suppressed, in which case it is not pos sible to determine its value from the diagram.
Presentation OptionIt is possible to only allow suppression of  this annotation when isReadOnly=false. In  this case it is possi ble to assume this 
value in all cases where {readOnly} is not shown.
9.4 Classifiers Package
The Classifiers package in the Abstractions package specifies an abstract generalization for the classification of instances 
according to their features.
Figure 9.7 - The Classifiers packageNamespaces
Classifiers
UML Infrastructure Specification, v2.4        359.4.1 Classifier
A classifier is a classification of instances — it descri bes a set of instances that have features in common.
Description
A classifier is a namespace whose members can include  features. Classifier is an abstract metaclass.
Generalizations
• “Namespace” on page 74
Attributes
No additional attributes
Associations
• / feature : Feature [*]  
Specifies each feature defined in the classifier. Subsets Namespace::member . This is a derived union.
Additional Operations
[1]  The query allFeatures() gives all of th e features in the namespace of the classifi er. In general, through mechanisms such as 
inheritance, this will be a larger set than feature.
Classifier::allFeatures(): Set(Feature);
allFeatures = member->sele ct(oclIsKindOf(Feature))
Constraints
No additional constraints
Semantics
A classifier is a classification of instances according to their features.Figure 9.8 - The elements defined in the Classifiers packageNamedElement
(from  Nam espaces)Namespace
(from  Nam espaces)
Classifier Feature
0..* */featuringClassifier
0..* {union}/f eat ure
*
{subsets member, 
union}
36                 UML Infrastructure Specification, v2.4Notation
The default notation for a classifier is a solid-outline rectan gle containing the classifier’s name, and optionally with 
compartments separated by horizontal lines containing features or other members of the classifier. The specific type of 
classifier can be shown in guillemets above the name. Some spec ializations of Classifier have  their own distinct notations.
Presentation Options
Any compartment may be suppressed. A se parator line is not drawn for a suppre ssed compartment. If a compartment is 
suppressed, no inference can be drawn about  the presence or absence of elements in it. Compartment names can be used 
to remove ambiguity, if necessary. 
9.4.2 Feature
A feature declares a behavioral or structural  characteristic of instances of classifiers.
DescriptionA feature declares a behavioral or struct ural characteristic of instances of classi fiers. Feature is an abstract metaclass.
Generalizations
• “NamedElement” on page 72
Attributes
No additional attributes
Associations
• / featuringClassifier : Classifier [0..*]  
The Classifiers that have this Feature as a feature. This is a derived union.
Constraints
No additional constraints
Semantics
A Feature represents some charac teristic for its featuring classifiers. A Feat ure can be a feature of multiple classifiers. 
Notation
No general notation. Subclasses define their specific notation.
UML Infrastructure Specification, v2.4        379.5 Comments Package
The Comments package of the Abstractions package defines th e general capability of attaching comments to any element. 
9.5.1 Comment
A comment is a textual annotation that ca n be attached to a set of elements.
Description
A comment gives the ability to attach various remarks to elem ents. A comment carries no semantic force, but may contain 
information that is useful to a modeler.
A comment may be owned by any element.
Generalizations
NoneFigure 9.9 - The Comments package
Figure 9.10 - The elements defined in the Comments packageOwnerships
Comments

38                 UML Infrastructure Specification, v2.4Attributes
• body: String  
Specifies a string th at is the comment.
Associations
• annotatedElement: Element[*]  
References the Elemen t(s) being commented.
Constraints
No additional constraints
Semantics
A Comment adds no semantics to the annotated elements, but may represent information useful to the reader of the 
model.
Notation
A Comment is shown as a rectangle with the upper right corn er bent (this is also known as a “note symbol”). The 
rectangle contains the body of the Comment. The connection to  each annotated element is shown by a separate dashed 
line.
Presentation Options
The dashed line connecting the note to the annotated element(s) may be suppressed if it is clear from the context, or not 
important in this diagram.
Examples
9.5.2 Element
Description
An element can own comments.
Attributes
No additional attributesFigure 9.11 - Comment notationAccountThis class was added
by Alan Wright after
meeting with the
mission planning team.
UML Infrastructure Specification, v2.4        39Generalizations
• “Element (as specialized)” on page 76
Associations
• ownedComment: Comment[*]  
The Comments owned by th is element. Subsets Element::ownedElement .
Constraints
No additional constraints
Semantics
The comments for an Element add no semantics but may repr esent information useful to the reader of the model.
Notation
No additional notation
9.6 Constraints Package
The Constraints subpackage of the Abstractions package spec ifies the basic building blocks that can be used to add 
additional semantic information to an element.
Figure 9.12 - The Constraints packageNamespaces Expressions
Constraints
40                 UML Infrastructure Specification, v2.49.6.1 Constraint
A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the 
purpose of declaring some of the semantics of an element.
Description
Constraint contains a ValueSpecification that specifies additional semantics for on e or more elements. Certain kinds of 
constraints are predefined in UML, others may be user-defin ed. A user-defined Constraint is described using a specified 
language, whose syntax and interpretation is a tool responsibility. One predefined  language for writing constraints is 
OCL. In some situations, a programming la nguage such as Java may be appropriat e for expressing a constraint. In other 
situations natural language may be used.
Constraint is a condition (a Boolean expression) that restrict s the extension of the associated element beyond what is 
imposed by the other language constructs applied to the element. Figure 9.13 - The elements defi ned in the Constraints packageElement
NamedElement{readOnly, union,
subsets ownedElement,subsets member}
+/ownedMember
NamespaceConstraintElement
ValueSpecification*
*{readOnly , union }
+/member
{readOnly, union,
subsets owner}
+/namespace 0..1
{subsets namespace}
+context{subsets ownedMember}
+ownedRule
**
{subsets owner}
+owningConstraint
0..1{subsets ownedElement}
+specification
1* *{ordered}
+constrainedElement
0..1NamespaceConstraintElement
ValueSpecification*
*
0..1
{subsets namespace}
+context{subsets ownedMember}
**
{subsets owner}
0..1{subsets ownedElement}
1* *{ordered}
0..1
UML Infrastructure Specification, v2.4        41Constraint contains an optional name, although they are commonly unnamed.
Generalizations
• “NamedElement” on page 72
Attributes
No additional attributes
Associations
• constrainedElement: Element[*]  
The ordered set of Elements referenced by this Constraint.
• context: Namespace [0..1]  
Specifies the Namespace that is the contex t for evaluating this constraint. Subsets NamedElement::namespace .
• specification: Va lueSpecification[1]  
A condition that must be true when evaluated in order for the constraint to be satisfied.  
Subsets Element::ownedElement .
Constraints
[1]  The value specification for a constrai nt must evaluate to a Boolean value.
Cannot be expressed in OCL.
[2] Evaluating the value specification for a constraint must not have side effects.
Cannot be expressed in OCL.
[3] A constraint cannot be applied to itself.
not constrainedElement->includes( self )
Semantics
A Constraint represents additional semantic  information attached to the constrained elements. A constraint is an assertion 
that indicates a restriction that must be satisfied by a corre ct design of the system. The constrained elements are those 
elements required to evaluate the constrai nt specification. In addition, the contex t of the Constraint may be accessed, and 
may be used as the namespace for interpre ting names used in the specification. For ex ample, in OCL ‘self’ is used to refer 
to the context element.
Constraints are often expressed as a text string in some language. If a form al language such as OCL is used, then tools 
may be able to verify some aspects of the constraints.In general there are many possible kinds of owners for a Constr aint. The only restriction is that the owning element must 
have access to the constrainedElements. 
The owner of the Constraint will determine when the constraint specification is ev aluated. For example, this allows an 
Operation to specify if a Constraint represents a precondition or a postcondition.
Notation
A Constraint is shown as a text string in braces ({}) according to the following BNF:
constraint ::= ‘{‘ [ <name> ‘:’ ] <Boolean expression>’ }’
42                 UML Infrastructure Specification, v2.4For an element whose notation is a text string (such as an attrib ute, etc.), the constraint string may follow the element text 
string in braces. Figure 9.14 shows a constraint string that follows an attribute within a class symbol.
For a Constraint that applies to a single element (such as a class or an association path), the constraint string may be 
placed near the symbol for the element, preferably near the name, if any. A tool must make it possible to determine the 
constrained element.
For a Constraint that applies to two elements (such as two cl asses or two associations), the constraint may be shown as a 
dashed line between the elements labeled by the constraint string (in braces). Fi gure 9.15 shows an {xor} constraint 
between two associations.
Presentation Options
The constraint string may be placed in a note symbol and attached to each of the symbols for the constrained elements by 
a dashed line. Figure 9.16 shows an example of a constraint in a note symbol.
If the constraint is shown as a dashed line between two el ements, then an arrowhead may be placed on one end. The 
direction of the arrow is relevant information within the cons traint. The element at the tail of the arrow is mapped to the 
first position and the element at the head of the arrow is mapped to the second position in the constrainedElements 
collection.
For three or more paths of the same ki nd (such as generalization paths or asso ciation paths), the constraint may be 
attached to a dashed line crossing all of the paths.
Examples
Figure 9.14 - Constraint attached to an attribute
Figure 9.15  - {xor} constraintStack
size: Integer {size >= 0}
push()
pop()
AccountPerson
Corporation{xor}
UML Infrastructure Specification, v2.4        439.6.2 Namespace (as specialized)
Description
A namespace can own constraints. A constr aint associated with a namespace may either apply to the namespace itself, or 
it may apply to elements in the namespace.
Generalizations
• “Namespace” on page 74
Attributes
No additional attributes
Associations
• ownedRule: Constraint[*]  
Specifies a set of Constraints owned by this Namespace. Subsets Namespace::ownedMember .
Constraints
No additional constraints
Semantics
The ownedRule constraints for a Namespace represent well-formedness rules for the constrained elements. These 
constraints are evaluated when determini ng if the model elements are well-formed.
Notation
No additional notationFigure 9.16 - Constraint in a note symbolPerson Companyemployee employer
* 0..1boss0..1
{self.boss->isEmpty() or
self.employer = self.boss.employer}
44                 UML Infrastructure Specification, v2.49.7 Elements Package
The Elements subpackage of the Abstractions package sp ecifies the most basic abstract construct, Element.
9.7.1 Element 
An element is a constituent of a model.
Description
Element is an abstract metaclass with no superclass. It is  used as the common superclass for all metaclasses in the 
infrastructure library.
Generalizations
• None
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
Subclasses of Element provide semantics a ppropriate to the concept they represent.
NotationThere is no general notation for an Element. The spec ific subclasses of Element define their own notation.Figure 9.17 - The Elements package
Figure 9.18 - The elements defined in the Elements packageElements
Element
UML Infrastructure Specification, v2.4        459.8 Expressions Package
The Expressions package in the Abstractions package spec ifies the general metaclass supporting the specification of 
values, along with specializations for supporting structured e xpression trees and opaque, or uninterpreted, expressions. 
Various UML constructs require or use e xpressions, which are linguistic formulas th at yield values when evaluated in a 
context.
9.8.1 Expression
An expression is a structured tree of symbols that denotes a (possibly empty) set of values when evaluated in a context.
Description
An expression represents a node in an e xpression tree, which may be non-terminal or terminal. It defines a symbol, and 
has a possibly empty sequence of opera nds that are value specifications.
• “ValueSpecification” on page 48Figure 9.19 - The Expressions package
Figure 9.20 - The elements defined in the Expressions packageOwnerships
Expressions

46                 UML Infrastructure Specification, v2.4Attributes
• symbol: String [1]  
The symbol associated with th e node in the expression tree.
Associations
• operand: ValueSpecification[*]  
Specifies a sequence of operands. Subsets Element::ownedElement .
Constraints
No additional constraints
Semantics
An expression represents a node in an expression tree. If there is no operand, it represents a terminal node. If there are 
operands, it represents an operator applied to those operands. In either case there is a symbol associated with the node. 
The interpretation of this symbol depe nds on the context of the expression.
NotationBy default an expression with no operands is notated simply by its symbol, with no quotes. An expression with operands 
is notated by its symbol, followed by round parentheses containing its operands in order. In particular contexts special 
notations may be permitted, including infix operators.
Examples
xor
elseplus(x,1)x+1
9.8.2 OpaqueExpression
An opaque expression is an uninterpreted textual statement that  denotes a (possibly empty) set of values when evaluated 
in a context.
Description
An opaque expression contains language-specific text strings used to describe a value or values, and an optional 
specification of the languages.
One predefined language for specifying expressions is OCL. Natu ral language or programming languages may also be 
used.
Generalizations
• “ValueSpecification” on page 48
Attributes
• body: String [0..*] {nonunique, ordered}  
The text of the expression, possibly in multiple languages.  
UML Infrastructure Specification, v2.4        47• language: String [0..*] {ordered}  
Specifies the languages in which the expression is stated. The interpretation of the expression body depends on the  
language. If languages are unspecified, it might be implicit  from the expression body or the context. Languages are  
matched to body strings by order.
Associations
No additional associations
Constraints
[1]  If the language attribute is not empty, then the size of the body and language arrays must be the same.
language->notEmpty() implies 
                 (body->size() = language->size())
Semantics
The expression body may consist of a sequen ce of text strings – each in a differ ent language – representing alternative 
representations of the same content. When multiple language st rings are provided, the language  of each separate string is 
determined by its corresponding entry in the “language” attr ibute (by sequence order). The interpretation of the text 
strings is language specific. La nguages are matched to body strings by order. If the languages are unspecified, it might be 
implicit from the expression bodies or the context.
It is assumed that a linguistic analyzer for the specified la nguages will evaluate the bodies. The time at which the bodies 
will be evaluated is not specified.
Notation
An opaque expression is displayed as text string in particular  languages. The syntax of the strings are the responsibility of 
a tool and linguistic analyzers for the language. 
An opaque expression is displayed as a part of the notation for its containing element.
The languages of an opaque expression, if  specified, are often not shown on a diagram. Some modeling tools may impose 
a particular language or assume a partic ular default language. The language is of ten implicit under the assumption that the 
form of the expression makes its purpose clear. If the langua ge name is shown, it should be displayed in braces ({}) 
before the expression string to which it corresponds.
Style Guidelines
A language name should be spelled and capitalized exactly as it appears in th e document defining the language. For 
example, use OCL, not ocl.
Examples
a > 0
{OCL} i > j and self.size > iaverage hours worked per week
48                 UML Infrastructure Specification, v2.49.8.3 ValueSpecification
A value specification is the specification of a (possibly empty) set of instances,  including both objects and data values.
Description
ValueSpecification is an abstract metaclass used to identify a value or values in a model. It may reference an instance or 
it may be an expression denoting an instance or instances when evaluated.
Generalizations
• “Element (as specialized)” on page 76
Attributes
No additional attributes
Associations
• expression: Expression[0..1]  
If this value specification is an operand, the owning expression. Subsets Element::owner .
Constraints
No additional constraints
Additional Operations 
These operations are introduced here. They are expected to be redefined in subc lasses. Conforming implementations may 
be able to compute values for more expressions that are specified by the constraints that involve these operations.
[1]  The query isComputable() determines whether a value specification can  be computed in a model. This operation cannot be 
fully defined in OCL. A conforming implementation is expected to deliver true for this operation for all value 
specifications that it can compute, and to compute all of those for which the operation is true. A conforming 
implementation is expected to be able to compute the value of all literals.
ValueSpecification::isComputable(): Boolean;
isComputable = false
[2] The query integerValue() gives a single Integer value when one can be computed.
ValueSpecification::integerValue() : [Integer];
integerValue = Set{}
[3] The query realValue() gives a single Real value when one can be computed.
ValueSpecification::realValue() : [Real];realValue = Set{}
[4] The query booleanValue() gives a single Boolean value when one can be computed.
ValueSpecification::booleanValue() : [Boolean];
booleanValue = Set{}
[5] The query stringValue() gives a single String value when one can be computed.
ValueSpecification::stringValue() : [String];stringValue = Set{}
[6] The query unlimitedValue() gives a single Un limitedNatural value when  one can be computed.
ValueSpecification::unlimitedValue() : [UnlimitedNatural];
unlimitedValue = Set{}
UML Infrastructure Specification, v2.4        49[7] The query isNull() returns true when it  can be computed th at the value is null.
ValueSpecification::isNull() : Boolean;
isNull = false
Semantics
A value specification yields zero or more values. It is required that the type a nd number of values is suitable for the 
context where the value specification is used.
Notation
No specific notation
9.9 Generalizations Package
The Generalizations package of the Abstractions package prov ides mechanisms for specifying  generalization relationships 
between classifiers.
Figure 9.21 - The Generalizations packageRelationshipsSuper
GeneralizationsTypedElements
50                 UML Infrastructure Specification, v2.49.9.1 Classifier (as specialized)
Description
A classifier is a type and can own gene ralizations, thereby making it possible to  define generalization relationships to 
other classifiers.
Attributes
No additional attributes
Generalizations
• “Type” on page 87
• “Classifier (as specialized)” on page 84
Associations
• generalization: Generalization[*]  
Specifies the Generalization relationships for this Classi fier. These Generalizations navigate to more general  
classifiers in the generali zation hierarchy. Subsets Element::ownedElement .
• / general : Classifier[*]  
Specifies the general Clas sifiers for this Classifier. This is derived.
Constraints
[1]  The general classifiers ar e the classifiers referenced by the generalization relationships.
general = self.parents()Figure 9.22 - The elements define d in the Generalizations package

UML Infrastructure Specification, v2.4        51Additional Operations
[1]  The query parents() gives all of the imme diate ancestors of a ge neralized Classifier.
Classifier::parents(): Set(Classifier);
parents = generalization.general
[2] The query conformsTo() gives true for a classifier that define s a type that conforms to another. This is used, for example, 
in the specification of signature conformance for operations.
Classifier::conformsTo(other: Classifier): Boolean;
conformsTo = (self=other) or (s elf.allParents()->includes(other))
Semantics
A Classifier may participate in generaliza tion relationships with other Classifiers. An instance of a specific Classifier is 
also an (indirect) instance of the general Classifier. The sp ecific semantics of how genera lization affects each concrete 
subtype of Classifier varies. A Classifier  defines a type. Type conformance between generalizable Classifiers is defined so 
that a Classifier conforms to itself and to all of its ancestors in the generalization hierarchy.
Notation
No additional notation
Examples
See Generalization
9.9.2 Generalization
A generalization is a taxonomic relationshi p between a more general classifier a nd a more specific classifier. Each 
instance of the specific classifier is also an instance of th e general classifier. Thus, the specific classifier indirectly has  
features of the more general classifier.
Description
A generalization relates a specific classi fier to a more general classifier, and is owned by the specific classifier. 
Generalizations
• “DirectedRelationship” on page 80
Attributes
No additional attributes
Associations
• general: Classifier [1]  
References the general classifier in the Generalization relationship. Subsets DirectedRelationship::target .
• specific: Classifier [1]  
References the specializing classifier in the Generalization relationship. Subsets DirectedRelationship::source and 
Element::owner .
52                 UML Infrastructure Specification, v2.4Constraints
No additional constraints
Semantics
Where a generalization relates a specific clas sifier to a general classifier, each instance of the specific classifier is also an 
instance of the general classifier. Therefore, features sp ecified for instances of the general classifier are implicitly 
specified for instances of the specific classifier. Any constraint applying to instances of the general classifier also applies  
to instances of the specific classifier.
Notation
A Generalization is shown as a line w ith a hollow triangle as an arrowhead between the symbols representing the 
involved classifiers. The arrowhead points to the symbol repres enting the general classifier. This notation is referred to as 
the “separate target style.” See the example sub clause below.
Presentation Options 
Multiple Generalization relationships that reference the same general classifier can  be connected together in the “shared 
target style.” See the example sub clause below.
UML Infrastructure Specification, v2.4        53Examples
9.10 Instances Package
The Instances package in the Abstractions package provides for modeling instances of classifiers.Figure 9.23 - Examples of ge neralizations between classes
Figure 9.24 - The Instances packageShape
Polygon Ellipse Spline
Shape
Polygon Ellipse SplineSeparate target style
Shared target style
Expressions
InstancesStructuralFeatures
54                 UML Infrastructure Specification, v2.49.10.1 InstanceSpecification
An instance specification is a model element that represents an instance in a modeled system.
Description
An instance specification specifies existence of an entity in a modeled system and completely or partially describes the 
entity. The description includes:
• Classification of the entity by one or more classifiers of which the ent ity is an instance. If the only classifier specified is  
abstract, then the instance specificatio n only partially describes the entity.
• The kind of instance, based on it s classifier or classifiers. For example, an  instance specification whose classifier is a 
class describes an object of that class,  while an instance specificatio n whose classifier is an association describes a link 
of that association.  Figure 9.25 - The elements defined in the Instances packageInstanceSpecification
+ instanceInstanceValueValueSpecificationElement
ValueSpecification
StructuralFeature* 1NamedElement
{subsets owner}
+owninginstance{subsets OwnedElement}
+ slotSlot{subsets owner}
+ owningSlot{subsets ownedElement,ordered}
+value
*+definingFeature
1* 0..1
1
ValueSpecification
Classifier{subsets owner}
+owningInstanceSpec{subsets ownedElement}
+specification
0..10..1
+classifier
***
UML Infrastructure Specification, v2.4        55• Specification of values of struct ural features of the entity. No t all structural features of all classifiers of the instance 
specification need be repres ented by slots, in which case the instance specification is a partial description.
• Specification of how to compute, derive, or construct the instance (optional).
InstanceSpecification is a concrete class. 
Generalizations
• “NamedElement” on page 72
Attributes
No additional attributes
Associations
• classifier : Classifier [0..*]  
The classifier or classifier s of the represented instance. If multiple  classifiers are specified, the instance is  
classified by all of them.
• slot : Slot [*]  
A slot giving the value or values of a structural featur e of the instance. An instan ce specification can have one  
slot per structural feature of its classi fiers, including inherited features. It is  not necessary to model a slot for each  
structural feature, in which case the instance specification is a partial description. Subsets Element::ownedElement .
• specification : Valu eSpecification [0..1]  
A specification of how to compute, deri ve, or construct th e instance. Subsets  Element::ownedElement .
Constraints
[1]  The defining feature of each slot is a structural feature (directly or inherited) of a classifi er of the instance specific ation. 
slot->forAll(s |
classifier->exists(c | c.allFeatu res()->includes(s. definingFeature))
)
[2] One structural feature (incl uding the same feature inherited from multiple cla ssifiers) is the defining feature of at most o ne 
slot in an instance specification.
classifier->forAll(c |
(c.allFeatures()->forAll(f | slot->select(s  | s.definingFeature = f)->size() <= 1)
)
Semantics
An instance specification may specify the existence of an entity in a modeled system. An instance specification may 
provide an illustration or example of a possible entity in a m odeled system. An instance specification describes the entity. 
These details can be incomplete. The purpose of an instance specification is to show what is of interest about an entity in 
the modeled system. The entity conforms to the specification of  each classifier of the instance specification, and has 
features with values indicated by each slot of the instance specification. Having no slot in an instance specification for 
some feature does not mean that the represented entity does not have the feature, but merely that the feature is not of 
interest in the model.
An instance specification can represent an entity at a point in time (a snapshot). Changes to the entity can be modeled 
using multiple instance specifica tions, one for each snapshot.
56                 UML Infrastructure Specification, v2.4It is important to keep in mind that InstanceSpecification is  a model element and should not be confused with the dynamic 
element that it is modeling. Therefore, one should not e xpect the dynamic semantics of InstanceSpecification model 
elements in a model repository to conform to the sema ntics of the dynamic elements that they represent.
When used to provide an illustration or example of an entity in a modeled system, an InstanceSpecification class does not 
depict a precise run-time structure. Inst ead, it describes information about such structures. No conclusions can be drawn 
about the implementation detail of run-time  structure. When used to specify the existence of an entity in a modeled 
system, an instance specification represents part of that system. Instance specifications can be modeled incompletely, 
required structural features can be omitted, and classifiers of an instance specification can be abstract, even though an 
actual entity would have a concrete classification.
Notation
An instance specification is depicted using the same notation as  its classifier, but in place of the classifier name appears 
an underlined concatenation of the instance name, a colon (‘: ’), and the classifier name or names. The convention for 
showing multiple classifiers is to separate their names by commas. 
Names are optional for UML 2 classifiers and instance specific ations. The absence of a name in a diagram may reflect its 
absence in the underlying model.The standard notation for an anonymous instance specification of an unnamed classifier is an underlined colon (' :').
If an instance specification has a value sp ecification as its specification, the valu e specification is shown either after an 
equal sign (“=”) following the name, or without an equal si gn below the name. If the instance specification is shown using 
an enclosing shape (such as a rectangle) that contains the name, the value specification is shown within the enclosing 
shape.
Figure 9.26 - Specification of an instance of String
Slots are shown using similar notation to that of the corres ponding structural features. Where a feature would be shown 
textually in a compartment, a slot for that feature can be s hown textually as a feature name followed by an equal sign 
(‘=’) and a value specification. Other properties of the feature, such as its type, optionally can be shown.
Figure 9.27 - Slots with valuesstreetName: String
"S. Crown Ct."
streetName = "S. Crown Ct."
streetNumber : Integer = 381myAddress: Address
UML Infrastructure Specification, v2.4        57An instance specification whose classifier is an association represents a link and is shown using the same notation as for 
an association, but the solid path or paths connect instance sp ecifications rather than classi fiers. It is not necessary to 
show an underlined name where it is clea r from its connection to instance specifica tions that it represents a link and not 
an association. End names can adorn the ends. Navigation arrows can be shown, bu t if shown, they must agree with the 
navigation of the association ends.
Figure 9.28 - Instance specifications repr esenting two objects connected by a link
Presentation Options
A slot value for an attribute can be s hown using a notation similar to that for a link. A solid path runs from the owning 
instance specification to the target instance specification repr esenting the slot value, and the name of the attribute adorns 
the target end of the path. Navigability, if shown,  must be only in the direction of the target.
9.10.2 InstanceValue
An instance value is a value specifi cation that identifies an instance.
Description
An instance value specifies the value modeled by an instance specification.
Generalizations
• “ValueSpecification” on page 48
Attributes
No additional attributes
Associations
• instance: InstanceSpecification [1]  
The instance that is the specified value.
Constraints
No additional constraints
Semantics
The instance specification is the specified value.
Notation
An instance value can appear using textual or graphical notation. When textual, as can appear for the value of an attribute 
slot, the name of the instance is shown. When graphical, a reference value is shown by connecting to the instance. See 
“InstanceSpecification.”Don : Person Josh : Person father son
58                 UML Infrastructure Specification, v2.49.10.3 Slot
A slot specifies that an entity modeled by an instance specific ation has a value or values for a specific structural feature.
Description
A slot is owned by an instance specification. It specifies the value or values for its defining feature, which must be a 
structural feature of a classifier of the instance specification owning the slot.
Generalizations
• “Element (as specialized)” on page 76
Attributes
No additional attributes
Associations
• definingFeature : StructuralFeature [1]  
The structural feature that specifies the values that may be held by the slot.
• owningInstance : Inst anceSpecification [1]  
The instance specification that  owns this slot. Subsets Element.owner .
• value : ValueSpecification [*]  
The value or values corresponding to the defining feature for the owning instance specification. This is an ordered  
association. Subsets Element.ownedElement .
Constraints
No additional constraints
Semantics
A slot relates an instance spec ification, a structural feature, and a value or values. It represents that an entity modeled by 
the instance specification has a structural feature with the spec ified value or values. The values in a slot must conform to 
the defining feature of the slot (in type, multiplicity, etc.).
Notation
See “InstanceSpecification”
UML Infrastructure Specification, v2.4        599.11 Literals Package
The Literals package in the Abstractions package specifies metaclasses for specifying literal values.
9.11.1 LiteralBoolean
A literal Boolean is a specification of a Boolean value.
Description
A literal Boolean contains a Boolean-valued attribute.
Generalizations
• “LiteralSpecification” on page 63
Attributes
• value: Boolean  
The specified Boolean value. Redefines ValueSpecification::value . 
Associations
No additional associationsFigure 9.29 - The Literals package
Figure 9.30 - The elements defi ned in the Literals packageExpressions
Literals
ValueSpecification
(from Expressions)
LiteralSpecification
LiteralBoolean
value : Boolean = falseLiteralInteger
value : Integer = 0LiteralNull LiteralReal
value : RealLiteralString
value : String [0..1]LiteralUnlimitedNatura l
value : UnlimitedNatural = 0
60                 UML Infrastructure Specification, v2.4Constraints
No additional constraints
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralBoolean::isComputable(): Boolean;
isComputable = true  
[2] The query booleanValue() gives the value.
LiteralBoolean::booleanValue() : [Boolean];
booleanValue = value
Semantics
A LiteralBoolean specifies a constant Boolean value.
Notation
A LiteralBoolean is shown as either the word ‘true’  or the word ‘false,’ corresponding to its value. 
9.11.2 LiteralInteger
A literal integer is a specification of an integer value.
Description
A literal integer contains an Integer-valued attribute.
Generalizations
• “LiteralSpecification” on page 63
Attributes
• value: Integer  
The specified Integer value. Redefines ValueSpecification::value . 
Associations
No additional associations
Constraints
No additional constraints
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralInteger::isComputable(): Boolean;
isComputable = true
[2] The query integerValue() gives the value.
LiteralInteger::integerValue() : [Integer];
UML Infrastructure Specification, v2.4        61integerValue = value
Semantics
A LiteralInteger specifies a constant Integer value.
Notation
A LiteralInteger is typically shown as a sequence of digits.
9.11.3 LiteralNull
A literal null specifies the lack of a value. 
Description
A literal null is used to represent nu ll (i.e., the absence of a value).
Generalizations
• “LiteralSpecification” on page 63
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralNull::isComputable(): Boolean;
isComputable = true
[2] The query isNull() returns true.
LiteralNull::isNull() : Boolean;
isNull = true
Semantics
LiteralNull is intended to be used to  explicitly model the lack of a value.
Notation
Notation for LiteralNull varies depending on where it is used . It often appears as the word ‘null.’ Other notations are 
described for specific uses.
62                 UML Infrastructure Specification, v2.49.11.4 LiteralReal
A literal real is a specif ication of a real value.
Description
A literal real contains a Real-valued attribute.
Generalizations
• “LiteralSpecification” on page 63
Attributes
• value: Real  
The specified Real value. Redefines ValueSpecification::value . 
Associations
No additional associations
Constraints
No additional constraints
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralReal::isComputable(): Boolean;
isComputable = true
[2] The query realValue() gives the value.
LiteralString::realValue() : [Real];realValue = value
Semantics
A LiteralReal specifies a constant Real value.
Notation
A LiteralReal is shown in the decimal no tation or scientific notation. Decimal no tation consists of an optional sign 
character (+/-) followed by zero or more digits followed optiona lly by a dot (.) followed by one or more digits. Scientific 
notation consists of decimal notation followed by either the le tter “e” or “E” and an exponent consisting of an optional 
sign character followed by one or more digits. The scientific no tation expresses a real number equal to that given by the 
decimal notation before the exponent, times 10 raised to the power of the exponent. 
This notation is specified by the following BNF rules: 
<natural-literal> ::= ('0'..'9')+ 
<decimal-literal> ::= ['+' | '-' ] <natural-literal>  | ['+' | '-' ] [<natural-lite ral>] '.' <natural-literal> 
<real-literal> ::= <decimal-literal> [ ('e' | 'E') ['+' | '-' ] <natural-literal> ] 
UML Infrastructure Specification, v2.4        639.11.5 LiteralSpecification
A literal specification identifies a literal constant being modeled.
Description
A literal specification is an abstract specialization of Valu eSpecification that identifies a literal constant being modeled.
Generalizations
• “ValueSpecification” on page 48
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics. Subclasses of  LiteralSpecification are defined to sp ecify literal values of different types.
Notation
No specific notation
9.11.6 LiteralString
A literal string is a specification of a string value.
Description
A literal string contains a String-valued attribute.
Generalizations
• “LiteralSpecification” on page 63
Attributes
• value: String  
The specified String value. Redefines ValueSpecification::value . 
Associations
No additional associations
64                 UML Infrastructure Specification, v2.4Constraints
No additional constraints
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralString::isComputable(): Boolean;
isComputable = true
[2] The query stringValue() gives the value.
LiteralString::stringValue() : [String];stringValue = value
Semantics
A LiteralString specifies a constant String value.
Notation
A LiteralString is shown as a sequence of characters within double quotes . The character set used is unspecified.
9.11.7 LiteralUnlimitedNatural
A literal unlimited natural is a specification of an unlimited natural number.
Description
A literal unlimited natural contains an UnlimitedNatural-valued attribute.
Generalizations
• “LiteralSpecification” on page 63
Attributes
• value: UnlimitedNatural  
The specified UnlimitedNat ural value. Redefines ValueSpecification::value.
Associations
No additional associations
Constraints
No additional constraints
Additional Operations 
[1]  The query isComputable() is redefined to be true.
LiteralUnlimitedNatural::isComputable(): Boolean;
isComputable = true  
[2] The query unlimitedValue() gives the value.
LiteralUnlimitedNatural::unlimitedValue() : [UnlimitedNatural];
UML Infrastructure Specification, v2.4        65unlimitedValue = value
Semantics
A LiteralUnlimitedNatural specifies a constant UnlimitedNatural value.
Notation
A LiteralUnlimitedNatural is shown either as a sequence of di gits or as an asterisk (*),  where the asterisk denotes 
unlimited (and not infinity).
9.12 Multiplicities Package
The Multiplicities subpackage of the Abstractions package define s the metamodel classes used to support the specification 
of multiplicities for typed elements (such as association ends  and attributes), and for specifying whether multivalued 
elements are ordered or unique.
Figure 9.31 - The Multiplicities package
Figure 9.32 - The elements define d in the Multiplicities packageElements
Multiplicities
MultiplicityElement
isOrdered : Boolean = false
isUnique : Boolean = true
lower : Integer = 1
upper : UnlimitedNatural = 1[0..1]
[0..1]Element
(from Elements)
66                 UML Infrastructure Specification, v2.49.12.1 MultiplicityElement
A multiplicity is a definition of an inclusive interval of non- negative integers beginning with a lower bound and ending 
with a (possibly infinite) upper bound. A multiplicity elemen t embeds this information to specify the allowable 
cardinalities for an instantiation of this element.
Description
A MultiplicityElement is an abstract metaclass which includes optional attributes for defining the bounds of a multiplicity. 
A MultiplicityElement also includes specifications of whether the values in an instantiation of this element must be 
unique or ordered.
Generalizations
• “Element” on page 44
Attributes
• isOrdered: Boolean  
For a multivalued multiplicity, this attribute specifies wh ether the values in an inst antiation of this element are  
sequentially ordered. Default is false .
• isUnique : Boolean  
For a multivalued multiplicity, this attributes specifies whether the values in an in stantiation of this element  
are unique. Default is true.
• lower : Integer [0..1]  
Specifies the lower bound of the multiplicity interval. Default is one.
• upper : UnlimitedNatural [0..1]  
Specifies the upper bound of the multiplicity interval. Default is one.
Associations
No additional associations
Constraints
These constraint must handle situations  where the upper bound may be specified by an expression not computable in the 
model. In this package such situations cannot arise but they can in subclasses.
[1]  The lower bound must be a non-negative integer literal.
lowerBound()->notEmpty() implies  lowerBound() >= 0
[2] The upper bound must be greater than or equal to the lower bound.
(upperBound()->notEmpty() and lowerBound()->notEmpty()) implies upperBound() >= lowerBound()
Additional Operations
[1]  The query isMultivalued() ch ecks whether this multiplicity ha s an upper bound greater than one.
MultiplicityElement::isMultivalued() : Boolean;
pre: upperBound ()->notEmpty()
isMultivalued = (upperBound() > 1)
[2] The query includesCardinality() ch ecks whether the specified  cardinality is valid for this multiplicity.
MultiplicityElement::includesCardinality(C : Integer) : Boolean;
UML Infrastructure Specification, v2.4        67pre: upperBound()->notEmpty() and lowerBound()->notEmpty()
includesCardinality = (lowerBound() <= C) and (upperBound() >= C)
[3] The query includesMultiplicity() checks whether this multiplic ity includes all the cardinaliti es allowed by the specified 
multiplicity.
MultiplicityElement::include sMultiplicity(M : MultiplicityElement) : Boolean;
pre: self.upperBound()->notEmpty() and self.lowerBound()->notEmpty()  
and M.upperBound()->notEmpty() and M.lowerBound()->notEmpty()
includesMultiplicity = (self.lo werBound() <= M.lowerBound()) and (self.upperBound() >= M.upperBound())
[4] The query lowerBound() returns the lower bound of the multiplicity as an integer.
MultiplicityElement::lo werBound() : [Integer];
lowerBound = if lower->notEmpty() then  lower else 1 endif
[5] The query upperBound() returns the upper bound of the multiplicity for a bounded multiplicity as an unlimited natural.
MultiplicityElement::upperBou nd() : [UnlimitedNatural];
upperBound = if upper->notEmpty() then  upper else 1 endif
Semantics
A multiplicity defines a set of integers th at define valid cardinalities. Specifica lly, cardinality C is valid for multiplicity  M 
if M.includesCardinality(C).
A multiplicity is specified as an interval of integers starting with the lower bound and ending with the (possibly infinite) 
upper bound.
If a MultiplicityElement specifies a multivalued multiplicity, then an  instantiation of this element has a set of values. The 
multiplicity is a constraint on the number of va lues that may validly occur in that set.
If the MultiplicityElement is specified as ordered (i.e., isOrdered is true), then the set of values in an instantiation of thi s 
element is ordered. This ordering implies that there is a mapping from positive inte gers to the elements of the set of 
values. If a MultiplicityElement is not multivalued, then  the value for isOrdered has no semantic effect.
If the MultiplicityElement is specified as uno rdered (i.e., isOrdered is false), then  no assumptions can be made about the 
order of the values in an instantiation of this element.
If the MultiplicityElement is specified as uni que (i.e., isUnique is true), then the se t of values in an instantiation of this 
element must be unique. If a MultiplicityElement is not multival ued, then the value for isUni que has no semantic effect.
The lower and upper bounds for the multiplicity of a MultiplicityEl ement may be specified by value specifications, such 
as (side-effect free, constant ) expressions. A MultiplicityElement can define a [0..0] multiplicity. This restricts cardinality  
to be 0; that is, it forces the collection to be empty. This is useful in the context of generalizations - to constrain the 
cardinalities of a more general classifier. It applies to (but is not limited to) rede fining properties existing in more genera l 
classifiers.
Notation
The specific notation for a MultiplicityElement is defined by the concrete subclasses. In gene ral, the notation will include 
a multiplicity specification, which is shown as a text stri ng containing the bounds of the interval, and a notation for 
showing the optional ordering a nd uniqueness specifications.
The multiplicity bounds are typically shown in the format:
<lower-bound>’..’ <upper-bound>
where < lower-bound>  is a non-negative integer and < upper-bound>  is an unlimited natural number. The asterisk (*) is 
used as part of a multiplicity specification to  represent the unlimited (or infinite) upper bound.
68                 UML Infrastructure Specification, v2.4If the Multiplicity is associated with an element whose notation is  a text string (such as an attribute, etc.), the multiplicit y 
string will be placed within square bracke ts ([]) as part of that text string. Figure 9.33 shows two multiplicity strings as 
part of attribute specifications within a class symbol.
If the Multiplicity is associated with an element that appear s as a symbol (such as an association end), the multiplicity 
string is displayed without square brackets and may be placed  near the symbol for the element. Figure 9.34 shows two 
multiplicity strings as part of the sp ecification of two association ends.
The specific notation for the ordering and uniqueness specific ations may vary depending on the specific subclass of 
MultiplicityElement. A general notation is to use a property stri ng containing ordered or unordered to define the ordering, 
and unique or nonunique to define the uniqueness.
Presentation Options
If the lower bound is equal to the upper bound, then an alternat e notation is to use the string containing just the upper 
bound. For example, “1” is seman tically equivalent to “1..1.”
A multiplicity with zero as the lower bound and an unspecified  upper bound may use the alternative notation containing 
a single asterisk “*” instead of “0..*”.
The following BNF defines the syntax for a multiplicity stri ng, including support for the presentation options listed 
above.
<multiplicity> ::= <multiplicity-range> 
                          [ [ ‘{‘ <order-designator> [‘,’ <uniqueness-designator> ] ‘}’ ] |                           [ ‘{‘ <uniqueness-designator> [‘,’ <order-designator> ] ‘}’ ] ]
<multiplicity-range> ::= [ <lower> ‘..’ ] <upper><lower> ::= <integer> | <value-specification><upper> ::= ‘*’ | <value-specification><order-designator> ::= ‘ordered’ | ‘unordered’ 
<uniqueness-designator> ::= ‘unique’ | ‘nonunique’
UML Infrastructure Specification, v2.4        69Examples
Rationale
MultiplicityElement represents a design trade-off to  improve some technology mappings (such as XMI).
9.13 MultiplicityExpressions Package
The MultiplicityExpressions subpackage of the Abstractions package extends the multiplicity capabilities to support the 
use of value expres sions for the bounds.Figure 9.33 - Multiplicity within a textual specification
Figure 9.34 - Multiplicity as an adornment to a symbol
Figure 9.35 - The Multipli cityExpressions packageCustomer
purchase  :  Purchase [*] {ordered, unique}
account: Account [0..5] {unique}
Customer Account Purchasepurchase account
0..5 *{ordered,
unique}{unique}
Expressions
MultiplicityExpressionsMultipliciies
70                 UML Infrastructure Specification, v2.4Figure 9.36 - The elements defined in the MultiplicityExpressions package
9.13.1 MultiplicityElement (specialized)
Description
MultiplicityElement is specialized to support the use of valu e specifications to define each bound of the multiplicity.
Generalizations
• “MultiplicityElement” on page 66
• “Element (as specialized)” on page 76
Attributes
• / lower : Integer [0..1]  
Specifies the lower bound of the multiplicity interval, if it is expressed as an integer. This is a redefinition of the  
corresponding property from Multiplicities.
• / upper : UnlimitedNatural [0..1]  
Specifies the upper bound of the multiplicity interval, if it is expressed as an unlimited natural. This is a redefinition  
of the corresponding property from Multiplicities.
Associations
• lowerValue: ValueS pecification [0..1]  
The specification of the lower bound for this multiplicity. Subsets Element::ownedElement .
• upperValue: ValueSpecification [0..1]  
The specification of the upper bound for this multiplicity. Subsets Element::ownedElement .
Constraints[1]  If a ValueSpecification is used for the lower or upper bound, then evaluating that specification must not have side effect s.
Cannot be expressed in OCL.
[2] If a ValueSpecification is used for th e lower or upper bound, then that specification must be a constant expression.
Cannot be expressed in OCL.
[3] The derived lower attribute must equal the lowerBound.
lower = lowerBound()  ValueSpecification
(from  Expressions)MultiplicityElement
/ lower : Integer
/ upper : UnlimitedNatural0..1 0..1upperValue
0..1{subsets ownedElement}+o wningUp per
0..1{subsets owner}
0..1 0..1lowerValue
0..1{subsets ownedElement}+owningLower
0..1{subsets owner}MultiplicityElement
(from  Multiplicities)Element
(from  Ownerships)
[0..1]
[0..1]
UML Infrastructure Specification, v2.4        71[4] The derived upper attribute must equal the upperBound.
upper = upperBound()
Additional Operations
[1]  The query lowerBound() returns the lower bound of the multiplicity as an integer.
MultiplicityElement::lo werBound() : [Integer];
lowerBound =
if lowerValue->isEmpty() then
1
else 
 lowerValue.integerValue()
endif
[2] The query upperBound() returns the upper bound of the multiplicity as an unlimited natural.
MultiplicityElement::upperBou nd() : [UnlimitedNatural];
upperBound =
if upperValue->isEmpty() then
1
else
upperValue.unlimitedValue()
endif
Semantics
The lower and upper bounds for the multiplicity of a MultiplicityEl ement may be specified by value specifications, such 
as (side-effect free, constant) expressions.
Notation
The notation for Multiplicities::MultiplicityEl ement (see page 66) is extended to  support value specifications for the 
bounds.
The following BNF defines the syntax for a multiplicity string, including support for the presentation options.
<multiplicity> ::= <multiplicity-range> 
                          [ [ ‘{‘ <order-designator> [‘,’ <uniqueness-designator> ] ‘}’ ] |
                           [ ‘{‘ <uniqueness-designator> [‘,’ <order-designator> ] ‘}’ ] ]
<multiplicity-range> ::= [ <lower> ‘..’ ] <upper><lower> ::= <integer> | <value-specification><upper> ::= ‘*’ | <value-specification><order-designator> ::= ‘ordered’ | ‘unordered’ <uniqueness-designator> ::= ‘unique’ | ‘nonunique’
72                 UML Infrastructure Specification, v2.49.14 Namespaces Package
The Namespaces subpackage of the Abstractions package specifies the concepts used for defining model elements that 
have names, and the containment and identificati on of these named elements within namespaces.
9.14.1 NamedElement
A named element is an element in a model that may have a name.
Description
A named element represents elements that may have a name. The name is used for identification of the named element 
within the namespace in which it is defined. A named el ement also has a qualified name that allows it to be 
unambiguously identified within a hierarchy of nested namespaces. NamedElement is  an abstract metaclass.Figure 9.37 - The Namespaces package
Figure 9.38 - The elements defined in the Namespaces packageOwnerships
Namespaces

UML Infrastructure Specification, v2.4        73Generalizations
• “Element (as specialized)” on page 76
Attributes
• name: String [0..1]  
The name of the NamedElement.
• / qualifiedName: String [0..1]  
A name which allows the NamedElement to be identified wi thin a hierarchy of nested Namespaces. It is constructed  
from the names of the containing namesp aces starting at the root of the hierar chy and ending with  the name of the  
NamedElement itself. This is a derived attribute.
Associations
• / namespace: Namespace [0..1]  
Specifies the namespace that owns the NamedElement. Subsets Element::owner .  This is a derived union.
Constraints[1]  If there is no name, or one of the containing namespaces has no name, there is no qualified name.
(self.name->isEmpty() or self.allNamespaces()->select(ns | ns.name->isEmpty())->notEmpty())
implies  self.qualifiedName->isEmpty()
[2] When there is a name, and all of the containing namespaces have a name, the qualified name is constructed from the 
names of the containing namespaces.
(self.name->notEmpty() and self.allNamespaces()->select(ns | ns.name->isEmpty())->isEmpty()) implies
self.qualifiedName = self.a llNamespaces()->iterate( ns : Namesp ace; result: Stri ng = self.name |
ns.name->union(self.sep arator())->union(result))
Additional Operations
[1]  The query allNamespaces() gives the sequence of namespaces in which the Name dElement is nested , working outwards.
NamedElement::allNamespaces (): Sequence(Namespace);
allNamespaces =
 if self.namespace->isEmpty()
 then  Sequence{}
 else  self.namespace.allNamespaces()->prepend(self.namespace)
 endif
[2] The query isDistinguishableFrom() determines whether tw o NamedElements may logically co-exist within a Namespace. 
By default, two named elements are distinguishable if (a) th ey have unrelated types or (b) they have related types but 
different names.
NamedElement::isDistinguish ableFrom(n:NamedElement, ns: Namespace): Boolean;
isDistinguishable =
 if self.oclIsKindOf(n.oclType) or n.oclIsKindOf(self.oclType)
 then  ns.getNamesOfMember(sel f)->intersection(ns.getNa mesOfMember(n))->isEmpty()
 else  true
 endif
[3] The query separator() gives the string that is used to separate names when constructing a qualified name.
NamedElement::separator(): String;
separator = ‘::’
74                 UML Infrastructure Specification, v2.4Semantics
The name attribute is used for identification of the named el ement within namespaces where its name is accessible. Note 
that the attribute has a multiplicity of [ 0..1 ], which provi des for the possibility of the absence of a name (which is 
different from the empty name).
9.14.2 Namespace
A namespace is an element in a model that contains a set of named elements that can be identified by name.
Description
A namespace is a named element that can own other named el ements. Each named element may be owned by at most one 
namespace. A namespace provides a mean s for identifying named elements by na me. Named elements can be identified 
by name in a namespace either by being directly owned by th e namespace or by being introduced into the namespace by 
other means (e.g., importing or inheriting) . Namespace is an abstract metaclass.
Generalizations
• “Namespace” on page 74
Attributes
No additional attributes
Associations
• / member: NamedElement [*]  
A collection of NamedElements identifi able within the Namespace, either by being owned or by being introduced by  
importing or inheritance. This is a derived union.
• / ownedMember: NamedElement [*]  
A collection of NamedElements ow ned by the Namespace. Subsets Element::ownedElement  and  
Namespace::member . This is a derived union.
Constraints
[1]  All the members of a Namesp ace are distinguishable within it.
membersAreDistinguishable()
Additional Operations
[1]  The query getNamesOfMember() gives a set of all of the names that a member would have in a Namespace. In general a 
member can have multiple names in a Name space if it is imported more than once w ith different aliases. Those semantics 
are specified by overriding th e getNamesOfMember operation. The specificati on here simply returns a set containing a 
single name, or the empty set if no name.
Namespace::getNamesOfM ember(element: NamedElement): Set(String);
getNamesOfMember = 
if member->includes(element) then  Set{}->including(element.name) else Set{} endif
[2] The Boolean query membersAreDist inguishable() determines  whether all of the namespace’s members are 
distinguishable within it.
Namespace::membersAreDistinguishable() : Boolean;
membersAreDistinguishable =self.member->fo rAll( memb |
UML Infrastructure Specification, v2.4        75self.member->excluding( memb)->forAll(other |
memb.isDistinguishableFrom(other, self)))
Semantics
A namespace provides a container for named elements. It pr ovides a means for resolving composite names, such as 
name1::name2::name3. The member  association identifies all named elements  in a namespace called N that can be 
referred to by a composite name of the form N::<x>. Note that this is different from all of the names that can be referred 
to unqualified within N, because that set also in cludes all unhidden members of enclosing namespaces.
Named elements may appear within a namespace according to rules that specify how one named element is 
distinguishable from another. The default rule is that two el ements are distinguishable if th ey have unrelated types, or 
related types but different names. This rule may be overr idden for particular cases, such as operations that are 
distinguished by their signature.
Notation
No additional notation. Concrete subclass es will define their own specific notation.
9.15 Ownerships Package
The Ownerships subpackage of the Abstractions package ex tends the basic element to support ownership of other 
elements.
Figure 9.39 - The Ownerships packageElements
Ownerships
76                 UML Infrastructure Specification, v2.49.15.1 Element (as specialized)
An element is a constituent of a model. As such, it has the capability of owning other elements.
Description
Element has a derived composition association to itself to support the general capability for elements to own other 
elements.
Generalizations
• “Element” on page 44
Attributes
No additional attributes
Associations
• / ownedElement: Element[*]  
The Elements owned by this element. This is a derived union.
• / owner: Element [0..1]  
The Element that owns this element. This is a derived union.
Constraints
[1]  An element may not directly or indirectly own itself.
not self.allOwnedElements()->includes(self)
[2] Elements that must be owned must have an owner.
self.mustBeOwned() implies  owner->notEmpty()
Additional Operations
[1]  The query allOwnedElem ents() gives all of the direct and in direct owned elements of an element.
Element::allOwnedElements(): Set(Element);Figure 9.40 - The elements defined in the Ownerships packageElement
*
0..1/ownedElement
*{union}
/owner
0..1{union}Element
(from  Elem ents)
UML Infrastructure Specification, v2.4        77allOwnedElements = ownedEle ment->union(ownedElem ent->collect(e | e. allOwnedElements()))
[2] The query mustBeOwned() indicates whethe r elements of this type must have an owner. Subclasses of Element that do not 
require an owner must override this operation.
Element::mustBeOwned() : Boolean;
mustBeOwned = true
Semantics
Subclasses of Element will provide semantics appropriate to the concept they represent.
The derived ownedElement  association is subsetted (directly or indirec tly) by all composed association ends in the 
metamodel. Thus ownedElement provides a convenient way to access all the elem ents that are directly owned by an 
Element.
Notation
There is no general notation for an Element. The specif ic subclasses of Element define their own notation.
9.16 Redefinitions Package
The Redefinitions package in the Abstractions package specif ies the general capability of redefining model elements in 
the context of a generalization hierarchy.
Figure 9.41 - The Redefinitions packageSuper
Redefinitions
78                 UML Infrastructure Specification, v2.49.16.1 RedefinableElement
A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or 
differently in the context of another classifier that sp ecializes (directly or indire ctly) the context classifier.
Description
A redefinable element is a named element that can be redefine d in the context of a generalization. RedefinableElement is 
an abstract metaclass.
Generalizations
• “NamedElement” on page 72
Attributes
No additional attributes
Associations
• / redefinedElement: RedefinableElement[*]  
The redefinable element that is being redefine d by this element. This is a derived union.
• / redefinitionContext: Classifier[*]  
References the contexts that this element ma y be redefined from. This is a derived union.
Constraints
[1]  At least one of the redefinition contexts of the redefini ng element must be a speciali zation of at least one of the 
redefinition contexts for each redefined element.
self.redefinedElement->forAll(e | self.isRedefinitionContextValid(e))  Figure 9.42 - The elements defined in the Redefinitions package

UML Infrastructure Specification, v2.4        79[2] A redefining element mu st be consistent with  each redefined element.
self.redefinedElement->forAll(re  | re.isConsistentWith(self))
Additional Operations
[1]  The query isConsistentWith() specifies, for any two Redefi nableElements in a context in which redefinition is possible, 
whether redefinition would be logically consistent. By defaul t, this is false; this operation must be overridden for 
subclasses of RedefinableElement to  define the consistency conditions.
RedefinableElement::isConsistentWith(redefinee: RedefinableElement): Boolean;
pre: redefinee.isRedefinitionContextValid(self)
isConsistentWith = false
[2] The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are 
properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the 
other. By default at least one of the redefinition contexts of this element must be a speciali zation of at least one of the 
redefinition contexts of  the specified element.
RedefinableElement::isRedefinitionContexValid(redefinable: RedefinableElement): Boolean;
isRedefinitionContextValid =
redefinitionConte xt->exists(c | c.allparents()->
includes (redefined. redefinitionContext))
Semantics
A RedefinableElement represents the gene ral ability to be redefined in the cont ext of a generalization relationship. The 
detailed semantics of redefinition varies fo r each specialization of RedefinableElement.
A redefinable element is a specification concerning instances of a classifier that is one of the element’s redefinition 
contexts. For a classifier that specializes that more general cl assifier (directly or indirectly), another element can redefine  
the element from the general classifier in order to augment, constrain, or override the sp ecification as it applies more 
specifically to instances of  the specializing classifier.
A redefining element must be consistent with the element it re defines, but it can add specific  constraints or other details 
that are particular to instances of the specializing redefiniti on context that do not contradict invariant constraints in the 
general context.
A redefinable element may be redefine d multiple times. Furthermore, one rede fining element may redefine multiple 
inherited redefinable elements.
Semantic Variation Points
There are various degrees of compatibility between the rede fined element and the redefining element, such as name 
compatibility (the redefining element has the same name as the redefined element), structural compatibility (the client 
visible properties of the redefined element are also properties of the redefining element), or behavioral compatibility (the 
redefining element is substitutable for the redefined elemen t). Any kind of compatibility involves a constraint on 
redefinitions. The particular constraint chosen is a semantic variation point. 
NotationNo general notation. See the subclasses of Rede finableElement for the specific notation used.
80                 UML Infrastructure Specification, v2.49.17 Relationships Package
The Relationships subpackage of the Abstractions package adds support for directed relationships.
9.17.1 DirectedRelationship
A directed relationship represents a rela tionship between a collection of source model elements and a collection of target 
model elements.
Description
A directed relationship references one or more source elements and one or more target elements. DirectedRelationship is 
an abstract metaclass.
Generalizations
• “Relationship” on page 81Figure 9.43 - The Relationships package
 
Figure 9.44 - The elements defi ned in the Relationships packageOwnerships
Relationships

UML Infrastructure Specification, v2.4        81Attributes
No additional attributes
Associations
• / source: Element [1..*]  
Specifies the sources of the DirectedRelationship. Subsets Relationship::relatedElement . This is a derived union.
• / target: Element [1..*]  
Specifies the targets of the DirectedRelationship. Subsets Relationship::relatedElement . This is a derived  
union.
Constraints
No additional constraints
Semantics
DirectedRelationship has no specific semantics. The various  subclasses of DirectedRe lationship will add semantics 
appropriate to the concept they represent.
Notation
There is no general notation for a DirectedRelationship. The sp ecific subclasses of Directed Relationship will define their 
own notation. In most cases the notation is a varia tion on a line drawn from the source(s) to the target(s).
9.17.2 Relationship
Relationship is an abstract concept that specif ies some kind of relationship between elements.
Description
A relationship references one or more related elements. Relationshi p is an abstract metaclass. 
Generalizations
• “Element (as specialized)” on page 76
Attributes
No additional attributes.
Associations
• / relatedElement: Element [1..*]  
Specifies the elements related by the Re lationship. This is a derived union.
Constraints
No additional constraints
82                 UML Infrastructure Specification, v2.4Semantics
Relationship has no specific semantics. Th e various subclasses of Relationship will add semantics appropriate to the 
concept they represent.
Notation
There is no general notation for a Relationship. The specific su bclasses of Relationship will de fine their own notation. In 
most cases the notation is a variation on a line drawn between the related elements.
9.18 StructuralFeatures Package
The StructuralFeatures package of the Abstractions package spec ifies an abstract generalization of structural features of 
classifiers. 
9.18.1 StructuralFeature
A structural feature is a typed feature of a classifier th at specifies the structure of instances of the classifier.
Description
A structural feature is a typed feature of a classifier that sp ecifies the structure of instances of the classifier. Structural  
feature is an abstract metaclass.Figure 9.45 - The StructuralFeatures package
Figure 9.46 - The elements define d in the StructuralFeatures packageClassifiers
StructuralFeaturesTypedElements
TypedElement
(from  TypedElem ents)
StructuralFeatureFeature
(from Classifiers)
UML Infrastructure Specification, v2.4        83Generalizations
• “TypedElement” on page 88
• “Feature” on page 36
Attributes
No additional attributes
Associations
No additional associations 
Constraints
No additional constraints
Semantics
A structural feature specifies that instances of the featuring cl assifier have a slot whose value or values are of a specified 
type. 
Notation
No additional notation
9.19 Super Package
The Super package of the Abstractions package provides mech anisms for specifying genera lization relationships between 
classifiers.
Figure 9.47 - The Super packageClassifiers
Super
84                 UML Infrastructure Specification, v2.49.19.1 Classifier (as specialized)
Description
A classifier can specify a generalization hier archy by referencing its general classifiers.
Generalizations
• “Classifier” on page 35.
Attributes
• isAbstract: Boolean  
If true, the Classifier does not pr ovide a complete declaration and can typi cally not be instantiated. An abstract  
classifier is intended to be used by other classifiers (e.g., as the target of general metarelationships or generalization  
relationships). Default value is false .
Associations
• general: Classifier[*]  
Specifies the more general classifiers in the generalization hierarchy for this Classifier.
• / inheritedMember: NamedElement[*]  
Specifies all elements inherited by this classifier from  the general classifiers. Subsets Namespace::member . This is  
derived.
Constraints[1]  Generalization hierarchies must be directed and acyclical. A classifier cannot be both a transitively general and 
transitively specific classifi er of the same classifier.
not self.allParents()->includes(self)  
 Figure 9.48 - The elements defined in the Super package

UML Infrastructure Specification, v2.4        85[2] A classifier may only special ize classifiers of a valid type.
self.parents()->forAll(c | self.maySpecializeType(c))
[3] The inheritedMember association is derived by inheriting the inheritable members of the parents.
self.inheritedMember = self.inherit( self.parents ()->collect(p | p.inheritableMembers(self))->asSet() )
Additional Operations 
[1]  The query parents() gives all of the imme diate ancestors of a ge neralized Classifier.
Classifier::parents(): Set(Classifier);
parents = general
[2] The query allParents() gives all of the direct and indirect ancestors of a generalized Classifier.
Classifier::allParents(): Set(Classifier);
allParents = self.parents ()->union(self.parents()->col lect(p | p.allParents()))
[3] The query inheritableMembers() gives all of the members of a classifier that may be inherited in one of its descendants, 
subject to whatever visibility restrictions apply.
Classifier::inheritableMembers(c: Classifier): Set(NamedElement);
pre: c.allParents()->includes(self)
inheritableMembers = member-> select(m | c.hasVisibilityOf(m))
[4] The query hasVisibilityOf() determines whether a named element is visible in the classifier. It is only called when the 
argument is something owned by a parent.
Classifier:: hasVisibilityOf (n: NamedElement) : Boolean;
pre: self.allParents()->collect (c | c.member)->includes(n)
hasVisibilityOf = (n.visibility <> #private)
[5] The query inherit() defines how to inherit a set of elements. He re the operation is defined to inherit them all. It is inten ded 
to be redefined in circumstances where i nheritance is affected by redefinition.
Classifier::inherit(inhs: Set(NamedElement)): Set(NamedElement);inherit = inhs
[6] The query maySpecializeType() determines  whether this classifier may have a generalization relationship to classifiers of 
the specified type. By default a classifier may specialize classifiers of the same or a more general type. It is intended to be  
redefined by classifiers that have different speciali zation constraints.
Classifier::maySpecializeType (c : Classifier) : Boolean;
maySpecializeType = self .oclIsKindOf(c.oclType)
Semantics
The specific semantics of how generalization affe cts each concrete subtype of Classifier varies.
An instance of a specific Classifier is also an (indirect) in stance of each of the general Classifiers. Therefore, features 
specified for instances of the general classifier are implic itly specified for instances of the specific classifier. Any 
constraint applying to instances of the general classifier  also applies to instances of the specific classifier.
Notation
The name of an abstract Classifier is shown in italics.
Generalization is shown as a line with an  hollow triangle as an arrowhead between the symbols representing the involved 
classifiers. The arrowhead points to the symbol representing the general classifier. This notation is referred to as “separate 
target style.” See the example sub clause below.
86                 UML Infrastructure Specification, v2.4Presentation Options 
Multiple Classifiers that have the same general classifier can be shown together in the “shared target style.” See the 
example sub clause below.
An abstract Classifier can be shown using the keyword {abstract} after or below the name of the Classifier.
Examples
9.20 TypedElements Package
The TypedElements subpackage of the Abstractions package defines typed elements and their types.Figure 9.49 - Example cl ass generalization hierarchy
Figure 9.50 - The TypedElements packageShape
Polygon Ellipse Spline
Shape
Polygon Ellipse SplineSeparate target style
Shared target style
TypedElementsNamespaces
UML Infrastructure Specification, v2.4        879.20.1 Type
A type constrains the values represented by a typed element.
Description
A type serves as a constraint on the range of values repr esented by a typed element. Type is an abstract metaclass.
Generalizations
• “NamedElement” on page 72
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Additional Operations
[1]  The query conformsTo() gives true for a type that conforms to another. By default, two types do not conform to each other.  
This query is intended to be redefi ned for specific conformance situations.
conformsTo(other: Type): Boolean;
conformsTo = false
Semantics
A type represents a set of values. A typed element that has th is type is constrained to repr esent values within this set.Figure 9.51 - The elements defined in the TypedElements package

88                 UML Infrastructure Specification, v2.4Notation
No general notation
9.20.2 TypedElement
A typed element has a type.
Description
A typed element is an element that has a type that serves as a constraint on the range of values the element can represent. 
Typed element is an abstract metaclass.
Generalizations
• “NamedElement” on page 72
Attributes
No additional attributes
Associations
• type: Type [0..1]  
The type of the TypedElement.
Constraints
No additional constraints.
Semantics
Values represented by the element are constrained to be instan ces of the type. A typed element with no associated type 
may represent values of any type.
Notation
No general notation
9.21 Visibilities Package
The Visibility subpackage of the Abstractions package provide s basic constructs from whic h visibility semantics can be 
constructed.
UML Infrastructure Specification, v2.4        899.21.1 NamedElement (as specialized)
Description
NamedElement has a visibility attribute.
Attributes
• visibility: VisibilityKind [0..1]  
Determines where the NamedElement appears within different Namespaces within the overall model, and its  
accessibility.
Generalizations
• “NamedElement” on page 72
Associations
No additional associations
Constraints
[1]  If a NamedElement is not owned by a Namespace, it does not have a visibility.
namespace->isEmpty() implies  visibility->isEmpty()Figure 9.52 - The Visibilities package
Figure 9.53 - The elements defi ned in the Visibilities packageNamespaces
Visibilities
NamedElement
+ visibility : VisibilityKind [0..1]«enumeration»
VisibilityKind
public
privateprotectedpackage
90                 UML Infrastructure Specification, v2.4Semantics
The visibility attribute provides the means to constrain the usage of a named element either in namespaces or in access to 
the element. It is intended for use in conjunction with import, generalizatio n, and access mechanisms.
9.21.2 VisibilityKind
VisibilityKind is an enumeration type that defines literals  to determine the visibility of elements in a model.
Generalizations
• None
DescriptionVisibilityKind is an enumeration of the following literal values:
• public
• private
• protected
• package
SemanticsVisibilityKind is intended for use in the specification of vi sibility in conjunction with, for example, the Imports, 
Generalizations, Packages, and Classifiers packages. Detaile d semantics are specified wi th those mechanisms. If the 
Visibility package is used without those packages, these literals will have different meanings, or no meanings.
• A public element is visible to all elements that can access the contents  of the namespace that owns it.
• A private element is only visible inside the namespace that owns it.
• A protected element is visible to elem ents that have a generalization relati onship to the namespace that owns it.
• A package element is owned by a namespace that is not a package, an d is visible to elements that are in the same 
package as its owning namespace. Only named elements that  are not owned by packages can be marked as having 
package visibility.  Any element marked  as having package visibility is visibl e to all elements within the nearest 
enclosing package (given that other owning elements have proper visibility).  Outside the nearest enclosing package, an 
element marked as having pack age visibility is not visible.
In circumstances where a named element ends up with multiple  visibilities, for example by being imported multiple times, 
public visibility overrides private visibility, i.e., if an elem ent is imported twice into the same namespace, once using 
public import and once using private import, it will be public.
Notation
The following visual presentation options are available fo r representing VisibilityKind enumeration literal values:
“+” public
“-“ private“#” protected
“~” package
UML Infrastructure Specification, v2.4        9110 Core::Basic
The Basic package of InfrastructureLibrary::Core provide s a minimal class-based modeling language on top of which 
more complex languages can be built. It is intended for reus e by the Essential layer of th e Meta-Object Facility (MOF). 
The metaclasses in Basic are specified using four diagrams : Types, Classes, DataTypes, and Packages. Basic can be 
viewed as an instance of itself. More complex versions of  the Basic constructs are defi ned in Constructs, which is 
intended for reuse by the Complete layer of  MOF as well as the UML Superstructure. 
Figure 10.1 illustrates the relationships between the Core packag es and how they contribute to the origin and evolution of 
package Basic. Package Basic imports model elements fro m package PrimitiveTypes. Basic also contains metaclasses 
derived from shared metaclasses defined in packages contained in Abstractions. These shared metaclasses are included in 
Basic by copy.
Figure 10.1  - The Core package is owned by the InfrastructureLibrary package and contains several subpackagesConstructs
ConstructsBasicAbstractionsPrimitiveTypes
«import»
«import»«import»
92                 UML Infrastructure Specification, v2.410.1 Types Diagram
The Types diagram defines abstract metaclasses that deal with naming and typing of elements.
10.1.1 Comment
Description
Basic::Comment reuses the definition of Comment from Abstractions::Comments . 
Generalizations
• “Element” on page 93
Attributes
• body: String [0..1]  
Specifies a string th at is the comment.
Associations
• annotatedElement: Element[*]  
Redefines the corresponding property in Abstractions .
Constraints
No additional constraintsFigure 10.2 - The classes defined in the Types diagram

UML Infrastructure Specification, v2.4        93Semantics
No additional semantics
Notation
No additional notation
10.1.2 Element 
An element is a constituent of a model.
Description
Element is an abstract metaclass with no superclass. It is used as the common superclass for all metaclasses in the 
infrastructure library.
Generalizations
• None
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
Subclasses of Element provide semantics a ppropriate to the concept they represent.
Notation
There is no general notation for an Element. The specif ic subclasses of Element define their own notation.
10.1.3 NamedElement
Description
A named element represents  elements with names.
Generalizations
• “Element” on page 93
Attributes
• name: String [0..1]  
The name of the element.
94                 UML Infrastructure Specification, v2.4Semantics
Elements with names are instan ces of NamedElement. The name for a named elem ent is optional. If specified, then any valid 
string, including the empty string, may be used.
Notation
As an abstract class, Basic::NamedElement has no notation.
10.1.4 Type
Description
A type is a named element that is us ed as the type for a typed element.
Generalizations
• “NamedElement” on page 93
Attributes
No additional attributes
Semantics
Type is the abstract class that represents the general notion of  the type of a typed element and constrains the set of values 
that the typed element may refer to.
Notation
As an abstract class, Basic::Type has no notation.
10.1.5 TypedElement
Description
A typed element is a kind of named element that represents elements with types.
Generalizations
• “NamedElement” on page 93
Attributes
• type: Type [0..1]  
The type of the element.
Semantics
Elements with types are instances of T ypedElement. A typed element may optionally  have no type. The type of a typed 
element constrains the set of values that the typed element may refer to.
NotationAs an abstract class, Basi c::TypedElement has no notation.
UML Infrastructure Specification, v2.4        9510.2 Classes Diagram
The Classes diagram defines the c onstructs for class-based modeling.
10.2.1 Class
Description
A class is a type that has objects as its instances. 
Generalizations
• “Type” on page 94
Attributes
• isAbstract : Boolean  
True when a class is abstract. The default value is false.
• ownedAttribute : Property [*]  
The attributes owned by a class. These do not include the inherited attributes. Attribut es are represented by instances  
of Property.Figure 10.3 - The classes defined in the Classes diagramType
Class
+ isAbstract : Boolean = falseProperty
+ isReadOnly : Boolean = false
+ default : String [0..1]+ isComposite : Boolean = false
+ isDerived : Boolean = false
+ isID : Boolean = falseTypedElementMultiplicityElement
+ isOrdered : Boolean = false
+ isUnique : Boolean = true+ lower : Integer [0..1] = 1+ upper : UnlimitedNatural [0..1] = 1Element
OperationTypedElement MultiplicityElement
ParameterTypedElement MultiplicityElement
Type**+ superClass0..10..1+ opposite
0..1 *+ ownedAttribute{ordered}
0..1 *+ ownedOperation{ordered}
0..1 *+ ownedParameter{ordered}
**+ raisedException
96                 UML Infrastructure Specification, v2.4• ownedOperation : Operation [*]  
The operations owned by a class. These do not include the inherited operations.
• superClass : Class[*]  
The immediate superclasses of a class, from which the class inherits.
Semantics
Classes have attributes and operations a nd participate in inheritance hierarchies.  Multiple inheritance is allowed. The 
instances of a class are objects. When a class is abstract it cannot have any direct instances. Any direct instance of a 
concrete (i.e., non-abstract) class is also an indirect instance of its class’s superclasses. An object has a slot for each of its 
class’s direct and inherited attributes. An  object permits the invocation of operatio ns defined in its class and its class’s 
superclasses. The context of such an invocation is the invoked object.
A class cannot access privat e features of another class, or protected features on another clas s that is not its supertype.  
When creating and deleting associations, at least one end must allow access to the class.
Notation
The notation for Basic::Class is the same as that for Constructs::Class  with the omission of those aspects of the notation 
that cannot be represented by the Basic model.
10.2.2 MultiplicityElement
Description
Basic::MultiplicityElement  reuses the definition from Abstractions::MultiplicityElement . 
Generalizations
• “Element” on page 93
Description
Constructs::Relationship reuses the definition of Relationship  from Abstractions::Relationships . It adds a specialization to 
Constructs::Element .
Generalizations
• “Element” on page 93
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
UML Infrastructure Specification, v2.4        97Semantics
No additional semantics
Notation
No additional notation
10.2.3 Operation
Description
An operation is owned by a class and may be invoked in the context of objects that are instances of  that class. It is a typed 
element and a multiplicity element.
Generalizations
• “TypedElement” on page 94
• “TypedElement” on page 94 - MultiplicityElement.
Attributes
• class : Class [0..1]  
The class that owns the operation.
• ownedParameter : Parameter [*] {ordered, composite }  
The parameters to the operation.
• raisedException : Type [*]  
The exceptions that are decl ared as possible during an invocation of the operation.
Semantics
An operation belongs to a class. It is possible to invoke an opera tion on any object that is directly or indirectly an instance  
of the class. Within such an invocation the execution context includes this object and the values of the parameters. The 
type of the operation, if any, is the type of the result re turned by the operation, and the multiplicity is the multiplicity of  
the result. An operation can be associated with a set of type s that represent possible exceptions that the operation may 
raise.
Notation
The notation for Basic::Class is the same as that for Constructs::Class  with the omission of those aspects of the notation 
that cannot be represented by the Basic model. 
10.2.4 Parameter
Description
A parameter is a typed element that repr esents a parameter of an operation. 
Attributes
• operation: Operation [0..1]  
The operation that owns the parameter.
98                 UML Infrastructure Specification, v2.4Semantics
When an operation is invoked, an argument may be passed to  it for each parameter. Each  parameter has a type and a 
multiplicity. Every Basic::Parameter is associated with an oper ation, although subclasses of  Parameter elsewhere in the 
UML model do not have to be associated w ith an operation, hence the 0..1 multiplicity.
Notation
The notation for Basic::Parameter is the same as that for C onstructs::Parameter with the omission of those aspects of the 
notation that cannot be repr esented by the Basic model.
10.2.5 Property
Description
A property is a typed element that re presents an attribute of a class. 
Generalizations
• “TypedElement” on page 94
• “TypedElement” on page 94 - MultiplicityElement.
Attributes
• class : Class [0..1]  
The class that owns the property, and of  which the property  is an attribute.
• default : String [0..1]  
A string that is evaluated to give a defa ult value for the attribute wh en an object of the owni ng class is instantiated.
• isComposite : Boolean  
If isComposite is true, the object cont aining the attribute is a c ontainer for the object or value contained in the  
attribute. The default value is false.
• isDerived : Boolean  
If isDerived is true, the value of the attribute is derive d from information elsewhere. The default value is false.
• isReadOnly : Boolean  
If isReadOnly is true, the attribute may not be written to after initialization. The default value is false.
• opposite : Property [0..1]  
Two attributes attr1 and attr2 of two obj ects o1 and o2 (which may be the same object) may be paired with each other  
so that o1.attr1 refers to o2 if and only if o2.attr2 refers to o1. In such a case attr1 is the opposite of attr2 and attr2 is  
the opposite of attr1.
• isID : Boolean  
True indicates this property  can be used to uniquely iden tify an instance of the contai ning Class. Default value is false
Semantics
A property represents an attribute of a class. A property has a type and a multiplicity. When a property is paired with an 
opposite they represent two mutually constrained attributes. Th e semantics of two properties that are mutual opposites are 
the same as for bidirectionally navigable associations in Constr ucts, with the exception that the association has no explicit 
links as instances,  and has no name.
UML Infrastructure Specification, v2.4        99A property may be marked as being (part of) the identifier (i f any) for classes of which it is a member. The interpretation 
of this is left open but this could be mapped to implementations  such as primary keys for rela tional database tables or ID 
attributes in XML. If multiple properties are marked (possibly in  superclasses) then it is the combination of the (property, 
value) tuples that will logically provide the uniqueness for a ny instance. Hence there is no need for any specification of 
order and it is possible for some (but not all) of the property values to be empty. If the pr operty is multivalued then all 
values are included.
Notation
When a Basic::Property has no opposite, its notation is the same for Constructs::Property when used as an attribute with 
the omission of those aspects of the notation that cannot be re presented by the Basic model. Normally if the type of the 
property is a data type, the attribute is shown within the attr ibute compartment of the class box, and if the type of the 
property is a class, it is shown usi ng the association-like arrow notation.
When a property has an opposite, the pair of attri butes are shown using the same notation as for a Constructs::Association  
with two navigable ends, with the omission of those aspects of  the notation that cannot be represented by the Basic model.
10.3 DataTypes Diagram
The DataTypes diagram defines the me taclasses that define data types.
10.3.1 DataType
Description
DataType is an abstract class that acts as a common superclass for different kinds of data types.
Generalizations
• “Type” on page 94
Attributes
No additional attributesFigure 10.4 - The classes defined in the DataTypes diagramType
NamedElement
PrimitiveTypeEnumerationLiteralEnumeration
* 0..1ownedLiteral
*{ordered}enumeration
0..1DataType
100                 UML Infrastructure Specification, v2.4Semantics
DataType is the abstract class that repr esents the general notion of being a data type (i.e., a type whose instances are 
identified only by their value).
Notation
As an abstract class, Ba sic::DataType has no notation.
10.3.2 Enumeration
Description
An enumeration defines a set of literals  that can be used as its values.
Generalizations
• “DataType” on page 99
Attributes
• ownedLiteral: EnumerationLiter al [*] {ordered, composite} — The ordered collection of literals for the enumeration.
Semantics
An enumeration defines a finite ordered se t of values, such as {red, green, blue}.
The values denoted by typed elements whose type is an enumeration must be taken from this set.
Notation
The notation for Basic::Enumeration is the same as that for Constructs::Enumeration with the omission of those aspects 
of the notation that cannot be represented by the Basic model.
10.3.3 EnumerationLiteral
Description
An enumeration literal is a value of an enumeration.
Generalizations
• “NamedElement” on page 93
Attributes
• enumeration: Enumeration [0..1]  
The enumeration that this literal belongs to.
Semantics
See Enumeration
UML Infrastructure Specification, v2.4        101Notation
See Enumeration
10.3.4 PrimitiveType
DescriptionA primitive type is a data type implemented by the underl ying infrastructure and made available for modeling.
Generalizations
• “DataType” on page 99
AttributesNo additional attributes
Semantics
Primitive types used in the Basic model itself are Integer, Boolean, String, and UnlimitedNatural. Their specific semantics 
is given by the tooling context, or in extensions of the metamodel (e.g., OCL).
Notation
The notation for a primitive type is implementation-depe ndent. Notation for the primitive types used in the UML 
metamodel is given in the “PrimitiveTypes Package” on page 171.
10.4 Packages Diagram
The Packages diagram defines the Basic constructs related to Packages and their contents.
10.4.1 Package
Description
A package is a container for types and other packages.Figure 10.5 - The classes defined in the Packages diagramNamedElement
Type Package
*0..1
nestedPackage
*nestin gPa ckage
0..1*0..1ownedType
*package
0..1
102                 UML Infrastructure Specification, v2.4Generalizations
• “NamedElement” on page 93
Attributes
• nestedPackage : Package [*]  
The set of contained packages.
• nestingPackage : Package [0..1]  
The containing package.
• ownedType : Type [*]  
The set of contained types.
• URI: String [0..1] {id}  
Provides an identifier for the packag e that can be used for many purposes. A URI is the universally unique 
identification of the package following the IETF URI speci fication, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and 
it must comply with those syntax rules.
Semantics
Packages provide a way of grouping types and packages togeth er, which can be useful for understanding and managing a 
model. A package cannot contain itself.  The URI can be specified to provid e a unique identifier for a Package.
Notation
Containment of packages and types in packages uses the same notation as for Constructs::Packages  with the omission of 
those aspects of the notation that ca nnot be represented by the Basic model.
10.4.2 Type 
Note – (additional properties - see “Type” on page 94).
Description
A type can be contained in a package.
Generalizations
• “NamedElement” on page 93
Attributes
• package : Package [0..1]  
The containing package. 
Semantics
No additional semantics
UML Infrastructure Specification, v2.4        103Notation
Containment of types in packages uses the same notation as for Constructs::Packages with th e omission of those aspects 
of the notation that cannot be represented by the Basic model.
104                 UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4        10311 Core::Constructs
This clause describes the Constructs pa ckage of InfrastructureLibrary::Core. The Constructs package is intended to be 
reused by the Meta-Object Facility.
Figure 11.1 -The Core package is owned by the InfrastructureLibrary package, and contains several subpackages
The Constructs package is spec ified by a number of diagrams each of which is  described in a separate sub clause below. 
The constructs package is dependent on se veral other packages, notably Basic and various packages from Abstractions, as 
depicted in Figure 11.2.Constructs
ConstructsBasicAbstractionsPrimitiveTypes
«import»
«import»«import»
104                 UML Infrastructure Specification, v2.4Figure 11.2 illustrates the relationships between the Core packag es and how they contribute to the origin and evolution of 
package Constructs. Package Constructs imports model elements from package PrimitiveTypes. Constructs also contains 
metaclasses from Basic and shared metaclasses defined in packages contained in Abstractions. These shared metaclasses 
are included in Constructs by copy. Figure 11.2 uses PackageM erge to illustrate the packages that contribute to the 
definition of Constructs and how. The InfrastructureLibrar y metamodel does not actually in clude these package merges as 
Constructs is a complete metamodel that already in cludes all the metaclasses in the referenced packages . This allows 
Constructs to be understood and used without requiring the use of PackageMerge. Figure 11.2 - The Constructs package depends on several other packages

UML Infrastructure Specification, v2.4        10511.1 Root Diagram
The Root diagram in the Constructs p ackage specifies the Element, Relationshi p, DirectedRelationship, and Comment 
constructs.
Figure 11.3 - The Root diagram of the Constructs package
11.1.1 Comment 
Description
Generalizations
• “Element” on page 106
Attributes
• body: String  
Specifies a string that is the comment.
Associations
• annotatedElement: Element[*]  
Redefines the corresponding property in Abstractions .

106                 UML Infrastructure Specification, v2.4Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
11.1.2 DirectedRelationship 
Description
Constructs::DirectedRelationshi p reuses the definition of DirectedRelationship  from Abstractions::Relationships . It adds a 
specialization to Constructs::Relationship .
Generalizations
• “Relationship” on page 107
AttributesNo additional attributes
Associations
• /source: Element[1..*]  
Redefines the corresponding property in Abstractions . Subsets Relationship::relatedElement . This is a derived  
union.
• /target: Element[1..*]  
Redefines the corresponding property in Abstractions . Subsets Relationship::relatedElement . This is a derived  
union.
Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
11.1.3 Element 
Description
Constructs::Element reuses the definition of Element  from Abstractions::Comments .
UML Infrastructure Specification, v2.4        107Generalizations
• None
Attributes
No additional attributes
Associations
• /ownedComment: Comment[*]  
Redefines the corresponding property in Abstractions . Subsets Element::ownedElement .
• /ownedElement: Element[*]  
Redefines the corresponding property in Abstractions . This is a derived union.
• /owner: Element[0..1]  
Redefines the corresponding property in Abstractions . This is a derived union.
Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
11.1.4 Relationship
Description
Constructs::Relationship reuses the definition of Relationship  from Abstractions::Relationships . It adds a specialization to 
Constructs::Element .
Generalizations
• “Element” on page 106
Attributes
No additional attributes
Associations
• /relatedElement: Element[1..*]  
Redefines the corresponding property in Abstractions . This is a derived union.
Constraints
No additional constraints
108                 UML Infrastructure Specification, v2.4Semantics
No additional semantics
Notation
No additional notation
11.2 Expressions Diagram
The Expressions diagram in the Constructs package specifie s the ValueSpecification, Expression, and OpaqueExpression 
constructs.
Figure 11.4 - The Expressions diagram of the Constructs package
11.2.1 Expression
Description
Constructs::Expression reuses the definition of Expression  from Abstractions::Expressions . It adds a specialization to 
Constructs::ValueSpecification .
Generalizations
• “ValueSpecification” on page 109
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints

UML Infrastructure Specification, v2.4        109Semantics
No additional semantics
Notation
No additional notation
11.2.2 OpaqueExpression
Description
Constructs::OpaqueExpression reuses the definition of OpaqueExpression  from Abstractions::Expressions . It adds a 
specialization to Constructs::ValueSpecification .
Generalizations
• “PackageableElement” on page 148
• “TypedElement” on page 135
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
11.2.3 ValueSpecification
Description
Constructs::ValueSpecificati on reuses the definition of ValueSpecification  from Abstractions::Expressions . It adds a 
specialization to Constructs::TypedElement .
Generalizations
• “Relationship” on page 107
AttributesNo additional attributes
110                 UML Infrastructure Specification, v2.4Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
11.3 Classes Diagram
The Classes diagram of the Constructs package specifies the As sociation, Class, and Property constructs and adds features 
to the Classifier and Operation constructs.
UML Infrastructure Specification, v2.4        111Figure 11.5 - The Classes diagram of the Constructs package
11.3.1 Association
An association describes a set of tuples whose values refer to typed instances. An  instance of an association is called a 
link.A link is a tuple with one value for each end of the associ ation, where each value is an instance of the type of the 
end.
Description
An association specifies a semantic relationship that can occur between typed instances.  It has at least two ends 
represented by properties, each of which is connected to the type of the en d. More than one end of an association may 
have the same type.StructuralFeature
Property
+ isReadOnly : Boolean = false
+ default : String [0..1]+ isComposite : Boolean = false
+ isDerived : Boolean = false
+ isDerivedUnion : Boolean = false
+ isID : Boolean = falseClassifier
Association
+ isDerived : Boolean = false
Class
+ isAbstract : Boolean = falseClassifier
Property
OperationTypeRelationship
0..10..1+ /opposite**+ subsettedProperty*
+ property*+ redefinedProperty
{subsets redefinableElement}{subsets redefinedElement}
0..1+ classifie r
*+ /attribute{subsets featuringClassifier,
subsets redefinitionContext}{readOnly, union, subsetsfeature, subsetsredefinableElement}
0..1+ association
2..*+ memberEnd{subsets memberNamespace} {ordered, subsets member}
0..1+ association
*+ navigableOwnedEnd{subsets owningAssociation} {subsets ownedEnd}0..1+ owningAssociation
*+ ownedEnd{subsets association,
subsets featuringClassifier,
subsets namespace}{ordered, subsets memberEnd, subsetsfeature, subsets ownedMember}
*
+ class*+ superClass
{subsets classifier}{redefines general}0..1+ class
*+ ownedAttribute{subsets classifier, subsets namespace} {ordered, subsets attribute, subsets ownedMember}
0..1+ class
*+ ownedOperation{subsets featuringClassifier,
subsets redefinitionContext,
subsets namespace}{ordered, subsets feature,subsets redefinableElement,subsets ownedMember}*+ association
1..*+ /endType{subsets relationship} {readOnly, subsets relatedElement}
112                 UML Infrastructure Specification, v2.4An end property of an association that is owned by an end class or that is a navigable owned end of the association 
indicates that the association is navigable from the opposite ends, otherwise the association is not navigable from the 
opposite ends.
Generalizations
• “Classifier” on page 130
• “Relationship” on page 107
Attributes
• isDerived : Boolean  
Specifies whether the associatio n is derived from other model elements such as other associations or constraints. The  
default value is false .
Associations
• memberEnd : Property [2..*]  
Each end represents participation of inst ances of the classifier conn ected to the end in links of the association. This is  
an ordered association. Subsets Namespace::member .
• ownedEnd : Property [*]  
The ends that are owned by the association itself. This is an  ordered association. Subsets  Association::memberEnd ,  
Classifier::feature , and Namespace::ownedMember .
• / endType: Type [1..*]  
References the classifiers that are used as types of the ends  of the association.
• navigableOwnedEnd : Property [*]  
The navigable ends that are owned by the as sociation itself. Subsets Association.ownedEnd.
Constraints[1]  An association specializing anot her association has the same number of ends as the other association.
parents()->select(oclIsKindOf(Associ ation)).oclAsType(Association)->  
forAll(p | p.memberEnd->size () = self.memberEnd->size())
[2] When an association specializes another association, every end of the specific association corresponds to an end of the 
general association, and the specifi c end reaches the same type or a subtype of the more general end.
Sequence{1..self.memberEnd->size()}->  
forAll(i | self.general->select(oclIsKind Of(Association)).oclA sType(Association)->  
forAll(ga |self.memberEnd->at(i).type. conformsTo(ga.member End->at(i).type)))
[3] endType is derived from the types of the member ends.
self.endType = self.memberEnd->collect(e | e.type)
[4] Only binary associations can be aggregations
self.memberEnd->exists(isComposite) implies self.memberEnd->size() = 2
[5] Association ends of associatio ns with more than two ends must be owned by the association.
if memberEnd->size() > 2
then  ownedEnd->includesAll(memberEnd)
UML Infrastructure Specification, v2.4        113Semantics
An association declares that there can be  links between instances of the associated types. A link is a tuple with one value 
for each end of the association, where each value is an instance of the type of the end.
When one or more ends of the association have isUnique=false , it is possible to have seve ral links associating the same 
set of instances. In such a case, links carry an  additional identifier apart from their end values.
When one or more ends of the associati on are ordered, links carry ordering information in addition to their end values.
For an association with N ends, choose any N-1 ends and associate specific instances with those ends. Then the collection 
of links of the association that refer to these specific inst ances will identify a collection of instances at the other end. Th e 
multiplicity of the association end constrains  the size of this collection. If the end is marked as ordered, this collection 
will be ordered. If the end is marked as unique, this co llection is a set; otherwise, it allows duplicate elements.
Subsetting  represents the familiar set-theoretic concept. It is app licable to the collections represented by association ends, 
not to the association itself. It means th at the subsetting association end is a coll ection that is either equal to the collect ion 
that it is subsetting or a proper subset of  that collection. (Proper subsetting implies that the superset is not empty and that  
the subset has fewer members.) Subsetting is a rela tionship in the domain of extensional semantics.
Specialization  is in contrast to Subsetting  a relationship in the domain of inte nsional semantics, which is to say it 
characterized the criteria whereby membership in the collecti on is defined, not by the membership. One classifier may 
specialize another by adding or re defining features; a set cannot specialize  another set. A naïve but popular and useful 
view has it that as the classifier becomes more specialized, the extent of the collection(s) of classified objects narrows. In the case of associations, subsetting ends , according to this view, correlates positiv ely with specializing the association.  
This view falls down because it ignores the case of classifiers which, for whatever  reason, denote the empty set. Adding 
new criteria for membership does not narrow the extent if the classifier already has a null denotation.
Redefinition  is a relationship between features of classifiers with in a specialization hierarchy. Redefinition may be used 
to change the definition of a feature, and thereby introduce a specialized classifier in place of the original featuring 
classifier, but this usage is incidental. The difference in domain (that redefinition applies to features ) differentiates 
redefinition from specialization. The combination of constraints [1,2] above with the semantics of property subsetting and redefinition specified in section 
11.3.5 in constraints [3,4,5] imply that any association end that subsets or redefines another association end forces the 
association of the subsetting or redefini ng association end to be a specialization of the association of the subsetted or 
redefined association end respectively.For n-ary associations, the lower multiplicity of an end is typically 0. A lower multiplicity for an end of an n-ary 
association of 1 (or more) implies that one link (or more) must exist for every possible combination of values for the other 
ends.An association may represent a composite aggregation (i.e., a whole/part relations hip). Only binary associations can be 
aggregations. Composite aggregation is a strong form of aggrega tion that requires a part instance be included in at most 
one composite at a time. If a composite is deleted, all of its pa rts are normally deleted with it. Note that a part can (where 
allowed) be removed from a composite befo re the composite is deleted, and thus no t be deleted as part of the composite. 
Compositions may be linked in a directed acyclic graph with  transitive deletion characteri stics; that is, deleting an 
element in one part of the graph will also result in the dele tion of all elements of the subgraph below that element. 
Composition is represented by the isComposite  attribute on the part end of the association being set to true.
114                 UML Infrastructure Specification, v2.4Navigability means instances participating in links at runtime (instances of an association) can be accessed efficiently 
from instances participating in links at the other ends of th e association. The precise mechanism by which such access is 
achieved is implementation specific. If an  end is not navigable, access from the other ends may or may not be possible, 
and if it is, it might not be efficient. Note that tool s operating on UML models are not prevented from navigating 
associations from non-navigable ends.
Semantic Variation Points
The order and way in which part instances in a composite are created is not defined.
The logical relationship between the derivation of an asso ciation and the derivation of its ends is not defined.
Notation
Any association may be drawn as a diamond (larger than a terminator on a line) w ith a solid line for each association end 
connecting the diamond to the classifier that is the end’s type. An association with more than two ends can only be drawn 
this way.
A binary assocation is normally drawn as a solid line connec ting two classifiers, or a solid line connecting a single 
classifier to itself (the two ends are distinct). A line ma y consist of one or more connected segments. The individual 
segments of the line itself have no semantic  significance, but they may be graphically meaningful to a tool in dragging or 
resizing an association symbol.An association symbol may be adorned as follows:
• The association’s name can be shown as a name string near the association symbol, but not near enough to an end to be 
confused with the end’s name. 
• A slash appearing in front of the name of an association, or in place of the name if no name is shown, marks the 
association as being derived.
• A property string may be placed near the association symbol, but far enough from any end to not be confused with a 
property string on an end. A property string  is a comma-delimited list of property  expressions enclosed in curly braces.  
A property expression is, in the simplest case,  a name such as ‘redefines’ or ‘subsets.’
• On a binary association drawn as a solid line, a solid tria ngular arrowhead next to or in place of the name of the 
association and pointing along the line in the direction of one end indicates that end to be the last in the order of the 
ends of the association. The arrow indicat es that the association is to be read  as associating the end away from the 
direction of the arrow with the end to which the arrow is po inting (see Figure 11.6). This notation is for documentation 
purposes only and has no general semantic interpretation. It is used to capture some application-specific detail of the 
relationship between the associated classifiers.
• Generalizations between associations can be shown usin g a generalization arrow betw een the association symbols.
An association end is the connection between the line depic ting an association and the icon (often a box) depicting the 
connected classifier. A name string may be placed near the end of the line to show the name of the association end. The 
name is optional and suppressible.
Various other notations can be placed near the end of the line as follows:
• A multiplicity.
• The BNF for property strings on association ends is:
<property-string> ::= '{' <end-prope rty> [ ',' <end-property> ]* '}'
<end-property> ::=  
UML Infrastructure Specification, v2.4        115( 
'subsets' <property-name> | 'redefines' <end-name> 
)
where <property-name>  and <end-name>  are names of user-provided propertie s and association ends found in the 
model context.
If an association end is navigable, attr ibute-properties defined for attributes ar e legal as end-proper ties in the property 
string for that association end.
Note that by default an association end represents a set.
A stick arrowhead on the end of an association indicates the end is navigable. A small x on the end of an association 
indicates the end is not navigable. A visibility symbol can be added as an adornment on a navigable end to show the end’s 
visibility as an attribute of the featuring classifier.
If the association end is derived, this may be shown by putting a slash in front of the name, or in place of the name if no 
name is shown.The notation for an attribute can be applied to a navigable end name as specified in the Notation sub clause of “Property” 
on page 124.
A composite aggregation is shown using the same notation as a binary association, but with a solid, filled diamond at the 
aggregate end.
Presentation Options
When two lines cross, the crossing may optionally be shown with  a small semicircular jog to indicate that the lines do not 
intersect (as in electr ical circuit diagrams).
Various options may be chosen for showing navigation arrows on  a diagram. In practice, it is  often convenient to suppress 
some of the arrows and crosses and just show exceptional situations:
• Show all arrows and xs. Navigation and its  absence are made completely explicit. 
• Suppress all arrows and xs. No inference can be drawn abou t navigation. This is similar to any situation in which 
information is suppressed from a view.
• Suppress arrows for associations with navigability in both di rections, and show arrows only  for associations with one-
way navigability. In this case, the two-way navigability cannot be distinguished from situations where there is no 
navigation at all; however, the latte r case occurs rarely in practice.
If there are two or more aggregations to the same aggregate, they may be drawn as a tree by merging the aggregation ends 
into a single segment. Any adornments on that singl e segment apply to all of the aggregation ends.
Style Guidelines
Lines may be drawn using various styles, including orthogona l segments, oblique segments, and curved segments. The 
choice of a particular set of line styles is a user choice.
Generalizations between associations are best drawn using a different color or line width than what is used for the 
associations.
116                 UML Infrastructure Specification, v2.4Examples
Figure 11.6 shows a binary association from Player  to Year named PlayedInYear . The solid triangle indicates the order of 
reading: Player PlayedInYear Year . The figure further shows a ternary association between Team , Year, and Player  with 
ends named team , season , and goalie  respectively.
Figure 11.6 - Binary and ternary associations
The following example shows association ends with various adornments.
Figure 11.7 - Association ends with various adornments
The following adornments are shown on the four association ends in Figure 11.7.
• Names a, b, and d on three of the ends.
• Multiplicities 0..1 on a, * on b, 1 on the unnamed end, and 0..1 on d.
• Specification of ordering on b.
• Subsetting on d. For an instance of class C, the collection d is a subset  of the collection b. This is equivalent to the OCL 
constraint:
context C inv: b->includesAll(d)TeamYear
PlayerPlayedInYear
year*
* season
**
goalie teamW
B A
C Db
{ordered}*a
0..1
d
{subsets b}0..1 1
UML Infrastructure Specification, v2.4        117The following examples show notation for navigable ends.
In Figure 11.8:
• The top pair AB shows a binary association with two navigable ends.
• The second pair CD shows a binary association with two non-navigable ends.
• The third pair EF shows a binary association with unspecified navigability.
• The fourth pair GH shows a binary association with one end navigable and the other non-navigable.
• The fifth pair IJ shows a binary association with one end navigable and the other having unspecified navigability.
Figure 11.9 shows that the attribute notation can be used for an association end owned by a class, because an association 
end owned by a class is also an attribut e. This notation may be used in conjunc tion with the line-arrow notation to make 
it perfectly clear that the attribute is also an association end.
Figure 11.10 shows the notation for a derived union. The attribute A::b is derived by being the strict union of all of the 
attributes that subset it. In this case ther e is just one of these, A1::b1. So for an instance of the class A1, b1 is a subset of 
b, and b is derived from b1.Figure 11.8  - Examples of navigable ends
Figure 11.9 - Example of attribute notation for navigable end owned by an end classb
A B
2..5 1..4a
E F
2..5f
1..4eC D
2..5d
1..4c
h
G H
2..5 1..4g
I J
2..5j
1..4ib
A B
2..5 1..4a
E F
2..5f
1..4eC D
2..5d
1..4c
h
G H
2..5 1..4g
I J
2..5j
1..4i
A
b: B[*]
118                 UML Infrastructure Specification, v2.4Figure 11.10 - Example of a derived union
Figure 11.11 shows the black diamond notation for composite aggregation.
11.3.2 Class
A class describes a set of objects that share the same sp ecifications of features, constraints, and semantics. 
Constructs::Class merges the definition of Basic::Class with Constructs::Classifier.
Description
Class is a kind of classifier whose features are attributes a nd operations. Attributes of a cl ass are represented by instances 
of Property  that are owned by the class. Some of these attributes may represent the navigable ends of binary associations.
Generalizations
• “Classifier” on page 130.
Attributes
• isAbstract : Boolean  
This redefines the corresponding attributes in Basic::Class  and Abstractions::Classifier .Figure 11.11 - Composite aggregation is depicted as a black diamondA B
0..*/b {union}
0..1a
A1 B1
0..*b1
0..1a
{subsets b}
Window
Slider
Header Panel+scrollbar
+title +body111
21 1
UML Infrastructure Specification, v2.4        119Associations
• ownedAttribute : Property [*]  
The attributes (i.e., the properties ) owned by the class. This is an ordered association. Subsets Classifier::attribute  
and Namespace::ownedMember .
• ownedOperation : Operation [*]  
The operations owned by the class. This  is an ordered association. Subsets Classifier::feature  and  
Namespace::ownedMember .
• superClass : Class [*]  
This gives the superclasses of a class. It redefines Classifier::general .
Constraints
No additional constraints
Additional Operations
[1]  The inherit operation is overridden to exclude redefined properties.
Class::inherit(inhs: Set(NamedE lement)) : Set(NamedElement);
inherit = inhs->excluding(inh |
ownedMember->select(oclIsKindOf(RedefinableEleme nt))->select(redefinedElement->includes(inh)))
Semantics
The purpose of a class is to specify a classification of objects and to specify the features that characterize the structure 
and behavior of those objects.
Objects of a class must contain values for each attribute th at is a member of that class, in accordance with the 
characteristics of the attribute, for example its type and multiplicity.
When an object is instantiated in a class, for every attribute of  the class that has a specified default, if an initial value o f 
the attribute is not specified explicitly for the instantiation, then the default value specification is evaluated to set the 
initial value of the attribute for the object.Operations of a class can be invoked on an object, given a particular set of substitutions  for the parameters of the 
operation. An operation invocation may cause changes to the values of the attrib utes of that object. It may also return a 
value as a result, where a result type fo r the operation has been defined. Operatio n invocations may also cause changes in 
value to the attributes of other objects that can be naviga ted to, directly or indirectly, from the object on which the 
operation is invoked, to its output paramete rs, to objects navigable from its paramete rs, or to other objects in the scope of 
the operation’s execution. Operation invocations may also cause the creation and deletion of objects.
Notation
A class is shown using the classifier symbol. As class is the most widely used classifier, the word “class” need not be 
shown in guillemets above the name. A classifier symbol without a metaclass shown in guillemets indicates a class.
Presentation Options
A class is often shown with three compartments. The middl e compartment holds a list of attributes while the bottom 
compartment holds a list of operations.
Attributes or operations may be presented grouped by visib ility. A visibility keyword or symbol can then be given once 
for multiple features with the same visibility.
120                 UML Infrastructure Specification, v2.4Additional compartments may be supplied to show other de tails, such as constraints, or to divide features.
Style Guidelines
• Center class name in boldface.
• Capitalize the first letter of class names (if the character set supports uppercase).
• Left justify attributes an d operations in plain face.
• Begin attribute and operation na mes with a lowercase letter.
• Put the class name in italics if the class is abstract.
• Show full attributes and operations when needed and suppress them in other contexts or when merely referring to a 
class.
Examples
Figure 11.12 -Class notation: details suppressed, analysis-level deta ils, implementati on-level detailsWindow
Window
size: Area
visibility: Boolean
display()
hide()Window
+ size: Area = (100, 100)
# visibility: Boolean = true
+ defaultSize: Rectangle
- xWin: XWindow
display()
hide()
- attachX(xWin: XWindow)
UML Infrastructure Specification, v2.4        12111.3.3 Classifier 
Note – (additional properties - see “Classifier” on page 130).
Description
Constructs::Classifier is defined in th e Classifiers diagram. A Classifier is a Type. The Classes diagram adds the 
association between Classifier and Property that represents the attributes  of the classifier.
Generalizations
• “Type” on page 134
• “Namespace” on page 147
Attributes
No additional attributes
Associations
• attribute: Property [*]  
Refers to all of the Properties that ar e direct (i.e., not inherited or imported)  attributes of the classifier. Subsets  
Classifier::feature  and is a derived union.
Constraints
No additional constraints
Semantics
All instances of a classifier have values corresponding to the classifier’s attributes. 
Semantic Variation PointsThe precise lifecycle semantics of aggr egation is a semantic variation point.Figure 11.13 - Class notation: attributes and operations grouped according to visibilityWindow
public
  size: Area = (100, 100)
  defaultSize: Rectangle
protected
  visibility: Boolean = true
private
  xWin: XWindow
public
  display()
  hide()
private
  attachX(xWin: XWindow)
122                 UML Infrastructure Specification, v2.4Notation
An attribute can be shown as a text string. The format of this  string is specified in the Notation sub clause of “Property” 
on page 124.
All redefinitions should be made explic it with the use of a {redefines <x>} property string. Matching features in 
subclasses without an explicit redefiniti on result in a redefinition that need not be shown in the notation. Redefinition 
prevents inheritance of a redefined element into the rede finition context thereby making the name of the redefined 
element available for reuse, either for th e redefining element, or for some other.
Presentation Options
The type, visibility, default, multiplicity, property string may be suppressed from being displayed,  even if there are values 
in the model. 
The individual properties of an attribute can be show n in columns rather than as a continuous string.
The attribute compartment is often suppres sed, especially when a data type does  not contain attributes. The operation 
compartment may be suppressed. A separator line is not  drawn for a missing compartment. If a compartment is 
suppressed, no inference can be drawn about  the presence or absence of elements in it. Compartment names can be used 
to remove ambiguity, if necessary. 
Additional compartments may be supplied to show other predef ined or user-defined model properties (for example, to 
show business rules, responsibilities, vari ations, events handled, exceptions rais ed, and so on). Most compartments are 
simply lists of strings, although more complicated formats ar e also possible. Appearance of each compartment should 
preferably be implicit based on its contents. Compartment names may be used, if needed.
A data-type symbol with a stereotype icon may be “collapsed” to show just the stereotype icon, with the name of the data 
type either inside the rectangle or below the icon.  Other contents of the data type are suppressed. 
Style Guidelines
• Center the name of the data type in boldface.
• Center keyword (including stereotype names) in plain face within guillemet s above data-type name.
• For those languages that distinguish between uppercase and lowercase characters, capitali ze names (i.e., begin them 
with an uppercase character). 
• Left justify attributes an d operations in plain face.
• Begin attribute and operation na mes with a lowercase letter.
• Show full attributes and operations when needed and suppress them in other contexts or references.
Attribute names typically begin with a lowercase letter. Mu ltiword names are often formed by concatenating the words 
and using lowercase for all letters, except for upca sing the first letter of each word but the first.
UML Infrastructure Specification, v2.4        123Examples
The attributes in Figure 11.14  are explained below.
• ClassA::name is an attribute with type String.
• ClassA::shape is an attribute with type Rectangle.
• ClassA::size is a public attribute with type Integer with multiplicity 0..1.
• ClassA::area is a derived attribute with ty pe Integer. It is marked as read-only.
• ClassA::height is an attribute of type Integer with a default initial value of 5.
• ClassA::width is an attribute of type Integer.
• ClassB::id is an attribute that redefines ClassA::name.
• ClassB::shape is an attribute that redefines ClassA::sha pe. It has type Square, a specialization of Rectangle.
• ClassB::height is an attribute that rede fines ClassA::height. It has a default of 7 for ClassB instances which overrides 
the ClassA default of 5.
• ClassB::width is a derived attribute that redefines ClassA::width, which is not derived.Figure 11.14 - Examples of attributesClassB
id {redefines name}
shape: Square
height = 7
/ widthClassA
name: String
shape: Rectangle
+ size: Integer [0..1]
/ area: Integer {readOnly}
height: Integer= 5
width: Integer
124                 UML Infrastructure Specification, v2.4An attribute may also be shown using asso ciation notation, with no adornments at the tail of the arrow as shown in Figure 
11.15.
11.3.4 Operation 
Note – (additional properties - see “Operation” on page 152).
Description
Constructs::Operation is defined in the Operations diagram. The Classes diagram adds the association between Operation 
and Class  that represents the owners hip of the operation by a class.
Generalizations
• “BehavioralFeature” on page 151
Attributes
No additional attributes
Associations
• class : Class [0..1]  
Redefines the corresponding a ssociation in Basic. Subsets RedefinableElement::redefinitionContext,  
NamedElement::namespace and Feature::featuringClassifier .
Constraints
No additional constraints
Semantics
An operation may be owned by and in the namespace of a clas s that provides the context for its possible redefinition.
11.3.5 Property
A property is a structural feature of a classifier that charac terizes instances of the classifi er. Constructs::Property merges 
the definition of Basic::Property with Constructs::StructuralFeature .
A property related by ownedAttribute to a cl assifier (other than an association) represents an attribute and might also 
represent an association end.  It relates an instance of the cl ass to a value or set of values  of the type of the attribute.
A property related by memberEnd or its specia lizations to an association represents an end of the association. The type of 
the property is the type of the end of the association.Figure 11.15 - Association-like notation for attributeWindow Areasize
1
UML Infrastructure Specification, v2.4        125Description
Property represents a declared state of one  or more instances in terms of a named relationship to a value or values. When 
a property is an attribute of a classifier, the value or values are related to the instance of the classifier by being held in 
slots of the instance. When a property is an association end, the value or values are related to the instance or instances at 
the other end(s) of the associati on (see semantics of Association).
Property is indirectly a subclass of Constructs::TypedElement . The range of valid values represented by the property can 
be controlled by setting the property’s type.
Generalizations
• “StructuralFeature” on page 133
Attributes
• isDerivedUnion : Boolean  
Specifies whether the prop erty is derived as the union of all of the prop erties that are constrained to subset it. The  
default value is false .
• isReadOnly : Boolean  
This redefines the corresponding attribute in Basic::Property  and Abstractions::StructuralFeature . The default value  
is false .
• isID : Boolean  
True indicates this property can be used to uniquely identify  an instance of the containi ng Class. Default value is false
Associations
• association: Association [0..1]  
References the association of which this property is a member, if any.
• owningAssociation: Association [0..1]  
References the owning association of  this property, if any. Subsets  Property::association,  
NamedElement::namespace , and Feature::featuringClassifier .
• redefinedProperty : Property [*]  
References the properties that are redefined by this property. Subsets RedefinableElement::redefinedElement .
• subsettedProperty : Property [*]  
References the properties of which this property is constrained to be a subset.
• / opposite : Property [0..1]  
In the case where the prop erty is one navigable end of a binary association with both ends navigable, this gives the  
other end.
• class : Class [0..1]  
References the Class that owns the Property. Subsets NamedElement::namespace , Feature::featuringClassifier
Constraints[1]  If this property is owned by a class, associated with a binary association, and the other end of the association is also o wned 
by a class, then opposite gives the other end.
opposite = 
if owningAssociation->isEmpty() and association.memberEnd->size() = 2 then  
let otherEnd = (association.memberEnd - self)->any() in 
126                 UML Infrastructure Specification, v2.4if otherEnd.owningAssociation->isEmpty() then  otherEnd else Set{} endif
else Set {}
endif
[2] A multiplicity of a composite aggregation must not have an upper bound greater than 1.
isComposite implies  (upperBound()->isEmpty() or upperBound() <= 1)
[3] Subsetting may only occur when the context of the subsetting property conforms to the cont ext of the subsetted property.
subsettedProperty->notEmpty() implies
(subsettingContext()->not Empty() and subs ettingContext()->forAll (sc |
subsettedProperty->forAll(sp | 
sp.subsettingContext()->exists(c | sc.conformsTo(c)))))
[4] A redefined property must be inherited from a more general classifier containing the redefining property.
if (redefinedProperty->notEmpty()) then  
   (redefinitionContext->notEmpty() and 
        redefinedProperty->forAll(rp| 
      ((redefiniti onContext->collect(fc| 
         fc.allParents()))->asSet())-> 
            collect(c| c.allFeatures())->asSet()-> 
               includes(rp))
[5] A subsetting property may strengthen the type of th e subsetted property, and its upper bound may be less.
subsettedProperty->forAll(sp |
type.conformsTo(sp.type) and
((upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies
upperBound()<=sp.upperBound() ))
[6] A derived union is derived.
isDerivedUnion implies  isDerived
[7] A derived union is read only
isDerivedUnion implies  isReadOnly
[8] The value of isComposite is true  only if aggregation is composite.
isComposite = (self.aggregation = #composite)
[9] A Property cannot be subset by a Property with the same name
if (self.subsettedProperty->notEmpty()) then  
      self.subsettedProperty->f orAll(sp | sp.name <> self.name)
Additional Operations
[1]  The query isConsistentWith() specifies , for any two Properties in a context in which redefinition is possible, whether 
redefinition would be logically consistent. A redefining property  is consistent with a redefined property if the type of the 
redefining property conforms to the type of the redefined pr operty, and the multiplicity of the redefining property (if 
specified) is contained in the multi plicity of the redefined property. 
Property::isConsistentWith (redefinee : RedefinableElement) : Boolean
pre: redefinee.isRedefinitionContextValid(self)  
isConsistentWith = redefi nee.oclIsKindOf(Property) and  
let prop : Property = redefinee.oclAsType(Property) in  
(prop.type.conformsTo(self.type) and  
((prop.lowerBound()->notEmpty() and self.lowerBound()->notEmpty()) implies   
prop.lowerBound() >= self.lowerBound()) and  
((prop.upperBound()->notEmpty() and self.upperBound()->notEmpty()) implies   
UML Infrastructure Specification, v2.4        127prop.lowerBound() <= self.lowerBound()) and  
and (self.isComposite implies  prop.isComposite))
[2] The query subsettingContext() gives the context for subsetting a property. It consists, in the case of an attribute, of the 
corresponding classifier, and in the case of an associa tion end, all of the classifiers at the other ends.
Property::subsettingContext() : Set(Type)
subsettingContext = 
if association->notEmpty()
then  association.endType-type 
else if classifier->notEmpty() then  Set{classifier} else Set{} endif
endif
[3] The query isNavigable indicates whether it is possible to navigate across the property.
Property::isNavigable() : Boolean
IsNavigable = not classifier->isEmpty() or
association.owningAssociation.nav igableOwnedEnd->includes(self)
[4] The query isAttribute() is true if the Propert y is defined as an attr ibute of some classifier
context  Property::isAttribute(p : Property) : Boolean  
post: result = Classifier.allInstances ->exists(c| c.attribute->includes(p))
Semantics
When a property is owned by a classifier other than an association via ownedAttribute, then it represents an attribute  of 
the class or data type. When related to an association via me mberEnd or one of its specializa tions, it represents an end of 
the association. In either case, when instantiated a property re presents a value or collection of values associated with an 
instance of one (or in the case of a ternary or higher-order asso ciation, more than one) type. This set of types is called the 
context for the property; in the case of an attribute the context is the owning classifier, and in the case of an association 
end the context is the set of types at th e other end or ends of the association.
The value or collection of values instantiated for a property in an instance of its context conforms to the property’s type. 
Property inherits from MultiplicityElement  and thus allows multiplicity bounds to be specified. These bounds constrain 
the size of the collection. Typically and by default the maximum bound is 1.
Property also inherits the isUnique  and isOrdered  meta-attributes. When isUnique  is true (the default) the collection of 
values may not contain duplicates. When isOrdered  is true (false  being the default) the collectio n of values is ordered. In 
combination these two allow the type of a propert y to represent a collection in the following way:
If there is a default specified for a property, this default is ev aluated when an instance of the property is created in the 
absence of a specific setting for the prope rty or a constraint in the model that requires the property to have a specific 
value. The evaluated default then becomes the initial value (or values) of the property.Table 11.1 - Collection types for properties
isOrdered isUnique Collection type
false true Set
true true OrderedSetfalse false Bagtrue false Sequence
128                 UML Infrastructure Specification, v2.4If a property is derived, then its value or values can be computed from other information. Actions involving a derived 
property behave the same as for a nonderived property. Derived properties are often specified to  be read-only (i.e., clients 
cannot directly change values). But wh ere a derived property is changeable, an  implementation is expected to make 
appropriate changes to the model in order for all the constraint s to be met, in particular the derivation constraint for the 
derived property. The derivation for a derived property may be specified by a constraint.
The name and visibility of a property are not require d to match those of any property it redefines. 
A derived property can redefine one that is not derived. An  implementation must ensure that the constraints implied by 
the derivation are maintained if the property is updated.
If a property has a specified default, and the property redefi nes another property with a specified default, then the 
redefining property’s default is used in place of th e more general default from the redefined property.
If a navigable property is marked as readOnly, then it cannot  be updated once it has been assigned an initial value.
A property may be marked as a subset of another, as long as every element in the context of the subsetting property 
conforms to the corresponding element in the context of the subs etted property. In this case, the collection associated with 
an instance of the subsetting property must be included in (or the same as) the collection associated with the 
corresponding instance of the subsetted property.
A property may be marked as being a derived union. This m eans that the collection of values denoted by the property in 
some context is derived by being the strict union of all of the values denoted, in the same context, by properties defined 
to subset it. If the property has a multiplicity upper bound of 1, then  this means that the values of all the subsets must be 
null or the same.A property may be marked as being (part of) the identifier (if any) for classes of which it is a member. The interpretation 
of this is left open but this could be mapped to implementati ons such as primary keys for re lational database tables or ID 
attributes in XML. If multiple properties are marked (possibly in  superclasses) then it is the combination of the (property, 
value) tuples that will logically provide the uniqueness for a ny instance. Hence there is no need for any specification of 
order and it is possible for some (but not all) of the property values to be empty. If the property is multivalued then all 
values are included.
Notation
The following general notation for properties is defined. Note  that some specializations of Property may also have 
additional notational forms. These are covered in th e appropriate Notation sub clauses of those classes.
<property> ::= [<visibility>] [‘/’] <name> [‘:’ <prop-type>] [‘[‘ <m ultiplicity> ‘]’] [‘=’ <default>] 
                          [‘{‘ <prop-modifier > [‘,’ <prop-modifier >]* ’}’]
where:
• <visibility>  is the visibility of the property  (See “VisibilityKind” on page 90).
<visibility> ::= ‘+’ | ‘-‘
• ‘/’ signifies that the property is derived. 
• <name>  is the name of the property.
• <prop-type>  is the name of the Classifier th at is the type of the property.
• <multiplicity>  is the multiplicity of the property. If this term is omitted, it implies a multiplicity of 1 (exactly one). (See 
UML Infrastructure Specification, v2.4        129“MultiplicityElement” on page 132.) 
• <default>  is an expression that evaluates to th e default value or values of the property.
• <prop-modifier >  indicates a modifier that  applies to the property.
<prop-modifier> ::= ‘readOnly’ | ‘union’ | ‘subsets‘ <property-name> |  
‘redefines’ <property-name> | ‘ordered’ | ‘unique’ | ‘id’ | <prop-constraint>
where:
• readOnly  means that the prop erty is read only.
• union  means that the property is a derived union of its subsets.
• subsets <property-name>  means that the property is a proper subset of the property identified by <property-
name> .
• redefines <property-name>  means that the property  redefines an inherited property identified by <property-
name> .
• ordered  means that the property is ordered.
• unique  means that there are no duplicat es in a multi-valued property.
• id means that the property is part of the identifier for the class. 
• <prop-constraint>  is an expression that specifies a co nstraint that applies to the property. 
All redefinitions shall be made explicit with the use of a {redefines <x>} property string. Redefinition prevents 
inheritance of a redefined element into the redefinition context thereby making the name of the redefined element 
available for reuse, either for the redefining element, or for some other.
11.4 Classifiers Diagram
The Classifiers diagram of the Constructs package specifies  the concepts Classifier, Ty pedElement, MultiplicityElement, 
RedefinableElement, Feature, and Structur alFeature. In each case these concepts are extended and redefined from their 
corresponding definitions in Basic and Abstractions.
130                 UML Infrastructure Specification, v2.4Figure 11.16 - The Classifiers diagram of the Constructs package
11.4.1 Classifier
Description
Constructs::Classifier merges the definitions of Classifier from Basic  and Abstractions . It adds specializations from 
Constructs::Namespace  and Constructs::Type and the capability to specify that a classifier cannot be specialized by 
generalization.
Generalizations
• “Type” on page 134
• “Namespace” on page 147
Attributes
• isFinalSpecialization: Boolean  
if true, the Classifier cannot be specialized  by generalization. Note that this property is preserved through package 
merge operations; that is, the cap ability to specialize a Classifier  (i.e., isFinalSpecialization = false ) must be preserved 
in the resulting Classifier of a package merge operation where a Classi fier with isFinalSpecialization = false  is merged 
with a matching Classifier wi th isFinalSpecialization = true: the resulting Classifier will have isFinalSpecialization 
=false . Default is false . 

UML Infrastructure Specification, v2.4        131Associations
• /feature : Feature [*]  
Redefines the corresponding association in Abstractions . Subsets Namespace::member and is a derived union.  
Note that there may be members of the Classifier that  are of the type Feature but are not included in this  
association (e.g., inherited features).
Constraints
[1] The parents of a classifier must be non-final.
self.parents()->forAll(not  isFinalSpecialization)
Semantics
No additional semantics
Notation
As defined in Abstractions
11.4.2 Feature
Description
Constructs::Feature reuses th e definition of Feature from Abstractions . It adds a specialization from 
Constructs::RedefinableElement .
Generalizations
• “RedefinableElement” on page 132
Attributes
No additional attributes
Associations
• /featuringClassifier : Classifier [1..*]  
Redefines the corresponding association in Abstractions . This is a derived union.
Constraints
No additional constraints
Semantics
No additional semantics
Notation
As defined in Abstractions
132                 UML Infrastructure Specification, v2.411.4.3 MultiplicityElement
Description
Constructs::MultiplicityElement reuses th e definition of MultiplicityElement from Abstractions . It adds a specialization 
from Constructs::Element.
Generalizations
• “Element” on page 106
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics
Notation
As defined in Abstractions
11.4.4 RedefinableElement
Description
Constructs::RedefinableElement reuses the definition of RedefineableElement  from Abstractions . It adds a specialization 
from Constructs::NamedElement and the capability for indicating whether it is possible to further redefine a 
RedefinableElement.
Generalizations
• “NamedElement” on page 146
Attributes
• isLeaf: Boolean  
Indicates whether it is possible to further re define a RedefinableElement. If the value is true, then it is not possible to 
further redefine the RedefinableElement. Note that this property is preserved through package merg e operations; that 
is, the capability to redefine a RedefinableElement (i.e., isLeaf= false ) must be preserved in the resulting 
RedefinableElement of a package merge operat ion where a RedefinableElement with isLeaf= false  is merged with a 
matching RedefinableElement with isLeaf= true: the resulting RedefinableElement will have isLeaf= false . Default 
value is false . 
UML Infrastructure Specification, v2.4        133Associations
• /redefinedElement: RedefinableElement[*]  
This derived union is redefined from Abstractions .
• /redefinitionContext: Classifier[*]  
This derived union is redefined from Abstractions .
Constraints
[1]  At least one of the redefinition contexts of the redefining element must be a specialization of at least one of the redefi nition 
contexts for each redefined element.
self.redefinedElement->forAll(e | se lf.isRedefinitionContextValid(e))
[2] A redefining element mu st be consistent with  each redefined element.
[3]self.redefinedElement->forAll(re  | re.isConsistentWith(self)) A redefinable element can only redefine non-leaf redefinable 
elements
self.redefinedElemen t->forAll(not isLeaf)
Additional Operations
[1]  The query isConsistentWith() specifies, for any two Redefi nableElements in a context in which redefinition is possible, 
whether redefinition would be logically consistent. By defaul t, this is false; this operation must be overridden for 
subclasses of RedefinableElement to  define the consistency conditions.
RedefinableElement::isConsistentWith(redefinee: RedefinableElement): Boolean;
pre: redefinee.isRedefinitionContextValid(self)
result = false
[2] The query isRedefinitionContextValid() specifies whether the redefinition contexts of this RedefinableElement are 
properly related to the redefinition contexts of the specified RedefinableElement to allow this element to redefine the 
other. By default at least one of the redefinition contexts of this element must be a speciali zation of at least one of the 
redefinition contexts of  the specified element.
RedefinableElement::isRedefinitionContextVal id(redefined: RedefinableElement): Boolean;
result = self.redef initionContext->exists(c | c.allParents ()->includes(redefined.redefinitionContext))
Semantics
No additional semantics
Notation
As defined in Abstractions
11.4.5 StructuralFeature
Description
Constructs::StructuralFeature  reuses the definition of StructuralFeature  from Abstractions . It adds specializations from 
Constructs::Feature , Constructs::TypedElement , and Constructs::MultiplicityElement .
By specializing MultiplicityElement , it supports a multiplicity that specifies va lid cardinalities for the set of values 
associated with an instantiation of the structural feature.
134                 UML Infrastructure Specification, v2.4Generalizations
• “Feature” on page 131
• “TypedElement” on page 135
• “MultiplicityElement” on page 132
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics
Notation
As defined in Abstractions
11.4.6 Type
Description
Constructs::Type merges the definitions of Type  from Basic  and Abstractions . It adds a specialization from 
Constructs::NamedElement .
Generalizations
• “NamedElement” on page 146
• “PackageableElement” on page 148
AttributesNo additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics
UML Infrastructure Specification, v2.4        135Notation
As defined in Abstractions
11.4.7 TypedElement
DescriptionConstructs::TypedElement merges the definitions of TypedElement  from Basic  and Abstractions . It adds a specialization 
from Constructs::NamedElement .
Generalizations
• “NamedElement” on page 146
Attributes
• type: Classifier [1]  
Redefines the corresponding attributes in both Basic  and Abstractions .
Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics
Notation
As defined in Abstractions
11.5 Constraints Diagram
The Constraints diagram of the Constructs  package specifies the Constraint construct and adds features to the Namespace 
construct.
 

136                 UML Infrastructure Specification, v2.4Figure 11.17 - The Constraints diagram of the Constructs package 
11.5.1 Constraint
Description
Constructs::Constraint reuses the definition of Constraint  from Abstractions::Constraints . It adds a specialization to 
PackageableElement .
Generalizations
• “PackageableElement” on page 148
Attributes
No additional attributes
Associations
• constrainedElement: Element  
Redefines the corresponding property in Abstractions .
• context: Namespace [0..1]  
Specifies the Namespace that is the contex t for evaluating this constraint. Subsets NamedElement::namespace .
• specification: ValueSpecification  
Redefines the corresponding property in Abstractions . Subsets Element.ownedElement .
Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
11.5.2 Namespace 
Note – (additional properties - see “Namespace” on page 147).
Description
Constructs::Namespace is defined in the Namespaces  diagram. The Constraints diagram shows the association between 
Namespace and Constraint  that represents the ownership of the constraint by a namespace.
Generalizations
• “NamedElement” on page 146
UML Infrastructure Specification, v2.4        137Attributes
No additional attributes
Associations
• ownedRule : Constraint [*]  
Redefines the corresponding property in Abstractions . Subsets Namespace::ownedMember .
Constraints
No additional constraints
Semantics
No additional semantics
11.6 DataTypes Diagram
The DataTypes diagram of the Constructs package specif ies the DataType, Enumeration, EnumerationLiteral, and 
PrimitiveType constructs, and adds features to the Property and Operation constructs. These constructs are used for 
defining primitive data types (such as Inte ger and String) and user-defined enumer ation data types. The data types are 
typically used for declaring the types of the class attributes.
Figure 11.18 - The classes defined in the DataTypes diagramPrimitiveType EnumerationLiteral Enumeration
* 0..1ownedLiteral
*
{subsets ownedMember,
ordered}enumeration
0..1
{subsets namespace}Classifier
Property
OperationDataType
* 0..1ownedAttribute
*{ordered
subsets attribute,
subsets ownedMember}datatype
0..1 {subsets namespace,
subsets featuringClassifier,
subsets classifier}
* 0..1ownedOperation
*{ordered
subsets feature,
subsets ownedMember}datatype
0..1
{subsets redefinitionContext,
subsets namespace,
subsets featuringClassifier}
NamedElement
138                 UML Infrastructure Specification, v2.411.6.1 DataType 
Description
A data type is a type whose instances ar e identified only by their value. A DataType may contain attributes to support the 
modeling of structured data types.  
A typical use of data types would be to represent progr amming language primitive types or CORBA basic types. For 
example, integer and string types are often treated as data types.
Generalizations
• “Classifier” on page 130
Attributes
No additional attributes
Associations
• ownedAttribute:  Property[*]  
The Attributes owned by the DataType. Th is is an ordered collection. Subsets Classifier::attribute and  
Namespace::ownedMember .
• ownedOperation:  Operation[*]  
The Operations owned by the DataType. Th is is an ordered collection. Subsets Classifier::feature and  
Namespace::ownedMember .
Constraints
No additional constraints
Additional Operations
[1]  The inherit  operation is overriden to exclude redefined properties
DataType::inherit(inhs: Set(Nam edElement)): Set(NamedElement);
inherit=inhs-> excluding (inh | ownedMember->
select (oclIsKindOf (RedefinableElement))-> select (redefinedElement-> includes (inh)))
Semantics
A data type is a special kind of classifier, similar to a class.  It differs from a class in that instances of a data type are 
identified only by their value.
All copies of an instance of a data type and any instances of that data type with the same va lue are considered to be equal 
instances. Instances of a data type that ha ve attributes (i.e., is a structured data  type) are considered to be equal if the 
structure is the same and the values of the corresponding attribut es are equal. If a data type has attributes, then instances 
of that data type will contain attr ibute values matching the attributes.
Semantic Variation Points
Any restrictions on the capabilities of data types, such as constraining the types of their attributes, is a semantic variation  
point.
UML Infrastructure Specification, v2.4        139Notation
A data type is shown using the classifier symbol with keywor d «dataType» or when it is referenced by e.g., an attribute, 
shown as a string containing the name of the data type.
Examples
Figure 11.19 - Notation of data type: to the left is an icon denoting a  
data type and to the right is a reference to a data type that is used in an attribute.
11.6.2 Enumeration
An enumeration is a data type whose values are enumerated in the model as enumeration literals.
Description
Constructs::Enumeration reuses the definition of Enum eration from Basic. It adds a specialization to 
Constructs::DataType.
Enumeration is a kind of data type, whose instances may be any of a number of predefined enumeration literals. 
It is possible to extend the set of applicable enumeration literals in other packages or profiles.
Generalizations
• “DataType” on page 138.
Attributes
No additional attributes
Associations
• ownedLiteral: Enum erationLiteral[*]  
The ordered set of literals for this Enumeration. Subsets Namespace::ownedMember .
Constraints
No additional constraints
Semantics
The run-time instances of an Enumeration are data va lues. Each such value corresponds to exactly one 
EnumerationLiteral.«dataType»
Integersize: Integer
140                 UML Infrastructure Specification, v2.4Notation
An enumeration may be shown using the classifier notation (a  rectangle) with the keyword «enumeration». The name of 
the enumeration is placed in the upper compartment. A compar tment listing the attributes for the enumeration is placed 
below the name compartment. A compartment listing the operati ons for the enumeration is placed below the attribute 
compartment. A list of enumeration literals may be placed, one  to a line, in the bottom compartment. The attributes and 
operations compartments may be suppr essed, and typically are suppre ssed if they would be empty.
Examples
11.6.3 EnumerationLiteral
An enumeration literal is a user-defin ed data value for an enumeration.
Description
Constructs::EnumerationLiteral reuses the definition of Enumeration from Basic. It adds a specialization to 
Constructs::NamedElement.
Generalizations
• “NamedElement” on page 146
Attributes
No additional attributes
Associations
• enumeration: Enumeration[0..1]  
The Enumeration that this Enumera tionLiteral is a member of. Subsets NamedElement::namespace .
Constraints
No additional constraints
Semantics
An EnumerationLiteral defines an element of the run-time extension of an enumeration data type.
An EnumerationLiteral has a name that ca n be used to identify it within its enum eration datatype. The enumeration literal 
name is scoped within and must be unique  within its enumeration. Enumeration literal names are not global and must be 
qualified for general use.Figure 11.20 - Example of an enumeration

UML Infrastructure Specification, v2.4        141The run-time values corresponding to enumera tion literals can be compared for equality.
Notation
An EnumerationLiteral is typically shown as a name, one to a line, in the comp artment of the enumeration notation (see 
“Enumeration”).
Examples
See “Enumeration”
11.6.4 Operation 
Note – (additional properties - see “Operation” on page 152)
Description
Constructs::Operation is defined in the Operations  diagram. The DataTypes diagram shows the association between 
Operation and DataType  that represents the ownership of the operation by a data type.
Generalizations
• “BehavioralFeature” on page 151
Attributes
No additional attributes
Associations
• datatype : DataType [0..1]  
The DataType that owns this Operation. Subsets NamedElement::namespace , Feature::featuringClassifier , and  
RedefinableElement::redefinitionContext .
Constraints
No additional constraints
Semantics
An operation may be owned by and in the na mespace of a datatype that provides th e context for its possible redefinition.
11.6.5 PrimitiveType
A primitive type defines a predefined data t ype, without any relevant substructure (i .e., it has no parts in the context of 
UML). A primitive datatype may have an algebra and operations  defined outside of UML, for example, mathematically.
Description
Constructs::PrimitiveType reuses the definition of PrimitiveType  from Basic . It adds a specialization to 
Constructs::DataType .
142                 UML Infrastructure Specification, v2.4The instances of primitive type used in UM L itself include Boolean, Integer, Unlimite dNatural, and String (see Clause 12, 
“Core::PrimitiveTypes”).
Generalizations
• “DataType” on page 138
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
The run-time instances of a primitive type are data values. The values are in many-to-one correspondence to mathematical 
elements defined outside of UML (fo r example, the various integers).
Instances of primitive types do not have identity. If two inst ances have the same representation, then they are 
indistinguishable.
Notation
A primitive type has the keyword «primitive» above or before the name of the primitive type.
Instances of the predefined primitive types (see Clause 12,  “Core::PrimitiveTypes”) may be denoted with the same 
notation as provided for references to such instan ces (see the subtypes of “ValueSpecification”).
ExamplesSee Clause 12, “Core::PrimitiveTypes” for examples
11.6.6 Property 
Note – (additional properties - see “Property” on page 124)
Description
Constructs::Property is defined in the Classes  diagram. The DataTypes diagram show s the association between Property 
and DataType  that represents the ownership of the property by a data type.
Generalizations
• “StructuralFeature” on page 133
Attributes
No additional attributes
UML Infrastructure Specification, v2.4        143Associations
• datatype : DataType [0..1]  
The DataType that owns this Property. Subsets NamedElement::namespace , Feature::featuringClassifier , and  
Property::classifier .
Constraints
No additional constraints
Semantics
A property may be owned by and in the namespace of a datatype.
11.7 Namespaces Diagram
The Namespaces diagram of the Constructs package specifie s Namespace and related constructs. It specifies how named 
elements are defined as members of namespaces, and also spec ifies the general capability for any namespace to import all 
or individual members of packages.
Figure 11.21 - The Namespaces diagram of the Constructs packageElement
NamedElement
+ name : String [0..1]
+ visibility : VisibilityKind [0..1]+ /qualifiedName : String [0..1] {readOnly}
Namespace NamedElement PackageableElement
PackageableElementElementImport
+ visibility : VisibilityKind = public+ alias : String [0..1]DirectedRelationshipDirectedRelationship
PackageImport
+ visibility : VisibilityKind = public«enumeration»
VisibilityKin d
publicprivateprotectedpackage
Package
+ URI : String [0..1]*+ namespace *
+ /importedMember{subsets memberNamespace}
{readOnly, subsets member}0..1+ /namespace
*+ /ownedMember{readOnly, union, subsetsowner, subsetsmemberNamespace}{readOnly, union, subsetsownedElement, subsetsmember}
*
+ memberNamespace*
+ /member
{readOnly, union}
1+ importingNamespace
*+ elementImport{subsets source,subsets owner}{subsetsdirectedRelationship,subsets ownedElement}
* + elementImport
1
+ importedElement{subsets directedRelationship}
{subsets target}1+ importingNamespace *
+ packageImport{subsets source,subsets owner}
{subsets directedRelationship,subsets ownedElement}
* + packageImport
1
+ importedPackage{subsetsdirectedRelationship}
{subsets target}
144                 UML Infrastructure Specification, v2.411.7.1 ElementImport
An element import identifies an element in another package, and allows the element to be referenced using its name 
without a qualifier.
Description
An element import is defined as a directed relationship between an importing namespace and a packageable element. The 
name of the packageable element or its alias is to be adde d to the namespace of the importing namespace. It is also 
possible to control whether the imported element can be further imported.
Generalizations
• “DirectedRelationship” on page 106
Attributes
• visibility: VisibilityKind  
Specifies the visibi lity of the imported P ackageableElement within the importing Package. The default visibility is  
the same as that of the imported elemen t. If the imported element does not ha ve a visibility, it is possible to add  
visibility to the element import; default value is public .
• alias: String [0..1]  
Specifies the name that shou ld be added to the namespace of the import ing Package in lieu of the name of the  
imported PackagableElement. The aliase d name must not clash with any other member name in the importing  
Package. By default, no alias is used.
Associations 
• importedElement: P ackageableElement [1]  
Specifies the PackageableElemen t whose name is to be added to a Namespace. Subsets DirectedRelationship::target .
• importingNamespace: Namespace [1]  
Specifies the Namespace that im ports a PackageableElement from  another Package. Subsets  
DirectedRelationship::source  and Element::owner .
Constraints
[1]  The visibility of an ElementImp ort is either public or private.
self.visibility = #public or self.visibility = #private
[2] An importedElement has either public visibility or no visibility at all.
self.importedElement.v isibility.notEmpty() implies  self.importedElement.visibility = #public
Additional Operations
[1]  The query getName() returns the name under which the imported PackageableElement will be known in the importing 
namespace.
ElementImport::get Name(): String;
getName = 
if self.alias->notEmpty() then  
self.alias
else
self.importedElement.name
endif
UML Infrastructure Specification, v2.4        145Semantics
An element import adds the name of a packageable elemen t from a package to the importing namespace. It works by 
reference, which means that it is not possible to add features to the element import itself, but it is possible to modify the 
referenced element in the namespace from which it was impor ted. An element import is used to selectively import 
individual elements without relying on a package import.
In case of a nameclash with an outer name (an element that is defined in an enclosing na mespace is available using its 
unqualified name in enclosed namespaces) in the importing na mespace, the outer name is hidden by an element import, 
and the unqualified name refers to the imported element. Th e outer name can be accessed  using its qualified name.
If more than one element with the same name would be impor ted to a namespace as a consequence of element imports or 
package imports, the elements are not added to the importi ng namespace and the names of  those elements must be 
qualified in order to be used in that namespace. If the name of  an imported element is the same as the name of an element 
owned by the importing namespace, that element is not added to the importing namespace and the name of that element 
must be qualified in order to be used. If the name of an im ported element is the same as the name of an element owned 
by the importing namespace, the name of the imported element mu st be qualified in order to be used and is not added to 
the importing namespace.
An imported element can be further imported by other na mespaces using either element or package imports.
The visibility of the ElementImport may be either the same or more restricted than that of the imported element. 
Notation
An element import is shown using a dashed arrow with an  open arrowhead from the importing namespace to the imported 
element. The keyword «import» is shown near the dashed arro w if the visibility is public, otherwise the keyword «access» 
is shown to indicate private visibility.
If an element import has an alias, this is used in lieu of the name of the imported elemen t. The aliased name may be 
shown after or below the keyword «import».
Presentation Options
If the imported element is a package, the keyword may opti onally be preceded by element (i.e., «element import»).
As an alternative to the dashed arrow, it is possible to show an element import by  having a text that uniquely identifies 
the imported element within curly brackets either below or af ter the name of the namespace. The textual syntax is then:
‘{element import ‘ <qualif iedName> ‘} | ‘{element access ‘ <qualifiedName> ‘}’
Optionally, the aliased name may be shown as well:
‘{element import ‘ <qualifie dName> ‘as’ <alias> ‘}  | ‘{element acces s ‘  <qualifiedName> ‘as’ <alias> ‘}’
ExamplesThe element import that is shown in Figure 11.22 allows elemen ts in the package Program to refer to the type Time in 
Types without qualification. However, they still need to refe r explicitly to Types::Integer, since this element is not 
imported. Type String can be used in the Program package but cannot be further imported from Program to other 
packages.
146                 UML Infrastructure Specification, v2.4In Figure 11.23, the element import is combined with aliasing,  meaning that the type Types::Real will be referred to as 
Double in the package Shapes.
11.7.2 NamedElement
Description
Constructs::NamedElement reuses the definition of NamedElement  from Abstractions::Visibilitites . It adds specializations 
from Constructs::Element and Basic::NamedElement .
Generalizations
• “Element” on page 106
Attributes
• name: String [0..1]  
The name of the NamedElement.Figure 11.22 - Example of element import
Figure 11.23 - Example of element import with aliasing«datatype»
Integer
ProgramTypes
«datatype»
String
«datatype»
Time«import»«access»
Types
Shapes
«datatype»
Real Circle
radius: Double«import»
Double
UML Infrastructure Specification, v2.4        147Associations
• namespace: NamedElement [0..1]  
The Namespace that owns this NamedElement . Redefines the corres ponding property from  
Abstractions::Namespaces::NamedElement .
Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
11.7.3 Namespace
Description
Constructs::Namespace reus es the definition of Abstractions::Constraints::Namespace . 
A namespace has the ability to import either individual member s or all members of a package, thereby making it possible 
to refer to those named elements without qualification in the imp orting namespace. In the case of conflicts, it is necessary 
to use qualified names or aliases to di sambiguate the referenced elements.
Generalizations
• “NamedElement” on page 146
Attributes
No additional attributes
Associations
• elementImport: ElementImport [*]  
References the ElementImports owned by the Namespace.Subsets Element::ownedElement .
• /importedMember: PackageableElement [*]  
References the PackageableElements that  are members of this Namespace as a re sult of either P ackageImports or  
ElementImports. Subsets  Namespace::member .
• /member: NamedElement [*]  
Redefines the corresponding property of Abstractions::Namespaces::Namespace . 
• /ownedMember: NamedElement [*]  
Redefines the corresponding property of Abstractions::Namespaces::Namespace .
• packageImport: P ackageImport [*]  
References the PackageImports owned by the Namespace. Subsets Element::ownedElement . 
148                 UML Infrastructure Specification, v2.4Constraints
[1]  The importedMember property is derived fr om the ElementImports and the PackageImports.
importedMember = self.elementImport.importedElement.asSet ()->union(self.packageImport.importedPackage->collect(p | 
p.visibleMembers()))
Additional operations
[1]  The query getNamesOfMember() is ov erridden to take account of importing. It gives back the set of names that an 
element would have in an import ing namespace, either because it is owned; or  if not owned, then imported individually; 
or if not individually , then from a package.
Namespace::getNamesOfM ember(element: NamedElement): Set(String);
getNamesOfMember=
if self.ownedMember ->includes(element)
then  Set{}->include(element.name)
else let elementImports: ElementImport = self.elementImport->select(ei | ei.importedElement = element) in
if elementImports->notEmpty()
then  elementImports->collect(el | el.getName())
else 
self.packageImport->select(pi | pi.importedPackage.visibleM embers()->includes(element))->
collect(pi | pi.importedPack age.getNamesOfMember(element))
endif
endif
[2] The query importMembers() defines which of a set of P ackageableElements are actually imported into the namespace. 
This excludes hidden ones, i.e., those which have names that  conflict with names of owned members, and also excludes 
elements that would have th e same name when imported.
Namespace::importMembers(imps: Set(Pack ageableElement)): Set(PackageableElement);
importMembers = self.excludeCollisions(imps)->se lect(imp | self.owned Member->forAll(mem | 
mem.imp.isDistinguishableFrom(mem, self)))
[3] The query excludeCollisions( ) excludes from a set of Pack ageableElements any that would not be distinguishable from 
each other in this namespace.
Namespace::excludeCollisions(imps: Set(PackageableElements)): Set(PackageableElements);
excludeCollisions = imps->reject(imp1 | imps.exists( imp2 | not imp1.isDistinguishableFrom(imp2, self)))
Semantics
No additional semantics
Notation
No additional notation
11.7.4 PackageableElement
A packageable element indicates a named element that may be owned directly by a package.
Description
A packageable element indicates a named element that may be owned directly by a package. 
Generalizations
• “NamedElement” on page 146
UML Infrastructure Specification, v2.4        149Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
11.7.5 PackageImport
A package import is a relationship that allows the use of  unqualified names to refer to package members from other 
namespaces.
Description
A package import is defined as a directed relationship that identifies a package whose members are to be imported by a 
namespace.
Generalizations
• “DirectedRelationship” on page 106
Attributes
• visibility: VisibilityKind  
Specifies the visibility of the imported Packageable Elements within the importing Namespace, i. e., whether imported  
elements will in turn be visible to other packages that use that importin gPackage as an importedPackage. If the  
PackageImport is public, the im ported elements will be visible outside the package, while if it is private they will  
not. By default, the value of visibility is public .
Associations
• importedPackage: Package [1]  
Specifies the Package whose members ar e imported into a Namespace. Subsets DirectedRelationship::target .
• importingNamespace: Namespace [1]  
Specifies the Namespace that imports th e members from a Package. Subsets DirectedRelationship::source  and  
Element::owner .
Constraints
[1]  The visibility of a PackageIm port is either public or private.
self.visibility = #public or self.visibility = #private
150                 UML Infrastructure Specification, v2.4Semantics
A package import is a relationship between an importing namespace and a package, indicating that the importing 
namespace adds the names of the members of the package to its own namespace. Conceptually, a package import is 
equivalent to having an element import to each individual me mber of the imported namespace, unless there is already a 
separately-defined element import.
Notation
A package import is shown using a dashed arrow with an open arrowhead from the importing package to the imported 
package. A keyword is shown near the dashed arrow to id entify which kind of package import that is intended. The 
predefined keywords are «import» for a public pack age import, and «access» for a private package import.
Presentation options
As an alternative to the dashed arrow, it is possible to show a package import by having a text that uniquely identifies the 
imported package within curly brackets either below or afte r the name of the namespace. The textual syntax is then:
‘{‘import ‘ <qualifiedName> ‘}’ | ‘{access ‘ <qualifiedName> ‘}’
Examples
In Figure 11.24, a number of package imports are shown. The elements in Types are imported to ShoppingCart, and then 
further imported WebShop. However, the elements of Auxilia ry are only accessed from ShoppingCart, and cannot be 
referenced using unqualified names from WebShop. 
11.8 Operations Diagram
The Operations diagram of the Constructs package specifies the BehavioralFeature, Operatio n, and Parameter constructs.Figure 11.24 - Examples of public and private package importsAuxiliary
TypesWebShop ShoppingCart
«import»«import»«access» AuxiliaryAuxiliary
TypesTypesWebShopWebShop ShoppingCartShoppingCart
«import»«import»«access»
UML Infrastructure Specification, v2.4        151Figure 11.25 - The Operations diagram of the Constructs package 
11.8.1 BehavioralFeature
Description
Constructs::BehavioralFeature  reuses the definition of BehavioralFeature  from Abstractions::BehavioralFeatures . It adds 
specializations to Constructs::Namespace  and Constructs::Feature .Feature NamespaceTypedElement MultiplicityElement
BehavioralFeature
Type
TypeParameter
ParameterParameterDirectionKind
in
inout
out
return
ConstraintOperation
isQuery : Boolean
/isOrdered : Boolean
/isUnique : Boolean/lower : Integer/upper : UnlimitedNaturaldefault : String
direction : ParameterDirectionKind{subsets namespace}
+ ownerFormalParam{subsets ownedMamber,
ordered}
+ownedParameter
0..1*
+raisedException
* *
{subsets namespace}
+operation{redefines ownedParameter}
+ownedParameter
0..1*
+type
0..1
{redefines raisedException}
+ raisedException
* *
{subsets context}
+preContext
0..1{subsets ownedRule}
+precondition
{subsets context}
+postContext{subsets ownedRule}+postcondition
{subsets context}
+bodyContext{subsets ownedRule}+bodyCondition
{subsets redefinedElement}
+redefinedOperation0..1**
0..1
0..1
*
*
152                 UML Infrastructure Specification, v2.4Generalizations
• “Feature” on page 131
• “Namespace” on page 147
Attributes
No additional attributes
Associations
• ownedParameter: Parameter[*]  
Specifies the ordered set of formal parame ters of this BehavioralFeature. Subsets Namespace::ownedMember .
• raisedException: Type[*]  
References the Types representing exceptions that ma y be raised during an invocation of this feature.
Constraints
No additional constraints
Additional Operations
[1]  The query isDistinguishableFrom() determines whether tw o BehavioralFeatures may coexis t in the same Namespace. It 
specifies that they have to have different signatures.
BehavioralFeature::isDistinguishableFrom(n: NamedElement, ns: Namespace): Boolean;
isDistinguishableFrom =
if n.oclIsKindOf(BehavioralFeature)
then
if ns.getNamesOfMember(self)->intersec tion(ns.getNamesOfM ember(n))->notEmpty()
then  Set{}->include(self)->include(n)->isUni que( bf | bf.ownedPara meter->collect(type))
else true
endif
else true
endif
Semantics
The list of owned parameters describes the order, type, and direction of arguments that can be given when the 
BehavioralFeature is invoked or which are retu rned when the BehavioralFeature terminates. 
The owned parameters with direction in or inout define the type, and number, of arguments that must be provided when 
invoking the BehavioralFeature. An owned pa rameter with direction out, inout, or re turn defines the type of the argument 
that will be returned from a successful invocation. A Beha vioralFeature may raise an exception during its invocation.
Notation
No additional notation
11.8.2 Operation
An operation is a behavioral feature of a classifier that sp ecifies the name, type, paramete rs, and constraints for invoking 
an associated behavior.
UML Infrastructure Specification, v2.4        153Description
Constructs::Operation reus es the definition of Operation  from Basic . It adds a specialization to 
Constructs::BehavioralFeature .
The specification of an operation defines what service it provide s, not how this is done, and can include a list of pre- and 
postconditions.
Generalizations
• “BehavioralFeature” on page 151
Attributes
• /isOrdered : Boolean  
Redefines the corresponding property from Basic  to derive this information from the return result for this Operation.
• isQuery : Boolean  
Specifies whether an execution of the Operation leaves the state of the syst em unchanged (isQuery=true) or whether  
side effects may occur (isQuery=fal se). The default value is false.
• /isUnique : Boolean  
Redefines the corresponding property from Basic  to derive this information from the return result for this Operation.
• /lower : Integer[0..1]  
Redefines the corresponding property from Basic  to derive this information from the return result for this Operation.
• /upper : UnlimitedNatural[0..1]  
Redefines the corresponding property from Basic  to derive this information from the return result for this Operation.
Associations
• bodyCondition: Constraint[0..1]  
An optional Constraint on the result values of an invocation of this Operation. Subsets Namespace.ownedRule .
• postcondition: Constraint[*]  
An optional set of Constraints specifying the state of the system when the Operation is completed. Subsets  
Namespace.ownedRule .
• precondition: Constraint[*]  
An optional set of Constraints on the state of the system when the Operation is invoked. Subsets  
Namespace.ownedRule .
• raisedException: Type[*]  
References the Types representing excepti ons that may be raised during an invocation of this operation. Redefines  
Basic::Operation.raisedException  and BehavioralFeature.raisedException .
• redefinedOperation: Operation[*]  
References the Operations that are re defined by this Operation. Subsets RedefinableElement.redefinedElement .
• /type: Type[0..1]  
Redefines the corresponding property from Basic  to derive this information from the return result for this Operation.
Constraints
[1]  n operation can have at most one return parameter (i.e., an owned parameter with the direction set to ‘return’).
ownedParameter->select(par | par.direction = #return)->size() <= 1
154                 UML Infrastructure Specification, v2.4[2] If this operation has a return parameter, isOrdered equals th e value of isOrdered for that pa rameter. Otherwise isOrdered is  
false.
isOrdered = if returnResult()->notEmpty() then  returnResult()->any().isOrdered else false endif
[3] If this operation has a return parameter, isUnique equals the value of isUnique for that parameter. Otherwise isUnique is 
true.
isUnique  = if returnResult()->notEmpty() then  returnResult()->any(). isUnique  else true endif
[4] If this operation has a return parameter, lower equals the value of lower for that parameter. Otherwise lower is not defined .
lower  = if returnResult()->notEmpty() then  returnResult()->any(). lower  else Set{} endif
[5] If this operation has a return parameter, upper equals the value of upper for that parameter. Otherwise upper is not defined .
upper  = if returnResult()->notEmpty() then  returnResult()->any(). upper  else Set{} endif
[6] If this operation has a return parameter, type equals the valu e of type for that parameter. Otherwise type is not defined.
type = if returnResult()->notEmpty() then  returnResult()->any(). type  else Set{} endif
[7] A bodyCondition can only be specified for a query operation.
bodyCondition->notEmpty() implies  isQuery
Additional Operations
[1]  The query isConsistentWith() specifies, for any two Operations in a context in which redefinition is possible, whether 
redefinition would be logically consistent. A redefining operat ion is consistent with a redefined operation if it has the 
same number of owned parameters, and the type of each owne d parameter conforms to the type of the corresponding  
redefined parameter.  
 
A redefining operation is consistent with a redefined operation if it has the same number of formal parameters, the same 
number of return results, and the type of each formal para meter and return result conforms to the type of the 
corresponding redefined parameter or return result.
Operation::isConsistentWith(redefinee: RedefinableElement): Boolean;
pre: redefinee.isRedefinitionContextValid(self)
result = (redefinee.oclI sKindOf(Operation) and
let op: Operation = redefinee.oclAsTyp e(Operation) in
self.ownedParamete r->size() = op.owned Parameter->size() and
Sequence{1..self.owned Parameter->size()}->
forAll(i | op.ownedParameter-> at(1).type.conformsTo(self.o wnedParameter->at(1).type))
[2] The query returnResult() returns the set containing the return parameter of the Operation if one exists, otherwise, it retur ns 
an empty set
Operation::returnResult() : Set(Parameter);
returnResult = ownedPara meter->select (par | par.direction = #return) 
Semantics
An operation is invoked on an instance of the classifier for wh ich the operation is a feature. A static operation is invoked 
on the classifier owning the operation, hence it can be invoked without an instance. 
The preconditions for an operation define c onditions that must be true when the op eration is invoked. These preconditions 
may be assumed by an implementation of this operation.
The postconditions for an operation define conditions that will be true when the invocation of the operation completes 
successfully, assuming the preconditions were satisfied. These postconditions must be satisfied by any implementation of 
the operation.
UML Infrastructure Specification, v2.4        155The bodyCondition for an operation constrains the return resu lt. The bodyCondition differs from postconditions in that 
the bodyCondition may be overridden when an operation is rede fined, whereas postconditions can only be added during 
redefinition.
An operation may raise an exception during its invocation. When an exception is raised, it should not be assumed that the 
postconditions or bodyCondition of the operation are satisfied.An operation may be redefined in a specialization of the featur ed classifier. This redefinition may specialize the types of 
the formal parameters or return results, add new preconditions  or postconditions, add new raised exceptions, or otherwise 
refine the specification of the operation.Each operation states whether or not its application will modify the state of the instance or any other element in the model 
(isQuery). 
Semantic Variation Points
The behavior of an invocation of an operation when a pr econdition is not satisfied is a semantic variation point.
When operations are redefined in a specia lization, rules regarding invariance, cova riance, or contravariance of types and 
preconditions determine whether the specialized classifier is substitutable for its more general parent. Such rules 
constitute semantic variation points with respect to redefinition of operations.
Notation
If shown in a diagram, an operation is shown as a text string of the form:
[<visibility>] <name> ‘(‘ [<para meter-list>] ‘)’ [‘:’ [<return-t ype>] [‘[‘ <multiplicity> ‘]’]  
[‘{‘ <oper-property> [‘,’  <oper-property>]* ‘}’]]
where:
• <visibility> is the visibility of the operation (See “VisibilityKind” on page 90.)  
<visibility> ::= ‘+’ | ‘-‘ 
• <name> is the name of the operation.
• <return-type>  is the type of the return result parameter if the operation has one defined.
• <multiplicity>  is the multiplicity of the return type . (See “MultiplicityElement” on page 132).
• <oper-property>  indicates the properties of the operation  
 
<oper-property> ::= ‘redefines’ <oper-name> | ‘que ry’ | ‘ordered’ | ‘unique’ | <oper-constraint>  
 where:
• redefines <oper-name> means that the operation redefines an inherited operation identified by <oper-name>.
• query  means that the operation does no t change the state of the system.
• ordered  means that the values of the return parameter are ordered.
• unique  means that the values returned by the parameter have no duplicates.
• <oper-constraint>  is a constraint that applies to the operation. 
• <parameter-list>  is a list of parameters of the operation in the following format:  
<parameter-list> ::= <par ameter> [‘,’<parameter>]*  
<parameter> ::= [<direction>] <param eter-name> ‘:’ <type-expression>  
156                 UML Infrastructure Specification, v2.4[‘[‘<multiplicity>’]’] [‘=’ <d efault>] [‘{‘ <parm-property> [‘,’ <parm-property>]* ‘}’]  
 
where:
• <direction> ::= ‘in’ | ‘out’ | ‘inout’  (defaults to ‘ in’ if omitted).
• <parameter-name>  is the name of the parameter.
• <type-expression>  is an expression that specifi es the type of the parameter.
• <multiplicity>  is the multiplicity of the parameter. (See “MultiplicityElement” on page  66.)
• <default>  is an expression that defines the value speci fication for the default value of the parameter.
• <parm-property>  indicates additional property values that apply to the parameter.
Presentation Options
The parameter list can be suppressed. The return result of the op eration can be expressed as a return parameter, or as the type  
of the operation. For example:
toString(return : String)
means the same thing as
toString() : String
Style Guidelines
An operation name typically begins with a lowercase letter.
Examples
display ()
-hide ()
+createWindow (location: Coordinates,  container: Container [0..1]): Window
+toString (): String
11.8.3 Parameter
A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral 
feature.
Description
Constructs::Parameter merges the definitions of Parameter  from Basic  and Abstractions::BehavioralFeatures . It adds 
specializations to TypedElement  and MultiplicityElement .
A parameter is a kind of typed element in order to allow th e specification of an optional multiplicity on parameters. In 
addition, it supports the specifica tion of an optional default value.
Generalizations
• “TypedElement” on page 135
• “MultiplicityElement” on page 132
UML Infrastructure Specification, v2.4        157Attributes
• default: String [0..1]  
Specifies a  String that represents a value to be used wh en no argument is supplied for the Parameter.
• direction: ParameterDirectionKind [1]  
Indicates whether a parameter is being sent into or out of a behavioral elemen t. The default value is in. 
Associations
• /operation: Operation[0..1]  
References the Operation for which th is is a formal parameter. Subsets NamedElement::namespace  and redefines  
Basic::Parameter::operation .
Constraints
No additional constraints
Semantics
A parameter specifies how arguments are passed into or out of an invocation of a behavioral feature like an operation. The 
type and multiplicity of a parameter restri ct what values can be passed, how ma ny, and whether the values are ordered.
If a default is specified for a parameter, then it is evaluated at invocation time and used as the argument for this parameter 
if and only if no argument is supplied at  invocation of the behavioral feature.
Notation
See Operation
11.8.4 ParameterDirectionKind
Parameter direction kind is an enumeration type that de fines literals used to specify direction of parameters.
Generalizations
• none
Description
ParameterDirectionKind is an enumerat ion of the following literal values:
• in — Indicates that parameter values are passed  into the behavioral element by the caller. 
• inout — Indicates that parameter values  are passed into a behavi oral element by the calle r and then back out to  
the caller from the behavioral element.
• out — Indicates that parameter values are passe d from a behavioral elem ent out to the caller. 
• return — Indicates that parameter values are passed as retu rn values from a behavioral element back to the caller. 
11.9 Packages Diagram
The Packages diagram of the Constructs package specifies the Package and PackageMerge constructs.
158                 UML Infrastructure Specification, v2.4Figure 11.26 - The Packages diagram of the Constructs package
11.9.1 Type 
Note – (additional properties - see “Type” on page 134).
Description
Constructs::Type is defined in the Classifiers  diagram. The Packages diagram adds the association between Type and 
Package  that represents the owners hip of the type by a package.
Generalizations
• “NamedElement” on page 146
• “PackageableElement” on page 148
Attributes
No additional attributes
Associations
• package: Package [0..1]  
Specifies the owning pack age of this classifi er, if any. Subsets Package::owningPackage .Namespace
PackageableElement
PackageableElement
Type
PackageMerge
DirectedRelationship
Package
+ URI : String [0..1]
 0..1+ owningPackage
*+ packagedElement{subsets namespace} {subsets ownedMember}
1+ receivingPackage
*+ packageMerge{subsets source,
subsets owner}{subsets directedRelationship,
subsets ownedElement}
0..1
+ nestingPackage*+ /nestedPackage
{subsets owningPackage}{subsets packagedElement}0..1+ package
*+ /ownedType{subsets owningPackage} {subsets packagedElement}
*
+ packageMerge1
+ mergedPackage
{subsets directedRelationship} {subsets target}
UML Infrastructure Specification, v2.4        159Constraints
No additional constraints
Semantics
No additional semantics
11.9.2 Package
A package is used to group elements, and pr ovides a namespace for the grouped elements.
Description
A package is a namespace for its members, and may contain other packages. Only packageable elements can be owned 
members of a package. By virtue of being a namespace, a package can import either individual members of other 
packages, or all the members of other packages.
In addition a package can be merged with other packages.
Generalizations
• “PackageableElement” on page 148
• “Namespace” on page 147
Attributes
• URI: String [0..1] {id}  
Provides an identifier  for the package that can be used for many purposes. A URI is the universally unique 
identification of the package following the IETF URI specification, RFC 2396 http://www.ietf.org/rfc/rfc2396.txt and 
it must comply with those syntax rules.
Associations
• /nestedPackage: Package [*]  
References the owned members that are Packages. Subsets Package::ownedMember  and redefines  
Basic::Package::nestedPackage .
• ownedMember: PackageableElement [*]  
Specifies the members that are ow ned by this Package. Redefines Namespace::ownedMember .
• ownedType: Type [*]  
References the owned members that are Types. Subsets Package::ownedMember  and redefines  
Basic::Package::ownedType .
• package: Package [0..1]  
References the owning packag e of a package. Subsets NamedElement::namespace  and redefines  
Basic::Package::nestingPackage .
• packageMerge: Package [*]  
References the PackageMerges that ar e owned by this Package. Subsets Element::ownedElement .
Constraints
[1]  If an element that is owned by a pack age has visibility, it is public or private.
160                 UML Infrastructure Specification, v2.4self.ownedElements->forAll(e | e.visibility->notEmpty() implies  e.visibility = #public or e.visibility = #private)
Additional Operations
[1]  The query mustBeOwned() in dicates whether elements of this type must have an owner.
Package::mustBeOwned() : Boolean
mustBeOwned = false
[2] The query visibleMembers() defines which me mbers of a Package can be accessed outside it.
Package::visibleMembers() : Set(PackageableElement);
visibleMembers = member->select( m | self.makesVisible(m))
[3] The query makesVisible() defines whethe r a Package makes an element visible outs ide itself. Elements with no visibility 
and elements with public vi sibility are made visible.
Package::makesVisible(el: Name spaces::NamedElement) : Boolean;
pre: self.member->includes(el)
makesVisible = 
-- the element is in the package
(ownedMember->includes(el)) or
-- it is imported individually with public visibility
(elementImport->
select(ei|ei.visibility = #public)->
collect(ei|ei.importedElement)->includes(el)) or
-- it is imported through a package with public visibility
(packageImport->
select(pi|pi.visibility = #public)->
collect(pi|
pi.importedPackage.member- >includes(el))->notEmpty())
Semantics
A package is a namespace and is also a packageable element that can be contained in other packages.
The elements that can be referred to using non-qualified na mes within a package are owned elements, imported elements, 
and elements in enclosing (outer) namesp aces. Owned and imported elements may ea ch have a visibility that determines 
whether they are available outside the package. 
A package owns its owned members, with the implication that if a package is removed from a model, so are the elements 
owned by the package.The public contents of a package are always accessible  outside the package through the use of qualified names.
The URI can be specified to provide a unique identifier for a Package. Within UML there is no predetermined usage for 
this, with the exception of profiles (see Using XMI to exchange  Profiles in section 18.3.6). It may, for example, be used 
by model management facilities for model identification. The URI should hence be unique and unchanged once assigned. 
There is no requirement that the URI be derefe renceable (though this is  of course permitted).
Notation
A package is shown as a large rectangle with a small rectangle (a  “tab”) attached to the left side of the top of the large 
rectangle. The members of the package may be shown within the large rectangle. Members may also be shown by branching lines to member elements, drawn outside the package. A plus sign (+) within a circle is drawn at the end 
attached to the namespace (package).
• If the members of the package are not sh own within the large rectangle, then th e name of the package should be placed 
within the large rectangle.
UML Infrastructure Specification, v2.4        161• If the members of the package are show n within the large rectangle, then th e name of the package should be placed 
within the tab.
The visibility of a package element may be indicated by preceding the name of the element by a visibility symbol (‘+’ for 
public and ‘-’ for private). Package elements with define d visibility may not have protected or package visibility.
The URI for a Package may be indicated with th e text {uri=<uri>} following the package name. 
Presentation Options
A tool may show visibility by a graphic marker, such as color or font. A tool may also show visibility by selectively displaying those elements that meet a given visibility level (e.g., only public elements). A diagram showing a package 
with contents must not necessarily show all its contents; it may show a subset of the contained elements according to 
some criterion.
Elements that become available for use in an importing pack age through a package import or an element import may have 
a distinct color or be dimmed to indicate that they cannot be modified.
Examples
There are three representations of the same package Types in Figure 11.27. The one on the left just shows the package 
without revealing any of its members. The middle one shows so me of the members within the borders of the package, and 
the one to the right shows some of the members using the alternative membership notation. 
11.9.3 PackageMerge
A package merge defines how the contents of one pack age are extended by the cont ents of another package.
Generalizations
• “DirectedRelationship” on page 106
Description
A package merge is a directed relationship between two packages, th at indicates that th e contents of the two packages are to be  
combined. It is very similar to Generalization in the sense that  the source element conceptually adds the characteristics of th e 
target element to its own characteristics resulting in an element that combines the characteristics of both.
This mechanism should be used when elements defined in di fferent packages have the same name and are intended to 
represent the same concept. Most often it is used to provide different definitions of a given concept for different purposes, Figure 11.27 - Examples of a package with membersTypesTypes
{uri=http://www.abc.com/models/Types}
Integer
TimeTypes
Shape Point
162                 UML Infrastructure Specification, v2.4starting from a common base de finition. A given base concept is extended in  increments, with each increment defined in a 
separate merged package. By selecting whic h increments to merge, it is possible to  obtain a custom definition of a concept for 
a specific end. Package merge is particular ly useful in meta-modeling and is extensively used in the definition of the UML 
metamodel.
Conceptually, a package merge can be viewed as an operation that takes the contents of two packages and produces a new 
package that combines the contents of the packages involved in the merge. In terms of model semantics, there is no 
difference between a model with explicit package merges, a nd a model in which all the me rges have been performed.
Attributes
No additional attributes
Associations
• mergedPackage: Package [1]  
References the Package that is to be merged with  the receiving package of the PackageMerge. Subsets  
DirectedRelationship::target .
• receivingPackage:  Package [1]  
References the Package that is being extended with the contents of the merged p ackage of the PackageMerge.  
Subsets  Element::owner  and DirectedRelationship::source .
Constraints
No additional constraints
Semantics
A package merge between two packages implies  a set of transformations, whereby the contents of the package to be 
merged are combined with the contents of  the receiving package. In cases in whic h certain elements in the two packages 
represent the same entity, their contents  are (conceptually) merged into a single resulting element according to the formal 
rules of package merge specified below. 
As with Generalization, a package merg e between two packages in a model mere ly implies these transformations, but the 
results are not themselves included in the model. Neverthele ss, the receiving package and its contents are deemed to 
represent the result of the merge, in the sa me way that a subclass of a class represen ts the aggregation of features of all of 
its superclasses (and not merely the incr ement added by the class). Thus, within  a model, any reference to a model 
element contained in the receiving package implies a reference to  the results of the merge rather than to the increment that 
is physically contained in that  package. This is illustrated by the example in Figure 11.28  in which package P1 and 
package P2 both define different increments of the same clas s A (identified as P1::A and P2::A respectively). Package P2 
merges the contents of package P1, which implies the merg ing of increment P1::A into increment P2::A. Package P3 
imports the contents of P2 so that it can define a subclass of  A called SubA. In this case, element A in package P3 (P3::A) 
UML Infrastructure Specification, v2.4        163represents the result  of the merge of P1::A into P2::A and not just the increment P2::A. Note that, if another package were 
to import  P1, then a reference to A in the importing package would represent the increment P1::A rather than the A 
resulting from merge. 
To understand the rules of package merge, it is necessary to cl early distinguish between three distinct entities: the merged 
increment (e.g., P1::A in Figure 11.28 ), the receiving incremen t (e.g., P2::A), and the result of the merge transformations. 
The main difficulty comes from the fact that the receiving pa ckage and its contents represents both the operand and the 
results of the package merge, depending on the context in which they are considered. For example, in Figure 11.28 , with 
respect to the package merge operation, P2 represents the in crement that is an operand for the merge. However, with 
respect to the import operation, P2 repres ents the result of the merge. This dual interpretation of the same model element 
can be confusing, so it is useful to introduce the following terminology that aids understanding:
• merged package  - the first operand of the merge, th at is, the package that is to be  merged into the receiving package 
(this is the package that is the target  of the merge arrow in the diagrams).
• receiving package  - the second operand of the merge, that is, the p ackage that, conceptually, c ontains the results of the 
merge (and which is the source of the merge arrow in the diag rams). However, this term is used to refer to the package 
and its contents before  the merge transformations have been performed.
• resulting package  - the package that, conceptually, cont ains the results of the merge. In the model, this is, of course, the 
same package as the receiving package, but this particular  term is used to refer to the package and its contents after  the 
merge has been performed.
• merged element  - refers to a model element that  exists in the merged package.
• receiving element  - is a model element in the receiv ing package. If the element has a matching merged element, the two 
are combined to produce the resul ting element (see below). This term is used to refer to the element before  the merge 
has been performed (i.e., the incremen t itself rather than the result).
• resulting element  - is a model element in the resulting package after  the merge was performed. For receiving elements 
that have a matching merged element, this is the sa me element as the receiving element, but in the state after  the merge 
was performed. For merged elements that have no matchi ng receiving element, this is the merged element. For 
receiving elements that have no matching merged el ement, this is the same  as the receiving element.
• element type  - refers to the type of any kind of TypedElement, su ch as the type of a Parameter or StructuralFeature.
• element metatype  - is the MOF type of a mo del element (e.g., Classifi er, Association, Feature).
This terminology is based on a conceptual view of package merge that is represented by the schematic diagram in 
Figure 11.29 (NOTE: this is not a UML diagram). The owned el ements of packages A and B are all incorporated into the 
namespace of package B. However, it is im portant to emphasize that this view is  merely a convenience for describing the 
semantics of package merge and is not reflec ted in the repository model, that is, the physical  model itself is not 
transformed in any way by the presence of package merges.Figure 11.28 - Illustration of the meaning of package mergeP1
AP2
A«merge»P3
A«import»
SubA
164                 UML Infrastructure Specification, v2.4The semantics of package merge are defined by a set of co nstraints and transformations. The constraints specify the 
preconditions for a valid package merge, wh ile the transformations describe its sema ntic effects (i.e., postconditions). If 
any constraints are violated, the package merge is ill-formed and the resulting model that contains it is invalid. Different 
metatypes have different semantics, but the general principle is always the same : a resulting element will not be any less 
capable than it was prior to the merge. This means, for inst ance, that the resulting navigability, multiplicity, visibility, et c. 
of a receiving model element will not be reduced as a result of  a package merge. One of the key consequences of this is 
that model elements in the resulting package are compatible ex tensions of the corresponding elements in the (unmerged) 
receiving package in the same namespace . This capability is particularly useful in defining metamodel compliance levels 
such that each successive level is compatible with the prev ious level, including their corresponding XMI representations.
In this specification, explicit merge transformations are only defined for certain general metatypes found mostly in 
metamodels (Packages, Classes,  Associations, Properties, etc.), since the se mantics of merging other kinds of metatypes 
(e.g., state machines, interactions) are complex and domain specific. Elements of all other kinds of metatypes are 
transformed according to the default rule: they are simply deep copied into the resulting package. (This rule can be 
superseded for specific metat ypes through profiles or other ki nds of language extensions.)
General package merge rules
A merged element and a receiving element match  if they satisfy the matching rules for their metatype.
CONSTRAINTS:
1. There can be no cycles in the «merge» dependency graph.
2. A package cannot merge a package in which it is contained.3. A package cannot merge a package that it contains.  
 Figure 11.29 - Conceptual view of the package merge semanticsmerged
packagereceiving
package
resulting
packagepackage
merge
«becomes»AB
B'A
B«merge»
UML Infrastructure Specification, v2.4        1654. A merged element whose metatype is not a kind of Packag e, Class, DataType, Property,  Association, Operation, 
Constraint, Enumeration,  or EnumerationLiteral, cannot have a receiving  element with the same name and metatype 
unless that receiving element is an exact copy of the merged elem ent (i.e., they are the same). 
5. A package merge is valid if and on ly if all the constraints required to perform the me rge are satisfied.
6. Matching typed elements (e.g., Properti es, Parameters) must have conforming types. For types that are classes or data 
types, a conforming type is either the same type or a co mmon supertype. For all other cases, conformance means that 
the types must be the same.
7. A receiving element cannot have explicit  references to any merged element.
8. Any redefinitions associated with matching redefinable elements must not be conflicting.
TRANSFORMATIONS:
1. ( The default rule ) Merged or receiving elements for which there is  no matching element are deep copied into the 
resulting package.
2. The result of merging two elements with matching names and metatypes that are exact copies of each other is the 
receiving element.
3. Matching elements are combined accord ing to the transformation rules specifi c to their metatype and the results 
included in the resulting package.
4. All type references to typed elements that end up in th e resulting package are transfor med into references to the 
corresponding resulting typed elements (i.e., not to their respective increments).
5. For all matching elements: if both matching elements have private visibility, the resulting element will have private 
visibility; otherwise, the resulting element will have public visibility.
6. For all matching classifier elements: if both matching elements are abstract, the resulting element is abstract; 
otherwise, the resulting element is non-abstract.
7. For all matching classifier elements: if both matching el ements are final specializations , the resulting element is a 
final specialization; otherwise, the resul ting element is a non-f inal specialization.
8. For all matching elements: if both matching elements ar e not derived, the resulting element is also not derived; 
otherwise, the resulting element is derived.
9. For all matching multiplicity elements: the lower bound of the resulting multiplicity is the lesser of the lower bounds 
of the multiplicities of  the matching elements.
10. For all matching multiplicity elements: the upper bound of the resulting multiplicity is the greater of the upper bounds 
of the multiplicities of  the matching elements.
11. Any stereotypes applied to a model element in either a merged or receiving elemen t are also applied to the 
corresponding resulting element.
12. For matching redefinable elements: different redefini tions of matching redefinable elements are combined 
conjunctively.
13. For matching redefinable elements: if both matching elements have isLeaf=true, the resulting element also has 
isLeaf=true; otherwise, the resu lting element has isLeaf=false.
166                 UML Infrastructure Specification, v2.4Package rules
Elements that are a kind of Package matc h by name and metatype (e.g., profiles match with profiles and regular packages 
with regular packages).
CONSTRAINTS:
1. All classifiers in the merged package must have a non-em pty qualified name and be distinguishable in the merged 
package.
2. All classifiers in the receiving packag e must have a non-empty qualified name and be distinguishable in the receiving 
package.
TRANSFORMATIONS:
1. A nested package from the merged pack age is transformed into a nested packag e with the same name in the resulting 
package, unless the receiving package al ready contains a matching nested packag e. In the latter case, the merged 
nested package is recursivel y merged with the matching receiving nested package. 
2. An element import owned by the receiving package is transformed in to a corresponding el ement import in the 
resulting package. Impor ted elements are not merged (unless there is also a package merge to the package owning the 
imported element or its alias). 
Class and DataType rules
Elements that are kinds of Class or DataType match by name and metatype.
TRANSFORMATIONS:
1. All properties from the merged classi fier are merged with the receiving classifier to produ ce the resulting classifier 
according to the property transfor mation rules specified below.
2. Nested classifiers are merged recu rsively according to the same rules.
Property rules
Elements that are kinds of Prope rty match by name and metatype.
CONSTRAINTS:
1. The static (or non-static) characteristic of matching pr operties must be the same.
2. The uniqueness characteristic of matc hing properties must be the same.
3. Any constraints associated with matchi ng properties must not be conflicting.
TRANSFORMATIONS:
1. For merged properties that do not have a matching receiving property,  the resulting property is a newly created 
property in the resulting classifier that is the same as the merged property. 
2. For merged properties that have a ma tching receiving property, th e resulting property is a property with the same 
name and characteristics except where th ese characteristics are different. Where these characteristics are different, the 
resulting property characteristics are determined by application of the appropriate transformation rules.  
UML Infrastructure Specification, v2.4        1673. For matching properties: if both properties are designated r ead-only, the resulting property  is also designated read-
only; otherwise, the resulting property is designated as not read-only.
4. For matching properties: if bo th properties are unordered, then the resulting property is also unordered; otherwise, the 
resulting property is ordered.
5. For matching properties: if neither property is designated  as a subset of some derived union, then the resulting 
property will not be designated as a s ubset; otherwise, the resulting property w ill be designated as a subset of that 
derived union. 
6. For matching properties: differ ent constraints of matching proper ties are combined conjunctively.
7. For matching properties: if either the merged and/or receiving elements are non-uniqu e, the resulting element is non-
unique; otherwise, the resulting element is designated as unique.
8. The resulting property type is transformed to refer to the corresponding type  in the resulting package.
Association rules
Elements that are a kind of Association match by name and metatype.
CONSTRAINTS:
1. These rules only apply to binary associations. (The default rule is used for merging n-ary associations.)
2. The receiving association e nd must be a composite if the matching merged association end is a composite.
3. The receiving association end must be owned by the association if the ma tching merged associat ion end is owned by 
the association
TRANSFORMATIONS:
1. A merge of matching associations is accomplished by merg ing the Association classifier s (using the merge rules for 
classifiers) and merging their corres ponding owned end proper ties according to the rules for properties and 
association ends.
2. For matching association ends: if neithe r association end is navigable, then th e resulting association end is also not 
navigable. In all other cases, the re sulting association end is navigable.
Operation rules
Elements that are a kind of Operation match by name, parame ter order, and parameter type s, not including any return 
type.
CONSTRAINTS:
1. Operation parameters and types must conform to the sa me rules for type and multiplicity as were defined for 
properties.
2. The receiving operation must be a query if the matchi ng merged operation is a query.
TRANSFORMATIONS:
1. For merged operations that do not have  a matching receiving operation, the re sulting operation is an operation with 
the same name and signature in the resulting classifier. 
168                 UML Infrastructure Specification, v2.42. For merged operations that have a ma tching receiving operat ion, the resulting operation is  the outcome of a merge of 
the matching merged and receiving operations, with para meter transformations perfor med according to the property 
transformations defined above.
Enumeration rules
Elements that are a kind of EnumerationLitera l match by owning enumeration and literal name.
CONSTRAINTS:
1. Matching enumeration literals must be in the same order.
TRANSFORMATIONS:
1. Non-matching enumeration literals fr om the merged enumeration are concat enated to the r eceiving enumeration.
Constraint Rules
CONSTRAINTS:
1. Constraints must be mutually non-contradictory.
TRANSFORMATIONS:
1. The constraints of the merged model elements are conjunctively added to the constraints of the matching receiving 
model elements.
Notation
A PackageMerge is shown using a dashed line with an open arrowhead pointing from the receiving package (the source) 
to the merged package (the target). In addition, the keyword «merge» is shown near the dashed line. 
Figure 11.30 - Notation for package mergeSourceTarget«merge»
UML Infrastructure Specification, v2.4        169Examples
In Figure 11.31, packages P and Q are being merged by package R, while package S merges only package Q. 
The transformed packages R and S are shown in Figure 11. 32. The expressions in square brackets indicate which 
individual increments were merged to produce the final result , with the “@” character denoting the merge operator (note 
that these expressions are not part of  the standard notation, but are includ ed here for explanatory purposes). Figure 11.31 - Simple example of package merges
 
Figure 11.32 - Simple example of transformed packages following the merges in Figure 11.31P Q
RSA
BA C
A«merge»«merge»
«merge»
A BD
R
B
[P::B]A
[P::A@(Q::A@R::A)]C
[Q::C]S
B
[S::B]A
[Q::A@S::A]C
[Q::C]D
[S::D]
170                 UML Infrastructure Specification, v2.4In Figure 11.33, additional package merges are introduced by ha ving package T, which is empty prior to execution of the 
merge operation, merge packages R and S defined previously. 
In Figure 11.34, the transformed version of package T is depicted . In this package, the partial definitions of A, B, C, and 
D have all been brought together. Note that the types of the ends  of the associations that were  originally in the packages 
Q and S have all been updated to refer to  the appropriate elements in package T. Figure 11.33 - Introducing additional package merges
 
Figure 11.34 - The result of the additional package merges in Figure 11.33R
ST
«merge»«merge»
T
A
[(P::A@(Q::A@R::A))
@S::A]C
[Q::C]D
[S::D]
B
[P::B@S::B]
UML Infrastructure Specification, v2.4        17712 Core::Profiles
The Profiles package contains mechanisms that allow metaclas ses from existing metamodels to be extended to adapt them 
for different purposes. This includes the ability to tailor th e UML metamodel for different platforms (such as J2EE or 
.NET) or domains (such as real-time or business process modeling). The profiles mechanism is consistent with the OMG 
Meta Object Facility (MOF).
Positioning profiles versus metamodels, MOF and UML
The infrastructure specification is reused  at several meta-levels in various OMG specifications that deal with modeling. 
For example, MOF uses it to provide the ability to model me tamodels, whereas the UML supe rstructure uses it to model 
the UML model. This clause deals with use cases comparable to the MOF at th e meta-meta-level, which is one level 
higher than the UML metamodel specification. In order to a llow this, the reference metamodel must be defined as an 
instance of UML that corresponds to its definition using MOF.  Thus when defining a UML profile, the profile?s 
stereotypes are defined to extend the UML classes in the nor mative version of the UML metamodel merged at the highest 
level of compliance, L3, defined in UML w hose xmi serialization is listed in Append ix C. This approach allows defining 
a UML profile for arbitrary subsets of the UML at lower leve ls of compliance, which can be further restricted using 
constraints defined in the profile.
Profiles History and design requirements 
The Profile mechanism has been specifically defined for providing a lightweight extension mechanism to the UML 
standard. In UML 1.1, stereotypes and tagge d values were used as string-based extensions that could be attached to UML 
model elements in a flexible way. In s ubsequent revisions of UML, the notion of a Profile was defined in order to provide 
more structure and precision to the definition of Stereo types and Tagged values. The UML 2 infrastructure and 
superstructure specifications have carried this further, by defining it as a specific meta-modeling technique.
The following requirements have driven the de finition of profile semantics from inception:
1. A profile must provide mechanisms for specializing a refe rence metamodel (such as a se t of UML packages) in such 
a way that the specialized semantics do  not contradict the semantics of the reference metamodel. That is, profile 
constraints may typically define well-f ormedness rules that are more constr aining (but consistent with) those 
specified by the reference metamodel. 
2. It must be possible to interchange profiles between tools, together with models to which they have been applied, by 
using the UML XMI interchange mechanisms. A profile mu st therefore be defined as an interchangeable UML 
model. In addition to exchanging profiles together with models between tools, profile application should also be 
definable “by reference” (e.g., “import by name”); that is, a profile does not need  to be interchanged if it is already 
present in the importing tool. 
3. A profile must be able to referen ce domain-specific UML libraries where cer tain model elements are pre-defined. 
4. It must be possible to specify which profiles are being ap plied to a given Package (or any specializations of that 
concept). This is particularly useful during model interchange so that an importing environment can interpret a model 
correctly. 
5. It should be possible to define a UML extension that combines profiles and model libraries (including template 
libraries) into a single logical unit. However, within such a unit, for definitional clarity and for ease of interchange 
(e.g., ‘reference by name’), it s hould still be possible to keep  the libraries and the profiles  distinct from each other. 
6. A profile should be able to speciali ze the semantics of standard UML metamo del elements. For example, in a model 
with the profile “Java model,” generalizat ion of classes should be able to be restricted to single inheritance without 
178                 UML Infrastructure Specification, v2.4having to explicitly assign a stereotype «Java class» to each and every class instance. 
7. A notational convention for graphical stereotype definitions as part of a profile should be provided. 
8. In order to satisfy requirement [1] above, UML Profiles should form a metamodel extension mechanism that imposes 
certain restrictions on how the UML metamodel can be modi fied. The reference metamodel is considered as a “read 
only” model, that is extended without changes by profiles. It  is therefore forbidden to insert new metaclasses in the 
UML metaclass hierarchy (i.e., new super-classes for stan dard UML metaclasses) or to modify the standard UML 
metaclass definitions (e.g., by adding meta-associations). Su ch restrictions do not appl y in a MOF context where in 
principle any metamodel can be reworked in any direction.
9. The vast majority of UML case tools should be able to  implement Profiles. The design of UML profiles should 
therefore not constrain thes e tools to have an internal implementa tion based on a meta-metamodel/metamodel 
architecture.
10. Profiles can be dynamically applied to or retracted from a model. It is possi ble on an existing model to apply new 
profiles, or to change the set of applied profiles.
11. Profiles can be dynamically combined. Frequently, several profiles will be applied at the same time on the same 
model. This profile combination may not be foreseen at profile definition time.
12. Models can be exchanged regardless of the profiles known by the destination target. The destination of the exchange 
of a model extended by a profile may not know the profil e, and is not required to interpret a specific profile 
description. The destination environment interprets extensions only if it possesses the required profiles.
Extensibility
The profiles mechanism is not a first-class extension m echanism (i.e., it does not allow for modifying existing 
metamodels). Rather, the intention of profiles is to give a straightforward mechanism for adapting an existing metamodel 
with constructs that are specific to a particular domain, plat form, or method. Each such adaptation is grouped in a profile. 
It is not possible to take away any of the constraints that  apply to a metamodel such as UML using a profile, but it is 
possible to add new constraints that are specific to the profile . The only other restrictions are those inherent in the profile s 
mechanism; there is nothing else that is intended to  limit the way in which a metamodel is customized.
First-class extensibility is handled through MOF, where there ar e no restrictions on what you are allowed to do with a 
metamodel: you can add and remove metaclas ses and relationships as you find necess ary. Of course, it is then possible to 
impose methodology restrictions that you are not allowed to mo dify existing metamodels, but only extend them. In this 
case, the mechanisms for first-class ex tensibility and profiles start coalescing. 
There are several reasons why you may want to customize a metamodel:
• Give a terminology that is adapted to a particular plat form or domain (such as capturing EJB terminology like home 
interfaces, enterprise java beans, and archives).
• Give a syntax for constructs that do not have  a notation (such as in the case of actions).
• Give a different notation for already existing symbols (such as being able to use a picture of  a computer instead of the 
ordinary node symbol to represent a computer in a network).
• Add semantics that is left unspecified in the metamodel (suc h as how to deal with priori ty when receiving signals in a 
statemachine).
• Add semantics that does not exist in the metamodel (suc h as defining a timer, clock, or continuous time).
• Add constraints that restrict the way you  may use the metamodel and its constructs (such as disallowing actions from 
UML Infrastructure Specification, v2.4        179being able to execute in parall el within a single transition).
• Add information that can be used when transforming a model to another model or code (such as defining mapping rules 
between a model and Java code).
Profiles and Metamodels
There is no simple answer for when you should create a new metamodel and when you instead should create a new 
profile. 
12.1 Profiles package
The Profiles package is dependent on the Constructs  package from Core , as is depicted in Figure 12.1.
The classes of the Profiles package are depicted in  Figure 12.2, and subsequently specified textually.Figure 12.1 - Dependencies between packages described in this clauseProfilesConstructs PrimitiveTypes
«merge»«import»
180                 UML Infrastructure Specification, v2.412.1.1 Class (from Profiles)
Generalizations
• “Classifier” on page 121
• “PackageableElement (from Profiles)” on page 188
Description
Class has derived association that indicates how it ma y be extended through one or more stereotypes. 
Stereotype is the only kind of metaclass that cannot be extended by stereotypes.
Attributes
No additional attributes
Associations
• / extension: Extension [*]  
References the Extensions that specify  additional properties of the metacla ss. The property is derived from the  
extensions whose memberEnds are typed by the Class.Figure 12.2 - The classes defined in the Profiles packageExtension
/isRequired : Boolean = false {readOnly}
ExtensionEn d
+ lower : Integer [0..1] = 0 {redefines lower}
Image
content : String [0..1]
location : String [0..1]format : String [0..1]InfrastructureLibrary::Core::Constructs:
Association
InfrastructureLibrary::Core::Constructs:
PropertyPackage
ProfileApplication
isStrict : Boolean = false
ProfileInfrastructureLibrary::Core::Constructs::
NamespaceInfrastructureLibrary::Core::Constructs::
DirectedRelationship
Class
Stereotype
InfrastructureLibrary::Core::Constructs::
PackagePackageableElementInfrastructureLibrary::Core::Constructs::
Classifier
InfrastructureLibrary::Core::Constructs:
ElementImportInfrastructureLibrary::Core::Constructs:
PackageImportInfrastructureLibrary::Core::Constructs::
Element1 + extension
1 + ownedEnd{subsetsowningAssociation}
{redefines ownedEnd}1+ applyingPackage
*+ profileApplication{subsets source,subsets owner}{subsets directedRelationship,subsets ownedElement}
* + profileApplication
1
+ appliedProfile{subsets directedRelationship}
{subsets target}*
+ stereotype1
+ /profile
{readOnly}
0..1+ profile
* + metaclassReference{subsets importingNamespace}
{subsets elementImport}0..1+ profile
* + metamodelReference{subsets importingNamespace}
{subsets packageImport}1+ owningPackage
*+ /ownedStereotype{redefines owningPackage}{readOnly, subsets
packagedElement}0..1+ owningPackage
*+ packagedElement
1+ /metaclass
*+ /extension{readOnly} {readOnly}
* + extensionEnd1
+ type
{subsets typedElement}{redefines type}
0..1 + stereotype
*+ icon{subsets owner}
{subsets ownedElement}
UML Infrastructure Specification, v2.4        181Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
Presentation Options
A Class that is extended by a Stereotype may be extended by the optional keyword «Metacla ss» shown above or before 
its name.
Examples
In Figure 12.3, an example is given where it is made explicit that the extended class Interface  is in fact a metaclass (from 
a reference metamodel). 
Changes from previous UML
A link typed by UML 1.4 ModelElement::stereotype is ma pped to a link that is typed by Class::extension.
12.1.2 Extension (from Profiles)
An extension is used to indicate that the properties of a metaclass are extended through a stereotype, and gives the ability 
to flexibly add (and later remove) stereotypes to classes.
Generalizations
• “Association” on page 111
Description
Extension is a kind of Association. One end of the Exte nsion is an ordinary Propert y and the other end is an 
ExtensionEnd. The former ties the Extension to a Class, while the latter ties the Extension to a Stereotype that extends the 
Class. Figure 12.3 - Showing that the extended class is a metaclass«Metaclass»  
Interface«stereotype» 
Remote
182                 UML Infrastructure Specification, v2.4Attributes
• / isRequired: Boolean  
Indicates whether an instance of the exte nding stereotype must be created when an instance of  the extended class is 
created. The attribute value is derived from the value of the lower property of the ExtensionEnd referenced by  
Extension::ownedEnd ; a lower value of 1 means that isRequired is true, but otherwise it is false . Since the default 
value of ExtensionEnd::lower is 0, the default value of isRequired is false . 
Associations
• ownedEnd: ExtensionEnd [1]  
References the end of the extension th at is typed by a Stereotype. {Redefines  Association::ownedEnd }
• / metaclass: Class [1]  
References the Class that is extended through an Exte nsion. The property is derived from the type of the  
memberEnd that is not the ownedEnd.
Constraints
[1]  The non-owned end of an Extension is typed by a Class.
metaclassEnd()->notEmpty() and metaclass()->oclIsKindOf(Class)
[2] An Extension is binary (i.e., it has only two memberEnds).
memberEnd->size() = 2
Additional Operations
[1]  The query metaclassEnd() returns the Property that is typed by a metaclass (a s opposed to a stereotype).
Extension::metaclassEnd(): Property;
metaclassEnd = memberEnd->reject(ownedEnd)
[2] The query metaclass() returns the metaclass that is being extended (as opposed to the extending stereotype).
Extension::metaclass(): Class;metaclass = metaclassEnd().type
[3] The query isRequired() is true if the owned end has a multiplicity with the lower bound of 1.
Extension::isRequired(): Boolean;
isRequired = (ownedEnd->lowerBound() = 1)
Semantics
A required extension means that an instance of a stereotype  must always be linked to an instance of the extended 
metaclass. The instance of the stereotype is typically delete d only when either the instance of the extended metaclass is 
deleted, or when the profile defining the stereotype is rem oved from the applied profiles of the package. The model is not 
well-formed if an instance of the stereotype is not presen t when isRequired is true. If the extending stereotype has 
subclasses, then at most one instance of the st ereotype or one of its subclasses is required.
A non-required extension means that an instance of a stereotype  can be linked to an instance of an extended metaclass at 
will, and also later deleted at will; however, there is no require ment that each instance of a metaclass be extended. An 
instance of a stereotype is further deleted when either the instance of the extended metaclass is deleted, or when the 
profile defining the stereotype is remove d from the applied profiles of the package.
The equivalence to a MOF construction is shown in Figure 12. 4. This figure illustrates the case shown in Figure 12.6, 
where the “Home” stereotype extends the “Interface” metaclass. In this figure, Interface is an instance of a CMOF::Class 
and Home is an instance of a CMOF::Ste reotype. The MOF construct equivalent to  an extension is an aggregation from 
UML Infrastructure Specification, v2.4        183the extended metaclass to the extension st ereotype, navigable from the extension st ereotype to the extended metaclass. 
When the extension is required, then the cardinality on the ex tension stereotype is “1.” The role names are provided using 
the following rule: The name of the role of the extended metaclass is:
‘base_’ extendedMetaclassName
The name of the role of the extension stereotype is:
‘extension$_’ stereotypeName
Constraints are frequently added to stereotypes. The role  names will be used for expressing OCL navigations. For 
example, the following OCL expression states th at a Home interface shall not have attributes:
self.base_Interface.ownedAttributes->size() = 0
Figure 12.4 - MOF model equivalent to exten ding “interface” by the “Home” stereotype
Notation
The notation for an Extension is an arrow pointing from a Stereotype to the extended Class, where the arrowhead is 
shown as a filled triangle. An Extension may have the same adornments as an ordinary association, but navigability 
arrows are never shown. If isRequired is true, the property {require d} is shown near the ExtensionEnd. 
Presentation Options
It is possible to use the multiplicities 0..1 or 1 on the Extens ionEnd as an alternative to the property {required}. Due to 
how isRequired is derived, the multiplicity  0..1 corresponds to isRequired being false . 
Style Guidelines
Adornments of an Extension are typically elided. Figure 12.5 - The notation for an ExtensionInterface Homebase_Interface
1extension_Home
0..1
184                 UML Infrastructure Specification, v2.4Examples
In Figure 12.6, a simple example of using an  extension is shown, where the stereotype Home  extends the metaclass 
Interface . 
An instance of the stereotype Home  can be added to and deleted from an instance of the class Interface  at will, which 
provides for a flexible approach of dyna mically adding (and removing) information specific to a profile to a model.
In Figure 12.7, an instance of the stereotype Bean  always needs to be linked to an instance of class Component  since the 
Extension is defined to be re quired. (Since the stereotype Bean  is abstract, this means that an instance of one of its 
concrete subclasses alwa ys has to be linked to an instance of class Component .) The model is not well-formed unless such 
a stereotype is applied. This provides a way to express extensions that should always be present for all instances of the 
base metaclass depending on wh ich profiles are applied. 
Changes from previous UML
Extension did not exist as a metaclass in UML 1.x.
Occurrences of Stereotype::baseC lass of UML 1.4 is mapped to an instance of Extension, where the ownedEnd is typed 
by Stereotype and the other end is typed by the metaclass that is indicated by the baseClass.
12.1.3 ExtensionEnd (from Profiles)
An extension end is used to tie an extensi on to a stereotype when extending a metaclass.
Generalizations
• “Property” on page 124
Description
ExtensionEnd is a kind of Property th at is always typed by a Stereotype. 
An ExtensionEnd is a navigable ownedEnd, ow ned by an Extension. This allows a st ereotype instance to be attached to 
an instance of the extended classifier without adding a property to the classifier.
The aggregation of an ExtensionEnd is always composite.Figure 12.6 - An example of using an Extension
Figure 12.7 - An example of a required Extension«stereotype»
HomeInterface
Component«stereotype»
Bean{required}
UML Infrastructure Specification, v2.4        185The default multiplicity of an ExtensionEnd is 0..1.
Attributes
• /lower : integer [0..1] = 0   
This redefinition changes the default multiplicity  of association ends, since model elements are  
usually extended by 0 or 1 instance of the extension ster eotype. The value of lower is derived from the redefined  
lowerBound() operation, via a constraint inherited from MultiplicityElement. { Redefines  
MultiplicityElement::lower }
Associations
• type: Stereotype [1]  
References the type of the ExtensionEnd.  Note that this association restricts the possible types of an ExtensionEnd  
to only be Stereotypes. {Redefines TypedElement::type }. 
Constraints
[1]  The multiplicity of ExtensionEnd is 0..1 or 1. 
(self->lowerBound() = 0 or self->lowerBound() = 1) and self->upperBound() = 1
[2] The aggregation of an ExtensionEnd is composite.
self.aggregation = #composite
Additional Operations
[1]  The query lowerBound() returns the lower bound of the multip licity as an Integer. This is a redefinition of the default 
lower bound, which, if empty, normally evaluates to 1 for MulticplicityElements.
ExtensionEnd::lowerBoun d() : Set(Integer);
lowerBound = if lowerValue->isEmpty() then  0 else lowerValue->IntegerValue() endif
Semantics
No additional semantics
Notation
No additional notation
Examples
See “Extension (from Profiles)” on page 181. 
Changes from previous UML
ExtensionEnd did not exist as a metaclass in UML 1.4. See “Extension (from Profiles)” on page 181 for further details.
12.1.4 Image (from Profiles)
Physical definition of a graphical image.
Generalizations
• “Element” on page 106
186                 UML Infrastructure Specification, v2.4Description
The Image class provides the necessary info rmation to display an Image in a diagram. Icons are typically handled through 
the Image class.
Attributes
• content : String [0..1]  
This contains the serialization of th e image according to the imageFormat. Th e value could represent a bitmap, image  
such as a GIF file, or drawing ‘instructions’ using a standard  such as Scalable Vector Gr aphics (SVG) (which is XML  
based). 
• format : String [0..1]  
This indicates the format of the imageContent - which is how the string imageContent should be interpreted. The  
following values are reserved: 
SVG, GIF, PNG, JPG, WMF, EMF, BMP. 
In addition the prefix ‘MIME:’ is also reserved: this  must be followed by a valid MIME type as defined by  
RFC3023. This option can be used as an alternative to  express the reserved values above, for example “SVG”  
could instead be expresse d “MIME: image/svg+xml.” 
• location : String [0..1]  
This contains a location that can be used by a tool to lo cate the image as an alterna tive to embedding it in the  
stereotype.
Associations
No additional associations
Constraints
No additional constraints
Semantics
Information such as physical localization or format is provi ded by the Image class. The Image class provides a generic 
way of representing images in different formats. Although so me predefined values are specified for imageFormat for 
convenience and interoperability, the set of possible formats is open-ended. However there is no requirement for an 
implementation to be able to interpret and display an y specific format, including those predefined values.
12.1.5 Package (from Profiles)
Generalizations
• “Namespace” on page 136
Description
A package can have one or more ProfileApplications  to indicate which prof iles have been applied.
Because a profile is a package, it is  possible to apply a profile not only to packages, but also to profiles.
UML Infrastructure Specification, v2.4        187Attributes
No additional attributes
Associations
• profileApplication : ProfileApplication [*]  
References the ProfileApplications th at indicate which profiles have been  applied to the Package. Subsets  
Element::ownedElement .
• /ownedStereotype: Stereotype [*]  
References the Stereotypes that are owned by the Package. Subsets  Package::packagedElement
• packagedElement: P ackageableElement [*]  
Specifies the Packageab leElements that are owned by this Package.
Constraints
No additional constraints
Additional Operations
[1]  The query allApplicableStereotypes() returns all the directly or indirectly owned stereotypes, including stereotypes 
contained in sub-profiles.
Package::allApplicableStereotypes(): Set(Stereotype)
result  = self.ownedStereotype->union(self.ownedMember->
select(oclIsKindOf(Package)).oclAsType(Package). allApplicableSte reotypes()->flatten())->asSet()
[2]  The query containingProfile()  returns the closest profile dir ectly or indirectly containing this package (or this package 
itself, if it is a profile).
Package::containingProfile(): Profile  
result  =  
if self.oclIsKindOf(Profile) then  
self.oclAsType(Profile)  
else  
self.namespace.oclAsType(Package).containingProfile()  
endif
Semantics
The association “appliedProfile” between a package and a profile conceptually cr osses metalevels: It links one element 
from a model (a kind of package) to an element of its meta model and represents the set of profiles that define the 
extensions applicable to the package.  In  order to represent this conceptual cros sing of metalevels, the UML metamodel is 
available as an instance of UML.
Notation
No additional notation
Changes from previous UML
In UML 1.4, it was not possible to indicate  which profiles were applied to a package.
188                 UML Infrastructure Specification, v2.412.1.6 PackageableElement (from Profiles)
Generalizations
• “PackageableElement” on page 148 (merge increment)
Description
See InfrastructureLibrary::Core ::Constructs::PackageableElement.
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
No additional semantics
Notation
No additional notation
12.1.7 Profile (from Profiles)
A profile defines limited extensions to a reference metamodel with the purpose of  adapting the metamodel to a specific 
platform or domain. 
Generalizations
• “Package (from Profiles)” on page 186
Description
A Profile is a kind of Package that extends a reference meta model. The primary extension construct is the Stereotype, 
which is defined as part of Profiles.
A profile introduces several c onstraints, or restrictions, on ordinary meta modeling through the use of the metaclasses 
defined in this package.
A profile is a restricted form of a meta model that must always be related to a reference metamodel , such as UML, as 
described below. A profile cannot be used without its reference metamodel, and defines a limited capability to extend 
metaclasses of the reference metamodel. The extensions are defined as stereotypes that apply to existing metaclasses.
Attributes
No additional attributes
UML Infrastructure Specification, v2.4        189Associations
• metaclassReference: ElementImport [*]  
References a metaclass that  may be extended. Subsets  Package::elementImport
• metamodelReference:  PackageImport [*]  
References a package containing (directly or i ndirectly) metaclasses th at may be extended.  
Subsets Package::packageImport . 
Constraints
[1]  An element imported as a metaclassReference is not specialized or ge neralized in a Profile.
self.metaclassReferenc e.importedElement->
select(c | c.oclIsKindOf(Classifier) and
(c.generalization.namespace = self or
c.specialization.namespa ce = self))->isEmpty()
[2] All elements imported either as metaclassReferences or through metamodelReferences are members of the same base 
reference metamodel. 
self.metamodelRefe rence.importedPackage.el ementImport.importedEle ment.allOwningPackages()->
union(self.metaclassReference.importedE lement.allOwningPackages())->notEmpty()
Additional Operations
[1]  The query allOwningPackages () returns all the directly or  indirectly owning packages.
NamedElement::allOwningP ackages(): Set(Package)
allOwningPackages = self .namespace->select(p | p.oclIsKindO f(Package))->
union(p.allOwningPackages())
Semantics
A profile by definition extends a reference metamodel. It is not possible to defi ne a standalone profile that does not 
directly or indirectly extend an existing metamodel. The pr ofile mechanism may be used with any metamodel that is 
created from MOF, including UML and CWM. 
A reference metamodel typically consists of metaclasses that are either imported or locally owned. All metaclasses that 
are extended by a profile have to be members of the same  reference metamodel. The “metaclassReference” element 
imports and “metamodelReference” package imports serve two purposes: (1) they identify the reference metamodel 
elements that are imported by the profile and (2) they specify the profile’s filtering rules. The filtering rules determine 
which elements of the metamodel are visible  when the profile is applied and which ones are hidden . Note that applying a 
profile does not change the underlying model in any way;  it merely defines a view of the underlying model.
In general, only model elements that are instances of importe d reference metaclasses will be visible when the profile is 
applied. All other metaclasses will be hi dden. By default, model elements whose metaclasses are public and owned by the 
reference metamodel are visible. This applies transitively to  any subpackages of the reference metamodel according to the 
default rules of package import. If any metaclasses is imported using a metaclass reference  element import, then model 
elements whose metaclasses are the same  as that metaclass are visible. Note , however, that a metaclass reference 
overrides a metamodel reference  whenever an element or package of the referenced metamodel is also referenced by a 
metaclass reference. In such cases, only the elements that are explicitly re ferenced by the metaclass reference will be 
visible, while all other elements of the metamodel package will be hidden.
The following rules are used to determine whether a model elem ent is visible or hidden when a profile has been applied. 
Model elements are visible  if they are instances of metaclasses that are:
190                 UML Infrastructure Specification, v2.41. referenced by an expl icit MetaclassReference, or
2. contained (directly or transitively) in  a package that is referenced by an explicit MetamodelReference; unless there 
are other elements of subpackages of  that package that are explicitly re ferenced by a MetaclassReference, or
3. extended by a stereotype owned by the applied profile (even if the extended metacl ass itself is not visible).
All other model elements are hidden  (not visible) when the profile is applied.
The most common case is when a profile just imports an entire metamodel using a Metamo delReference. In that case, 
every element of the metamodel is visible.
In the example in Figure 12.8, MyMetamodel is a metamode l containing two metaclasses: Metaclass1 and Metaclass2. 
MyProfile is a profile that references  MyMetamodel and Metaclass2. However, there is also an explicit metaclass 
reference to Metaclass2, which overrides the metamodel reference. An applicatio n of MyProfile to some model based on 
MyMetamodel will show instances of Metacl ass2 (because it is referenced by an ex plicit metaclass reference). Also, those 
instances of Metaclass1 that are extended by an instance of MyStereotype will be visible. However, instances of 
Metaclass1 that are not extended by MyStereotype remain hidden. 
Figure 12.8 Specification of an accessible metaclass
If a profile P1 imports another profile P2, then all metaclassReference and me tamodelReference associations will be 
combined at the P2 level, and the filtering rules apply to this union.
The filtering rules defined at the profile le vel are, in essence, merely a suggestio n to modeling tools on what to do when 
a profile is applied to a model.
The “isStrict” attribute on a profileApplica tion specifies that the filtering rules have to be applied strictly. If isStrict is  true 
on a ProfileApplication, then no other metaclasses than the acc essible one defined by the profile  shall be accessible when 
the profile is applied on a model. This prohibits the comb ination of applied profiles that specify different accessible 
metaclasses. In addition to these import and filtering mechanisms, profile de signers can select the approp riate metamodel by selecting 
the appropriate subpackages, and using the package merge mech anism. For example, they can build a specific reference 
metamodel by merging UML2 superstructure  packages and classes, and or import packages from one of the UML2 
compliance packages (L0-L4).«profile»  MyProfileMyMetamodel «reference» 
«Metaclass» 
Metaclass2
«Metaclass» 
Metaclass1«stereotype» 
MyStereotype«reference» 
UML Infrastructure Specification, v2.4        191A Profile can define Classes, DataTypes, PrimitiveTypes, and Enumerations as  well as Stereotypes since Profiles imports 
Constructs. However, these types ca n only be used as the type of properties in th e profile, they cannot be used as types in 
models the profile is applied to since they apply at the meta -model level, not the model level. It is however possible to 
define these types in separate packages and import them as needed in both profile s and models in order to use them for 
both purposes.
Stereotypes can participate in binary associations. The oppos ite class can be another stereotype, a non-stereotype class 
that is owned by a profile, or a metaclas s of the reference metamodel. For these associations there must be a property 
owned by the Stereotype to navigate to the opposite class.  Where the opposite class is not a stereotype, the opposite 
property must be owned by the Association its elf rather than the other class/metaclass.
The most direct implementation of the Profile mechanism that a tool can provide is by having a metamodel based 
implementation, similar to the Profile me tamodel. However, this is not a requ irement of the current standard, which 
requires only the support of the specifie d notions, and the standard XMI based interchange capacities. The profile 
mechanism has been designed to be implementable by tool s that do not have a metamodel-based implementation. 
Practically any mechanism used to attach  new values to model elements can serv e as a valid profile implementation. As 
an example, the UML1.4 profile metamodel could be th e basis for implementing a UML 2-compliant profile tool.
Integrating and extending Profiles
Integrating and extending existing profiles can result in impr oved reuse, better integration between OMG specifications, and 
less gaps and overlaps between metamodel extensions. There are a number of ways to  create, extend and integrate profiles.  
These are described briefly in this section in or der to foster better profile integration and reuse.
The simplest form of profile integration is to simply apply multiple profiles to the same model. This requires no integration 
between the profiles at all. Such profiles might be designed to complement  each other, addressing different concerns.
It is also possible to one profile to reus e all of or parts of another, and to exte nd existing profiles. Like any other class, 
Stereotypes can be defined in packages or profiles that can be factored for reuse. These stereotypes can be directly reused 
through PackageImport or ElementImport in other profiles. Importing profiles can also use Generalizations to extend 
referenced and reused stereo types for their unique purposes.
However, referencing stereotypes in other packages and profiles can sometimes result in undue coupling. This is because the 
referenced stereotypes may be associated with other stereotypes resulting in the need for the referencing profile to include 
large, perhaps unpredictable parts of the referenced profile in order to maintain semantic consistency. This can lead to unexpected burden on profile  implementers and users because more is reused  than intended resulting in coupling complex 
profiles together so they cannot be easily reused separately.
PackageMerge can be used to address this problem. A profile can define stereotypes that intentionally overlap with stereotypes 
in another profile. The profiles can be designe d in such a way that they can stand alone . But they can also be merged together 
using PackageMerge to create a new profile that combines the capabilities of both. Ve ndors and users can th en decide whether 
to apply one profile or the other, or the merged profile to get capabilities resulting from the combination of two or more 
profiles.For example, the UPDM profile could integrate with SysML to reuse stereotypes such as Requ irement and ViewPoint. UPDM 
could be designed to use ViewPoint is a manner that is sema ntically consistent with SysM L since SysML already existed. 
However UPDM could extend ViewPoint with additional pr operties and associations for its purposes. The UPDM 
specification could note to users that View Point is a stereotype in UPDM that repr esents a “placeholder” to ViewPoint in 
SysML. Users could then apply UPDM to a model, and get UP DM’s ViewPoint capabilities without any coupling with, or 
need for SysML. UPDM could th en provide another compliance point that merges with the SysML profile resulting in 
stereotypes Requirement and ViewPoint ha ving the capabilities of both profiles.  The SysML::ViewPoint would be merged 
with the UPDM::ViewPoint allowing the shar ed semantics to be supported without making any changes to the existing model. 
Users who want UPDM with SysML would then apply this merged profile.
192                 UML Infrastructure Specification, v2.4Using XMI to exchange Profiles
A profile is an instance of a UML2 metamodel, not a CMOF  metamodel. Therefore the MOF to XMI mapping rules do 
not directly apply for instances of a prof ile. Figure 12.4 on page 183 is an example of a mapping between a UML2 Profile 
and an equivalent CMOF model. This ma pping is used as a means to explain and formalize how profiles are serialized 
and exchanged as XMI. Using this Profile  to CMOF mapping, rules for mapping CMOF to XMI can be used indirectly to 
specify mappings from Profiles to XMI. In the mapping:
• A Profile maps to a CMOF Package.
• The metaclass, Extension::Class, is an in stance of a MOF class; Extension::Class maps to itself (that is, a Class in the 
profile is also the same Class in the corresponding CMOF  model; the mapping is the identity transformation). 
• A Stereotype maps to a MOF class with the same name and properties.
• An Extension maps to an Association as described in th e Semantics sub clause of Profile::Class on page 181. 
For a Profile the URI attribute (inherited fro m package) is used to determine the nsUR I to be used to identify instances of 
the profile in XMI.  
[Note: by default the name attribute of the Profile is used for the nsPrefix in XMI but this can be overridden by the 
CMOF tag org.omg.xmi.nsPrefix]. 
OMG normative profiles, such as those described in Annex H, follow an OMG normative naming scheme for URIs. For 
non-standard profiles a r ecommended convention is:
uri = http://<profileParentQualifiedName>/<version>/<profileName>.xmi
where:
• <profileParentQualifiedName> is the qualified name of the package c ontaining the Profile (if any) with / 
(forward slash) substituted for ::, and all other illegal XML QName characters removed, 
• <version>  is a version identifier (note that for OMG normative profiles this is a date in the format YYYYMMDD),
• <profileName>  is the name of the Profile,
• nsPrefix = <profileName> ,
A profile can be exchanged just like any model, as an XMI sc hema definition, and models that are extended by a profile 
can also be interchanged.
Figure 12.6 on page 184 shows a “Home” stereotype extending th e “Interface” UML2 metaclass.  Figure 12.4 on page 183 
illustrates the MOF correspondence for that example, basically by introducing an association from the “Home” MOF class 
to the “Interface” MOF class. For illustration purposes, we add a property (tagged value definition in UML1.4) called 
“magic:String” to the “Home” stereotype.
The first serialization below shows how the model in Fi gure 12.6 on page 184 (instance of the profile and UML2 
metamodel) can be exchanged. Note that [UML version num ber], [MOF version number] and [XMI version number] are 
placeholders for the published normative version numbers  of the referenced normative UML, MOF and XMI 
specifications respectively, which follow the format YYYYMMDD.
<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI    xmlns:xmi="http:// www.omg.org/spec/XMI/[XMI version number]" 
  xmlns:mofext="http://www.omg.org/spec/MOF/[MOF version number]" 
  xmlns:uml="http://www.omg.org/spec/UML/[UML version number]">   <uml:Profile xmi:id="id0" name="HomeExample" metamodelReference="id2" 
UML Infrastructure Specification, v2.4        193URI="http://HomeExample/20101201/HomeExample.xmi"> 
<packageImport xmi:id="id2"> 
<importedPackage href="http://www.omg.org/spec/UML/[UML version number]/UML.xmi#_0"/> 
</packageImport> <packagedElement xmi:type="uml:Stereotype" xmi:id="id3" name="Home"> 
<ownedAttribute xmi:type="uml:Property" xmi:id="id5" name="base_Interface" association="id6"> 
<type href="http://www.omg.org/spec/UML/[UML version number]/UML.xmi#Interface"/> 
</ownedAttribute> 
</packagedElement> 
<packagedElement xmi:type="uml:Extension" xmi:id="id6" name="A_Interface_Home" 
memberEnd="id7 id5"> <ownedEnd xmi:type="uml:ExtensionEnd" xmi:id="id7" name="extension_Home" type="id3" 
aggregation="composite"> 
</ownedEnd> 
</packagedElement> 
  </uml:Profile> 
  <mofext:Tag name="org.omg.xmi.nsPrefix" value="HomeExample"/>  
</xmi:XMI>
Figure 12.9 is an example model that includes an instance of Interface extended by the Home stereotype. 
Now the XMI below shows how this model extended by the profile is serialized. A tool importing that XMI file can filter 
out the elements related to the “HomeExample” schema, if the tool does not have this profile definition. 
<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI
    xmlns:xmi="http:// www.omg.org/spec/XMI/[XMI version number]"
    xmlns:uml="http://www.omg.org/spec/UML/[UML version number]"    xmlns:HomeExample="http://HomeExample/20101201/HomeExample.xmi">
    <uml:Package xmi:id="id1" name="ClientPackage">
        <profileApplication xmi:id="id3">
            <appliedProfile
               href="http://HomeExample/20101201/HomeExample.xmi#id0"/>
        </profileApplication>        <packagedElement xmi:type="uml:Interface" xmi:id="id2" name="Client"/> 
    </uml:Package>
<!-- applied stereotypes -->    <HomeExample:Home xmi:id= "id4" base_Interface="id2"/>
</xmi:XMI>
Notation
A Profile uses the same notation as a Pa ckage, with the addition that the keywor d «profile» is shown before or above the 
name of the Package. Profile::metaclassReference  and Profile::metamodelReference  uses the same notation as 
Package::elementImport  and Package::packageImport , respectively. Figure 12.9 - Using the “HomeExample” profile to extend a model<<Home>>
ClientClientPackage  
194                 UML Infrastructure Specification, v2.4Examples
In Figure 12.10, a simple example of an EJB profile is shown.
Figure 12.10 - Defining a simple EJB profile
The profile states that the abstract stereotype Bean  is required to be applied to metaclass Component , which means that an 
instance of either of the concrete subclasses Entity  and Session  of Bean  must be linked to each instance of Component . 
The constraints that are part of the profile are evaluated when the profile has been applied to a package, and these 
constraints need to be satisfied in order for the model to be well-formed.
Figure 12.11 - Importing a package from a profile«profile»  EJB
«stereotype» 
Bean
«stereotype» 
Entity
state: StateKind«stereotype» 
Session«Metaclass» 
Component{required}
{A component 
cannot be 
generalized or 
specialized}«stereotype» 
JAR
«stereotype» 
Remote
«stereotype» 
Home«Metaclass» 
Interface«Metaclass» 
Artifact
{A bean must 
realize exactly 
one Home 
interface}stateless
stateful«enumeration» 
StateKind
Types
«profile»  Manufacturer
Factory«import» «import»red
green
blue«enumeration» 
Color JavaInteger
«Metaclass» 
Class author: String
color: Colorvolume; JavaInteger «stereotype» 
Device
channel: JavaInteger«Device» 
TV«Device» volume=10«apply» 
UML Infrastructure Specification, v2.4        195In Figure 12.11, the package Types  is imported from the profile Manufacturer . The data type Color  is then used as the 
type of one of the properties of the stereotype Device , just like the predefined type Stri ng is also used. Note that the class 
JavaInteger  may also be used as the type of a property.
If the profile Manufacturer  is later applied to a package, then the types from Types  are not available for use in the package 
to which the profile is applied unless package Types  is explicitly imported. This means that for example the class 
JavaInteger  can be used as a metaproperty (as part of the stereotype Device ) but not as an ordinary property (as part of 
the class TV) unless package Factory  also imports package Types . Note how the metaproperty is given a value when the 
stereotype Device  is applied to the class TV.
12.1.8 ProfileApplicat ion (from Profiles)
A profile application is used to show whic h profiles have been applied to a package. 
Generalizations
• “DirectedRelationship” on page 106
Description
ProfileApplication is a kind of DirectedRelationship that adds th e capability to state that a Profile is applied to a Package.
Attributes
• isStrict : Boolean [1] = false  
Specifies whether or not the Pr ofile filtering rules for the metaclasses of the referenced metamodel shall be strictly  
applied. See the semantics sub clause of “Profile  (from Profiles)” on page 188 for further details.
Associations
• importedProfile: Profile [1]  
References the Profiles that are applied to  a Package through this ProfileApplication.  
Subsets PackageImport::importedPackage
• applyingPackage : Package [1]  
The package that owns th e profile application. { Subsets Element::owner  and DirectedRelationship::source }
Constraints
No additional constraints
Semantics
One or more profiles may be applied at will to a package that  is created from the same metamodel that is extended by the 
profile. Applying a profile means that it is allowed, but not n ecessarily required, to apply the stereotypes that are defined 
as part of the profile. It is possible to apply multiple pr ofiles to a package as long as they do not have conflicting 
constraints. Applying a profile means re cursively applying all its nested and imp orted. Stereotypes imported from another 
profile using ElementImport or PackageImport are added to the namespace members of the importing profile. Stereotypes 
that are public namespace members of a pr ofile may be used to extend the applic able model elements in packages to 
which the profile has been applied.
When a profile is applied, instances of the appropriate stereotypes should be created for those elements that are instances 
of metaclasses with required extensions. The m odel is not well-formed without these instances.
196                 UML Infrastructure Specification, v2.4Once a profile has been applied to a pa ckage, it is allowed to remove the appl ied profile at will. Removing a profile 
implies that all elements that are instances of elements define d in a profile are deleted. A profile that has been applied 
cannot be removed unless other applied prof iles that depend on it are first removed. 
A nested profile can be applied individua lly. However, the nested profile must specify any required metaclass and/or 
metamodel references if it contains a ny stereotypes and may use PackageImport to indicate other dependent packages. 
Metaclass and/or metamodel references ar e not inherited from a containing profile.
ProfileApplication makes stereotype names visible to the refere nced metamodel, not the model the profile is applied to.  
ProfileApplication is not a kind of Packag eImport because of this crossing of me tamodel levels. As with package import, 
profile application does not expose the names of nested profiles.
Note – The removal of an applied profile leaves the instances of elements fr om the referenced metamodel intact. It is only the 
instances of the elements from the profile that are deleted. This means that for example a profiled UML model can always be 
interchanged with another tool that does not support  the profile and be interpreted as a pure UML model.
Notation
The names of Profiles are shown using a dashed arrow with an open arrowhead from the package to the applied profile. 
The keyword «apply» is shown near the arrow.
If multiple applied profiles have stereotypes with the same  name, it may be necessary to qualify the name of the 
stereotype (with the profile name).
Examples
Given the profiles Java  and EJB, Figure 12.12 shows how these have been applied to the package WebShopping . 
12.1.9 Stereotype (from Profiles)
A stereotype defines how an existing meta class may be extended, and enables the use of platform or domain specific 
terminology or notation in place of, or in addition to, the ones used for the extended metaclass.
Generalizations
• InfrastructureLibrar y::Constructs::ClassFigure 12.12 - Profiles applied to a packageWebShopping«profile»
Java«profile»
EJB
«apply»
«apply»
UML Infrastructure Specification, v2.4        197• “Class (from Profiles)” on page 180
Description
Stereotype is a kind of Class that  extends Classes through Extensions. 
Just like a class, a stereotype may have properties, which may be referred to as  tag definitions. When a stereotype is 
applied to a model element, the values of the properties may be referred to as tagged values.
Attributes
No additional attributes
Associations
• icon : Image [*]  
Stereotype can change the graphical appearance of the ex tended model element by using attached icons. When this  
association is not null, it references the location of the ic on content to be displayed within diagrams presenting the  
extended model elements. {Subsets Element::ownedElement}
• /profile : Profile [1]  
The profile that directly or indi rectly contains this stereotype.
Constraints
[1]  A Stereotype may only generalize or specialize another Stereotype.
generalization.general->forAll(e | e.oclIsKindOf(Stereotype)) and
generalization.specific->forAll(e  | e.oclIsKindOf(Stereotype))
[2] Stereotype names should not clash with keyword names for the extended model element.
[3] A stereotype must be contained, directly or indirectly, in a profile.
profile = self.containingProfile()
Additional Operations
[1]  The query containingPr ofile() returns the closest profile directly or in directly containing this package (or this package 
itself, if it is a profile).
Package::containingProfile(): Profile  
result  = self.namespace.oclAsType(Package).containingProfile()
Semantics
A stereotype is like a limited kind of metaclass that cannot be us ed by itself, but must always be used in conjunction with 
one of the metaclasses it extends. Each stereotype may extend on e or more classes through extensions as part of a profile. 
Similarly, a class may be extended by one or more stereotypes.
An instance “S” of Stereotype is like a kind of metaclass th at extends other metaclasses th rough association (Extension) 
rather than generalization/specialization. Relating it to a metaclass “C” from the reference metamodel (typically UML) 
using an “Extension” (which is a specific kind of association) , signifies that model elements of type C can be extended by 
an instance of “S” (see example in Figure 12.13). At the model level (such as in Figure 12.18) instances of “S” are related 
to “C” model elements (instances of “C”) by links (occu rrences of the association/extension from “S’ to “C”).
198                 UML Infrastructure Specification, v2.4Any metaclassReference or model element from the metamode lReference of the closest profile directly or indirectly 
containing a stereotype can be extended by the stereotype. For example in UML, States, Tran sitions, Activities, Use cases, 
Components, Attributes, Dependencies, etc.  can all be extended with stereotypes if the metamodelReference is UML. A 
stereotype may be contained in a package in which case the metaclass and/or metamode l references available for 
extension are those of the closest pa rent profile containing the package.
Stereotype specializes Class which may be merged with Clas s from InfrastructureLibrary and Superstructure in different 
UML2 compliance levels. This adds a number of additiona l properties to class such as isLeaf, isAbstract, and 
ownedAttributes needed to provide the properties of the stereotype. These properties have the same meaning in 
Stereotypes as they do in Class. Tool vendors may choose to suppor t extensibility that includes owned operations and 
behaviors, but are not required to do so. Tools must however support Stereotype ownedAttributes.
A Stereotype may be contained in a Profile or Package whic h defines the namespace for the Stereotype. When profiles are 
applied to a Package, the available stereotypes for use as extensions are defined by the applied profiles, and theses 
stereotypes can be identified by the fully qualified name if need ed in order to distinguish stereotypes with the same name 
in different profiles or packages. Package and element im port can be used to allow th e use of unqualified names. 
Stereotypes directly owned by an applied profile (o wnedStereotype) may be used without qualified names.
Notation
A Stereotype uses the same notation as a Class, with the addition that the keyword «stereotype» is shown before or above 
the name of the Class. 
When a stereotype is applied to a model element (an instance of  a stereotype is linked to an instance of a metaclass), the 
name of the stereotype is shown within a pair of guillemets above or before the name of the model element, or where the 
name would appear if the name is omitte d or not displayed. For model elements that do not have names but do have a 
graphical representation, unless specifically stated elsewhere,  the stereotypes can be displayed within a pair of guillemets 
near the upper right corner of the graphi cal representation. If multiple stereotype s are applied, the names of the applied 
stereotypes are shown as a comma-separated list with a pa ir of guillemets. When the extended model element has a 
keyword, then the stereotype name will be displayed clos e to the keyword, within se parate guillemets (example: 
«interface» «Clock»). 
Normally a stereotype?s name and the name of its applicatio ns start with upper-case letters, to follow the convention for 
naming classes. Domain-specific profiles may use different conventions. Matching between the names of stereotype 
definitions and uses is case-i nsensitive, so naming stereotype applications with lower-case letters where the stereotypes 
are defined using upper-case letters is  valid, although stylistically obsolete.
Presentation Options
If multiple stereotypes are applied to an element, it is possibl e to show this by enclosing each stereotype name within a 
pair of guillemets and listing them after each other. A tool can choose whether it will display stereotypes or not. In 
particular, some tools can choose not to display “required stereo types,” but to display only th eir attributes (tagged values) 
if any.The values of a stereotyped element can be  shown in one of the following three ways:
• As part of a comment symbol connected to th e graphic node representi ng the model element 
• In separate compartments of a graphi c node representing that model element.
• Above the name string within the graphic node or, else, before the name string.
UML Infrastructure Specification, v2.4        199In the case where a compartment or comment symbol is used , the stereotype name may shown in guillemets before the 
name string in addition to being included in the compartment or comment.
The values are displaye d as name-value pairs:
<namestring> ‘=’ <valuestring>
If a stereotype property is multi-valued then the <v aluestring> is displayed as a comma-separated list:
<valuestring> ::= <value> [‘,’ <value>]*
Certain values have special display rules:
• As an alternative to a name-value pair, when displaying  the values of Boolean prop erties, diagrams may use the  
convention that if the <namestring> is displayed th en the value is True, otherwise the value is False.
• If the value is the name of a NamedElement, then, optionally, its qualifiedName can be used.
If compartments are used to display ster eotype values, then an additional compartment is required for each applied 
stereotype whose values are to be displa yed. Each such compartment is headed by the name of the applied stereotype in 
guillemets. Any graphic node ma y have these compartments.
Within a comment symbol, or, if displayed before or a bove the symbols's <namestring>, the values from a specific 
stereotype are optionally preceded with th e name of the applied stereotype within a pair of guillemets. This is useful if 
values of more than one applie d stereotype should be shown.
When displayed in compartments or in a comment symbol, at mo st one name-value pair can appear on a single line. When 
displayed above or before a <namestri ng>, the name-value pairs are separated by semicolons and all pairs for a given 
stereotype are enclosed in braces.
If the extension end is given a name, this name can be used in  lieu of the stereotype name within the pair of guillemets 
when the stereotype is applied to a model element. 
It is possible to attach a specific notation to a stereotype th at can be used in lieu of the notation of a model element to 
which the stereotype is applied.
Icon presentation
When a stereotype includes the definition of an icon, this icon can be graphically attached to the model elements extended 
by the stereotype. Every model element that has a graphical presentation can have an attached icon. When model elements 
are graphically expressed as:
• Boxes (see Figure 12.14 on page 200): the box can be replace d by the icon, and the name of the model element appears  
below the icon. This presentation option can be used only when a model element is extended by one single stereotype 
and when properties of the model element (i.e., attributes , operations of a class) are no t presented. As another option, 
the icon can be presented in a reduced shape, inside and on top of the box representing the model element. When 
several stereotypes are applied, several icons can be presented within the box.
• Links: the icon can be placed close to the link.
• Textual notation: the icon can be presented to the left of the textual notation.
200                 UML Infrastructure Specification, v2.4Several icons can be attached to a stereoty pe. The interpretation of the different att ached icons in that case is a semantic 
variation point. Some tools may use different images for the icon  replacing the box, for the reduced icon inside the box, 
for icons within explorers, etc. Dependi ng on the image format, other tools may choose to display one single icon into 
different sizes.
Some model elements are already using an icon for their defa ult presentation. A typical ex ample of this is the Actor 
model element, which uses the “stickman” icon. In that case, when a model elemen t is extended by a stereotype with an 
icon, the stereotype’s icon replaces the default presentation icon within diagrams.
Examples
In Figure 12.13, a simple stereotype Clock  is defined to be applicable at will (dynamically) to instances of the metaclass 
Class. 
In Figure 12.15, an instance specification of the example in Fi gure 12.13 is shown. Note that the extension end must be 
composite, and that the derived isRequired” attribute in this case  is false. Figure 12.15 shows the repository schema of the 
stereotype “clock” defined in Figure 12.13. In this schema, the extended instance (:Class; “name = Class”) is defined in 
the UML 2 (reference metamodel) repositor y. In a UML modeling tool these extended instances referring to the UML 2 
standard would typically be in a “read only” form, or  presented as proxies to the metaclass being extended.Figure 12.13 - Defining a stereotype
Figure 12.14 - Presentation options for an extended class«Metaclass»  
Class OSVersion: String
startOperation: OperationPOSIXCompliant: Boolean«stereotype» 
Clock
«Clock»
StopWatch
«Creator, Clock»
StopWatchStopWatchStopWatch
StopWatch
UML Infrastructure Specification, v2.4        201(It is therefore still at the same meta-level as UML, and do es not show the instance model of a model extended by the 
stereotype. An example of this is provided in Figure 12.17 a nd Figure 12.18.) The Semantics sub clause of the Extension 
concept explains the MOF equivalent, and how co nstraints can be attached to stereotypes. 
Figure 12.16 shows how the same stereotype Clock  can extend either the metaclass Component or the metaclass Class. It 
also shows how different stereotypes can extend the same metaclass. Figure 12.15 - An instance specification when defining a stereotype
Figure 12.16 - Defining multiple st ereotypes on multiple stereotypesname = “Class”:Class
isComposite=false:Propertytype
isRequired=false:Extension
isComposite=true:ExtensionEndname=”OSVersion”:Property
name=”startOperation”:Property
name=”POSIXCompliant”:Propertyname=”String”:PrimitiveType
name=”Operation”:Class
name=”Boolean”:PrimitiveTypeName=”Clock”:Stereotype
ownedAttribute
memberEnd ownedEnd,
memberEndtype
ownedAttributetype
type
type
«Metaclass»  
ClassOSVersion: String
startOperation: OperationPOSIXCompliant: Boolean«stereotype» 
Clock
«Metaclass»  
Component
author: String
date: String «stereotype» 
Creator
{required}
202                 UML Infrastructure Specification, v2.4Figure 12.17 shows how the stereotype Clock , as defined in Figure 12.16, is applied to a class called StopWatch . 
Figure 12.18 shows an example instance model for when the stereotype Clock  is applied to a class called StopWatch . The 
extension between the stereotype and the metaclass re sults in a link between the instance of stereotype Clock  and the 
(user-defined) class StopWatch . 
Next, two stereotypes, Clock  and Creator , are applied to the same model element, as  shown in Figure 12.19. Note that the 
attribute values of each of the applie d stereotypes can be shown in a comment symbol attached to the model element.Figure 12.17 - Using a stereotype
Figure 12.18 - Showing values of stereo types and a simple instance specification
Figure 12.19 - Using stereotypes and showing values«Clock» 
StopWatch
«Clock» 
StopWatch
«Clock»
OSVersion=”3.32"startOperation=Clickname=”StopWatch”:Class
name=”Click”:OperationOSVersion=”3.32"POSIXCompliant=False:Clockextension_Clock
base_Class
ownedOperation
startOperation
Click()«Clock, Creator» 
StopWatch«Clock»
OSVersion=”3.32"
startOperation=Click
«Creator»
name=”Jones"
date=”04-04-04"
UML Infrastructure Specification, v2.4        203Finally, two more alternative notational forms are shown in Figure 12.20. 
Changes from previous UML
In UML 1.3, tagged values could extend a model element without requiring the presence of a stereotype. In UML 1.4, this 
capability, although still supported, was deprecated, to be used only for backward compatibility reasons. In UML 2, a 
tagged value can only be repres ented as an attribute defined on a stereoty pe. Therefore, a model element must be 
extended by a stereotype in order to be extended by tagged va lues. However, the “required” extension mechanism can, in 
effect, provide the 1.3 capability, since a tool can in those circumstances automatically define a stereotype to which 
“unattached” attributes (tagged values) would be attached.Figure 12.20 - Other notational forms for depicting stereotype values«Clock»
OSVersion=”1.1"startOperation=Start
POSIXCompliant=TrueStart()«Clock» 
AlarmClock
Start()«Clock»
{POSIXCompliant} 
AlarmClock
204                 UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4        17113 PrimitiveTypes
The PrimitiveTypes package is a top level package that contains  a number of predefined types that can be imported and 
used when defining the abstract syntax of metamodels.
Figure 13.1  - The Core package is owned by the Infrast ructureLibrary package, and contains several subpackages
13.1 PrimitiveTypes Package
The PrimitiveTypes package is a top level package that is indepe ndent of any other package. The package defines a set of 
reusable primitive types that are commonly used in the defin ition of metamodels. The InfrastructureLibrary and the UML 
metamodel are examples of metam odels using the PrimitiveTypes package to define their primitive data.
13.1.1 Boolean
A Boolean type is used for logical expres sion, consisting of the predefined values true and false . 
Description
Boolean is an instance of PrimitiveType. In the metamodel, Boolean defines an enumeration that denotes a logical 
condition. Its enumeration literals are:
• true — The Boolean co ndition is satisfied.
• false — The Boolean co ndition is not satisfied.
It is used for Boolean attribute and Boolean expres sions in the metamodel, such as OCL expression.
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
Boolean is an instance of PrimitiveType. Figure 13.2 - The classes defined in the PrimitiveTypes packagePrimitiveTypes
«primitive»
Boolean«primitive»
Integer«primitive»
String«primitive»
UnlimitedNatural«primitive»
Real
172                 UML Infrastructure Specification, v2.4Notation
Boolean will appear as the type of attri butes in the metamodel. Boolean instances will be values associated to slots, and 
can have literally the following values: true or false .
Examples
13.1.2 Integer
An integer is a primitive type representing integer values.
Description
An instance of Integer is an element in the (infinite) set of in tegers (…-2, -1, 0, 1, 2…). It is used for integer attributes 
and integer expressions  in the metamodel.
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
Integer is an instance of PrimitiveType.
Notation
Integer will appear as the type of attributes in the metamodel.  Integer instances will be values  associated to slots such as 
1, -5, 2, 34, 26524, etc.Figure 13.3 - An example of a Boolean attributeCar
isAutomatic: Boolean = true
UML Infrastructure Specification, v2.4        173Examples
13.1.3 Real
A real is a primitive type representing the mathematical concept of real.
Description
An instance of Real is an element in the infinite set of real numbers. It is used for real attributes and real expressions in 
the models. 
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
Real is an instance of PrimitiveType. 
Notation
Real will appear as the type of  attributes in the metamodel. Real instances will be literals associated to real-typed slots 
such as 1, -5, 0.3, 34.75, 26524.2339, 2.99E5, etc. Figure 13.4 - An example of an integer attributeMagazine
pages: Integer = 64
174                 UML Infrastructure Specification, v2.4Examples
13.1.4 String
A string is a sequence of characters in some suitable character set used to display information about the model. Character 
sets may include non-Roman alphabets and characters.
Description
An instance of String defines a piece of text. The semantic s of the string itself depends on its purpose, it can be a 
comment, computational language expression,  OCL expression, etc. It is used for String attributes and String expressions 
in the metamodel.
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
String is an instance of PrimitiveType. 
Notation
String appears as the type of attributes in  the metamodel. String instances are values associated to slots. The value is a 
sequence of characters surrounded by double quot es ("). It is assumed that the underl ying character set is sufficient for 
representing multibyte characters in various human languages; in particular, the traditional 8-bit ASCII character set is 
insufficient. It is assumed that tools and computers manipul ate and store strings correctly, including escape conventions 
for special characters, and this document will assume that arbitrary strings can be used.
A string is displayed as a text string graphic. Normal printa ble characters should be displayed directly. The display of 
nonprintable characters is unspecified and platform-dependent.Figure 13.5 - An example of a real attribute+x : Real
+y : RealPoint
UML Infrastructure Specification, v2.4        175Examples
13.1.5 UnlimitedNatural
An unlimited natural is a primitive t ype representing unlimited natural values.
Description
An instance of UnlimitedNatural is an element in the (infinite) se t of naturals (0, 1, 2…). The value of infinity is shown 
using an asterisk (‘*’).
Attributes
No additional attributes
Associations
No additional associations
Constraints
No additional constraints
Semantics
UnlimitedNatural is an instance of PrimitiveType. 
Notation
UnlimitedNatural will appear as the type of upper bounds of multiplicities in the metamodel. UnlimitedNatural instances 
will be values associated to slots such as 1, 5, 398475, etc.  The value infinity may be shown using an asterisk (‘*’).
ExamplesFigure 13.6 - An example of a string attribute
Figure 13.7 - An example of an unlimited naturalBook
author: String = "Joe"
Teacher Studentstudent
*
176                 UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4        205Part III - Annexes
Annexes include:
A - XMI Serialization and SchemaB - Support for Model Driven Architecture
206                 UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4        207Annex A: XMI Serialization and Schema
(normative)
UML 2 models are serialized in XMI according to the ru les specified by the MOF 2: XMI Mapping Specification. 
XMI allows the use of tags to tailor th e schemas that are produced and the documents that are produced using XMI. The 
following are the tag settings that appear in the XMI of the InfrastructureLibrary :
• tag “org.omg.xmi.nsPrefix” set to  “uml” (for packages L0, LM)
The following are the tag settings that appear in the XMI of the PrimitiveTypes  package: 
• tag “org.omg.xmi.nsPrefix” set to “primitives”
• tag “org.omg.xmi.schemaType” set to “http://www.w3.org/2001/XMLSchema#integer” (for element PrimitiveTypes-
Integer)
• tag “org.omg.xmi.schemaType” set to “http://www.w3.org/2001/XMLSchema#boolean” (for element PrimitiveTypes-
Boolean)
• tag “org.omg.xmi.schemaType” set to “http://www.w3.org/2001/XMLSchema#double” (for element PrimitiveTypes-
Real)
No other tags are explicitly set, wh ich means they assume their default values as documented in the MOF 2 XMI 
Mappings Specification.
208                 UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4        209Annex B: Support for Model Driven Architecture
(normative)
The OMG’s Model Driven Architecture (MDA) initiative is an ev olving conceptual architecture for a set of industry-wide 
technology specifications that will suppor t a model-driven approach to software development. Although MDA is not itself 
a technology specification, it represents an  approach and a plan to achieve a co hesive set of model-driven technology 
specifications.
The MDA initiative was initiated after the UML 2 RFPs were issued. However, as noted in the OMG’s Executive 
Overview  of MDA (www.omg.org/mda/executive_overview.htm): “[MDA] is built on the solid foundation of well-
established OMG standards, including: Unified Modeling Language™ (UML™), th e ubiquitous modeling notation used 
and supported by every major company in the software industr y; XML Metadata Interchange (XMI™), the standard for 
storing and exchanging models using XM L; and CORBA™, the most popular open  middleware standard.” Consequently, 
it is expected that this major revision to UML will play an important role in furthering the goals of MDA.The OMG Object Reference Model Subcom mittee has produced MDA Guide (the latest  version of which is referenced 
from www.omg.org/mda) which is the official, commonly agreed upon, definition of MDA. This MDA Guide draft 
characterizes MDA as follows: 
“MDA provides an approach for and enables tools to be provided for:
 
    - specifying a system independently of the platform that supports it,  
    - specifying platforms or selecting existing platform specifications,  
    - choosing a particular platform for the system, and  
    - transforming the system specification into one for the chosen particular platform.”
In addition, this MDA Guide draft and many other MDA docum ents commonly refer to a “UML family of languages,” 
which is described in the MDA Guide as: “Extensions to th e UML language [that] will be standardized for specific 
purposes. Many of these will be desi gned specifically for use in MDA.”
The following sections explain how UML 2 supports the mo st prominent concepts in the evolving MDA vision.
•Family of languages:  UML is a general purpose language, that is expe cted to be customized for a wide variety of 
domains, platforms and methods. Towards that end, this UML  specification refines UML 1.x’s Profile mechanism so 
that it is more robust and flexible, and significantly easier to implement and apply. Consequently, it can be used to customize UML dialects for various doma ins (e.g., finance, tel ecommunications, aerospace), platforms (e.g., J2EE, 
.NET), and methods (e.g., Unified Proce ss, Agile methods). For those whose cu stomization requirements exceed these 
common anticipated usages, an d who want to define their new languages vi a metamodels, the InfrastructureLibrary is 
intended to be reused by MOF 2. Tools that implement MOF 2 will allow users to define entirely new languages via 
metamodels.
•Specifying a system independently of  the platform th at supports it:  As was the case with its predecessor, the 
general purpose UML 2 specification is intended to be used with a wide range of software methods. Consequently, it 
includes support for software methods that distinguish between analysis or logical models, and design or physical models. Since analysis or logical models  are typically independent of implemen tation and platform specifics, they can 
be considered “Platform Independent M odels” (PIMs), consistent with the evolving MDA terminology. Some of the 
proposed improvements to UML  that will make it easier for modelers to specify Platform  Independent Models include 
the ability to model logical as well as physical Classes and Components, consistent with either a class-based or 
component-based  approach.  
210                 UML Infrastructure Specification, v2.4•Specifying platforms:  Although UML 1.x provided extremely limited support for modeling Platform Specific Models 
(PSMs, the complement of PIMs), this specification offers two significant impr ovements. First, the revised Profile 
mechanism allows modelers to more effi ciently customize UML for target platfo rms, such as J2EE or .NET. (Examples 
of J2EE/EJB or .NET/COM micro-profiles can be found in the UML Superstructure Specification.) Secondly, the 
constructs for specifying component architectures, compone nt containers (execution runtime environments), and 
computational nodes are significantly enhanced, allowing modelers to fully specify target implementation 
environments.
•Choosing a particular pl atform for the system:  This is considered a method or a pproach requirement, rather than a 
modeling requirement. Consequently, we will not address it here. 
•Transforming the system specification into one fo r a particular platform:  This refers to the transformation of a 
Platform Independent Model into a Plat form Specific Model. The UML Superstr ucture Specification specifies various 
relationships that can be used to sp ecify the transformation of a PIM to a PSM, including Realization, Refine, and 
Trace. However, the specific manner in whic h these transformations are used will depend upon the profiles used for the 
PSMs involved, as well as the me thod or approach applied to guide the transformation process. Consequently, we will 
not address it further here.
UML Infrastructure Specification, v2.4        207Annex C: UML XMI Documents
(normative)
UML defined in UML: 
• http://www.omg.org/spec/UML/20100901/UML.xmi
208                 UML Infrastructure Specification, v2.4
UML Infrastructure Specification, v2.4                      211INDEX
A
Abstract syntax compliance 4
abstract syntax compliance 4
access 150
acyclical 84adorn 57
adorned 114
aggregation 115
alias 144, 145, 147
allFeatures 35
allNamespaces 73allOwnedElements 76
allParents 51
ancestor 85annotatedElement 38, 92, 105
argument 98
arrow 99, 114, 145, 163
solid
for navigation 115
arrow notation 99arrowhead 114, 145, 150, 168
arrrowhead 168
association 114association ends 65
association notation 124
asterisk 26, 65, 67, 175attribute 98, 119
attribute compartment 99, 122, 140
attributes 65
B
Bag 127
behavioral compatibility 24, 79
BehavioralFeature 31, 32bidirectionally naviga ble associations 98
binary association 112, 125BNF 114bodyCondition 153, 154, 155
boldface 120, 122
Boolean 60, 101, 142booleanValue 48, 60
bound 66, 126, 127
braces 42, 114
C
Changeabilities 33
character set 64, 120, 174
Class 17, 18, 22, 25, 95class 95, 96, 97, 98, 99, 118, 119, 124
Classifier 51, 55, 85
classifier 35, 56, 79Classifier (as specialized) 50, 84Classifiers package 34
colon 56
color 115, 161comma 56, 114
comment 37
Comments package 37common superclass 44, 93Common Warehouse Metamodel (CWM) 17
compartment 119, 140
compartment name 36, 122compliance 4
compliance level 1
composite 113
composite aggregation 115, 118composite name 75
concrete 85
Concrete syntax compliance 4concrete syntax compliance 4
conform 87
Conformance 1conformsTo 87
constant 60, 63
constrainedElement 41, 42constraint 41, 67, 85, 88, 127, 152
constraint language 22, 24
constraints 120context 41, 45, 136
contravariance 155
Core 12, 29, 91, 103Core package 12, 27
covariance 155
D
dashed arrow 145, 150
dashed line 38, 168
DataType 91, 99
default 119, 127, 157definingFeature 55, 58
derived union 35, 73, 78
diagram interchange 4
diamond 114, 115
digit 61, 65
dimmed 161direct instance 96
DirectedRelationship 81, 106, 144
direction 157distinguishable 32, 73
double quotes 64, 174
E
Element 38, 39, 93
Element (as specialized) 38
element access 145
element import 145ElementImport 144, 147
empty name 74
endType 112Enumeration 137, 139, 140, 165
enumeration 140
Enumeration rules 168EnumerationLiteral 140, 165equal sign 56
exception 155
exceptions 97excludeCollisions 148
expression 23, 40, 45, 46
Expressions package 45
212                                                                                UML Infrastructure Specification, v2.4F
false 60
Feature 31
feature 31, 131featuringClassifier 36, 131formalism 21
G
Generalization 90
generalization 51, 90generalization arrow 114
generalization hi erarchy 50, 84
Generalizations betwee n associations 115
generalizations betw een associations 114
Generalizations package 49
getName 144getNamesOfMember 74, 148
guillemets 36, 119, 122
H
hasVisibilityOf 85
hidden 148
hierarchy 73
hollow triangle 52, 85
I
identity 142
image 185
import 90, 145, 150importedElement 144
importedMember 148
importedPackage 149importingNamespace 144, 149
importMembers 148
includesCardinality 67
infinity 175
inherit 85, 119, 138
initial 119, 128initialization 98
inout 157
Instance specification 54Instance value 57
Instances package 53
instantiated 119, 127instantiation 66
Integer 60, 101, 142
integer 66, 101, 123, 142, 145integerValue 48, 60, 61
isAbstract 84, 95
isComposite 98
isComputable 48, 60, 61, 62, 64
isConsistentWith 79
isDerived 98, 112isDistinguishableFrom 32, 73, 75isFinalSpecialization 130
isID 98, 125
isLeaf 132
isMultivalued 66
isNull 49, 61
isOrdered 66, 67, 153isQuery 153
isReadOnly 34, 98, 125isUnique 66, 113, 127, 153
italics 120
J
Java 40
K
keyword 26, 119, 122
L
language 21, 40
Language Architecture 11
language units 1line width 115
link 111
literal 48, 100literalBoolean 59
literalInteger 60
literalNull 61Literals package 59
literalSpecification 63
literalString 63literalUnlimitedNatural 64
lower 185
lowerBound 66, 70, 71lowerValue 70
M
M2 17
makesVisible 160maySpecializeType 85
MDA 12, 209
member 74memberEnd 112
membersAreDistinguishable 74
mergedPackage 162Model Driven Architecture 209
MOF 11, 12, 14, 15, 17, 91
multiple inheritance 96multiplicities 116, 175
Multiplicities package 65
multiplicity 66, 67, 97, 113, 133MultiplicityElement 66, 67
MultiplicityElement (specialized) 70
MultiplicityExpressions package 69multivalued 65
mustBeOwned 76, 160
mutually constrained 98
N
name 33, 72, 85, 94, 128
NamedElement 74, 85, 89
namedElement 72NamedElement (as specialized) 89Namespace 147
namespace 72, 147
Namespace (as specialized) 43
Namespaces 72
Namespaces diagram 143
Namespaces package 72natural language 25, 46
navigable 117, 125, 167
UML Infrastructure Specification, v2.4                      213navigableOwnedEnd 112
navigation arrow 115
navigation arrows 57, 115nested namespaces 72nestedPackage 102
nestingPackage 102
nonprintable characters 174nonunique 68
note symbol 38, 42
null 61
O
OCL 23, 40, 46, 47, 70, 171, 174
onstraint language 9, 24
OpaqueExpression 46opaqueExpression 46, 108, 109
operand 46
operation 41, 119, 152, 157operation compartment 122
opposite 98, 125
ordered 113, 129, 139, 155OrderedSet 127
out 157
overriding 74ownedAttribute 95, 119, 138
ownedComment 39, 107
ownedElement 76ownedEnd 112
ownedLiteral 100, 139
ownedMember 147, 159ownedOperation 96, 119, 138
ownedParameter 97, 152
ownedRule 43, 137ownedStereotype 187
ownedType 159
owner 76Ownerships package 75
owningAssociation 125
owningInstance 58
P
package 90, 101, 179
package import 145, 149
PackageableElement  136, 144, 147, 159
packagedElement 187
PackageImport 147, 149
PackageMerge 104, 157, 168packageMerge 159, 161
Packages diagram 101, 157
Parameter 97parameter 32, 156, 163
parameter list 156
ParameterDirectionKind 157parameters 119plus sign 160
postcondition 41, 153
precondition 153predefined 171
primitive type 101
PrimitiveType 101PrimitiveTypes 27, 171printable characters 174
private 90, 161
profile 197ProfileApplication 195Profiles 14
Profiles package 179
Property 95, 98, 118, 119property string 68, 114
protected 90
public 90, 160, 161
Q
qualified 145
qualified name 147, 160
qualifiedName 145query 154, 155, 167
R
raisedException 97, 152, 153
readOnly 128, 129realValue 48, 62
rectangle 36, 38, 123, 140, 160
RedefinableElement 119, 124, 125, 129, 132
redefine 128, 129
redefined 153, 155
redefinedElement 78, 133redefinedOperation 153
redefinedProperty 125
redefines 129, 155redefinitionContext 78, 133
redefinitions 77
Redefinitions package 77relatedElement 81, 107
relationship 81, 105
relationship (directed) 80
Relationships package 80
returnResult 154
Root diagram 105round parentheses 46
run-time extension 140
S
segments 114, 115
self 24, 41
semantic variation point 23
semicircular jog 115separate target style 52
separator 73
Sequence 127
sequence 127
Set 127
set 127shared target style 52, 86
side effect 70
slash 114slot 55, 58, 83, 96snapshot 55
solid line 114
solid path 57solid-outline rectangle 36
source 81, 106
214                                                                                UML Infrastructure Specification, v2.4specific 51
specification 41, 54, 55, 136
square brackets 26, 68, 169state 155static operation 154
String 63, 101, 142
string 142stringValue 48, 64
structural compatibility 79
structuralFeature 133StructuralFeature (as specialized) 34
StructuralFeatures package 82
subset 128subsettedProperty 125
subsetting 126
subsettingContext 126, 127substitutable 79, 155
Super package 83
superClass 96Superstructure 91
superstructure 91
symbol 46
T
tab 160
target 81, 106
ternary association 116tree 115
true 60
tuple 111Type 102
type 85, 87, 121, 134, 165
type conformance 51TypedElement 88
typedElement 88, 129, 135
TypedElements package 86
U
UML 12
underlined name 57
union 128unique 66, 68, 129
unlimited 64
UnlimitedNatural 48, 101, 142unlimitedNatural 142, 175
unlimitedValue 48, 64
unordered 67upper 66, 70, 153
upperBound 71
upperValue 70URI 102, 159
V
value 58
ValueSpecification 41, 70valueSpecification 48visibilities 88
visibility 88, 128, 144, 159
visibility keyword 119Visibility package 88
visibility symbol 115visibilityKind 90
X
XMI 12, 27, 69, 164
XML Metadata Interchange (XMI) 15
